!function(e){function r(e,r,o){return 4===arguments.length?t.apply(this,arguments):void n(e,{declarative:!0,deps:r,declare:o})}function t(e,r,t,o){n(e,{declarative:!1,deps:r,executingRequire:t,execute:o})}function n(e,r){r.name=e,e in v||(v[e]=r),r.normalizedDeps=r.deps}function o(e,r){if(r[e.groupIndex]=r[e.groupIndex]||[],-1==g.call(r[e.groupIndex],e)){r[e.groupIndex].push(e);for(var t=0,n=e.normalizedDeps.length;n>t;t++){var a=e.normalizedDeps[t],u=v[a];if(u&&!u.evaluated){var d=e.groupIndex+(u.declarative!=e.declarative);if(void 0===u.groupIndex||u.groupIndex<d){if(void 0!==u.groupIndex&&(r[u.groupIndex].splice(g.call(r[u.groupIndex],u),1),0==r[u.groupIndex].length))throw new TypeError("Mixed dependency cycle detected");u.groupIndex=d}o(u,r)}}}}function a(e){var r=v[e];r.groupIndex=0;var t=[];o(r,t);for(var n=!!r.declarative==t.length%2,a=t.length-1;a>=0;a--){for(var u=t[a],i=0;i<u.length;i++){var s=u[i];n?d(s):l(s)}n=!n}}function u(e){return y[e]||(y[e]={name:e,dependencies:[],exports:{},importers:[]})}function d(r){if(!r.module){var t=r.module=u(r.name),n=r.module.exports,o=r.declare.call(e,function(e,r){if(t.locked=!0,"object"==typeof e)for(var o in e)n[o]=e[o];else n[e]=r;for(var a=0,u=t.importers.length;u>a;a++){var d=t.importers[a];if(!d.locked)for(var i=0;i<d.dependencies.length;++i)d.dependencies[i]===t&&d.setters[i](n)}return t.locked=!1,r},{id:r.name});t.setters=o.setters,t.execute=o.execute;for(var a=0,i=r.normalizedDeps.length;i>a;a++){var l,s=r.normalizedDeps[a],c=v[s],f=y[s];f?l=f.exports:c&&!c.declarative?l=c.esModule:c?(d(c),f=c.module,l=f.exports):l=p(s),f&&f.importers?(f.importers.push(t),t.dependencies.push(f)):t.dependencies.push(null),t.setters[a]&&t.setters[a](l)}}}function i(e){var r,t=v[e];if(t)t.declarative?f(e,[]):t.evaluated||l(t),r=t.module.exports;else if(r=p(e),!r)throw new Error("Unable to load dependency "+e+".");return(!t||t.declarative)&&r&&r.__useDefault?r["default"]:r}function l(r){if(!r.module){var t={},n=r.module={exports:t,id:r.name};if(!r.executingRequire)for(var o=0,a=r.normalizedDeps.length;a>o;o++){var u=r.normalizedDeps[o],d=v[u];d&&l(d)}r.evaluated=!0;var c=r.execute.call(e,function(e){for(var t=0,n=r.deps.length;n>t;t++)if(r.deps[t]==e)return i(r.normalizedDeps[t]);throw new TypeError("Module "+e+" not declared as a dependency.")},t,n);void 0!==c&&(n.exports=c),t=n.exports,t&&t.__esModule?r.esModule=t:r.esModule=s(t)}}function s(r){var t={};if(("object"==typeof r||"function"==typeof r)&&r!==e)if(m)for(var n in r)"default"!==n&&c(t,r,n);else{var o=r&&r.hasOwnProperty;for(var n in r)"default"===n||o&&!r.hasOwnProperty(n)||(t[n]=r[n])}return t["default"]=r,x(t,"__useDefault",{value:!0}),t}function c(e,r,t){try{var n;(n=Object.getOwnPropertyDescriptor(r,t))&&x(e,t,n)}catch(o){return e[t]=r[t],!1}}function f(r,t){var n=v[r];if(n&&!n.evaluated&&n.declarative){t.push(r);for(var o=0,a=n.normalizedDeps.length;a>o;o++){var u=n.normalizedDeps[o];-1==g.call(t,u)&&(v[u]?f(u,t):p(u))}n.evaluated||(n.evaluated=!0,n.module.execute.call(e))}}function p(e){if(I[e])return I[e];if("@node/"==e.substr(0,6))return I[e]=s(D(e.substr(6)));var r=v[e];if(!r)throw"Module "+e+" not present.";return a(e),f(e,[]),v[e]=void 0,r.declarative&&x(r.module.exports,"__esModule",{value:!0}),I[e]=r.declarative?r.module.exports:r.esModule}var v={},g=Array.prototype.indexOf||function(e){for(var r=0,t=this.length;t>r;r++)if(this[r]===e)return r;return-1},m=!0;try{Object.getOwnPropertyDescriptor({a:0},"a")}catch(h){m=!1}var x;!function(){try{Object.defineProperty({},"a",{})&&(x=Object.defineProperty)}catch(e){x=function(e,r,t){try{e[r]=t.value||t.get.call(e)}catch(n){}}}}();var y={},D="undefined"!=typeof System&&System._nodeRequire||"undefined"!=typeof require&&"undefined"!=typeof require.resolve&&"undefined"!=typeof process&&process.platform&&require,I={"@empty":{}};return function(e,n,o,a){return function(u){u(function(u){for(var d={_nodeRequire:D,register:r,registerDynamic:t,get:p,set:function(e,r){I[e]=r},newModule:function(e){return e}},i=0;i<n.length;i++)(function(e,r){r&&r.__esModule?I[e]=r:I[e]=s(r)})(n[i],arguments[i]);a(d);var l=p(e[0]);if(e.length>1)for(var i=1;i<e.length;i++)p(e[i]);return o?l["default"]:l})}}}("undefined"!=typeof self?self:global)

(["1","2"], [], true, function($__System) {
var require = this.require, exports = this.exports, module = this.module;
!function(e){function r(e,r){for(var n=e.split(".");n.length;)r=r[n.shift()];return r}function n(n){if("string"==typeof n)return r(n,e);if(!(n instanceof Array))throw new Error("Global exports must be a string or array.");for(var t={},o=!0,f=0;f<n.length;f++){var i=r(n[f],e);o&&(t["default"]=i,o=!1),t[n[f].split(".").pop()]=i}return t}function t(r){if(Object.keys)Object.keys(e).forEach(r);else for(var n in e)a.call(e,n)&&r(n)}function o(r){t(function(n){if(-1==l.call(s,n)){try{var t=e[n]}catch(o){s.push(n)}r(n,t)}})}var f,i=$__System,a=Object.prototype.hasOwnProperty,l=Array.prototype.indexOf||function(e){for(var r=0,n=this.length;n>r;r++)if(this[r]===e)return r;return-1},s=["_g","sessionStorage","localStorage","clipboardData","frames","frameElement","external","mozAnimationStartTime","webkitStorageInfo","webkitIndexedDB","mozInnerScreenY","mozInnerScreenX"];i.set("@@global-helpers",i.newModule({prepareGlobal:function(r,t,i){var a=e.define;e.define=void 0;var l;if(i){l={};for(var s in i)l[s]=e[s],e[s]=i[s]}return t||(f={},o(function(e,r){f[e]=r})),function(){var r;if(t)r=n(t);else{r={};var i,s;o(function(e,n){f[e]!==n&&"undefined"!=typeof n&&(r[e]=n,"undefined"!=typeof i?s||i===n||(s=!0):i=n)}),r=s?r:i}if(l)for(var u in l)e[u]=l[u];return e.define=a,r}}}))}("undefined"!=typeof self?self:global);
!function(e){function n(e,n){e=e.replace(l,"");var r=e.match(u),t=(r[1].split(",")[n]||"require").replace(s,""),i=p[t]||(p[t]=new RegExp(a+t+f,"g"));i.lastIndex=0;for(var o,c=[];o=i.exec(e);)c.push(o[2]||o[3]);return c}function r(e,n,t,o){if("object"==typeof e&&!(e instanceof Array))return r.apply(null,Array.prototype.splice.call(arguments,1,arguments.length-1));if("string"==typeof e&&"function"==typeof n&&(e=[e]),!(e instanceof Array)){if("string"==typeof e){var l=i.get(e);return l.__useDefault?l["default"]:l}throw new TypeError("Invalid require")}for(var a=[],f=0;f<e.length;f++)a.push(i["import"](e[f],o));Promise.all(a).then(function(e){n&&n.apply(null,e)},t)}function t(t,l,a){"string"!=typeof t&&(a=l,l=t,t=null),l instanceof Array||(a=l,l=["require","exports","module"].splice(0,a.length)),"function"!=typeof a&&(a=function(e){return function(){return e}}(a)),void 0===l[l.length-1]&&l.pop();var f,u,s;-1!=(f=o.call(l,"require"))&&(l.splice(f,1),t||(l=l.concat(n(a.toString(),f)))),-1!=(u=o.call(l,"exports"))&&l.splice(u,1),-1!=(s=o.call(l,"module"))&&l.splice(s,1);var p={name:t,deps:l,execute:function(n,t,o){for(var p=[],c=0;c<l.length;c++)p.push(n(l[c]));o.uri=o.id,o.config=function(){},-1!=s&&p.splice(s,0,o),-1!=u&&p.splice(u,0,t),-1!=f&&p.splice(f,0,function(e,t,l){return"string"==typeof e&&"function"!=typeof t?n(e):r.call(i,e,t,l,o.id)});var d=a.apply(-1==u?e:t,p);return"undefined"==typeof d&&o&&(d=o.exports),"undefined"!=typeof d?d:void 0}};if(t)c.anonDefine||c.isBundle?c.anonDefine&&c.anonDefine.name&&(c.anonDefine=null):c.anonDefine=p,c.isBundle=!0,i.registerDynamic(p.name,p.deps,!1,p.execute);else{if(c.anonDefine&&!c.anonDefine.name)throw new Error("Multiple anonymous defines in module "+t);c.anonDefine=p}}var i=$__System,o=Array.prototype.indexOf||function(e){for(var n=0,r=this.length;r>n;n++)if(this[n]===e)return n;return-1},l=/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/gm,a="(?:^|[^$_a-zA-Z\\xA0-\\uFFFF.])",f="\\s*\\(\\s*(\"([^\"]+)\"|'([^']+)')\\s*\\)",u=/\(([^\)]*)\)/,s=/^\s+|\s+$/g,p={};t.amd={};var c={isBundle:!1,anonDefine:null};i.amdDefine=t,i.amdRequire=r}("undefined"!=typeof self?self:global);
$__System.registerDynamic("1", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    System.config({
      baseURL: "./",
      defaultJSExtensions: true,
      transpiler: "babel",
      babelOptions: {
        "optional": ["runtime", "optimisation.modules.system"]
      },
      paths: {
        "*": "./JavaScript/js/*",
        "mock/*": "./JavaScript/mock/*",
        "./*": "./*",
        "github:*": "jspm_packages/github/*",
        "npm:*": "jspm_packages/npm/*"
      },

      packages: {
        "summernote/summernote": {
          "format": "cjs"
        }
      },

      meta: {
        "*/RTCMultiConnection.js": {
          "format": "global"
        },
        "Editor/lib/codemirror/codemirror.js": {
          "format": "global"
        },
        "Editor/lib/codemirror/css.js": {
          "deps": ["Editor/lib/codemirror/codemirror.js"]
        },
        "Editor/lib/codemirror/formatting.js": {
          "deps": ["Editor/lib/codemirror/codemirror.js"]
        },
        "Editor/lib/codemirror/htmlmixed.js": {
          "deps": ["Editor/lib/codemirror/codemirror.js"]
        },
        "Editor/lib/codemirror/javascript.js": {
          "deps": ["Editor/lib/codemirror/codemirror.js"]
        }
      },

      map: {
        "AkeemMcLennon/dom2hscript": "github:AkeemMcLennon/dom2hscript@master",
        "Weedshaker/virtual-dom": "github:Weedshaker/virtual-dom@2.1.2",
        "babel": "npm:babel-core@5.8.38",
        "babel-runtime": "npm:babel-runtime@5.8.38",
        "bootstrap": "github:twbs/bootstrap@3.3.7",
        "capaj/systemjs-hot-reloader": "github:alexisvincent/systemjs-hot-reloader@0.6.0",
        "core-js": "npm:core-js@1.2.7",
        "hockic/summernote-ext-filedialog": "github:hockic/summernote-ext-filedialog@master",
        "jquery": "npm:jquery@3.3.1",
        "muaz-khan/RTCMultiConnection": "github:muaz-khan/RTCMultiConnection@3.4.4",
        "parse-torrent": "npm:parse-torrent@5.8.3",
        "pieroxy/lz-string": "github:pieroxy/lz-string@1.4.4",
        "socket.io-client": "github:socketio/socket.io-client@1.7.4",
        "summernote/summernote": "github:summernote/summernote@0.8.10",
        "tanaka-de-silva/google-diff-match-patch-js": "github:tanaka-de-silva/google-diff-match-patch-js@1.0.0",
        "webtorrent/webtorrent": "github:webtorrent/webtorrent@0.98.23",
        "xuset/indexeddb-chunk-store": "github:xuset/indexeddb-chunk-store@2.2.1",
        "github:alexisvincent/systemjs-hot-reloader@0.6.0": {
          "debug": "npm:debug@2.6.9",
          "socket.io-client": "github:socketio/socket.io-client@1.7.4",
          "weakee": "npm:weakee@1.0.0"
        },
        "github:jspm/nodelibs-assert@0.1.0": {
          "assert": "npm:assert@1.4.1"
        },
        "github:jspm/nodelibs-buffer@0.1.1": {
          "buffer": "npm:buffer@5.1.0"
        },
        "github:jspm/nodelibs-constants@0.1.0": {
          "constants-browserify": "npm:constants-browserify@0.0.1"
        },
        "github:jspm/nodelibs-crypto@0.1.0": {
          "crypto-browserify": "npm:crypto-browserify@3.12.0"
        },
        "github:jspm/nodelibs-events@0.1.1": {
          "events": "npm:events@1.0.2"
        },
        "github:jspm/nodelibs-http@1.7.1": {
          "Base64": "npm:Base64@0.2.1",
          "events": "github:jspm/nodelibs-events@0.1.1",
          "inherits": "npm:inherits@2.0.1",
          "stream": "github:jspm/nodelibs-stream@0.1.0",
          "url": "github:jspm/nodelibs-url@0.1.0",
          "util": "github:jspm/nodelibs-util@0.1.0"
        },
        "github:jspm/nodelibs-https@0.1.0": {
          "https-browserify": "npm:https-browserify@0.0.0"
        },
        "github:jspm/nodelibs-path@0.1.0": {
          "path-browserify": "npm:path-browserify@0.0.0"
        },
        "github:jspm/nodelibs-process@0.1.2": {
          "process": "npm:process@0.11.10"
        },
        "github:jspm/nodelibs-querystring@0.1.0": {
          "querystring": "npm:querystring@0.2.0"
        },
        "github:jspm/nodelibs-stream@0.1.0": {
          "stream-browserify": "npm:stream-browserify@1.0.0"
        },
        "github:jspm/nodelibs-string_decoder@0.1.0": {
          "string_decoder": "npm:string_decoder@0.10.31"
        },
        "github:jspm/nodelibs-url@0.1.0": {
          "url": "npm:url@0.10.3"
        },
        "github:jspm/nodelibs-util@0.1.0": {
          "util": "npm:util@0.10.3"
        },
        "github:jspm/nodelibs-vm@0.1.0": {
          "vm-browserify": "npm:vm-browserify@0.0.4"
        },
        "github:twbs/bootstrap@3.3.7": {
          "jquery": "npm:jquery@3.3.1"
        },
        "npm:asn1.js@4.10.1": {
          "bn.js": "npm:bn.js@4.11.8",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "inherits": "npm:inherits@2.0.3",
          "minimalistic-assert": "npm:minimalistic-assert@1.0.0",
          "vm": "github:jspm/nodelibs-vm@0.1.0"
        },
        "npm:assert@1.4.1": {
          "assert": "github:jspm/nodelibs-assert@0.1.0",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "process": "github:jspm/nodelibs-process@0.1.2",
          "util": "npm:util@0.10.3"
        },
        "npm:babel-runtime@5.8.38": {
          "process": "github:jspm/nodelibs-process@0.1.2"
        },
        "npm:bencode@2.0.0": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "safe-buffer": "npm:safe-buffer@5.1.1"
        },
        "npm:blob-to-buffer@1.2.7": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1"
        },
        "npm:browserify-aes@1.1.1": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "buffer-xor": "npm:buffer-xor@1.0.3",
          "cipher-base": "npm:cipher-base@1.0.4",
          "create-hash": "npm:create-hash@1.1.3",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "evp_bytestokey": "npm:evp_bytestokey@1.0.3",
          "inherits": "npm:inherits@2.0.1",
          "safe-buffer": "npm:safe-buffer@5.1.1",
          "systemjs-json": "github:systemjs/plugin-json@0.1.2"
        },
        "npm:browserify-cipher@1.0.0": {
          "browserify-aes": "npm:browserify-aes@1.1.1",
          "browserify-des": "npm:browserify-des@1.0.0",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "evp_bytestokey": "npm:evp_bytestokey@1.0.3"
        },
        "npm:browserify-des@1.0.0": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "cipher-base": "npm:cipher-base@1.0.4",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "des.js": "npm:des.js@1.0.0",
          "inherits": "npm:inherits@2.0.1"
        },
        "npm:browserify-rsa@4.0.1": {
          "bn.js": "npm:bn.js@4.11.8",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "constants": "github:jspm/nodelibs-constants@0.1.0",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "randombytes": "npm:randombytes@2.0.6"
        },
        "npm:browserify-sign@4.0.4": {
          "bn.js": "npm:bn.js@4.11.8",
          "browserify-rsa": "npm:browserify-rsa@4.0.1",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "create-hash": "npm:create-hash@1.1.3",
          "create-hmac": "npm:create-hmac@1.1.6",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "elliptic": "npm:elliptic@6.4.0",
          "inherits": "npm:inherits@2.0.1",
          "parse-asn1": "npm:parse-asn1@5.1.0",
          "stream": "github:jspm/nodelibs-stream@0.1.0",
          "systemjs-json": "github:systemjs/plugin-json@0.1.2"
        },
        "npm:buffer-xor@1.0.3": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "systemjs-json": "github:systemjs/plugin-json@0.1.2"
        },
        "npm:buffer@5.1.0": {
          "base64-js": "npm:base64-js@1.3.0",
          "ieee754": "npm:ieee754@1.1.12"
        },
        "npm:cipher-base@1.0.4": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "inherits": "npm:inherits@2.0.1",
          "safe-buffer": "npm:safe-buffer@5.1.1",
          "stream": "github:jspm/nodelibs-stream@0.1.0",
          "string_decoder": "github:jspm/nodelibs-string_decoder@0.1.0"
        },
        "npm:constants-browserify@0.0.1": {
          "systemjs-json": "github:systemjs/plugin-json@0.1.2"
        },
        "npm:core-js@1.2.7": {
          "fs": "github:jspm/nodelibs-fs@0.1.2",
          "path": "github:jspm/nodelibs-path@0.1.0",
          "process": "github:jspm/nodelibs-process@0.1.2",
          "systemjs-json": "github:systemjs/plugin-json@0.1.2"
        },
        "npm:core-util-is@1.0.2": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1"
        },
        "npm:create-ecdh@4.0.0": {
          "bn.js": "npm:bn.js@4.11.8",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "elliptic": "npm:elliptic@6.4.0"
        },
        "npm:create-hash@1.1.3": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "cipher-base": "npm:cipher-base@1.0.4",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "inherits": "npm:inherits@2.0.1",
          "ripemd160": "npm:ripemd160@2.0.1",
          "sha.js": "npm:sha.js@2.4.10"
        },
        "npm:create-hmac@1.1.6": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "cipher-base": "npm:cipher-base@1.0.4",
          "create-hash": "npm:create-hash@1.1.3",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "inherits": "npm:inherits@2.0.1",
          "ripemd160": "npm:ripemd160@2.0.1",
          "safe-buffer": "npm:safe-buffer@5.1.1",
          "sha.js": "npm:sha.js@2.4.10"
        },
        "npm:crypto-browserify@3.12.0": {
          "browserify-cipher": "npm:browserify-cipher@1.0.0",
          "browserify-sign": "npm:browserify-sign@4.0.4",
          "create-ecdh": "npm:create-ecdh@4.0.0",
          "create-hash": "npm:create-hash@1.1.3",
          "create-hmac": "npm:create-hmac@1.1.6",
          "diffie-hellman": "npm:diffie-hellman@5.0.2",
          "inherits": "npm:inherits@2.0.1",
          "pbkdf2": "npm:pbkdf2@3.0.14",
          "public-encrypt": "npm:public-encrypt@4.0.0",
          "randombytes": "npm:randombytes@2.0.6",
          "randomfill": "npm:randomfill@1.0.4"
        },
        "npm:debug@2.6.9": {
          "ms": "npm:ms@2.0.0"
        },
        "npm:des.js@1.0.0": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "inherits": "npm:inherits@2.0.1",
          "minimalistic-assert": "npm:minimalistic-assert@1.0.0"
        },
        "npm:diffie-hellman@5.0.2": {
          "bn.js": "npm:bn.js@4.11.8",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "miller-rabin": "npm:miller-rabin@4.0.1",
          "randombytes": "npm:randombytes@2.0.6",
          "systemjs-json": "github:systemjs/plugin-json@0.1.2"
        },
        "npm:elliptic@6.4.0": {
          "bn.js": "npm:bn.js@4.11.8",
          "brorand": "npm:brorand@1.1.0",
          "hash.js": "npm:hash.js@1.1.3",
          "hmac-drbg": "npm:hmac-drbg@1.0.1",
          "inherits": "npm:inherits@2.0.1",
          "minimalistic-assert": "npm:minimalistic-assert@1.0.0",
          "minimalistic-crypto-utils": "npm:minimalistic-crypto-utils@1.0.1",
          "systemjs-json": "github:systemjs/plugin-json@0.1.2"
        },
        "npm:evp_bytestokey@1.0.3": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "md5.js": "npm:md5.js@1.3.4",
          "safe-buffer": "npm:safe-buffer@5.1.1"
        },
        "npm:get-stdin@5.0.1": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "process": "github:jspm/nodelibs-process@0.1.2"
        },
        "npm:hash-base@2.0.2": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "inherits": "npm:inherits@2.0.3",
          "stream": "github:jspm/nodelibs-stream@0.1.0"
        },
        "npm:hash-base@3.0.4": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "inherits": "npm:inherits@2.0.3",
          "safe-buffer": "npm:safe-buffer@5.1.1",
          "stream": "github:jspm/nodelibs-stream@0.1.0"
        },
        "npm:hash.js@1.1.3": {
          "inherits": "npm:inherits@2.0.3",
          "minimalistic-assert": "npm:minimalistic-assert@1.0.0"
        },
        "npm:hmac-drbg@1.0.1": {
          "hash.js": "npm:hash.js@1.1.3",
          "minimalistic-assert": "npm:minimalistic-assert@1.0.0",
          "minimalistic-crypto-utils": "npm:minimalistic-crypto-utils@1.0.1",
          "systemjs-json": "github:systemjs/plugin-json@0.1.2"
        },
        "npm:https-browserify@0.0.0": {
          "http": "github:jspm/nodelibs-http@1.7.1"
        },
        "npm:inherits@2.0.1": {
          "util": "github:jspm/nodelibs-util@0.1.0"
        },
        "npm:inherits@2.0.3": {
          "util": "github:jspm/nodelibs-util@0.1.0"
        },
        "npm:magnet-uri@5.1.7": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "safe-buffer": "npm:safe-buffer@5.1.1",
          "thirty-two": "npm:thirty-two@1.0.2",
          "uniq": "npm:uniq@1.0.1",
          "xtend": "npm:xtend@4.0.1"
        },
        "npm:md5.js@1.3.4": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "hash-base": "npm:hash-base@3.0.4",
          "inherits": "npm:inherits@2.0.1"
        },
        "npm:miller-rabin@4.0.1": {
          "bn.js": "npm:bn.js@4.11.8",
          "brorand": "npm:brorand@1.1.0"
        },
        "npm:once@1.4.0": {
          "wrappy": "npm:wrappy@1.0.2"
        },
        "npm:parse-asn1@5.1.0": {
          "asn1.js": "npm:asn1.js@4.10.1",
          "browserify-aes": "npm:browserify-aes@1.1.1",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "create-hash": "npm:create-hash@1.1.3",
          "evp_bytestokey": "npm:evp_bytestokey@1.0.3",
          "pbkdf2": "npm:pbkdf2@3.0.14",
          "systemjs-json": "github:systemjs/plugin-json@0.1.2"
        },
        "npm:parse-torrent-file@4.1.0": {
          "bencode": "npm:bencode@2.0.0",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "path": "github:jspm/nodelibs-path@0.1.0",
          "simple-sha1": "npm:simple-sha1@2.1.0",
          "uniq": "npm:uniq@1.0.1"
        },
        "npm:parse-torrent@5.8.3": {
          "blob-to-buffer": "npm:blob-to-buffer@1.2.7",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "fs": "github:jspm/nodelibs-fs@0.1.2",
          "get-stdin": "npm:get-stdin@5.0.1",
          "magnet-uri": "npm:magnet-uri@5.1.7",
          "parse-torrent-file": "npm:parse-torrent-file@4.1.0",
          "process": "github:jspm/nodelibs-process@0.1.2",
          "simple-get": "npm:simple-get@2.7.0",
          "systemjs-json": "github:systemjs/plugin-json@0.1.2"
        },
        "npm:path-browserify@0.0.0": {
          "process": "github:jspm/nodelibs-process@0.1.2"
        },
        "npm:pbkdf2@3.0.14": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "create-hash": "npm:create-hash@1.1.3",
          "create-hmac": "npm:create-hmac@1.1.6",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "process": "github:jspm/nodelibs-process@0.1.2",
          "ripemd160": "npm:ripemd160@2.0.1",
          "safe-buffer": "npm:safe-buffer@5.1.1",
          "sha.js": "npm:sha.js@2.4.10"
        },
        "npm:process@0.11.10": {
          "assert": "github:jspm/nodelibs-assert@0.1.0",
          "fs": "github:jspm/nodelibs-fs@0.1.2",
          "vm": "github:jspm/nodelibs-vm@0.1.0"
        },
        "npm:public-encrypt@4.0.0": {
          "bn.js": "npm:bn.js@4.11.8",
          "browserify-rsa": "npm:browserify-rsa@4.0.1",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "create-hash": "npm:create-hash@1.1.3",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "parse-asn1": "npm:parse-asn1@5.1.0",
          "randombytes": "npm:randombytes@2.0.6"
        },
        "npm:punycode@1.3.2": {
          "process": "github:jspm/nodelibs-process@0.1.2"
        },
        "npm:randombytes@2.0.6": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "process": "github:jspm/nodelibs-process@0.1.2",
          "safe-buffer": "npm:safe-buffer@5.1.1"
        },
        "npm:randomfill@1.0.4": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "process": "github:jspm/nodelibs-process@0.1.2",
          "randombytes": "npm:randombytes@2.0.6",
          "safe-buffer": "npm:safe-buffer@5.1.1"
        },
        "npm:readable-stream@1.1.14": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "core-util-is": "npm:core-util-is@1.0.2",
          "events": "github:jspm/nodelibs-events@0.1.1",
          "inherits": "npm:inherits@2.0.3",
          "isarray": "npm:isarray@0.0.1",
          "process": "github:jspm/nodelibs-process@0.1.2",
          "stream-browserify": "npm:stream-browserify@1.0.0",
          "string_decoder": "npm:string_decoder@0.10.31"
        },
        "npm:ripemd160@2.0.1": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "hash-base": "npm:hash-base@2.0.2",
          "inherits": "npm:inherits@2.0.1"
        },
        "npm:rusha@0.8.13": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1"
        },
        "npm:safe-buffer@5.1.1": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1"
        },
        "npm:sha.js@2.4.10": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "fs": "github:jspm/nodelibs-fs@0.1.2",
          "inherits": "npm:inherits@2.0.1",
          "process": "github:jspm/nodelibs-process@0.1.2",
          "safe-buffer": "npm:safe-buffer@5.1.1"
        },
        "npm:simple-concat@1.0.0": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1"
        },
        "npm:simple-get@2.7.0": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "http": "github:jspm/nodelibs-http@1.7.1",
          "https": "github:jspm/nodelibs-https@0.1.0",
          "once": "npm:once@1.4.0",
          "querystring": "github:jspm/nodelibs-querystring@0.1.0",
          "simple-concat": "npm:simple-concat@1.0.0",
          "url": "github:jspm/nodelibs-url@0.1.0"
        },
        "npm:simple-sha1@2.1.0": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1",
          "crypto": "github:jspm/nodelibs-crypto@0.1.0",
          "process": "github:jspm/nodelibs-process@0.1.2",
          "rusha": "npm:rusha@0.8.13"
        },
        "npm:stream-browserify@1.0.0": {
          "events": "github:jspm/nodelibs-events@0.1.1",
          "inherits": "npm:inherits@2.0.3",
          "readable-stream": "npm:readable-stream@1.1.14"
        },
        "npm:string_decoder@0.10.31": {
          "buffer": "github:jspm/nodelibs-buffer@0.1.1"
        },
        "npm:thirty-two@1.0.2": {
          "assert": "github:jspm/nodelibs-assert@0.1.0",
          "buffer": "github:jspm/nodelibs-buffer@0.1.1"
        },
        "npm:url@0.10.3": {
          "assert": "github:jspm/nodelibs-assert@0.1.0",
          "punycode": "npm:punycode@1.3.2",
          "querystring": "npm:querystring@0.2.0",
          "util": "github:jspm/nodelibs-util@0.1.0"
        },
        "npm:util@0.10.3": {
          "inherits": "npm:inherits@2.0.1",
          "process": "github:jspm/nodelibs-process@0.1.2"
        },
        "npm:vm-browserify@0.0.4": {
          "indexof": "npm:indexof@0.0.1"
        }
      }
    });
  })(this);

  return _retrieveGlobal();
});
$__System.register('3', ['4', '5', '6', '7'], function (_export) {
	var MasterLastMessage, _get, _inherits, _classCallCheck, SentMessage;

	return {
		setters: [function (_4) {
			MasterLastMessage = _4.MasterLastMessage;
		}, function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			SentMessage = (function (_MasterLastMessage) {
				_inherits(SentMessage, _MasterLastMessage);

				function SentMessage(elID, remoteUserId) {
					_classCallCheck(this, SentMessage);

					_get(Object.getPrototypeOf(SentMessage.prototype), 'constructor', this).call(this, elID, remoteUserId);
				}

				return SentMessage;
			})(MasterLastMessage);

			_export('SentMessage', SentMessage);
		}
	};
});
$__System.registerDynamic("8", ["9"], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var _Object$defineProperty = $__require("9")["default"];
  exports["default"] = function (obj, key, value) {
    if (key in obj) {
      _Object$defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  };
  exports.__esModule = true;
});
$__System.register('4', ['7', '8', 'a'], function (_export) {
	var _classCallCheck, _defineProperty, _createClass, MasterLastMessage;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			_defineProperty = _2['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterLastMessage = (function () {
				function MasterLastMessage() {
					var elID = arguments.length <= 0 || arguments[0] === undefined ? 'sst_all' : arguments[0];
					var remoteUserId = arguments.length <= 1 || arguments[1] === undefined ? 'sst_toAll' : arguments[1];

					_classCallCheck(this, MasterLastMessage);

					this.elID = elID;
					this.remoteUserId = remoteUserId;

					// shared vars
					this.cont = _defineProperty({}, this.remoteUserId, _defineProperty({}, this.elID, '')); // sst_toAll means to all channel peers, sst_all is just a dummy class for elementID
				}

				_createClass(MasterLastMessage, [{
					key: 'set',
					value: function set(message) {
						var elID = arguments.length <= 1 || arguments[1] === undefined ? this.elID : arguments[1];
						var remoteUserId = arguments.length <= 2 || arguments[2] === undefined ? this.remoteUserId : arguments[2];

						// keep track on sent messages
						// new unique message
						if (!this.cont[remoteUserId]) {
							this.cont[remoteUserId] = {};
						}
						this.cont[remoteUserId][elID] = [new Date().getTime(), message];
					}
				}, {
					key: 'get',
					value: function get() {
						var elID = arguments.length <= 0 || arguments[0] === undefined ? this.elID : arguments[0];
						var remoteUserId = arguments.length <= 1 || arguments[1] === undefined ? this.remoteUserId : arguments[1];

						return this.cont[remoteUserId] && this.cont[remoteUserId][elID] ? this.cont[remoteUserId][elID][1] : false;
					}
				}, {
					key: 'getLatestElIDvsToAll',
					value: function getLatestElIDvsToAll() {
						var elID = arguments.length <= 0 || arguments[0] === undefined ? this.elID : arguments[0];
						var remoteUserId = arguments.length <= 1 || arguments[1] === undefined ? this.remoteUserId : arguments[1];

						if (this.cont[remoteUserId] && this.cont[remoteUserId][elID] && this.cont[this.remoteUserId][elID]) {
							return this.cont[this.remoteUserId][elID][0] > this.cont[remoteUserId][elID][0] ? this.cont[this.remoteUserId][elID][1] : this.cont[remoteUserId][elID][1];
						} else {
							return this.cont[remoteUserId] && this.cont[remoteUserId][elID] ? this.cont[remoteUserId][elID][1] : this.cont[this.remoteUserId][elID][1];
						}
					}
				}, {
					key: 'getAll',
					value: function getAll() {
						var remoteUserId = arguments.length <= 0 || arguments[0] === undefined ? this.remoteUserId : arguments[0];

						var messages = [];
						for (var key in this.cont[remoteUserId]) {
							if (this.cont[remoteUserId].hasOwnProperty(key) && this.cont[remoteUserId][key].length > 0) {
								messages.push([this.cont[remoteUserId][key][1], key, remoteUserId]);
							}
						}
						return messages;
					}
				}]);

				return MasterLastMessage;
			})();

			_export('MasterLastMessage', MasterLastMessage);
		}
	};
});
$__System.register('b', ['4', '5', '6', '7'], function (_export) {
	var MasterLastMessage, _get, _inherits, _classCallCheck, ReceivedMessage;

	return {
		setters: [function (_4) {
			MasterLastMessage = _4.MasterLastMessage;
		}, function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			ReceivedMessage = (function (_MasterLastMessage) {
				_inherits(ReceivedMessage, _MasterLastMessage);

				function ReceivedMessage(elID, remoteUserId) {
					_classCallCheck(this, ReceivedMessage);

					_get(Object.getPrototypeOf(ReceivedMessage.prototype), 'constructor', this).call(this, elID, remoteUserId);

					this.cont = {};
				}

				return ReceivedMessage;
			})(MasterLastMessage);

			_export('ReceivedMessage', ReceivedMessage);
		}
	};
});
$__System.register('c', ['5', '6', '7', '10', 'a', 'd', 'e', 'f'], function (_export) {
	var _get, _inherits, _classCallCheck, _Map, _createClass, MasterOption, Diff_match_patchWorker, LZStringWorker, OptionSender;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_4) {
			_Map = _4['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_d) {
			MasterOption = _d.MasterOption;
		}, function (_e) {
			Diff_match_patchWorker = _e.Diff_match_patchWorker;
		}, function (_f) {
			LZStringWorker = _f.LZStringWorker;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			OptionSender = (function (_MasterOption) {
				_inherits(OptionSender, _MasterOption);

				function OptionSender(SentMessage, returnMap) {
					var _this = this;

					_classCallCheck(this, OptionSender);

					_get(Object.getPrototypeOf(OptionSender.prototype), 'constructor', this).call(this, returnMap);

					this.SentMessage = SentMessage;
					// workers can only handle arrays in their data -> setOptions and getOptions has to be used to map to array
					/**
      * (api hook)
      * setOptions & getOptions convert map to array according to the number passed to the map at value array[0], since webworker can't handle send/receive Objects like Map
      * 
      * @param {Map([['diffed', [0, true]], ['compressed', [1, 'auto']]])} options
      * @memberof OptionSender
      */
					this.options = new _Map([['diffed', [0, true]],
					//['diffed', [0, false]],
					['compressed', [1, 'auto']]
					//['compressed', [1, false]]
					]);

					// workers
					this.Diff_match_patchWorker = new Diff_match_patchWorker();
					this.Diff_match_patchWorker.create(this.Diff_match_patchWorker.sendDiff, function (result) {
						_this.returnApply('sendDiff', result);
					});
					this.LZStringWorker = new LZStringWorker();
					this.LZStringWorker.create(this.LZStringWorker.sendCompress, function (result) {
						_this.returnApply('sendCompress', result);
					});
				}

				_createClass(OptionSender, [{
					key: 'init',
					value: function init() {
						for (var _len = arguments.length, data = Array(_len), _key = 0; _key < _len; _key++) {
							data[_key] = arguments[_key];
						}

						data.push(this.optionsConvertMapToArray(data.pop()));
						_get(Object.getPrototypeOf(OptionSender.prototype), 'init', this).apply(this, data);
					}
				}, {
					key: 'sendDiff',
					value: function sendDiff(message, elID, remoteUserId, requestID, options) {
						var result = arguments.length <= 5 || arguments[5] === undefined ? [] : arguments[5];

						if (this.getOptions('diffed', options)) {
							var oldMessage = this.SentMessage.get(elID, remoteUserId);
							if (oldMessage && oldMessage.length > 0 && message[1] !== oldMessage) {
								this.Diff_match_patchWorker.run([oldMessage, message, elID, remoteUserId, requestID, options, result]);
								return true;
							}
						}
						// whole message
						result.push('sendDiff:false');
						this.returnApply('sendDiff', [message, elID, remoteUserId, requestID, options, result]);
						return false;
					}
				}, {
					key: 'sendCompress',
					value: function sendCompress(message, elID, remoteUserId, requestID, options) {
						var result = arguments.length <= 5 || arguments[5] === undefined ? [] : arguments[5];

						// compression: false (68kB in 68, 1MB in 2317),
						// Uint8Array (68kB in 91, 1MB in 6218),
						// EncodedURIComponent (68kB in 48, 1MB in 2484),
						// auto (chooses fastest compression 'EncodedURIComponent', if no base64 in message)
						var compressed = this.getOptions('compressed', options);
						if (compressed === 'auto') {
							compressed = message[1].indexOf('base64') === -1 ? 'EncodedURIComponent' : false;
							// set the options to the changed parameter, used insed message info for receive/decompress
							options = this.setOptions('compressed', compressed, options);
						}
						if (compressed) {
							this.LZStringWorker.run([compressed, message, elID, remoteUserId, requestID, options, result]);
							return true;
						}
						// whole message
						result.push('sendCompress:false');
						this.returnApply('sendCompress', [message, elID, remoteUserId, requestID, options, result]);
						return false;
					}

					// workers can only handle arrays in their data -> setOptions and getOptions has to be used to map to array
				}, {
					key: 'optionsConvertMapToArray',
					value: function optionsConvertMapToArray(map) {
						var _this2 = this;

						if (map instanceof _Map) {
							var _ret = (function () {
								var arr = [];
								map.forEach(function (value, key) {
									var i = _this2.options.get(key)[0];
									arr[i] = value;
								});
								return {
									v: arr
								};
							})();

							if (typeof _ret === 'object') return _ret.v;
						}
						return [];
					}
				}, {
					key: 'setOptions',
					value: function setOptions(name, prop) {
						var options = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];

						var i = this.options.get(name)[0];
						options[i] = prop;
						return options;
					}
				}, {
					key: 'getOptions',
					value: function getOptions(name) {
						var options = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

						var i = this.options.get(name)[0];
						return options[i] !== undefined ? options[i] : this.options.get(name)[1];
					}
				}, {
					key: 'getCompressedStatus',
					value: function getCompressedStatus(options) {
						var compressed = this.getOptions('compressed', options) === 'auto' ? false : this.getOptions('compressed', options);
						return compressed ? compressed : false;
					}
				}]);

				return OptionSender;
			})(MasterOption);

			_export('OptionSender', OptionSender);
		}
	};
});
$__System.register('11', ['7', '12', 'a', 'c'], function (_export) {
	var _classCallCheck, Helper, _createClass, OptionSender, MasterSender;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			Helper = _2.Helper;
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_c) {
			OptionSender = _c.OptionSender;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterSender = (function () {
				function MasterSender(connection, SentMessage) {
					_classCallCheck(this, MasterSender);

					this.connection = connection;
					this.SentMessage = SentMessage;

					this.Helper = new Helper();
					this.OptionSender = new OptionSender(this.SentMessage);
					this.OptionSender.returnMap.set('init', [this.OptionSender.sendDiff, this.OptionSender]);
					this.OptionSender.returnMap.set('sendDiff', [this.OptionSender.sendCompress, this.OptionSender]);
					this.OptionSender.returnMap.set('sendCompress', [this.send, this]);
					this.changeDelay = 1000;
					this.timeout = true;
					this.timeoutCont = null; // used internal when timeout true
					this.chunkSize = this.connection.chunkSize || 1000;
					this.chunkSizeRegEx = new RegExp('(.|[\r\n]){1,' + this.chunkSize + '}', 'g');
				}

				/**
     * message, elID (used for Diff_match_patch), remoteUserId (@user), requestID (used at sendRequest)
     * sendEvent (api hook)
     * 
     * @param {string} message 
     * @param {string} [elID=this.SentMessage.elID] 
     * @param {string} [remoteUserId=this.SentMessage.remoteUserId] 
     * @param {string} [requestID=''] 
     * @param {boolean} [timeout=this.timeout] 
     * @param {Map} options 
     * @memberof MasterSender
     */

				_createClass(MasterSender, [{
					key: 'sendEvent',
					value: function sendEvent(message, elID, remoteUserId, requestID, timeout, options) {
						if (elID === undefined) elID = this.SentMessage.elID;
						if (remoteUserId === undefined) remoteUserId = this.SentMessage.remoteUserId;
						if (requestID === undefined) requestID = '';

						var _this = this;

						if (timeout === undefined) timeout = this.timeout;

						if (this.connection.getAllParticipants().length > 0 && message.length > 0) {
							//console.log(`send: ${message}`);
							if (timeout) {
								clearTimeout(this.timeoutCont);
								this.timeoutCont = setTimeout(function () {
									if (message !== _this.SentMessage.get(elID, remoteUserId)) {
										// make a backup of the message and doublicate to [rawMessage, message]
										_this.OptionSender.init([message, message], elID, remoteUserId, requestID, options);
									}
								}, this.changeDelay);
							} else {
								if (message !== this.SentMessage.get(elID, remoteUserId)) {
									// make a backup of the message and doublicate to [rawMessage, message]
									this.OptionSender.init([message, message], elID, remoteUserId, requestID, options);
								}
							}
						} else {
							console.info('SST: Not connected!');
						}
					}

					// message = [rawMessage, message]
				}, {
					key: 'send',
					value: function send(message, elID, remoteUserId, requestID, options) {
						var _this2 = this;

						// set rawMessage
						this.SentMessage.set(message[0], elID, remoteUserId);
						// check compression
						var compressed = this.OptionSender.getCompressedStatus(options);
						var chunks = message[1].toString().match(this.chunkSizeRegEx);
						if (chunks.length > 0) {
							var toAll = remoteUserId === this.SentMessage.remoteUserId || !remoteUserId;
							var remoteUserIds = toAll ? this.connection.getAllParticipants() : [remoteUserId];
							remoteUserIds.forEach(function (remoteUserId) {
								var remoteUser = _this2.connection.peers[remoteUserId];
								if (remoteUser) {
									if (!remoteUser.channels.length) {
										_this2.connection.peers[remoteUserId].createDataChannel();
										_this2.connection.renegotiate(remoteUserId);
										setTimeout(function () {
											_this2._send(chunks, elID, remoteUserId, requestID, compressed);
										}, 3000);
									}
									_this2._send(chunks, elID, remoteUserId, requestID, compressed);
									return true;
								} else {
									console.warn('SST: Unable to send message to ' + remoteUserId + '. No connection.peers found!');
								}
							});
						}
						return false;
					}
				}, {
					key: '_send',
					value: function _send(chunks, elID, remoteUserId, requestID) {
						var compressed = arguments.length <= 4 || arguments[4] === undefined ? false : arguments[4];

						var uuid = this.Helper.getRandomString();
						this.connection.peers[remoteUserId].channels.forEach(function (channel) {
							chunks.forEach(function (chunk, i) {
								var info = [uuid, elID, requestID, compressed, i + 1, chunks.length, new Date().getTime()];
								channel.send(chunk + '(sst:' + info.toString() + ')');
							});
						});
					}
				}, {
					key: 'setIgnoreOption',
					value: function setIgnoreOption() {
						// skip with binding this.send
						this.oldInit = this.OptionSender.init;
						this.OptionSender.init = this.send.bind(this);
					}
				}, {
					key: 'unsetIgnoreOption',
					value: function unsetIgnoreOption() {
						// skip with binding this.send
						this.OptionSender.init = this.oldInit ? this.oldInit : this.OptionSender.init;
					}
				}]);

				return MasterSender;
			})();

			_export('MasterSender', MasterSender);
		}
	};
});
$__System.register('13', ['5', '6', '7', '11'], function (_export) {
	var _get, _inherits, _classCallCheck, MasterSender, Sender;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_4) {
			MasterSender = _4.MasterSender;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			Sender = (function (_MasterSender) {
				_inherits(Sender, _MasterSender);

				function Sender(connection, SentMessage) {
					_classCallCheck(this, Sender);

					_get(Object.getPrototypeOf(Sender.prototype), 'constructor', this).call(this, connection, SentMessage);
				}

				return Sender;
			})(MasterSender);

			_export('Sender', Sender);
		}
	};
});
$__System.register('14', ['7', '10', '12', 'a'], function (_export) {
	var _classCallCheck, _Map, Helper, _createClass, MasterConnectionEvent;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			_Map = _2['default'];
		}, function (_3) {
			Helper = _3.Helper;
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterConnectionEvent = (function () {
				function MasterConnectionEvent(connection, Sender, SentMessage) {
					var _this = this;

					_classCallCheck(this, MasterConnectionEvent);

					this.connection = connection;
					this.Sender = Sender;
					this.SentMessage = SentMessage;

					this.openOrJoinEventDelay = 5000;
					this.newParticipantDelay = 1000;
					// newParticipantEvent
					this.connection.onNewParticipant = function (participantId, userPreferences) {
						_this.newParticipant(participantId, userPreferences);
					};
					this.Helper = new Helper();
					this.onNewParticipant = this.Helper.getEventHandler(); // event handler (api hook)
				}

				/**
     * called from dom
     * openOrJoinEvent (api hook)
     * 
     * @param {string} roomid 
     * @param {string} [message=''] 
     * @param {string} [elID=''] 
     * @memberof MasterConnectionEvent
     */

				_createClass(MasterConnectionEvent, [{
					key: 'openOrJoinEvent',
					value: function openOrJoinEvent(roomid) {
						var _this2 = this;

						var message = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];
						var elID = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];

						this.connection.openOrJoin(roomid || 'predefiend-roomid');
						setTimeout(function () {
							if (!_this2.connection.isInitiator) {
								_this2.Sender.sendEvent(message, elID, undefined, undefined, false, new _Map([['diffed', false]]));
							}
						}, this.openOrJoinEventDelay); // timeout = false, diffed = false
					}

					// called from connection
					// newParticipant
				}, {
					key: 'newParticipant',
					value: function newParticipant(remoteUserId, userPreferences) {
						var _this3 = this;

						this.connection.acceptParticipationRequest(remoteUserId, userPreferences);
						var msgElID = false;
						this.onNewParticipant.container.forEach(function (e) {
							var result = e.func.apply(e.scope, [remoteUserId].concat(e.args));
							msgElID = result.constructor === Array && result[0] && result[1] ? result : msgElID;
						});
						setTimeout(function () {
							if (_this3.connection.isInitiator) {
								if (msgElID) {
									_this3.Sender.sendEvent(msgElID[0], msgElID[1], remoteUserId, undefined, false, new _Map([['diffed', false]])); // timeout = false, diffed = false
								} else {
										_this3.SentMessage.getAll().forEach(function (message) {
											_this3.Sender.sendEvent(message[0], message[1], remoteUserId, undefined, false, new _Map([['diffed', false]])); // timeout = false, diffed = false
										});
									}
							}
						}, this.newParticipantDelay);
					}
				}]);

				return MasterConnectionEvent;
			})();

			_export('MasterConnectionEvent', MasterConnectionEvent);
		}
	};
});
$__System.register('15', ['5', '6', '7', '14'], function (_export) {
	var _get, _inherits, _classCallCheck, MasterConnectionEvent, ConnectionEvent;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_4) {
			MasterConnectionEvent = _4.MasterConnectionEvent;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			ConnectionEvent = (function (_MasterConnectionEvent) {
				_inherits(ConnectionEvent, _MasterConnectionEvent);

				function ConnectionEvent(connection, Sender, SentMessage) {
					_classCallCheck(this, ConnectionEvent);

					_get(Object.getPrototypeOf(ConnectionEvent.prototype), 'constructor', this).call(this, connection, Sender, SentMessage);
				}

				return ConnectionEvent;
			})(MasterConnectionEvent);

			_export('ConnectionEvent', ConnectionEvent);
		}
	};
});
$__System.register('16', ['7', '10', '12', 'a'], function (_export) {
	var _classCallCheck, _Map, Helper, _createClass, MasterRequestor;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			_Map = _2['default'];
		}, function (_3) {
			Helper = _3.Helper;
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterRequestor = (function () {
				function MasterRequestor(Sender, SentMessage) {
					_classCallCheck(this, MasterRequestor);

					this.Sender = Sender;
					this.SentMessage = SentMessage;

					this.Helper = new Helper();
					this.initRequest = '!!!@';
					this.request = { resendMessage: '-> resendMessage!!!' };
					this.requests = {};
				}

				// requests
				// local

				_createClass(MasterRequestor, [{
					key: 'sendRequest',
					value: function sendRequest(request, elID, remoteUserId) {
						var requestID = this.Helper.getRandomString();
						this.requests[requestID] = request;
						this.Sender.sendEvent('' + this.initRequest + remoteUserId + request, elID, remoteUserId, requestID, false, new _Map([['diffed', false]])); // timeout = false, diffed = false
					}

					// remote
				}, {
					key: 'receiveRequest',
					value: function receiveRequest(request, requestID, elID, remoteUserId, localUserId) {
						switch (request) {
							case '' + this.initRequest + localUserId + this.request.resendMessage:
								// resend last WHOLE message
								this.Sender.sendEvent(this.SentMessage.getLatestElIDvsToAll(elID, remoteUserId), elID, remoteUserId, requestID, undefined, new _Map([['diffed', false]])); // diffed = false
								break;
						}
					}

					// local
				}, {
					key: 'fullFilledRequest',
					value: function fullFilledRequest(requestID, oldMessage, dataPack) {
						switch (this.requests[requestID]) {
							case this.request.resendMessage:
								delete this.requests[requestID];
								return dataPack;
						}
						return false;
					}
				}]);

				return MasterRequestor;
			})();

			_export('MasterRequestor', MasterRequestor);
		}
	};
});
$__System.register('17', ['5', '6', '7', '16'], function (_export) {
	var _get, _inherits, _classCallCheck, MasterRequestor, Requestor;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_4) {
			MasterRequestor = _4.MasterRequestor;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			Requestor = (function (_MasterRequestor) {
				_inherits(Requestor, _MasterRequestor);

				function Requestor(Sender, SentMessage) {
					_classCallCheck(this, Requestor);

					_get(Object.getPrototypeOf(Requestor.prototype), 'constructor', this).call(this, Sender, SentMessage);
				}

				return Requestor;
			})(MasterRequestor);

			_export('Requestor', Requestor);
		}
	};
});
$__System.register('e', ['5', '6', '7', '12', '18', 'a'], function (_export) {
	var _get, _inherits, _classCallCheck, Helper, MasterWorker, _createClass, Diff_match_patchWorker;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_5) {
			Helper = _5.Helper;
		}, function (_4) {
			MasterWorker = _4.MasterWorker;
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			Diff_match_patchWorker = (function (_MasterWorker) {
				_inherits(Diff_match_patchWorker, _MasterWorker);

				function Diff_match_patchWorker() {
					_classCallCheck(this, Diff_match_patchWorker);

					_get(Object.getPrototypeOf(Diff_match_patchWorker.prototype), 'constructor', this).call(this, false);

					this.name = 'Diff_match_patchWorker';
					this.Helper = new Helper();
					this.scripts = this.Helper.addBaseURL(['jspm_packages/' + System.map['tanaka-de-silva/google-diff-match-patch-js'] + '/diff_match_patch.js'], false);
				}

				_createClass(Diff_match_patchWorker, [{
					key: 'sendDiff',
					value: function sendDiff(data) {
						// diff
						//https://code.google.com/p/google-diff-match-patch/
						// https://neil.fraser.name/software/diff_match_patch/svn/trunk/demos/demo_patch.html
						this.Diff_match_patch = new diff_match_patch();
						// data = [oldMessage, [rawMessage, message], elID, remoteUserId, requestID, options, result]
						var diff = this.Diff_match_patch.diff_main(data[0], data[1][1], true); // needs diff to react sensitive
						var patch = this.Diff_match_patch.patch_make(data[0], data[1][1], diff);
						data[1][1] = this.Diff_match_patch.patch_toText(patch);
						if (data[6].constructor !== Array) {
							data[6] = [];
						}
						data[6].push('sendDiff:true');
						// remove oldMessage
						data.splice(0, 1);
						return data;
					}
				}, {
					key: 'receiveDiff',
					value: function receiveDiff(data) {
						//https://code.google.com/p/google-diff-match-patch/
						// https://neil.fraser.name/software/diff_match_patch/svn/trunk/demos/demo_patch.html
						this.Diff_match_patch = new diff_match_patch();
						// data = [[oldMessage, message], elID, remoteUserId, requestID, options, result]
						var patch = this.Diff_match_patch.patch_fromText(data[0][1]);
						var results = this.Diff_match_patch.patch_apply(patch, data[0][0]);
						if (data[5].constructor !== Array) {
							data[5] = [];
						}
						if (results[1].indexOf(false) !== -1) {
							data[5].push('receiveDiff:failed');
						} else {
							data[0][1] = results[0];
							data[5].push('receiveDiff:true');
						}
						return data;
					}
				}]);

				return Diff_match_patchWorker;
			})(MasterWorker);

			_export('Diff_match_patchWorker', Diff_match_patchWorker);
		}
	};
});
$__System.register('12', ['5', '6', '7', '19', 'a'], function (_export) {
	var _get, _inherits, _classCallCheck, MasterHelper, _createClass, Helper;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_4) {
			MasterHelper = _4.MasterHelper;
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			Helper = (function (_MasterHelper) {
				_inherits(Helper, _MasterHelper);

				function Helper() {
					_classCallCheck(this, Helper);

					_get(Object.getPrototypeOf(Helper.prototype), 'constructor', this).apply(this, arguments);
				}

				_createClass(Helper, [{
					key: 'getEventHandler',

					/**
      * event handler (api hook)
      * 
      * @param {Function} func 
      * @param {string} [scope = this]
      * @param {string} [args = [message = '', elID = '']]
      * @memberof Helper
      */
					value: function getEventHandler() {
						return {
							container: [],
							add: function add(func) {
								var scope = arguments.length <= 1 || arguments[1] === undefined ? this : arguments[1];
								var args = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];

								this.container.push({ func: func, scope: scope, args: args });
							},
							remove: function remove(func) {
								var scope = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

								this.container = this.container.filter(function (value, index, array) {
									if (func === value.func && (scope === false || scope === value.scope)) {
										return false;
									}
									return true;
								});
							}
						};
					}
				}, {
					key: 'arrayKeyValStrToObj',
					value: function arrayKeyValStrToObj() {
						var arr = arguments.length <= 0 || arguments[0] === undefined ? ['key:val', 'key:val'] : arguments[0];
						var needle = arguments.length <= 1 || arguments[1] === undefined ? ':' : arguments[1];

						var obj = {};
						arr.forEach(function (e) {
							e = e.split(needle);
							var val = e[1].trim();
							obj[e[0].trim()] = val === 'true' || val === 'false' ? val === 'true' : val;
						});
						return obj;
					}
				}]);

				return Helper;
			})(MasterHelper);

			_export('Helper', Helper);
		}
	};
});
$__System.register('f', ['5', '6', '7', '12', '18', 'a'], function (_export) {
	var _get, _inherits, _classCallCheck, Helper, MasterWorker, _createClass, LZStringWorker;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_5) {
			Helper = _5.Helper;
		}, function (_4) {
			MasterWorker = _4.MasterWorker;
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			LZStringWorker = (function (_MasterWorker) {
				_inherits(LZStringWorker, _MasterWorker);

				function LZStringWorker() {
					_classCallCheck(this, LZStringWorker);

					_get(Object.getPrototypeOf(LZStringWorker.prototype), 'constructor', this).call(this, false);

					this.name = 'LZStringWorker';
					this.Helper = new Helper();
					this.scripts = this.Helper.addBaseURL(['jspm_packages/' + System.map['pieroxy/lz-string'] + '/libs/lz-string.min.js'], false);
				}

				_createClass(LZStringWorker, [{
					key: 'sendCompress',
					value: function sendCompress(data) {
						// compress
						// data = [compressed, [rawMessage, message], elID, remoteUserId, requestID, options, result]
						var command = data[0] === 'compress' ? 'compress' : 'compressTo' + data[0];
						data[1][1] = LZString[command](data[1][1]);
						if (data[6].constructor !== Array) {
							data[6] = [];
						}
						data[6].push('sendCompress:true');
						// remove compressed
						data.splice(0, 1);
						return data;
					}
				}, {
					key: 'receiveDecompress',
					value: function receiveDecompress(data) {
						// compress
						// data = [compressed, [oldMessage, message], elID, remoteUserId, requestID, options, result]
						var command = data[0] === 'compress' ? 'decompress' : 'decompressFrom' + data[0];
						data[1][1] = LZString[command](data[1][1]);
						if (data[6].constructor !== Array) {
							data[6] = [];
						}
						data[6].push('receiveDecompress:true');
						// remove compressed
						data.splice(0, 1);
						return data;
					}
				}]);

				return LZStringWorker;
			})(MasterWorker);

			_export('LZStringWorker', LZStringWorker);
		}
	};
});
$__System.register('1a', ['5', '6', '7', 'a', 'd', 'e', 'f'], function (_export) {
	var _get, _inherits, _classCallCheck, _createClass, MasterOption, Diff_match_patchWorker, LZStringWorker, OptionReceiver;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_d) {
			MasterOption = _d.MasterOption;
		}, function (_e) {
			Diff_match_patchWorker = _e.Diff_match_patchWorker;
		}, function (_f) {
			LZStringWorker = _f.LZStringWorker;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			OptionReceiver = (function (_MasterOption) {
				_inherits(OptionReceiver, _MasterOption);

				function OptionReceiver(returnMap) {
					var _this = this;

					_classCallCheck(this, OptionReceiver);

					_get(Object.getPrototypeOf(OptionReceiver.prototype), 'constructor', this).call(this, returnMap);

					// workers
					this.LZStringWorker = new LZStringWorker();
					this.LZStringWorker.create(this.LZStringWorker.receiveDecompress, function (result) {
						_this.returnApply('receiveDecompress', result);
					});
					this.Diff_match_patchWorker = new Diff_match_patchWorker();
					this.Diff_match_patchWorker.create(this.Diff_match_patchWorker.receiveDiff, function (result) {
						_this.returnApply('receiveDiff', result);
					});
				}

				_createClass(OptionReceiver, [{
					key: 'receiveDecompress',
					value: function receiveDecompress(message, elID, remoteUserId, requestID, options) {
						var result = arguments.length <= 5 || arguments[5] === undefined ? [] : arguments[5];

						// options[0] must be compress option set in MasterReceiver
						if (options[0] !== 'false') {
							if (options[0] === 'Uint8Array') {
								message[1] = message[1].split(',').map(Number);
							}
							this.LZStringWorker.run([options[0], message, elID, remoteUserId, requestID, options, result]);
							return true;
						}
						// whole message
						result.push('receiveDecompress:false');
						this.returnApply('receiveDecompress', [message, elID, remoteUserId, requestID, options, result]);
						return false;
					}
				}, {
					key: 'receiveDiff',
					value: function receiveDiff(message, elID, remoteUserId, requestID, options) {
						var result = arguments.length <= 5 || arguments[5] === undefined ? [] : arguments[5];

						if (message[1].slice(0, 2) === '@@') {
							this.Diff_match_patchWorker.run([message, elID, remoteUserId, requestID, options, result]);
							return true;
						}
						// whole message
						result.push('receiveDiff:false');
						this.returnApply('receiveDiff', [message, elID, remoteUserId, requestID, options, result]);
						return false;
					}
				}]);

				return OptionReceiver;
			})(MasterOption);

			_export('OptionReceiver', OptionReceiver);
		}
	};
});
$__System.register('1b', ['7', '10', '12', 'a', '1c', '1a'], function (_export) {
	var _classCallCheck, _Map, Helper, _createClass, _toConsumableArray, OptionReceiver, MasterReceiver;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			_Map = _2['default'];
		}, function (_3) {
			Helper = _3.Helper;
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_c) {
			_toConsumableArray = _c['default'];
		}, function (_a2) {
			OptionReceiver = _a2.OptionReceiver;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterReceiver = (function () {
				function MasterReceiver(connection, Requestor, ReceivedMessage) {
					_classCallCheck(this, MasterReceiver);

					this.connection = connection;
					this.Requestor = Requestor;
					this.ReceivedMessage = ReceivedMessage;

					this.connection.receive = this.receiveEvent.bind(this); // bindings (2113:RTCMultiConnection => sst: hijack onDataChannelMessage)
					this.Helper = new Helper();
					this.onReceive = this.Helper.getEventHandler(); // event handler (api hook)
					this.OptionReceiver = new OptionReceiver();
					this.OptionReceiver.returnMap.set('init', [this.OptionReceiver.receiveDecompress, this.OptionReceiver]);
					this.OptionReceiver.returnMap.set('receiveDecompress', [this.OptionReceiver.receiveDiff, this.OptionReceiver]);
					this.OptionReceiver.returnMap.set('receiveDiff', [this.receive, this]);
					this.chunks = {};
					this.loading = '<p>loading...</p>';
				}

				_createClass(MasterReceiver, [{
					key: 'receiveEvent',
					value: function receiveEvent(message, remoteUserId) {
						//console.log(`receive: ${message}`);
						var receivingTime = new Date().getTime();
						var dataPack = {};
						var info = message.match(/\(sst:(.*?)\)/, '')[1].split(',');
						dataPack.uuid = info[0];
						dataPack.elID = info[1];
						dataPack.requestID = info[2];
						dataPack.compressed = info[3];
						dataPack.chunk = Number(info[4]);
						dataPack.chunkTotal = Number(info[5]);
						dataPack.latency = receivingTime - info[6];
						dataPack.message = message.replace(/\(sst:.*?\)/g, '');
						dataPack.remoteUserId = remoteUserId;
						if (!this.chunks[dataPack.uuid]) {
							this.chunks[dataPack.uuid] = { message: new _Map([[dataPack.chunk, dataPack.message]]), latency: dataPack.latency };
						} else {
							this.chunks[dataPack.uuid].message.set(dataPack.chunk, dataPack.message);
							this.chunks[dataPack.uuid].latency += dataPack.latency;
						}
						if (this.chunks[dataPack.uuid].message.size === dataPack.chunkTotal) {
							//console.log(this.chunks[dataPack.uuid].latency);
							// mapToArray => sort array => map values and join
							dataPack.message = [].concat(_toConsumableArray(this.chunks[dataPack.uuid].message)).sort(function (a, b) {
								return a[0] - b[0];
							}).map(function (e) {
								return e[1];
							}).join('');
							// [oldMessage, message], elID, remoteUserId, requestID, options [0:compressed]
							this.OptionReceiver.init([this.ReceivedMessage.get(dataPack.elID, dataPack.remoteUserId), dataPack.message], dataPack.elID, dataPack.remoteUserId, dataPack.requestID, [dataPack.compressed]);
							delete this.chunks[dataPack.uuid];
						}
					}

					// message = [oldMessage, message]
				}, {
					key: 'receive',
					value: function receive(message, elID, remoteUserId, requestID, options, result) {
						if (message[1].length > 0) {
							var dataPack = { message: message[1], elID: elID, remoteUserId: remoteUserId, requestID: requestID };
							var success = false;
							// diff did't pass
							if (this.Helper.arrayKeyValStrToObj(result)['receiveDiff'] === 'failed') {
								this.Requestor.sendRequest(this.Requestor.request.resendMessage, elID, remoteUserId);
								dataPack.message = this.loading;
								this._receive(dataPack);
							} else if (requestID.length > 0 && message[1].indexOf('' + this.Requestor.initRequest + this.connection.userid) !== -1) {
								// handle request
								this.Requestor.receiveRequest(message[1], requestID, elID, remoteUserId, this.connection.userid);
								// ==> don't _receive anything => text doesn't get updated but request gets fullFilled
							} else if (this.Requestor.requests[requestID]) {
									// fullFilled request received
									this._receive(this.Requestor.fullFilledRequest(requestID, message[0], dataPack));
									success = true;
								} else {
									// whole message
									this._receive(dataPack);
									success = true;
								}
							if (success) {
								this.ReceivedMessage.set(message[1], elID, remoteUserId);
							}
						}
					}
				}, {
					key: '_receive',
					value: function _receive() {
						var dataPack = arguments.length <= 0 || arguments[0] === undefined ? { message: undefined } : arguments[0];

						// give it further to the event listener
						this.onReceive.container.forEach(function (e) {
							e.func.apply(e.scope, [dataPack].concat(e.args));
						});
					}
				}, {
					key: 'setIgnoreOption',
					value: function setIgnoreOption() {
						// skip with binding this.receive
						this.oldInit = this.OptionReceiver.init;
						this.OptionReceiver.init = this.receive.bind(this);
					}
				}, {
					key: 'unsetIgnoreOption',
					value: function unsetIgnoreOption() {
						// skip with binding this.receive
						this.OptionReceiver.init = this.oldInit ? this.oldInit : this.OptionReceiver.init;
					}
				}]);

				return MasterReceiver;
			})();

			_export('MasterReceiver', MasterReceiver);
		}
	};
});
$__System.register('1d', ['5', '6', '7', '1b'], function (_export) {
	var _get, _inherits, _classCallCheck, MasterReceiver, Receiver;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_b) {
			MasterReceiver = _b.MasterReceiver;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			Receiver = (function (_MasterReceiver) {
				_inherits(Receiver, _MasterReceiver);

				function Receiver(connection, Requestor, ReceivedMessage) {
					_classCallCheck(this, Receiver);

					_get(Object.getPrototypeOf(Receiver.prototype), 'constructor', this).call(this, connection, Requestor, ReceivedMessage);
				}

				return Receiver;
			})(MasterReceiver);

			_export('Receiver', Receiver);
		}
	};
});
$__System.registerDynamic('1e', [], false, function ($__require, $__exports, $__module) {
    var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

    (function ($__global) {
        'use strict';

        // Last time updated: 2017-03-11 7:14:04 AM UTC

        // _________________________
        // RTCMultiConnection v3.4.4

        // Open-Sourced: https://github.com/muaz-khan/RTCMultiConnection

        // --------------------------------------------------
        // Muaz Khan     - www.MuazKhan.com
        // MIT License   - www.WebRTC-Experiment.com/licence
        // --------------------------------------------------

        window.RTCMultiConnection = function (roomid, forceOptions) {

            function SocketConnection(connection, connectCallback) {
                var parameters = '';

                parameters += '?userid=' + connection.userid;
                parameters += '&sessionid=' + connection.sessionid;
                parameters += '&msgEvent=' + connection.socketMessageEvent;
                parameters += '&socketCustomEvent=' + connection.socketCustomEvent;
                parameters += '&autoCloseEntireSession=' + !!connection.autoCloseEntireSession;

                parameters += '&maxParticipantsAllowed=' + connection.maxParticipantsAllowed;

                if (connection.enableScalableBroadcast) {
                    parameters += '&enableScalableBroadcast=true';
                    parameters += '&maxRelayLimitPerUser=' + (connection.maxRelayLimitPerUser || 2);
                }

                if (connection.socketCustomParameters) {
                    parameters += connection.socketCustomParameters;
                }

                try {
                    io.sockets = {};
                } catch (e) {};

                if (!connection.socketURL) {
                    connection.socketURL = '/';
                }

                if (connection.socketURL.substr(connection.socketURL.length - 1, 1) != '/') {
                    // connection.socketURL = 'https://domain.com:9001/';
                    throw '"socketURL" MUST end with a slash.';
                }

                if (connection.enableLogs) {
                    if (connection.socketURL == '/') {
                        console.info('socket.io is connected at: ', location.origin + '/');
                    } else {
                        console.info('socket.io is connected at: ', connection.socketURL);
                    }
                }

                try {
                    connection.socket = io(connection.socketURL + parameters);
                } catch (e) {
                    connection.socket = io.connect(connection.socketURL + parameters, connection.socketOptions);
                }

                // detect signaling medium
                connection.socket.isIO = true;

                var mPeer = connection.multiPeersHandler;

                connection.socket.on('extra-data-updated', function (remoteUserId, extra) {
                    if (!connection.peers[remoteUserId]) return;
                    connection.peers[remoteUserId].extra = extra;

                    connection.onExtraDataUpdated({
                        userid: remoteUserId,
                        extra: extra
                    });

                    if (!connection.peersBackup[remoteUserId]) {
                        connection.peersBackup[remoteUserId] = {
                            userid: remoteUserId,
                            extra: {}
                        };
                    }

                    connection.peersBackup[remoteUserId].extra = extra;
                });

                connection.socket.on(connection.socketMessageEvent, function (message) {
                    if (message.remoteUserId != connection.userid) return;

                    if (connection.peers[message.sender] && connection.peers[message.sender].extra != message.message.extra) {
                        connection.peers[message.sender].extra = message.extra;
                        connection.onExtraDataUpdated({
                            userid: message.sender,
                            extra: message.extra
                        });
                    }

                    if (message.message.streamSyncNeeded && connection.peers[message.sender]) {
                        var stream = connection.streamEvents[message.message.streamid];
                        if (!stream || !stream.stream) {
                            return;
                        }

                        var action = message.message.action;

                        if (action === 'ended' || action === 'inactive' || action === 'stream-removed') {
                            if (connection.peersBackup[stream.userid]) {
                                stream.extra = connection.peersBackup[stream.userid].extra;
                            }
                            connection.onstreamended(stream);
                            return;
                        }

                        var type = message.message.type != 'both' ? message.message.type : null;

                        if (typeof stream.stream[action] == 'function') {
                            stream.stream[action](type);
                        }
                        return;
                    }

                    if (message.message === 'connectWithAllParticipants') {
                        if (connection.broadcasters.indexOf(message.sender) === -1) {
                            connection.broadcasters.push(message.sender);
                        }

                        mPeer.onNegotiationNeeded({
                            allParticipants: connection.getAllParticipants(message.sender)
                        }, message.sender);
                        return;
                    }

                    if (message.message === 'removeFromBroadcastersList') {
                        if (connection.broadcasters.indexOf(message.sender) !== -1) {
                            delete connection.broadcasters[connection.broadcasters.indexOf(message.sender)];
                            connection.broadcasters = removeNullEntries(connection.broadcasters);
                        }
                        return;
                    }

                    if (message.message === 'dropPeerConnection') {
                        connection.deletePeer(message.sender);
                        return;
                    }

                    if (message.message.allParticipants) {
                        if (message.message.allParticipants.indexOf(message.sender) === -1) {
                            message.message.allParticipants.push(message.sender);
                        }

                        message.message.allParticipants.forEach(function (participant) {
                            mPeer[!connection.peers[participant] ? 'createNewPeer' : 'renegotiatePeer'](participant, {
                                localPeerSdpConstraints: {
                                    OfferToReceiveAudio: connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                                    OfferToReceiveVideo: connection.sdpConstraints.mandatory.OfferToReceiveVideo
                                },
                                remotePeerSdpConstraints: {
                                    OfferToReceiveAudio: connection.session.oneway ? !!connection.session.audio : connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                                    OfferToReceiveVideo: connection.session.oneway ? !!connection.session.video || !!connection.session.screen : connection.sdpConstraints.mandatory.OfferToReceiveVideo
                                },
                                isOneWay: !!connection.session.oneway || connection.direction === 'one-way',
                                isDataOnly: isData(connection.session)
                            });
                        });
                        return;
                    }

                    if (message.message.newParticipant) {
                        if (message.message.newParticipant == connection.userid) return;
                        if (!!connection.peers[message.message.newParticipant]) return;

                        mPeer.createNewPeer(message.message.newParticipant, message.message.userPreferences || {
                            localPeerSdpConstraints: {
                                OfferToReceiveAudio: connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                                OfferToReceiveVideo: connection.sdpConstraints.mandatory.OfferToReceiveVideo
                            },
                            remotePeerSdpConstraints: {
                                OfferToReceiveAudio: connection.session.oneway ? !!connection.session.audio : connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                                OfferToReceiveVideo: connection.session.oneway ? !!connection.session.video || !!connection.session.screen : connection.sdpConstraints.mandatory.OfferToReceiveVideo
                            },
                            isOneWay: !!connection.session.oneway || connection.direction === 'one-way',
                            isDataOnly: isData(connection.session)
                        });
                        return;
                    }

                    if (message.message.readyForOffer || message.message.addMeAsBroadcaster) {
                        connection.addNewBroadcaster(message.sender);
                    }

                    if (message.message.newParticipationRequest && message.sender !== connection.userid) {
                        if (connection.peers[message.sender]) {
                            connection.deletePeer(message.sender);
                        }

                        var userPreferences = {
                            extra: message.extra || {},
                            localPeerSdpConstraints: message.message.remotePeerSdpConstraints || {
                                OfferToReceiveAudio: connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                                OfferToReceiveVideo: connection.sdpConstraints.mandatory.OfferToReceiveVideo
                            },
                            remotePeerSdpConstraints: message.message.localPeerSdpConstraints || {
                                OfferToReceiveAudio: connection.session.oneway ? !!connection.session.audio : connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                                OfferToReceiveVideo: connection.session.oneway ? !!connection.session.video || !!connection.session.screen : connection.sdpConstraints.mandatory.OfferToReceiveVideo
                            },
                            isOneWay: typeof message.message.isOneWay !== 'undefined' ? message.message.isOneWay : !!connection.session.oneway || connection.direction === 'one-way',
                            isDataOnly: typeof message.message.isDataOnly !== 'undefined' ? message.message.isDataOnly : isData(connection.session),
                            dontGetRemoteStream: typeof message.message.isOneWay !== 'undefined' ? message.message.isOneWay : !!connection.session.oneway || connection.direction === 'one-way',
                            dontAttachLocalStream: !!message.message.dontGetRemoteStream,
                            connectionDescription: message,
                            successCallback: function () {
                                // if its oneway----- todo: THIS SEEMS NOT IMPORTANT.
                                if (typeof message.message.isOneWay !== 'undefined' ? message.message.isOneWay : !!connection.session.oneway || connection.direction === 'one-way') {
                                    connection.addNewBroadcaster(message.sender, userPreferences);
                                }

                                if (!!connection.session.oneway || connection.direction === 'one-way' || isData(connection.session)) {
                                    connection.addNewBroadcaster(message.sender, userPreferences);
                                }
                            }
                        };

                        connection.onNewParticipant(message.sender, userPreferences);
                        return;
                    }

                    if (message.message.shiftedModerationControl) {
                        connection.onShiftedModerationControl(message.sender, message.message.broadcasters);
                        return;
                    }

                    if (message.message.changedUUID) {
                        if (connection.peers[message.message.oldUUID]) {
                            connection.peers[message.message.newUUID] = connection.peers[message.message.oldUUID];
                            delete connection.peers[message.message.oldUUID];
                        }
                    }

                    if (message.message.userLeft) {
                        mPeer.onUserLeft(message.sender);

                        if (!!message.message.autoCloseEntireSession) {
                            connection.leave();
                        }

                        return;
                    }

                    mPeer.addNegotiatedMessage(message.message, message.sender);
                });

                connection.socket.on('user-left', function (userid) {
                    onUserLeft(userid);

                    connection.onUserStatusChanged({
                        userid: userid,
                        status: 'offline',
                        extra: connection.peers[userid] ? connection.peers[userid].extra || {} : {}
                    });

                    var eventObject = {
                        userid: userid,
                        extra: {}
                    };

                    if (connection.peersBackup[eventObject.userid]) {
                        eventObject.extra = connection.peersBackup[eventObject.userid].extra;
                    }

                    connection.onleave(eventObject);
                });

                var alreadyConnected = false;

                connection.socket.resetProps = function () {
                    alreadyConnected = false;
                };

                connection.socket.on('connect', function () {
                    if (alreadyConnected) {
                        return;
                    }
                    alreadyConnected = true;

                    if (connection.enableLogs) {
                        console.info('socket.io connection is opened.');
                    }

                    setTimeout(function () {
                        connection.socket.emit('extra-data-updated', connection.extra);

                        if (connectCallback) {
                            connectCallback(connection.socket);
                        }
                    }, 1000);
                });

                connection.socket.on('disconnect', function () {
                    if (connection.enableLogs) {
                        console.warn('socket.io connection is closed');
                    }
                });

                connection.socket.on('join-with-password', function (remoteUserId) {
                    connection.onJoinWithPassword(remoteUserId);
                });

                connection.socket.on('invalid-password', function (remoteUserId, oldPassword) {
                    connection.onInvalidPassword(remoteUserId, oldPassword);
                });

                connection.socket.on('password-max-tries-over', function (remoteUserId) {
                    connection.onPasswordMaxTriesOver(remoteUserId);
                });

                connection.socket.on('user-disconnected', function (remoteUserId) {
                    if (remoteUserId === connection.userid) {
                        return;
                    }

                    connection.onUserStatusChanged({
                        userid: remoteUserId,
                        status: 'offline',
                        extra: connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra || {} : {}
                    });

                    connection.deletePeer(remoteUserId);
                });

                connection.socket.on('user-connected', function (userid) {
                    if (userid === connection.userid) {
                        return;
                    }

                    connection.onUserStatusChanged({
                        userid: userid,
                        status: 'online',
                        extra: connection.peers[userid] ? connection.peers[userid].extra || {} : {}
                    });
                });

                connection.socket.on('closed-entire-session', function (sessionid, extra) {
                    connection.leave();
                    connection.onEntireSessionClosed({
                        sessionid: sessionid,
                        userid: sessionid,
                        extra: extra
                    });
                });

                connection.socket.on('userid-already-taken', function (useridAlreadyTaken, yourNewUserId) {
                    connection.isInitiator = false;
                    connection.userid = yourNewUserId;

                    connection.onUserIdAlreadyTaken(useridAlreadyTaken, yourNewUserId);
                });

                connection.socket.on('logs', function (log) {
                    if (!connection.enableLogs) return;
                    console.debug('server-logs', log);
                });

                connection.socket.on('number-of-broadcast-viewers-updated', function (data) {
                    connection.onNumberOfBroadcastViewersUpdated(data);
                });

                connection.socket.on('room-full', function (roomid) {
                    connection.onRoomFull(roomid);
                });

                connection.socket.on('become-next-modrator', function (sessionid) {
                    if (sessionid != connection.sessionid) return;
                    setTimeout(function () {
                        connection.open(sessionid);
                        connection.socket.emit('shift-moderator-control-on-disconnect');
                    }, 1000);
                });
            }

            function MultiPeers(connection) {
                var self = this;

                var skipPeers = ['getAllParticipants', 'getLength', 'selectFirst', 'streams', 'send', 'forEach'];
                connection.peersBackup = {};
                connection.peers = {
                    getLength: function () {
                        var numberOfPeers = 0;
                        for (var peer in this) {
                            if (skipPeers.indexOf(peer) == -1) {
                                numberOfPeers++;
                            }
                        }
                        return numberOfPeers;
                    },
                    selectFirst: function () {
                        var firstPeer;
                        for (var peer in this) {
                            if (skipPeers.indexOf(peer) == -1) {
                                firstPeer = this[peer];
                            }
                        }
                        return firstPeer;
                    },
                    getAllParticipants: function (sender) {
                        var allPeers = [];
                        for (var peer in this) {
                            if (skipPeers.indexOf(peer) == -1 && peer != sender) {
                                allPeers.push(peer);
                            }
                        }
                        return allPeers;
                    },
                    forEach: function (callbcak) {
                        this.getAllParticipants().forEach(function (participant) {
                            callbcak(connection.peers[participant]);
                        });
                    },
                    send: function (data, remoteUserId) {
                        var that = this;

                        if (!isNull(data.size) && !isNull(data.type)) {
                            self.shareFile(data, remoteUserId);
                            return;
                        }

                        if (data.type !== 'text' && !(data instanceof ArrayBuffer) && !(data instanceof DataView)) {
                            TextSender.send({
                                text: data,
                                channel: this,
                                connection: connection,
                                remoteUserId: remoteUserId
                            });
                            return;
                        }

                        if (data.type === 'text') {
                            data = JSON.stringify(data);
                        }

                        if (remoteUserId) {
                            var remoteUser = connection.peers[remoteUserId];
                            if (remoteUser) {
                                if (!remoteUser.channels.length) {
                                    connection.peers[remoteUserId].createDataChannel();
                                    connection.renegotiate(remoteUserId);
                                    setTimeout(function () {
                                        that.send(data, remoteUserId);
                                    }, 3000);
                                    return;
                                }

                                remoteUser.channels.forEach(function (channel) {
                                    channel.send(data);
                                });
                                return;
                            }
                        }

                        this.getAllParticipants().forEach(function (participant) {
                            if (!that[participant].channels.length) {
                                connection.peers[participant].createDataChannel();
                                connection.renegotiate(participant);
                                setTimeout(function () {
                                    that[participant].channels.forEach(function (channel) {
                                        channel.send(data);
                                    });
                                }, 3000);
                                return;
                            }

                            that[participant].channels.forEach(function (channel) {
                                channel.send(data);
                            });
                        });
                    }
                };

                this.uuid = connection.userid;

                this.getLocalConfig = function (remoteSdp, remoteUserId, userPreferences) {
                    if (!userPreferences) {
                        userPreferences = {};
                    }

                    return {
                        streamsToShare: userPreferences.streamsToShare || {},
                        rtcMultiConnection: connection,
                        connectionDescription: userPreferences.connectionDescription,
                        userid: remoteUserId,
                        localPeerSdpConstraints: userPreferences.localPeerSdpConstraints,
                        remotePeerSdpConstraints: userPreferences.remotePeerSdpConstraints,
                        dontGetRemoteStream: !!userPreferences.dontGetRemoteStream,
                        dontAttachLocalStream: !!userPreferences.dontAttachLocalStream,
                        renegotiatingPeer: !!userPreferences.renegotiatingPeer,
                        peerRef: userPreferences.peerRef,
                        channels: userPreferences.channels || [],
                        onLocalSdp: function (localSdp) {
                            self.onNegotiationNeeded(localSdp, remoteUserId);
                        },
                        onLocalCandidate: function (localCandidate) {
                            localCandidate = OnIceCandidateHandler.processCandidates(connection, localCandidate);
                            if (localCandidate) {
                                self.onNegotiationNeeded(localCandidate, remoteUserId);
                            }
                        },
                        remoteSdp: remoteSdp,
                        onDataChannelMessage: function (message) {
                            /*
                            if (!connection.fbr && connection.enableFileSharing) initFileBufferReader();
                             if (typeof message == 'string' || !connection.enableFileSharing) {
                                self.onDataChannelMessage(message, remoteUserId);
                                return;
                            }
                             var that = this;
                             if (message instanceof ArrayBuffer || message instanceof DataView) {
                                connection.fbr.convertToObject(message, function(object) {
                                    that.onDataChannelMessage(object);
                                });
                                return;
                            }
                             if (message.readyForNextChunk) {
                                connection.fbr.getNextChunk(message, function(nextChunk, isLastChunk) {
                                    connection.peers[remoteUserId].channels.forEach(function(channel) {
                                        channel.send(nextChunk);
                                    });
                                }, remoteUserId);
                                return;
                            }
                             if (message.chunkMissing) {
                                connection.fbr.chunkMissing(message);
                                return;
                            }
                             connection.fbr.addChunk(message, function(promptNextChunk) {
                                connection.peers[remoteUserId].peer.channel.send(promptNextChunk);
                            });
                            */
                            // sst: hijack onDataChannelMessage
                            connection.receive(message, remoteUserId);
                        },
                        onDataChannelError: function (error) {
                            self.onDataChannelError(error, remoteUserId);
                        },
                        onDataChannelOpened: function (channel) {
                            self.onDataChannelOpened(channel, remoteUserId);
                        },
                        onDataChannelClosed: function (event) {
                            self.onDataChannelClosed(event, remoteUserId);
                        },
                        onRemoteStream: function (stream) {
                            if (connection.peers[remoteUserId]) {
                                connection.peers[remoteUserId].streams.push(stream);
                            }

                            if (isPluginRTC && window.PluginRTC) {
                                var mediaElement = document.createElement('video');
                                var body = connection.videosContainer;
                                body.insertBefore(mediaElement, body.firstChild);
                                setTimeout(function () {
                                    window.PluginRTC.attachMediaStream(mediaElement, stream);
                                }, 3000);
                                return;
                            }

                            self.onGettingRemoteMedia(stream, remoteUserId);
                        },
                        onRemoteStreamRemoved: function (stream) {
                            self.onRemovingRemoteMedia(stream, remoteUserId);
                        },
                        onPeerStateChanged: function (states) {
                            self.onPeerStateChanged(states);

                            if (states.iceConnectionState === 'new') {
                                self.onNegotiationStarted(remoteUserId, states);
                            }

                            if (states.iceConnectionState === 'connected') {
                                self.onNegotiationCompleted(remoteUserId, states);
                            }

                            if (states.iceConnectionState.search(/closed|failed/gi) !== -1) {
                                self.onUserLeft(remoteUserId);
                                self.disconnectWith(remoteUserId);
                            }
                        }
                    };
                };

                this.createNewPeer = function (remoteUserId, userPreferences) {
                    if (connection.maxParticipantsAllowed <= connection.getAllParticipants().length) {
                        return;
                    }

                    userPreferences = userPreferences || {};

                    if (connection.isInitiator && !!connection.session.audio && connection.session.audio === 'two-way' && !userPreferences.streamsToShare) {
                        userPreferences.isOneWay = false;
                        userPreferences.isDataOnly = false;
                        userPreferences.session = connection.session;
                    }

                    if (!userPreferences.isOneWay && !userPreferences.isDataOnly) {
                        userPreferences.isOneWay = true;
                        this.onNegotiationNeeded({
                            enableMedia: true,
                            userPreferences: userPreferences
                        }, remoteUserId);
                        return;
                    }

                    userPreferences = connection.setUserPreferences(userPreferences, remoteUserId);
                    var localConfig = this.getLocalConfig(null, remoteUserId, userPreferences);
                    connection.peers[remoteUserId] = new PeerInitiator(localConfig);
                };

                this.createAnsweringPeer = function (remoteSdp, remoteUserId, userPreferences) {
                    userPreferences = connection.setUserPreferences(userPreferences || {}, remoteUserId);

                    var localConfig = this.getLocalConfig(remoteSdp, remoteUserId, userPreferences);
                    connection.peers[remoteUserId] = new PeerInitiator(localConfig);
                };

                this.renegotiatePeer = function (remoteUserId, userPreferences, remoteSdp) {
                    if (!connection.peers[remoteUserId]) {
                        if (connection.enableLogs) {
                            console.error('This peer (' + remoteUserId + ') does not exist. Renegotiation skipped.');
                        }
                        return;
                    }

                    if (!userPreferences) {
                        userPreferences = {};
                    }

                    userPreferences.renegotiatingPeer = true;
                    userPreferences.peerRef = connection.peers[remoteUserId].peer;
                    userPreferences.channels = connection.peers[remoteUserId].channels;

                    var localConfig = this.getLocalConfig(remoteSdp, remoteUserId, userPreferences);

                    connection.peers[remoteUserId] = new PeerInitiator(localConfig);
                };

                this.replaceTrack = function (track, remoteUserId, isVideoTrack) {
                    if (!connection.peers[remoteUserId]) {
                        throw 'This peer (' + remoteUserId + ') does not exist.';
                    }

                    var peer = connection.peers[remoteUserId].peer;

                    if (!!peer.getSenders && typeof peer.getSenders === 'function' && peer.getSenders().length) {
                        peer.getSenders().forEach(function (rtpSender) {
                            if (isVideoTrack && rtpSender.track instanceof VideoStreamTrack) {
                                connection.peers[remoteUserId].peer.lastVideoTrack = rtpSender.track;
                                rtpSender.replaceTrack(track);
                            }

                            if (!isVideoTrack && rtpSender.track instanceof AudioStreamTrack) {
                                connection.peers[remoteUserId].peer.lastAudioTrack = rtpSender.track;
                                rtpSender.replaceTrack(track);
                            }
                        });
                        return;
                    }

                    console.warn('RTPSender.replaceTrack is NOT supported.');
                    this.renegotiatePeer(remoteUserId);
                };

                this.onNegotiationNeeded = function (message, remoteUserId) {};
                this.addNegotiatedMessage = function (message, remoteUserId) {
                    if (message.type && message.sdp) {
                        if (message.type == 'answer') {
                            if (connection.peers[remoteUserId]) {
                                connection.peers[remoteUserId].addRemoteSdp(message);
                            }
                        }

                        if (message.type == 'offer') {
                            if (message.renegotiatingPeer) {
                                this.renegotiatePeer(remoteUserId, null, message);
                            } else {
                                this.createAnsweringPeer(message, remoteUserId);
                            }
                        }

                        if (connection.enableLogs) {
                            console.log('Remote peer\'s sdp:', message.sdp);
                        }
                        return;
                    }

                    if (message.candidate) {
                        if (connection.peers[remoteUserId]) {
                            connection.peers[remoteUserId].addRemoteCandidate(message);
                        }

                        if (connection.enableLogs) {
                            console.log('Remote peer\'s candidate pairs:', message.candidate);
                        }
                        return;
                    }

                    if (message.enableMedia) {
                        connection.session = message.userPreferences.session || connection.session;

                        if (connection.session.oneway && connection.attachStreams.length) {
                            connection.attachStreams = [];
                        }

                        if (message.userPreferences.isDataOnly && connection.attachStreams.length) {
                            connection.attachStreams.length = [];
                        }

                        var streamsToShare = {};
                        connection.attachStreams.forEach(function (stream) {
                            streamsToShare[stream.streamid] = {
                                isAudio: !!stream.isAudio,
                                isVideo: !!stream.isVideo,
                                isScreen: !!stream.isScreen
                            };
                        });
                        message.userPreferences.streamsToShare = streamsToShare;

                        self.onNegotiationNeeded({
                            readyForOffer: true,
                            userPreferences: message.userPreferences
                        }, remoteUserId);
                    }

                    if (message.readyForOffer) {
                        connection.onReadyForOffer(remoteUserId, message.userPreferences);
                    }

                    function cb(stream) {
                        gumCallback(stream, message, remoteUserId);
                    }
                };

                function gumCallback(stream, message, remoteUserId) {
                    var streamsToShare = {};
                    connection.attachStreams.forEach(function (stream) {
                        streamsToShare[stream.streamid] = {
                            isAudio: !!stream.isAudio,
                            isVideo: !!stream.isVideo,
                            isScreen: !!stream.isScreen
                        };
                    });
                    message.userPreferences.streamsToShare = streamsToShare;

                    self.onNegotiationNeeded({
                        readyForOffer: true,
                        userPreferences: message.userPreferences
                    }, remoteUserId);
                }

                this.connectNewParticipantWithAllBroadcasters = function (newParticipantId, userPreferences, broadcastersList) {
                    if (connection.socket.isIO) {
                        return;
                    }

                    broadcastersList = (broadcastersList || '').split('|-,-|');

                    if (!broadcastersList.length) {
                        return;
                    }

                    var firstBroadcaster;

                    var remainingBroadcasters = [];
                    broadcastersList.forEach(function (list) {
                        list = (list || '').replace(/ /g, '');
                        if (list.length) {
                            if (!firstBroadcaster) {
                                firstBroadcaster = list;
                            } else {
                                remainingBroadcasters.push(list);
                            }
                        }
                    });

                    if (!firstBroadcaster) {
                        return;
                    }

                    self.onNegotiationNeeded({
                        newParticipant: newParticipantId,
                        userPreferences: userPreferences || false
                    }, firstBroadcaster);

                    if (!remainingBroadcasters.length) {
                        return;
                    }

                    setTimeout(function () {
                        self.connectNewParticipantWithAllBroadcasters(newParticipantId, userPreferences, remainingBroadcasters.join('|-,-|'));
                    }, 3 * 1000);
                };

                this.onGettingRemoteMedia = function (stream, remoteUserId) {};
                this.onRemovingRemoteMedia = function (stream, remoteUserId) {};
                this.onGettingLocalMedia = function (localStream) {};
                this.onLocalMediaError = function (error, constraints) {
                    connection.onMediaError(error, constraints);
                };

                function initFileBufferReader() {
                    connection.fbr = new FileBufferReader();
                    connection.fbr.onProgress = function (chunk) {
                        connection.onFileProgress(chunk);
                    };
                    connection.fbr.onBegin = function (file) {
                        connection.onFileStart(file);
                    };
                    connection.fbr.onEnd = function (file) {
                        connection.onFileEnd(file);
                    };
                }

                this.shareFile = function (file, remoteUserId) {
                    if (!connection.enableFileSharing) {
                        throw '"connection.enableFileSharing" is false.';
                    }

                    initFileBufferReader();

                    connection.fbr.readAsArrayBuffer(file, function (uuid) {
                        var arrayOfUsers = connection.getAllParticipants();

                        if (remoteUserId) {
                            arrayOfUsers = [remoteUserId];
                        }

                        arrayOfUsers.forEach(function (participant) {
                            connection.fbr.getNextChunk(uuid, function (nextChunk) {
                                connection.peers[participant].channels.forEach(function (channel) {
                                    channel.send(nextChunk);
                                });
                            }, participant);
                        });
                    }, {
                        userid: connection.userid,
                        // extra: connection.extra,
                        chunkSize: isFirefox ? 15 * 1000 : connection.chunkSize || 0
                    });
                };

                if (typeof 'TextReceiver' !== 'undefined') {
                    var textReceiver = new TextReceiver(connection);
                }

                this.onDataChannelMessage = function (message, remoteUserId) {
                    textReceiver.receive(JSON.parse(message), remoteUserId, connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {});
                };

                this.onDataChannelClosed = function (event, remoteUserId) {
                    event.userid = remoteUserId;
                    event.extra = connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {};
                    connection.onclose(event);
                };

                this.onDataChannelError = function (error, remoteUserId) {
                    error.userid = remoteUserId;
                    event.extra = connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {};
                    connection.onerror(error);
                };

                this.onDataChannelOpened = function (channel, remoteUserId) {
                    // keep last channel only; we are not expecting parallel/channels channels
                    if (connection.peers[remoteUserId].channels.length) {
                        connection.peers[remoteUserId].channels = [channel];
                        return;
                    }

                    connection.peers[remoteUserId].channels.push(channel);
                    connection.onopen({
                        userid: remoteUserId,
                        extra: connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {},
                        channel: channel
                    });
                };

                this.onPeerStateChanged = function (state) {
                    connection.onPeerStateChanged(state);
                };

                this.onNegotiationStarted = function (remoteUserId, states) {};
                this.onNegotiationCompleted = function (remoteUserId, states) {};

                this.getRemoteStreams = function (remoteUserId) {
                    remoteUserId = remoteUserId || connection.peers.getAllParticipants()[0];
                    return connection.peers[remoteUserId] ? connection.peers[remoteUserId].streams : [];
                };

                this.isPluginRTC = connection.isPluginRTC = isPluginRTC;
            }

            // globals.js

            var isOpera = !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
            var isFirefox = typeof window.InstallTrigger !== 'undefined';
            var isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
            var isChrome = !!window.chrome && !isOpera;
            var isIE = !!document.documentMode;

            var isMobileDevice = !!navigator.userAgent.match(/Android|iPhone|iPad|iPod|BlackBerry|IEMobile/i);

            if (typeof cordova !== 'undefined') {
                isMobileDevice = true;
                isChrome = true;
            }

            if (navigator && navigator.userAgent && navigator.userAgent.indexOf('Crosswalk') !== -1) {
                isMobileDevice = true;
                isChrome = true;
            }

            var isPluginRTC = !isMobileDevice && (isSafari || isIE);

            if (isPluginRTC && typeof URL !== 'undefined') {
                URL.createObjectURL = function () {};
            }

            // detect node-webkit
            var isNodeWebkit = !!(window.process && typeof window.process === 'object' && window.process.versions && window.process.versions['node-webkit']);

            var chromeVersion = 50;
            var matchArray = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
            if (isChrome && matchArray && matchArray[2]) {
                chromeVersion = parseInt(matchArray[2], 10);
            }

            var firefoxVersion = 50;
            matchArray = navigator.userAgent.match(/Firefox\/(.*)/);
            if (isFirefox && matchArray && matchArray[1]) {
                firefoxVersion = parseInt(matchArray[1], 10);
            }

            function fireEvent(obj, eventName, args) {
                if (typeof CustomEvent === 'undefined') {
                    return;
                }

                var eventDetail = {
                    arguments: args,
                    __exposedProps__: args
                };

                var event = new CustomEvent(eventName, eventDetail);
                obj.dispatchEvent(event);
            }

            function setHarkEvents(connection, streamEvent) {
                if (!connection || !streamEvent) {
                    throw 'Both arguments are required.';
                }

                if (!connection.onspeaking || !connection.onsilence) {
                    return;
                }

                if (typeof hark === 'undefined') {
                    throw 'hark.js not found.';
                }

                hark(streamEvent.stream, {
                    onspeaking: function () {
                        connection.onspeaking(streamEvent);
                    },
                    onsilence: function () {
                        connection.onsilence(streamEvent);
                    },
                    onvolumechange: function (volume, threshold) {
                        if (!connection.onvolumechange) {
                            return;
                        }
                        connection.onvolumechange(merge({
                            volume: volume,
                            threshold: threshold
                        }, streamEvent));
                    }
                });
            }

            function setMuteHandlers(connection, streamEvent) {
                if (!streamEvent.stream || !streamEvent.stream || !streamEvent.stream.addEventListener) return;

                streamEvent.stream.addEventListener('mute', function (event) {
                    event = connection.streamEvents[streamEvent.streamid];

                    event.session = {
                        audio: event.muteType === 'audio',
                        video: event.muteType === 'video'
                    };

                    connection.onmute(event);
                }, false);

                streamEvent.stream.addEventListener('unmute', function (event) {
                    event = connection.streamEvents[streamEvent.streamid];

                    event.session = {
                        audio: event.unmuteType === 'audio',
                        video: event.unmuteType === 'video'
                    };

                    connection.onunmute(event);
                }, false);
            }

            function getRandomString() {
                if (window.crypto && window.crypto.getRandomValues && navigator.userAgent.indexOf('Safari') === -1) {
                    var a = window.crypto.getRandomValues(new Uint32Array(3)),
                        token = '';
                    for (var i = 0, l = a.length; i < l; i++) {
                        token += a[i].toString(36);
                    }
                    return token;
                } else {
                    return (Math.random() * new Date().getTime()).toString(36).replace(/\./g, '');
                }
            }

            // Get HTMLAudioElement/HTMLVideoElement accordingly

            function getRMCMediaElement(stream, callback, connection) {
                var isAudioOnly = false;
                if (!!stream.getVideoTracks && !stream.getVideoTracks().length) {
                    isAudioOnly = true;
                }

                var mediaElement = document.createElement(isAudioOnly ? 'audio' : 'video');

                if (isPluginRTC && window.PluginRTC) {
                    connection.videosContainer.insertBefore(mediaElement, connection.videosContainer.firstChild);

                    setTimeout(function () {
                        window.PluginRTC.attachMediaStream(mediaElement, stream);
                        callback(mediaElement);
                    }, 1000);

                    return;
                }

                // "mozSrcObject" is always preferred over "src"!!
                mediaElement[isFirefox ? 'mozSrcObject' : 'src'] = isFirefox ? stream : window.URL.createObjectURL(stream);
                mediaElement.controls = true;

                // http://goo.gl/WZ5nFl
                // Firefox don't yet support onended for any stream (remote/local)
                if (isFirefox) {
                    var streamEndedEvent = 'ended';

                    if ('oninactive' in mediaElement) {
                        streamEndedEvent = 'inactive';
                    }

                    mediaElement.addEventListener(streamEndedEvent, function () {
                        // fireEvent(stream, streamEndedEvent, stream);
                        currentUserMediaRequest.remove(stream.idInstance);

                        if (stream.type === 'local') {
                            streamEndedEvent = 'ended';

                            if ('oninactive' in stream) {
                                streamEndedEvent = 'inactive';
                            }

                            StreamsHandler.onSyncNeeded(stream.streamid, streamEndedEvent);

                            connection.attachStreams.forEach(function (aStream, idx) {
                                if (stream.streamid === aStream.streamid) {
                                    delete connection.attachStreams[idx];
                                }
                            });

                            var newStreamsArray = [];
                            connection.attachStreams.forEach(function (aStream) {
                                if (aStream) {
                                    newStreamsArray.push(aStream);
                                }
                            });
                            connection.attachStreams = newStreamsArray;

                            var streamEvent = connection.streamEvents[stream.streamid];

                            if (streamEvent) {
                                connection.onstreamended(streamEvent);
                                return;
                            }
                            if (this.parentNode) {
                                this.parentNode.removeChild(this);
                            }
                        }
                    }, false);
                }

                mediaElement.play();
                callback(mediaElement);
            }

            // if IE
            if (!window.addEventListener) {
                window.addEventListener = function (el, eventName, eventHandler) {
                    if (!el.attachEvent) {
                        return;
                    }
                    el.attachEvent('on' + eventName, eventHandler);
                };
            }

            function listenEventHandler(eventName, eventHandler) {
                window.removeEventListener(eventName, eventHandler);
                window.addEventListener(eventName, eventHandler, false);
            }

            window.attachEventListener = function (video, type, listener, useCapture) {
                video.addEventListener(type, listener, useCapture);
            };

            function removeNullEntries(array) {
                var newArray = [];
                array.forEach(function (item) {
                    if (item) {
                        newArray.push(item);
                    }
                });
                return newArray;
            }

            function isData(session) {
                return !session.audio && !session.video && !session.screen && session.data;
            }

            function isNull(obj) {
                return typeof obj === 'undefined';
            }

            function isString(obj) {
                return typeof obj === 'string';
            }

            var MediaStream = window.MediaStream;

            if (typeof MediaStream === 'undefined' && typeof webkitMediaStream !== 'undefined') {
                MediaStream = webkitMediaStream;
            }

            /*global MediaStream:true */
            if (typeof MediaStream !== 'undefined') {
                if (!('getVideoTracks' in MediaStream.prototype)) {
                    MediaStream.prototype.getVideoTracks = function () {
                        if (!this.getTracks) {
                            return [];
                        }

                        var tracks = [];
                        this.getTracks.forEach(function (track) {
                            if (track.kind.toString().indexOf('video') !== -1) {
                                tracks.push(track);
                            }
                        });
                        return tracks;
                    };

                    MediaStream.prototype.getAudioTracks = function () {
                        if (!this.getTracks) {
                            return [];
                        }

                        var tracks = [];
                        this.getTracks.forEach(function (track) {
                            if (track.kind.toString().indexOf('audio') !== -1) {
                                tracks.push(track);
                            }
                        });
                        return tracks;
                    };
                }

                if (!('stop' in MediaStream.prototype)) {
                    MediaStream.prototype.stop = function () {
                        this.getAudioTracks().forEach(function (track) {
                            if (!!track.stop) {
                                track.stop();
                            }
                        });

                        this.getVideoTracks().forEach(function (track) {
                            if (!!track.stop) {
                                track.stop();
                            }
                        });
                    };
                }
            }

            function isAudioPlusTab(connection, audioPlusTab) {
                if (connection.session.audio && connection.session.audio === 'two-way') {
                    return false;
                }

                if (isFirefox && audioPlusTab !== false) {
                    return true;
                }

                if (!isChrome || chromeVersion < 50) return false;

                if (typeof audioPlusTab === true) {
                    return true;
                }

                if (typeof audioPlusTab === 'undefined' && connection.session.audio && connection.session.screen && !connection.session.video) {
                    audioPlusTab = true;
                    return true;
                }

                return false;
            }

            function getAudioScreenConstraints(screen_constraints) {
                if (isFirefox) {
                    return true;
                }

                if (!isChrome) return false;

                return {
                    mandatory: {
                        chromeMediaSource: screen_constraints.mandatory.chromeMediaSource,
                        chromeMediaSourceId: screen_constraints.mandatory.chromeMediaSourceId
                    }
                };
            }

            window.iOSDefaultAudioOutputDevice = window.iOSDefaultAudioOutputDevice || 'speaker'; // earpiece or speaker

            // Last time updated: 2017-03-11 6:31:40 AM UTC

            // Latest file can be found here: https://cdn.webrtc-experiment.com/DetectRTC.js

            // Muaz Khan     - www.MuazKhan.com
            // MIT License   - www.WebRTC-Experiment.com/licence
            // Documentation - github.com/muaz-khan/DetectRTC
            // ____________
            // DetectRTC.js

            // DetectRTC.hasWebcam (has webcam device!)
            // DetectRTC.hasMicrophone (has microphone device!)
            // DetectRTC.hasSpeakers (has speakers!)

            (function () {

                'use strict';

                var browserFakeUserAgent = 'Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45';

                var isNodejs = typeof process === 'object' && typeof process.versions === 'object' && process.versions.node;
                if (isNodejs) {
                    var version = process.versions.node.toString().replace('v', '');
                    browserFakeUserAgent = 'Nodejs/' + version + ' (NodeOS) AppleWebKit/' + version + ' (KHTML, like Gecko) Nodejs/' + version + ' Nodejs/' + version;
                }

                (function (that) {
                    if (typeof window !== 'undefined') {
                        return;
                    }

                    if (typeof window === 'undefined' && typeof global !== 'undefined') {
                        global.navigator = {
                            userAgent: browserFakeUserAgent,
                            getUserMedia: function () {}
                        };

                        /*global window:true */
                        that.window = global;
                    } else if (typeof window === 'undefined') {
                        // window = this;
                    }

                    if (typeof document === 'undefined') {
                        /*global document:true */
                        that.document = {};

                        document.createElement = document.captureStream = document.mozCaptureStream = function () {
                            return {};
                        };
                    }

                    if (typeof location === 'undefined') {
                        /*global location:true */
                        that.location = {
                            protocol: 'file:',
                            href: '',
                            hash: ''
                        };
                    }

                    if (typeof screen === 'undefined') {
                        /*global screen:true */
                        that.screen = {
                            width: 0,
                            height: 0
                        };
                    }
                })(typeof global !== 'undefined' ? global : window);

                /*global navigator:true */
                var navigator = window.navigator;

                if (typeof navigator !== 'undefined') {
                    if (typeof navigator.webkitGetUserMedia !== 'undefined') {
                        navigator.getUserMedia = navigator.webkitGetUserMedia;
                    }

                    if (typeof navigator.mozGetUserMedia !== 'undefined') {
                        navigator.getUserMedia = navigator.mozGetUserMedia;
                    }
                } else {
                    navigator = {
                        getUserMedia: function () {},
                        userAgent: browserFakeUserAgent
                    };
                }

                var isMobileDevice = !!/Android|webOS|iPhone|iPad|iPod|BB10|BlackBerry|IEMobile|Opera Mini|Mobile|mobile/i.test(navigator.userAgent || '');

                var isEdge = navigator.userAgent.indexOf('Edge') !== -1 && (!!navigator.msSaveOrOpenBlob || !!navigator.msSaveBlob);

                var isOpera = !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
                var isFirefox = typeof window.InstallTrigger !== 'undefined';
                var isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
                var isChrome = !!window.chrome && !isOpera;
                var isIE = !!document.documentMode && !isEdge;

                // this one can also be used:
                // https://www.websocket.org/js/stuff.js (DetectBrowser.js)

                function getBrowserInfo() {
                    var nVer = navigator.appVersion;
                    var nAgt = navigator.userAgent;
                    var browserName = navigator.appName;
                    var fullVersion = '' + parseFloat(navigator.appVersion);
                    var majorVersion = parseInt(navigator.appVersion, 10);
                    var nameOffset, verOffset, ix;

                    // In Opera, the true version is after 'Opera' or after 'Version'
                    if (isOpera) {
                        browserName = 'Opera';
                        try {
                            fullVersion = navigator.userAgent.split('OPR/')[1].split(' ')[0];
                            majorVersion = fullVersion.split('.')[0];
                        } catch (e) {
                            fullVersion = '0.0.0.0';
                            majorVersion = 0;
                        }
                    }
                    // In MSIE, the true version is after 'MSIE' in userAgent
                    else if (isIE) {
                            verOffset = nAgt.indexOf('MSIE');
                            browserName = 'IE';
                            fullVersion = nAgt.substring(verOffset + 5);
                        }
                        // In Chrome, the true version is after 'Chrome' 
                        else if (isChrome) {
                                verOffset = nAgt.indexOf('Chrome');
                                browserName = 'Chrome';
                                fullVersion = nAgt.substring(verOffset + 7);
                            }
                            // In Safari, the true version is after 'Safari' or after 'Version' 
                            else if (isSafari) {
                                    verOffset = nAgt.indexOf('Safari');
                                    browserName = 'Safari';
                                    fullVersion = nAgt.substring(verOffset + 7);

                                    if ((verOffset = nAgt.indexOf('Version')) !== -1) {
                                        fullVersion = nAgt.substring(verOffset + 8);
                                    }
                                }
                                // In Firefox, the true version is after 'Firefox' 
                                else if (isFirefox) {
                                        verOffset = nAgt.indexOf('Firefox');
                                        browserName = 'Firefox';
                                        fullVersion = nAgt.substring(verOffset + 8);
                                    }

                                    // In most other browsers, 'name/version' is at the end of userAgent 
                                    else if ((nameOffset = nAgt.lastIndexOf(' ') + 1) < (verOffset = nAgt.lastIndexOf('/'))) {
                                            browserName = nAgt.substring(nameOffset, verOffset);
                                            fullVersion = nAgt.substring(verOffset + 1);

                                            if (browserName.toLowerCase() === browserName.toUpperCase()) {
                                                browserName = navigator.appName;
                                            }
                                        }

                    if (isEdge) {
                        browserName = 'Edge';
                        // fullVersion = navigator.userAgent.split('Edge/')[1];
                        fullVersion = parseInt(navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)[2], 10).toString();
                    }

                    // trim the fullVersion string at semicolon/space if present
                    if ((ix = fullVersion.indexOf(';')) !== -1) {
                        fullVersion = fullVersion.substring(0, ix);
                    }

                    if ((ix = fullVersion.indexOf(' ')) !== -1) {
                        fullVersion = fullVersion.substring(0, ix);
                    }

                    majorVersion = parseInt('' + fullVersion, 10);

                    if (isNaN(majorVersion)) {
                        fullVersion = '' + parseFloat(navigator.appVersion);
                        majorVersion = parseInt(navigator.appVersion, 10);
                    }

                    return {
                        fullVersion: fullVersion,
                        version: majorVersion,
                        name: browserName,
                        isPrivateBrowsing: false
                    };
                }

                // via: https://gist.github.com/cou929/7973956

                function retry(isDone, next) {
                    var currentTrial = 0,
                        maxRetry = 50,
                        interval = 10,
                        isTimeout = false;
                    var id = window.setInterval(function () {
                        if (isDone()) {
                            window.clearInterval(id);
                            next(isTimeout);
                        }
                        if (currentTrial++ > maxRetry) {
                            window.clearInterval(id);
                            isTimeout = true;
                            next(isTimeout);
                        }
                    }, 10);
                }

                function isIE10OrLater(userAgent) {
                    var ua = userAgent.toLowerCase();
                    if (ua.indexOf('msie') === 0 && ua.indexOf('trident') === 0) {
                        return false;
                    }
                    var match = /(?:msie|rv:)\s?([\d\.]+)/.exec(ua);
                    if (match && parseInt(match[1], 10) >= 10) {
                        return true;
                    }
                    return false;
                }

                function detectPrivateMode(callback) {
                    var isPrivate;

                    try {

                        if (window.webkitRequestFileSystem) {
                            window.webkitRequestFileSystem(window.TEMPORARY, 1, function () {
                                isPrivate = false;
                            }, function (e) {
                                isPrivate = true;
                            });
                        } else if (window.indexedDB && /Firefox/.test(window.navigator.userAgent)) {
                            var db;
                            try {
                                db = window.indexedDB.open('test');
                                db.onerror = function () {
                                    return true;
                                };
                            } catch (e) {
                                isPrivate = true;
                            }

                            if (typeof isPrivate === 'undefined') {
                                retry(function isDone() {
                                    return db.readyState === 'done' ? true : false;
                                }, function next(isTimeout) {
                                    if (!isTimeout) {
                                        isPrivate = db.result ? false : true;
                                    }
                                });
                            }
                        } else if (isIE10OrLater(window.navigator.userAgent)) {
                            isPrivate = false;
                            try {
                                if (!window.indexedDB) {
                                    isPrivate = true;
                                }
                            } catch (e) {
                                isPrivate = true;
                            }
                        } else if (window.localStorage && /Safari/.test(window.navigator.userAgent)) {
                            try {
                                window.localStorage.setItem('test', 1);
                            } catch (e) {
                                isPrivate = true;
                            }

                            if (typeof isPrivate === 'undefined') {
                                isPrivate = false;
                                window.localStorage.removeItem('test');
                            }
                        }
                    } catch (e) {
                        isPrivate = false;
                    }

                    retry(function isDone() {
                        return typeof isPrivate !== 'undefined' ? true : false;
                    }, function next(isTimeout) {
                        callback(isPrivate);
                    });
                }

                var isMobile = {
                    Android: function () {
                        return navigator.userAgent.match(/Android/i);
                    },
                    BlackBerry: function () {
                        return navigator.userAgent.match(/BlackBerry|BB10/i);
                    },
                    iOS: function () {
                        return navigator.userAgent.match(/iPhone|iPad|iPod/i);
                    },
                    Opera: function () {
                        return navigator.userAgent.match(/Opera Mini/i);
                    },
                    Windows: function () {
                        return navigator.userAgent.match(/IEMobile/i);
                    },
                    any: function () {
                        return isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows();
                    },
                    getOsName: function () {
                        var osName = 'Unknown OS';
                        if (isMobile.Android()) {
                            osName = 'Android';
                        }

                        if (isMobile.BlackBerry()) {
                            osName = 'BlackBerry';
                        }

                        if (isMobile.iOS()) {
                            osName = 'iOS';
                        }

                        if (isMobile.Opera()) {
                            osName = 'Opera Mini';
                        }

                        if (isMobile.Windows()) {
                            osName = 'Windows';
                        }

                        return osName;
                    }
                };

                // via: http://jsfiddle.net/ChristianL/AVyND/
                function detectDesktopOS() {
                    var unknown = '-';

                    var nVer = navigator.appVersion;
                    var nAgt = navigator.userAgent;

                    var os = unknown;
                    var clientStrings = [{
                        s: 'Windows 10',
                        r: /(Windows 10.0|Windows NT 10.0)/
                    }, {
                        s: 'Windows 8.1',
                        r: /(Windows 8.1|Windows NT 6.3)/
                    }, {
                        s: 'Windows 8',
                        r: /(Windows 8|Windows NT 6.2)/
                    }, {
                        s: 'Windows 7',
                        r: /(Windows 7|Windows NT 6.1)/
                    }, {
                        s: 'Windows Vista',
                        r: /Windows NT 6.0/
                    }, {
                        s: 'Windows Server 2003',
                        r: /Windows NT 5.2/
                    }, {
                        s: 'Windows XP',
                        r: /(Windows NT 5.1|Windows XP)/
                    }, {
                        s: 'Windows 2000',
                        r: /(Windows NT 5.0|Windows 2000)/
                    }, {
                        s: 'Windows ME',
                        r: /(Win 9x 4.90|Windows ME)/
                    }, {
                        s: 'Windows 98',
                        r: /(Windows 98|Win98)/
                    }, {
                        s: 'Windows 95',
                        r: /(Windows 95|Win95|Windows_95)/
                    }, {
                        s: 'Windows NT 4.0',
                        r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/
                    }, {
                        s: 'Windows CE',
                        r: /Windows CE/
                    }, {
                        s: 'Windows 3.11',
                        r: /Win16/
                    }, {
                        s: 'Android',
                        r: /Android/
                    }, {
                        s: 'Open BSD',
                        r: /OpenBSD/
                    }, {
                        s: 'Sun OS',
                        r: /SunOS/
                    }, {
                        s: 'Linux',
                        r: /(Linux|X11)/
                    }, {
                        s: 'iOS',
                        r: /(iPhone|iPad|iPod)/
                    }, {
                        s: 'Mac OS X',
                        r: /Mac OS X/
                    }, {
                        s: 'Mac OS',
                        r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/
                    }, {
                        s: 'QNX',
                        r: /QNX/
                    }, {
                        s: 'UNIX',
                        r: /UNIX/
                    }, {
                        s: 'BeOS',
                        r: /BeOS/
                    }, {
                        s: 'OS/2',
                        r: /OS\/2/
                    }, {
                        s: 'Search Bot',
                        r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/
                    }];
                    for (var id in clientStrings) {
                        var cs = clientStrings[id];
                        if (cs.r.test(nAgt)) {
                            os = cs.s;
                            break;
                        }
                    }

                    var osVersion = unknown;

                    if (/Windows/.test(os)) {
                        if (/Windows (.*)/.test(os)) {
                            osVersion = /Windows (.*)/.exec(os)[1];
                        }
                        os = 'Windows';
                    }

                    switch (os) {
                        case 'Mac OS X':
                            if (/Mac OS X (10[\.\_\d]+)/.test(nAgt)) {
                                osVersion = /Mac OS X (10[\.\_\d]+)/.exec(nAgt)[1];
                            }
                            break;
                        case 'Android':
                            if (/Android ([\.\_\d]+)/.test(nAgt)) {
                                osVersion = /Android ([\.\_\d]+)/.exec(nAgt)[1];
                            }
                            break;
                        case 'iOS':
                            if (/OS (\d+)_(\d+)_?(\d+)?/.test(nAgt)) {
                                osVersion = /OS (\d+)_(\d+)_?(\d+)?/.exec(nVer);
                                osVersion = osVersion[1] + '.' + osVersion[2] + '.' + (osVersion[3] | 0);
                            }
                            break;
                    }

                    return {
                        osName: os,
                        osVersion: osVersion
                    };
                }

                var osName = 'Unknown OS';
                var osVersion = 'Unknown OS Version';

                function getAndroidVersion(ua) {
                    ua = (ua || navigator.userAgent).toLowerCase();
                    var match = ua.match(/android\s([0-9\.]*)/);
                    return match ? match[1] : false;
                }

                var osInfo = detectDesktopOS();

                if (osInfo && osInfo.osName && osInfo.osName != '-') {
                    osName = osInfo.osName;
                    osVersion = osInfo.osVersion;
                } else if (isMobile.any()) {
                    osName = isMobile.getOsName();

                    if (osName == 'Android') {
                        osVersion = getAndroidVersion();
                    }
                }

                var isNodejs = typeof process === 'object' && typeof process.versions === 'object' && process.versions.node;

                if (osName === 'Unknown OS' && isNodejs) {
                    osName = 'Nodejs';
                    osVersion = process.versions.node.toString().replace('v', '');
                }

                var isCanvasSupportsStreamCapturing = false;
                var isVideoSupportsStreamCapturing = false;
                ['captureStream', 'mozCaptureStream', 'webkitCaptureStream'].forEach(function (item) {
                    if (!isCanvasSupportsStreamCapturing && item in document.createElement('canvas')) {
                        isCanvasSupportsStreamCapturing = true;
                    }

                    if (!isVideoSupportsStreamCapturing && item in document.createElement('video')) {
                        isVideoSupportsStreamCapturing = true;
                    }
                });

                // via: https://github.com/diafygi/webrtc-ips
                function DetectLocalIPAddress(callback) {
                    if (!DetectRTC.isWebRTCSupported) {
                        return;
                    }

                    if (DetectRTC.isORTCSupported) {
                        return;
                    }

                    getIPs(function (ip) {
                        //local IPs
                        if (ip.match(/^(192\.168\.|169\.254\.|10\.|172\.(1[6-9]|2\d|3[01]))/)) {
                            callback('Local: ' + ip);
                        }

                        //assume the rest are public IPs
                        else {
                                callback('Public: ' + ip);
                            }
                    });
                }

                //get the IP addresses associated with an account
                function getIPs(callback) {
                    var ipDuplicates = {};

                    //compatibility for firefox and chrome
                    var RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
                    var useWebKit = !!window.webkitRTCPeerConnection;

                    // bypass naive webrtc blocking using an iframe
                    if (!RTCPeerConnection) {
                        var iframe = document.getElementById('iframe');
                        if (!iframe) {
                            //<iframe id="iframe" sandbox="allow-same-origin" style="display: none"></iframe>
                            throw 'NOTE: you need to have an iframe in the page right above the script tag.';
                        }
                        var win = iframe.contentWindow;
                        RTCPeerConnection = win.RTCPeerConnection || win.mozRTCPeerConnection || win.webkitRTCPeerConnection;
                        useWebKit = !!win.webkitRTCPeerConnection;
                    }

                    // if still no RTCPeerConnection then it is not supported by the browser so just return
                    if (!RTCPeerConnection) {
                        return;
                    }

                    //minimal requirements for data connection
                    var mediaConstraints = {
                        optional: [{
                            RtpDataChannels: true
                        }]
                    };

                    //firefox already has a default stun server in about:config
                    //    media.peerconnection.default_iceservers =
                    //    [{"url": "stun:stun.services.mozilla.com"}]
                    var servers;

                    //add same stun server for chrome
                    if (useWebKit) {
                        servers = {
                            iceServers: [{
                                urls: 'stun:stun.services.mozilla.com'
                            }]
                        };

                        if (typeof DetectRTC !== 'undefined' && DetectRTC.browser.isFirefox && DetectRTC.browser.version <= 38) {
                            servers[0] = {
                                url: servers[0].urls
                            };
                        }
                    }

                    //construct a new RTCPeerConnection
                    var pc = new RTCPeerConnection(servers, mediaConstraints);

                    function handleCandidate(candidate) {
                        //match just the IP address
                        var ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3})/;
                        var match = ipRegex.exec(candidate);
                        if (!match) {
                            console.warn('Could not match IP address in', candidate);
                            return;
                        }
                        var ipAddress = match[1];

                        //remove duplicates
                        if (ipDuplicates[ipAddress] === undefined) {
                            callback(ipAddress);
                        }

                        ipDuplicates[ipAddress] = true;
                    }

                    //listen for candidate events
                    pc.onicecandidate = function (ice) {
                        //skip non-candidate events
                        if (ice.candidate) {
                            handleCandidate(ice.candidate.candidate);
                        }
                    };

                    //create a bogus data channel
                    pc.createDataChannel('');

                    //create an offer sdp
                    pc.createOffer(function (result) {

                        //trigger the stun server request
                        pc.setLocalDescription(result, function () {}, function () {});
                    }, function () {});

                    //wait for a while to let everything done
                    setTimeout(function () {
                        //read candidate info from local description
                        var lines = pc.localDescription.sdp.split('\n');

                        lines.forEach(function (line) {
                            if (line.indexOf('a=candidate:') === 0) {
                                handleCandidate(line);
                            }
                        });
                    }, 1000);
                }

                var MediaDevices = [];

                var audioInputDevices = [];
                var audioOutputDevices = [];
                var videoInputDevices = [];

                if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
                    // Firefox 38+ seems having support of enumerateDevices
                    // Thanks @xdumaine/enumerateDevices
                    navigator.enumerateDevices = function (callback) {
                        navigator.mediaDevices.enumerateDevices().then(callback).catch(function () {
                            callback([]);
                        });
                    };
                }

                // Media Devices detection
                var canEnumerate = false;

                /*global MediaStreamTrack:true */
                if (typeof MediaStreamTrack !== 'undefined' && 'getSources' in MediaStreamTrack) {
                    canEnumerate = true;
                } else if (navigator.mediaDevices && !!navigator.mediaDevices.enumerateDevices) {
                    canEnumerate = true;
                }

                var hasMicrophone = false;
                var hasSpeakers = false;
                var hasWebcam = false;

                var isWebsiteHasMicrophonePermissions = false;
                var isWebsiteHasWebcamPermissions = false;

                // http://dev.w3.org/2011/webrtc/editor/getusermedia.html#mediadevices
                function checkDeviceSupport(callback) {
                    if (!canEnumerate) {
                        if (callback) {
                            callback();
                        }
                        return;
                    }

                    if (!navigator.enumerateDevices && window.MediaStreamTrack && window.MediaStreamTrack.getSources) {
                        navigator.enumerateDevices = window.MediaStreamTrack.getSources.bind(window.MediaStreamTrack);
                    }

                    if (!navigator.enumerateDevices && navigator.enumerateDevices) {
                        navigator.enumerateDevices = navigator.enumerateDevices.bind(navigator);
                    }

                    if (!navigator.enumerateDevices) {
                        if (callback) {
                            callback();
                        }
                        return;
                    }

                    MediaDevices = [];

                    audioInputDevices = [];
                    audioOutputDevices = [];
                    videoInputDevices = [];

                    isWebsiteHasMicrophonePermissions = false;
                    isWebsiteHasWebcamPermissions = false;

                    // to prevent duplication
                    var alreadyUsedDevices = {};

                    navigator.enumerateDevices(function (devices) {
                        devices.forEach(function (_device) {
                            var device = {};
                            for (var d in _device) {
                                try {
                                    if (typeof _device[d] !== 'function') {
                                        device[d] = _device[d];
                                    }
                                } catch (e) {}
                            }

                            if (alreadyUsedDevices[device.deviceId + device.label]) {
                                return;
                            }

                            // if it is MediaStreamTrack.getSources
                            if (device.kind === 'audio') {
                                device.kind = 'audioinput';
                            }

                            if (device.kind === 'video') {
                                device.kind = 'videoinput';
                            }

                            if (!device.deviceId) {
                                device.deviceId = device.id;
                            }

                            if (!device.id) {
                                device.id = device.deviceId;
                            }

                            if (!device.label) {
                                device.label = 'Please invoke getUserMedia once.';
                                if (DetectRTC.browser.isChrome && DetectRTC.browser.version >= 46 && !/^(https:|chrome-extension:)$/g.test(location.protocol || '')) {
                                    if (document.domain.search && document.domain.search(/localhost|127.0./g) === -1) {
                                        device.label = 'HTTPs is required to get label of this ' + device.kind + ' device.';
                                    }
                                }
                            } else {
                                if (device.kind === 'videoinput' && !isWebsiteHasWebcamPermissions) {
                                    isWebsiteHasWebcamPermissions = true;
                                }

                                if (device.kind === 'audioinput' && !isWebsiteHasMicrophonePermissions) {
                                    isWebsiteHasMicrophonePermissions = true;
                                }
                            }

                            if (device.kind === 'audioinput') {
                                hasMicrophone = true;

                                if (audioInputDevices.indexOf(device) === -1) {
                                    audioInputDevices.push(device);
                                }
                            }

                            if (device.kind === 'audiooutput') {
                                hasSpeakers = true;

                                if (audioOutputDevices.indexOf(device) === -1) {
                                    audioOutputDevices.push(device);
                                }
                            }

                            if (device.kind === 'videoinput') {
                                hasWebcam = true;

                                if (videoInputDevices.indexOf(device) === -1) {
                                    videoInputDevices.push(device);
                                }
                            }

                            // there is no 'videoouput' in the spec.
                            MediaDevices.push(device);

                            alreadyUsedDevices[device.deviceId + device.label] = device;
                        });

                        if (typeof DetectRTC !== 'undefined') {
                            // to sync latest outputs
                            DetectRTC.MediaDevices = MediaDevices;
                            DetectRTC.hasMicrophone = hasMicrophone;
                            DetectRTC.hasSpeakers = hasSpeakers;
                            DetectRTC.hasWebcam = hasWebcam;

                            DetectRTC.isWebsiteHasWebcamPermissions = isWebsiteHasWebcamPermissions;
                            DetectRTC.isWebsiteHasMicrophonePermissions = isWebsiteHasMicrophonePermissions;

                            DetectRTC.audioInputDevices = audioInputDevices;
                            DetectRTC.audioOutputDevices = audioOutputDevices;
                            DetectRTC.videoInputDevices = videoInputDevices;
                        }

                        if (callback) {
                            callback();
                        }
                    });
                }

                // check for microphone/camera support!
                checkDeviceSupport();

                var DetectRTC = window.DetectRTC || {};

                // ----------
                // DetectRTC.browser.name || DetectRTC.browser.version || DetectRTC.browser.fullVersion
                DetectRTC.browser = getBrowserInfo();

                detectPrivateMode(function (isPrivateBrowsing) {
                    DetectRTC.browser.isPrivateBrowsing = !!isPrivateBrowsing;
                });

                // DetectRTC.isChrome || DetectRTC.isFirefox || DetectRTC.isEdge
                DetectRTC.browser['is' + DetectRTC.browser.name] = true;

                // -----------
                DetectRTC.osName = osName;
                DetectRTC.osVersion = osVersion;

                var isNodeWebkit = typeof process === 'object' && typeof process.versions === 'object' && process.versions['node-webkit'];

                // --------- Detect if system supports WebRTC 1.0 or WebRTC 1.1.
                var isWebRTCSupported = false;
                ['RTCPeerConnection', 'webkitRTCPeerConnection', 'mozRTCPeerConnection', 'RTCIceGatherer'].forEach(function (item) {
                    if (isWebRTCSupported) {
                        return;
                    }

                    if (item in window) {
                        isWebRTCSupported = true;
                    }
                });
                DetectRTC.isWebRTCSupported = isWebRTCSupported;

                //-------
                DetectRTC.isORTCSupported = typeof RTCIceGatherer !== 'undefined';

                // --------- Detect if system supports screen capturing API
                var isScreenCapturingSupported = false;
                if (DetectRTC.browser.isChrome && DetectRTC.browser.version >= 35) {
                    isScreenCapturingSupported = true;
                } else if (DetectRTC.browser.isFirefox && DetectRTC.browser.version >= 34) {
                    isScreenCapturingSupported = true;
                }

                if (!/^(https:|chrome-extension:)$/g.test(location.protocol || '')) {
                    if (document.domain.search && document.domain.search(/localhost|127.0./g) === -1) {
                        // DetectRTC.browser.isChrome
                        isScreenCapturingSupported = false;
                    }

                    if (DetectRTC.browser.isFirefox) {
                        isScreenCapturingSupported = false;
                    }
                }
                DetectRTC.isScreenCapturingSupported = isScreenCapturingSupported;

                // --------- Detect if WebAudio API are supported
                var webAudio = {
                    isSupported: false,
                    isCreateMediaStreamSourceSupported: false
                };

                ['AudioContext', 'webkitAudioContext', 'mozAudioContext', 'msAudioContext'].forEach(function (item) {
                    if (webAudio.isSupported) {
                        return;
                    }

                    if (item in window) {
                        webAudio.isSupported = true;

                        if (window[item] && 'createMediaStreamSource' in window[item].prototype) {
                            webAudio.isCreateMediaStreamSourceSupported = true;
                        }
                    }
                });
                DetectRTC.isAudioContextSupported = webAudio.isSupported;
                DetectRTC.isCreateMediaStreamSourceSupported = webAudio.isCreateMediaStreamSourceSupported;

                // ---------- Detect if SCTP/RTP channels are supported.

                var isRtpDataChannelsSupported = false;
                if (DetectRTC.browser.isChrome && DetectRTC.browser.version > 31) {
                    isRtpDataChannelsSupported = true;
                }
                DetectRTC.isRtpDataChannelsSupported = isRtpDataChannelsSupported;

                var isSCTPSupportd = false;
                if (DetectRTC.browser.isFirefox && DetectRTC.browser.version > 28) {
                    isSCTPSupportd = true;
                } else if (DetectRTC.browser.isChrome && DetectRTC.browser.version > 25) {
                    isSCTPSupportd = true;
                } else if (DetectRTC.browser.isOpera && DetectRTC.browser.version >= 11) {
                    isSCTPSupportd = true;
                }
                DetectRTC.isSctpDataChannelsSupported = isSCTPSupportd;

                // ---------

                DetectRTC.isMobileDevice = isMobileDevice; // "isMobileDevice" boolean is defined in "getBrowserInfo.js"

                // ------
                var isGetUserMediaSupported = false;
                if (navigator.getUserMedia) {
                    isGetUserMediaSupported = true;
                } else if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    isGetUserMediaSupported = true;
                }

                if (DetectRTC.browser.isChrome && DetectRTC.browser.version >= 46 && !/^(https:|chrome-extension:)$/g.test(location.protocol || '')) {
                    if (document.domain.search && document.domain.search(/localhost|127.0./g) === -1) {
                        isGetUserMediaSupported = 'Requires HTTPs';
                    }
                }

                if (DetectRTC.osName === 'Nodejs') {
                    isGetUserMediaSupported = false;
                }
                DetectRTC.isGetUserMediaSupported = isGetUserMediaSupported;

                var displayResolution = '';
                if (screen.width) {
                    var width = screen.width ? screen.width : '';
                    var height = screen.height ? screen.height : '';
                    displayResolution += '' + width + ' x ' + height;
                }
                DetectRTC.displayResolution = displayResolution;

                // ----------
                DetectRTC.isCanvasSupportsStreamCapturing = isCanvasSupportsStreamCapturing;
                DetectRTC.isVideoSupportsStreamCapturing = isVideoSupportsStreamCapturing;

                if (DetectRTC.browser.name == 'Chrome' && DetectRTC.browser.version >= 53) {
                    if (!DetectRTC.isCanvasSupportsStreamCapturing) {
                        DetectRTC.isCanvasSupportsStreamCapturing = 'Requires chrome flag: enable-experimental-web-platform-features';
                    }

                    if (!DetectRTC.isVideoSupportsStreamCapturing) {
                        DetectRTC.isVideoSupportsStreamCapturing = 'Requires chrome flag: enable-experimental-web-platform-features';
                    }
                }

                // ------
                DetectRTC.DetectLocalIPAddress = DetectLocalIPAddress;

                DetectRTC.isWebSocketsSupported = 'WebSocket' in window && 2 === window.WebSocket.CLOSING;
                DetectRTC.isWebSocketsBlocked = !DetectRTC.isWebSocketsSupported;

                if (DetectRTC.osName === 'Nodejs') {
                    DetectRTC.isWebSocketsSupported = true;
                    DetectRTC.isWebSocketsBlocked = false;
                }

                DetectRTC.checkWebSocketsSupport = function (callback) {
                    callback = callback || function () {};
                    try {
                        var websocket = new WebSocket('wss://echo.websocket.org:443/');
                        websocket.onopen = function () {
                            DetectRTC.isWebSocketsBlocked = false;
                            callback();
                            websocket.close();
                            websocket = null;
                        };
                        websocket.onerror = function () {
                            DetectRTC.isWebSocketsBlocked = true;
                            callback();
                        };
                    } catch (e) {
                        DetectRTC.isWebSocketsBlocked = true;
                        callback();
                    }
                };

                // -------
                DetectRTC.load = function (callback) {
                    callback = callback || function () {};
                    checkDeviceSupport(callback);
                };

                DetectRTC.MediaDevices = MediaDevices;
                DetectRTC.hasMicrophone = hasMicrophone;
                DetectRTC.hasSpeakers = hasSpeakers;
                DetectRTC.hasWebcam = hasWebcam;

                DetectRTC.isWebsiteHasWebcamPermissions = isWebsiteHasWebcamPermissions;
                DetectRTC.isWebsiteHasMicrophonePermissions = isWebsiteHasMicrophonePermissions;

                DetectRTC.audioInputDevices = audioInputDevices;
                DetectRTC.audioOutputDevices = audioOutputDevices;
                DetectRTC.videoInputDevices = videoInputDevices;

                // ------
                var isSetSinkIdSupported = false;
                if ('setSinkId' in document.createElement('video')) {
                    isSetSinkIdSupported = true;
                }
                DetectRTC.isSetSinkIdSupported = isSetSinkIdSupported;

                // -----
                var isRTPSenderReplaceTracksSupported = false;
                if (DetectRTC.browser.isFirefox && typeof mozRTCPeerConnection !== 'undefined' /*&& DetectRTC.browser.version > 39*/) {
                        /*global mozRTCPeerConnection:true */
                        if ('getSenders' in mozRTCPeerConnection.prototype) {
                            isRTPSenderReplaceTracksSupported = true;
                        }
                    } else if (DetectRTC.browser.isChrome && typeof webkitRTCPeerConnection !== 'undefined') {
                    /*global webkitRTCPeerConnection:true */
                    if ('getSenders' in webkitRTCPeerConnection.prototype) {
                        isRTPSenderReplaceTracksSupported = true;
                    }
                }
                DetectRTC.isRTPSenderReplaceTracksSupported = isRTPSenderReplaceTracksSupported;

                //------
                var isRemoteStreamProcessingSupported = false;
                if (DetectRTC.browser.isFirefox && DetectRTC.browser.version > 38) {
                    isRemoteStreamProcessingSupported = true;
                }
                DetectRTC.isRemoteStreamProcessingSupported = isRemoteStreamProcessingSupported;

                //-------
                var isApplyConstraintsSupported = false;

                /*global MediaStreamTrack:true */
                if (typeof MediaStreamTrack !== 'undefined' && 'applyConstraints' in MediaStreamTrack.prototype) {
                    isApplyConstraintsSupported = true;
                }
                DetectRTC.isApplyConstraintsSupported = isApplyConstraintsSupported;

                //-------
                var isMultiMonitorScreenCapturingSupported = false;
                if (DetectRTC.browser.isFirefox && DetectRTC.browser.version >= 43) {
                    // version 43 merely supports platforms for multi-monitors
                    // version 44 will support exact multi-monitor selection i.e. you can select any monitor for screen capturing.
                    isMultiMonitorScreenCapturingSupported = true;
                }
                DetectRTC.isMultiMonitorScreenCapturingSupported = isMultiMonitorScreenCapturingSupported;

                DetectRTC.isPromisesSupported = !!('Promise' in window);

                if (typeof DetectRTC === 'undefined') {
                    window.DetectRTC = {};
                }

                var MediaStream = window.MediaStream;

                if (typeof MediaStream === 'undefined' && typeof webkitMediaStream !== 'undefined') {
                    MediaStream = webkitMediaStream;
                }

                if (typeof MediaStream !== 'undefined') {
                    DetectRTC.MediaStream = Object.keys(MediaStream.prototype);
                } else DetectRTC.MediaStream = false;

                if (typeof MediaStreamTrack !== 'undefined') {
                    DetectRTC.MediaStreamTrack = Object.keys(MediaStreamTrack.prototype);
                } else DetectRTC.MediaStreamTrack = false;

                var RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;

                if (typeof RTCPeerConnection !== 'undefined') {
                    DetectRTC.RTCPeerConnection = Object.keys(RTCPeerConnection.prototype);
                } else DetectRTC.RTCPeerConnection = false;

                window.DetectRTC = DetectRTC;

                if (typeof module !== 'undefined' /* && !!module.exports*/) {
                        module.exports = DetectRTC;
                    }

                if (typeof define === 'function' && define.amd) {
                    define('DetectRTC', [], function () {
                        return DetectRTC;
                    });
                }
            })();

            // ios-hacks.js

            function setCordovaAPIs() {
                if (DetectRTC.osName !== 'iOS') return;
                if (typeof cordova === 'undefined' || typeof cordova.plugins === 'undefined' || typeof cordova.plugins.iosrtc === 'undefined') return;

                var iosrtc = cordova.plugins.iosrtc;
                window.webkitRTCPeerConnection = iosrtc.RTCPeerConnection;
                window.RTCSessionDescription = iosrtc.RTCSessionDescription;
                window.RTCIceCandidate = iosrtc.RTCIceCandidate;
                window.MediaStream = iosrtc.MediaStream;
                window.MediaStreamTrack = iosrtc.MediaStreamTrack;
                navigator.getUserMedia = navigator.webkitGetUserMedia = iosrtc.getUserMedia;

                iosrtc.debug.enable('iosrtc*');
                if (typeof iosrtc.selectAudioOutput == 'function') {
                    iosrtc.selectAudioOutput(window.iOSDefaultAudioOutputDevice || 'speaker'); // earpiece or speaker
                }
                iosrtc.registerGlobals();
            }

            document.addEventListener('deviceready', setCordovaAPIs, false);
            setCordovaAPIs();

            // RTCPeerConnection.js

            var defaults = {};

            function setSdpConstraints(config) {
                var sdpConstraints;

                var sdpConstraints_mandatory = {
                    OfferToReceiveAudio: !!config.OfferToReceiveAudio,
                    OfferToReceiveVideo: !!config.OfferToReceiveVideo
                };

                sdpConstraints = {
                    mandatory: sdpConstraints_mandatory,
                    optional: [{
                        VoiceActivityDetection: false
                    }]
                };

                if (!!navigator.mozGetUserMedia && firefoxVersion > 34) {
                    sdpConstraints = {
                        OfferToReceiveAudio: !!config.OfferToReceiveAudio,
                        OfferToReceiveVideo: !!config.OfferToReceiveVideo
                    };
                }

                return sdpConstraints;
            }

            var RTCPeerConnection;
            if (typeof window.RTCPeerConnection !== 'undefined') {
                RTCPeerConnection = window.RTCPeerConnection;
            } else if (typeof mozRTCPeerConnection !== 'undefined') {
                RTCPeerConnection = mozRTCPeerConnection;
            } else if (typeof webkitRTCPeerConnection !== 'undefined') {
                RTCPeerConnection = webkitRTCPeerConnection;
            }

            var RTCSessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription;
            var RTCIceCandidate = window.RTCIceCandidate || window.mozRTCIceCandidate;
            var MediaStreamTrack = window.MediaStreamTrack;

            window.onPluginRTCInitialized = function () {
                MediaStreamTrack = window.PluginRTC.MediaStreamTrack;
                RTCPeerConnection = window.PluginRTC.RTCPeerConnection;
                RTCIceCandidate = window.PluginRTC.RTCIceCandidate;
                RTCSessionDescription = window.PluginRTC.RTCSessionDescription;
            };

            if (typeof window.PluginRTC !== 'undefined') {
                window.onPluginRTCInitialized();
            }

            function PeerInitiator(config) {
                if (!RTCPeerConnection) {
                    throw 'WebRTC 1.0 (RTCPeerConnection) API are NOT available in this browser.';
                }

                var connection = config.rtcMultiConnection;

                this.extra = config.remoteSdp ? config.remoteSdp.extra : connection.extra;
                this.userid = config.userid;
                this.streams = [];
                this.channels = config.channels || [];
                this.connectionDescription = config.connectionDescription;

                this.addStream = function (session) {
                    connection.addStream(session, this.userid);
                };

                this.removeStream = function (streamid) {
                    connection.removeStream(streamid, this.userid);
                };

                var self = this;

                if (config.remoteSdp) {
                    this.connectionDescription = config.remoteSdp.connectionDescription;
                }

                var allRemoteStreams = {};

                defaults.sdpConstraints = setSdpConstraints({
                    OfferToReceiveAudio: true,
                    OfferToReceiveVideo: true
                });

                var peer;

                var renegotiatingPeer = !!config.renegotiatingPeer;
                if (config.remoteSdp) {
                    renegotiatingPeer = !!config.remoteSdp.renegotiatingPeer;
                }

                var localStreams = [];
                connection.attachStreams.forEach(function (stream) {
                    if (!!stream) {
                        localStreams.push(stream);
                    }
                });

                if (!renegotiatingPeer) {
                    var iceTransports = 'all';
                    if (connection.candidates.turn || connection.candidates.relay) {
                        if (!connection.candidates.stun && !connection.candidates.reflexive && !connection.candidates.host) {
                            iceTransports = 'relay';
                        }
                    }

                    peer = new RTCPeerConnection(navigator.onLine ? {
                        iceServers: connection.iceServers,
                        iceTransportPolicy: connection.iceTransportPolicy || iceTransports,
                        rtcpMuxPolicy: connection.rtcpMuxPolicy || 'negotiate'
                    } : null, window.PluginRTC ? null : connection.optionalArgument);

                    if (!connection.iceServers.length) {
                        peer = new RTCPeerConnection(null, null);
                    }
                } else {
                    peer = config.peerRef;
                }

                function getLocalStreams() {
                    // if-block is temporarily disabled
                    if (false && 'getSenders' in peer && typeof peer.getSenders === 'function') {
                        var streamObject2 = new MediaStream();
                        peer.getSenders().forEach(function (sender) {
                            streamObject2.addTrack(sender.track);
                        });
                        return streamObject2;
                    }
                    return peer.getLocalStreams();
                }

                peer.onicecandidate = function (event) {
                    if (!event.candidate) {
                        if (!connection.trickleIce) {
                            var localSdp = peer.localDescription;
                            config.onLocalSdp({
                                type: localSdp.type,
                                sdp: localSdp.sdp,
                                remotePeerSdpConstraints: config.remotePeerSdpConstraints || false,
                                renegotiatingPeer: !!config.renegotiatingPeer || false,
                                connectionDescription: self.connectionDescription,
                                dontGetRemoteStream: !!config.dontGetRemoteStream,
                                extra: connection ? connection.extra : {},
                                streamsToShare: streamsToShare,
                                isFirefoxOffered: isFirefox
                            });
                        }
                        return;
                    }

                    if (!connection.trickleIce) return;
                    config.onLocalCandidate({
                        candidate: event.candidate.candidate,
                        sdpMid: event.candidate.sdpMid,
                        sdpMLineIndex: event.candidate.sdpMLineIndex
                    });
                };

                var isFirefoxOffered = !isFirefox;
                if (config.remoteSdp && config.remoteSdp.remotePeerSdpConstraints && config.remoteSdp.remotePeerSdpConstraints.isFirefoxOffered) {
                    isFirefoxOffered = true;
                }

                localStreams.forEach(function (localStream) {
                    if (config.remoteSdp && config.remoteSdp.remotePeerSdpConstraints && config.remoteSdp.remotePeerSdpConstraints.dontGetRemoteStream) {
                        return;
                    }

                    if (config.dontAttachLocalStream) {
                        return;
                    }

                    localStream = connection.beforeAddingStream(localStream, self);

                    if (!localStream) return;

                    if (getLocalStreams().forEach) {
                        getLocalStreams().forEach(function (stream) {
                            if (localStream && stream.id == localStream.id) {
                                localStream = null;
                            }
                        });
                    }

                    if (localStream) {
                        peer.addStream(localStream);
                    }
                });

                peer.oniceconnectionstatechange = peer.onsignalingstatechange = function () {
                    var extra = self.extra;
                    if (connection.peers[self.userid]) {
                        extra = connection.peers[self.userid].extra || extra;
                    }

                    if (!peer) {
                        return;
                    }

                    config.onPeerStateChanged({
                        iceConnectionState: peer.iceConnectionState,
                        iceGatheringState: peer.iceGatheringState,
                        signalingState: peer.signalingState,
                        extra: extra,
                        userid: self.userid
                    });

                    if (isFirefox && peer.iceConnectionState.search(/closed|failed/gi) !== -1) {
                        self.streams.forEach(function (stream) {
                            var streamEvent = connection.streamEvents[stream.id] || {
                                streamid: stream.id,
                                stream: stream,
                                type: 'remote'
                            };

                            connection.onstreamended(streamEvent);
                        });
                    }
                };

                var sdpConstraints = {
                    OfferToReceiveAudio: !!localStreams.length,
                    OfferToReceiveVideo: !!localStreams.length
                };

                if (config.localPeerSdpConstraints) sdpConstraints = config.localPeerSdpConstraints;

                defaults.sdpConstraints = setSdpConstraints(sdpConstraints);

                var remoteStreamAddEvent = 'addstream';
                if ('ontrack' in peer) {
                    // temporarily disabled
                    // remoteStreamAddEvent = 'track';
                }

                var streamObject;
                peer.addEventListener(remoteStreamAddEvent, function (event) {
                    if (!event) return;
                    if (event.streams && event.streams.length && !event.stream) {
                        if (!streamObject) {
                            streamObject = new MediaStream();
                            return;
                        }

                        event.streams.forEach(function (stream) {
                            if (stream.getVideoTracks().length) {
                                streamObject.addTrack(stream.getVideoTracks()[0]);
                            }
                            if (stream.getAudioTracks().length) {
                                streamObject.addTrack(stream.getAudioTracks()[0]);
                            }
                        });
                        event.stream = streamObject;

                        if (connection.session.audio && connection.session.video && (!streamObject.getVideoTracks().length || !streamObject.getAudioTracks().length)) {
                            return;
                        }

                        streamObject = null;
                    }

                    var streamsToShare = {};
                    if (config.remoteSdp && config.remoteSdp.streamsToShare) {
                        streamsToShare = config.remoteSdp.streamsToShare;
                    } else if (config.streamsToShare) {
                        streamsToShare = config.streamsToShare;
                    }

                    var streamToShare = streamsToShare[event.stream.id];
                    if (streamToShare) {
                        event.stream.isAudio = streamToShare.isAudio;
                        event.stream.isVideo = streamToShare.isVideo;
                        event.stream.isScreen = streamToShare.isScreen;
                    }
                    event.stream.streamid = event.stream.id;
                    if (isFirefox || !event.stream.stop) {
                        event.stream.stop = function () {
                            var streamEndedEvent = 'ended';

                            if ('oninactive' in event.stream) {
                                streamEndedEvent = 'inactive';
                            }
                            fireEvent(event.stream, streamEndedEvent);
                        };
                    }
                    allRemoteStreams[event.stream.id] = event.stream;
                    config.onRemoteStream(event.stream);
                }, false);

                peer.onremovestream = function (event) {
                    event.stream.streamid = event.stream.id;

                    if (allRemoteStreams[event.stream.id]) {
                        delete allRemoteStreams[event.stream.id];
                    }

                    config.onRemoteStreamRemoved(event.stream);
                };

                this.addRemoteCandidate = function (remoteCandidate) {
                    peer.addIceCandidate(new RTCIceCandidate(remoteCandidate));
                };

                this.addRemoteSdp = function (remoteSdp, cb) {
                    remoteSdp.sdp = connection.processSdp(remoteSdp.sdp);
                    peer.setRemoteDescription(new RTCSessionDescription(remoteSdp), cb || function () {}, function (error) {
                        if (!!connection.enableLogs) {
                            console.error(JSON.stringify(error, null, '\t'), '\n', remoteSdp.type, remoteSdp.sdp);
                        }
                    });
                };

                var isOfferer = true;

                if (config.remoteSdp) {
                    isOfferer = false;
                }

                this.createDataChannel = function () {
                    var channel = peer.createDataChannel('sctp', {});
                    setChannelEvents(channel);
                };

                if (connection.session.data === true && !renegotiatingPeer) {
                    if (!isOfferer) {
                        peer.ondatachannel = function (event) {
                            var channel = event.channel;
                            setChannelEvents(channel);
                        };
                    } else {
                        this.createDataChannel();
                    }
                }

                if (config.remoteSdp) {
                    if (config.remoteSdp.remotePeerSdpConstraints) {
                        sdpConstraints = config.remoteSdp.remotePeerSdpConstraints;
                    }
                    defaults.sdpConstraints = setSdpConstraints(sdpConstraints);
                    this.addRemoteSdp(config.remoteSdp, function () {
                        createOfferOrAnswer('createAnswer');
                    });
                }

                function setChannelEvents(channel) {
                    // force ArrayBuffer in Firefox; which uses "Blob" by default.
                    channel.binaryType = 'arraybuffer';

                    channel.onmessage = function (event) {
                        config.onDataChannelMessage(event.data);
                    };

                    channel.onopen = function () {
                        config.onDataChannelOpened(channel);
                    };

                    channel.onerror = function (error) {
                        config.onDataChannelError(error);
                    };

                    channel.onclose = function (event) {
                        config.onDataChannelClosed(event);
                    };

                    channel.internalSend = channel.send;
                    channel.send = function (data) {
                        if (channel.readyState !== 'open') {
                            return;
                        }

                        channel.internalSend(data);
                    };

                    peer.channel = channel;
                }

                if (connection.session.audio == 'two-way' || connection.session.video == 'two-way' || connection.session.screen == 'two-way') {
                    defaults.sdpConstraints = setSdpConstraints({
                        OfferToReceiveAudio: connection.session.audio == 'two-way' || config.remoteSdp && config.remoteSdp.remotePeerSdpConstraints && config.remoteSdp.remotePeerSdpConstraints.OfferToReceiveAudio,
                        OfferToReceiveVideo: connection.session.video == 'two-way' || connection.session.screen == 'two-way' || config.remoteSdp && config.remoteSdp.remotePeerSdpConstraints && config.remoteSdp.remotePeerSdpConstraints.OfferToReceiveAudio
                    });
                }

                var streamsToShare = {};
                if (getLocalStreams().forEach) {
                    getLocalStreams().forEach(function (stream) {
                        streamsToShare[stream.streamid] = {
                            isAudio: !!stream.isAudio,
                            isVideo: !!stream.isVideo,
                            isScreen: !!stream.isScreen
                        };
                    });
                }

                function createOfferOrAnswer(_method) {
                    peer[_method](function (localSdp) {
                        localSdp.sdp = connection.processSdp(localSdp.sdp);
                        peer.setLocalDescription(localSdp, function () {
                            if (!connection.trickleIce) return;
                            config.onLocalSdp({
                                type: localSdp.type,
                                sdp: localSdp.sdp,
                                remotePeerSdpConstraints: config.remotePeerSdpConstraints || false,
                                renegotiatingPeer: !!config.renegotiatingPeer || false,
                                connectionDescription: self.connectionDescription,
                                dontGetRemoteStream: !!config.dontGetRemoteStream,
                                extra: connection ? connection.extra : {},
                                streamsToShare: streamsToShare,
                                isFirefoxOffered: isFirefox
                            });

                            connection.onSettingLocalDescription(self);
                        }, function (error) {
                            if (!connection.enableLogs) return;
                            console.error('setLocalDescription error', error);
                        });
                    }, function (error) {
                        if (!!connection.enableLogs) {
                            console.error('sdp-error', error);
                        }
                    }, defaults.sdpConstraints);
                }

                if (isOfferer) {
                    createOfferOrAnswer('createOffer');
                }

                peer.nativeClose = peer.close;
                peer.close = function () {
                    if (!peer) {
                        return;
                    }

                    try {
                        if (peer.iceConnectionState.search(/closed|failed/gi) === -1) {
                            peer.getRemoteStreams().forEach(function (stream) {
                                stream.stop();
                            });
                        }
                        peer.nativeClose();
                    } catch (e) {}

                    peer = null;
                    self.peer = null;
                };

                this.peer = peer;
            }

            // CodecsHandler.js

            var CodecsHandler = function () {
                var isMobileDevice = !!navigator.userAgent.match(/Android|iPhone|iPad|iPod|BlackBerry|IEMobile/i);
                if (typeof cordova !== 'undefined') {
                    isMobileDevice = true;
                }

                if (navigator && navigator.userAgent && navigator.userAgent.indexOf('Crosswalk') !== -1) {
                    isMobileDevice = true;
                }

                // "removeVPX" and "removeNonG722" methods are taken from github/mozilla/webrtc-landing
                function removeVPX(sdp) {
                    if (!sdp || typeof sdp !== 'string') {
                        throw 'Invalid arguments.';
                    }

                    // this method is NOT reliable

                    sdp = sdp.replace('a=rtpmap:100 VP8/90000\r\n', '');
                    sdp = sdp.replace('a=rtpmap:101 VP9/90000\r\n', '');

                    sdp = sdp.replace(/m=video ([0-9]+) RTP\/SAVPF ([0-9 ]*) 100/g, 'm=video $1 RTP\/SAVPF $2');
                    sdp = sdp.replace(/m=video ([0-9]+) RTP\/SAVPF ([0-9 ]*) 101/g, 'm=video $1 RTP\/SAVPF $2');

                    sdp = sdp.replace(/m=video ([0-9]+) RTP\/SAVPF 100([0-9 ]*)/g, 'm=video $1 RTP\/SAVPF$2');
                    sdp = sdp.replace(/m=video ([0-9]+) RTP\/SAVPF 101([0-9 ]*)/g, 'm=video $1 RTP\/SAVPF$2');

                    sdp = sdp.replace('a=rtcp-fb:120 nack\r\n', '');
                    sdp = sdp.replace('a=rtcp-fb:120 nack pli\r\n', '');
                    sdp = sdp.replace('a=rtcp-fb:120 ccm fir\r\n', '');

                    sdp = sdp.replace('a=rtcp-fb:101 nack\r\n', '');
                    sdp = sdp.replace('a=rtcp-fb:101 nack pli\r\n', '');
                    sdp = sdp.replace('a=rtcp-fb:101 ccm fir\r\n', '');

                    return sdp;
                }

                function disableNACK(sdp) {
                    if (!sdp || typeof sdp !== 'string') {
                        throw 'Invalid arguments.';
                    }

                    sdp = sdp.replace('a=rtcp-fb:126 nack\r\n', '');
                    sdp = sdp.replace('a=rtcp-fb:126 nack pli\r\n', 'a=rtcp-fb:126 pli\r\n');
                    sdp = sdp.replace('a=rtcp-fb:97 nack\r\n', '');
                    sdp = sdp.replace('a=rtcp-fb:97 nack pli\r\n', 'a=rtcp-fb:97 pli\r\n');

                    return sdp;
                }

                function prioritize(codecMimeType, peer) {
                    if (!peer || !peer.getSenders || !peer.getSenders().length) {
                        return;
                    }

                    if (!codecMimeType || typeof codecMimeType !== 'string') {
                        throw 'Invalid arguments.';
                    }

                    peer.getSenders().forEach(function (sender) {
                        var params = sender.getParameters();
                        for (var i = 0; i < params.codecs.length; i++) {
                            if (params.codecs[i].mimeType == codecMimeType) {
                                params.codecs.unshift(params.codecs.splice(i, 1));
                                break;
                            }
                        }
                        sender.setParameters(params);
                    });
                }

                function removeNonG722(sdp) {
                    return sdp.replace(/m=audio ([0-9]+) RTP\/SAVPF ([0-9 ]*)/g, 'm=audio $1 RTP\/SAVPF 9');
                }

                function setBAS(sdp, bandwidth, isScreen) {
                    if (!bandwidth) {
                        return sdp;
                    }

                    if (typeof isFirefox !== 'undefined' && isFirefox) {
                        return sdp;
                    }

                    if (isMobileDevice) {
                        return sdp;
                    }

                    if (isScreen) {
                        if (!bandwidth.screen) {
                            console.warn('It seems that you are not using bandwidth for screen. Screen sharing is expected to fail.');
                        } else if (bandwidth.screen < 300) {
                            console.warn('It seems that you are using wrong bandwidth value for screen. Screen sharing is expected to fail.');
                        }
                    }

                    // if screen; must use at least 300kbs
                    if (bandwidth.screen && isScreen) {
                        sdp = sdp.replace(/b=AS([^\r\n]+\r\n)/g, '');
                        sdp = sdp.replace(/a=mid:video\r\n/g, 'a=mid:video\r\nb=AS:' + bandwidth.screen + '\r\n');
                    }

                    // remove existing bandwidth lines
                    if (bandwidth.audio || bandwidth.video || bandwidth.data) {
                        sdp = sdp.replace(/b=AS([^\r\n]+\r\n)/g, '');
                    }

                    if (bandwidth.audio) {
                        sdp = sdp.replace(/a=mid:audio\r\n/g, 'a=mid:audio\r\nb=AS:' + bandwidth.audio + '\r\n');
                    }

                    if (bandwidth.video) {
                        sdp = sdp.replace(/a=mid:video\r\n/g, 'a=mid:video\r\nb=AS:' + (isScreen ? bandwidth.screen : bandwidth.video) + '\r\n');
                    }

                    return sdp;
                }

                // Find the line in sdpLines that starts with |prefix|, and, if specified,
                // contains |substr| (case-insensitive search).
                function findLine(sdpLines, prefix, substr) {
                    return findLineInRange(sdpLines, 0, -1, prefix, substr);
                }

                // Find the line in sdpLines[startLine...endLine - 1] that starts with |prefix|
                // and, if specified, contains |substr| (case-insensitive search).
                function findLineInRange(sdpLines, startLine, endLine, prefix, substr) {
                    var realEndLine = endLine !== -1 ? endLine : sdpLines.length;
                    for (var i = startLine; i < realEndLine; ++i) {
                        if (sdpLines[i].indexOf(prefix) === 0) {
                            if (!substr || sdpLines[i].toLowerCase().indexOf(substr.toLowerCase()) !== -1) {
                                return i;
                            }
                        }
                    }
                    return null;
                }

                // Gets the codec payload type from an a=rtpmap:X line.
                function getCodecPayloadType(sdpLine) {
                    var pattern = new RegExp('a=rtpmap:(\\d+) \\w+\\/\\d+');
                    var result = sdpLine.match(pattern);
                    return result && result.length === 2 ? result[1] : null;
                }

                function setVideoBitrates(sdp, params) {
                    if (isMobileDevice) {
                        return sdp;
                    }

                    params = params || {};
                    var xgoogle_min_bitrate = params.min;
                    var xgoogle_max_bitrate = params.max;

                    var sdpLines = sdp.split('\r\n');

                    // VP8
                    var vp8Index = findLine(sdpLines, 'a=rtpmap', 'VP8/90000');
                    var vp8Payload;
                    if (vp8Index) {
                        vp8Payload = getCodecPayloadType(sdpLines[vp8Index]);
                    }

                    if (!vp8Payload) {
                        return sdp;
                    }

                    var rtxIndex = findLine(sdpLines, 'a=rtpmap', 'rtx/90000');
                    var rtxPayload;
                    if (rtxIndex) {
                        rtxPayload = getCodecPayloadType(sdpLines[rtxIndex]);
                    }

                    if (!rtxIndex) {
                        return sdp;
                    }

                    var rtxFmtpLineIndex = findLine(sdpLines, 'a=fmtp:' + rtxPayload.toString());
                    if (rtxFmtpLineIndex !== null) {
                        var appendrtxNext = '\r\n';
                        appendrtxNext += 'a=fmtp:' + vp8Payload + ' x-google-min-bitrate=' + (xgoogle_min_bitrate || '228') + '; x-google-max-bitrate=' + (xgoogle_max_bitrate || '228');
                        sdpLines[rtxFmtpLineIndex] = sdpLines[rtxFmtpLineIndex].concat(appendrtxNext);
                        sdp = sdpLines.join('\r\n');
                    }

                    return sdp;
                }

                function setOpusAttributes(sdp, params) {
                    if (isMobileDevice) {
                        return sdp;
                    }

                    params = params || {};

                    var sdpLines = sdp.split('\r\n');

                    // Opus
                    var opusIndex = findLine(sdpLines, 'a=rtpmap', 'opus/48000');
                    var opusPayload;
                    if (opusIndex) {
                        opusPayload = getCodecPayloadType(sdpLines[opusIndex]);
                    }

                    if (!opusPayload) {
                        return sdp;
                    }

                    var opusFmtpLineIndex = findLine(sdpLines, 'a=fmtp:' + opusPayload.toString());
                    if (opusFmtpLineIndex === null) {
                        return sdp;
                    }

                    var appendOpusNext = '';
                    appendOpusNext += '; stereo=' + (typeof params.stereo != 'undefined' ? params.stereo : '1');
                    appendOpusNext += '; sprop-stereo=' + (typeof params['sprop-stereo'] != 'undefined' ? params['sprop-stereo'] : '1');

                    if (typeof params.maxaveragebitrate != 'undefined') {
                        appendOpusNext += '; maxaveragebitrate=' + (params.maxaveragebitrate || 128 * 1024 * 8);
                    }

                    if (typeof params.maxplaybackrate != 'undefined') {
                        appendOpusNext += '; maxplaybackrate=' + (params.maxplaybackrate || 128 * 1024 * 8);
                    }

                    if (typeof params.cbr != 'undefined') {
                        appendOpusNext += '; cbr=' + (typeof params.cbr != 'undefined' ? params.cbr : '1');
                    }

                    if (typeof params.useinbandfec != 'undefined') {
                        appendOpusNext += '; useinbandfec=' + params.useinbandfec;
                    }

                    if (typeof params.usedtx != 'undefined') {
                        appendOpusNext += '; usedtx=' + params.usedtx;
                    }

                    if (typeof params.maxptime != 'undefined') {
                        appendOpusNext += '\r\na=maxptime:' + params.maxptime;
                    }

                    sdpLines[opusFmtpLineIndex] = sdpLines[opusFmtpLineIndex].concat(appendOpusNext);

                    sdp = sdpLines.join('\r\n');
                    return sdp;
                }

                function preferVP9(sdp) {
                    if (sdp.indexOf('SAVPF 100 101') === -1 || sdp.indexOf('VP9/90000') === -1) {
                        return sdp;
                    }

                    return sdp.replace('SAVPF 100 101', 'SAVPF 101 100');
                }

                // forceStereoAudio => via webrtcexample.com
                // requires getUserMedia => echoCancellation:false
                function forceStereoAudio(sdp) {
                    var sdpLines = sdp.split('\r\n');
                    var fmtpLineIndex = null;
                    for (var i = 0; i < sdpLines.length; i++) {
                        if (sdpLines[i].search('opus/48000') !== -1) {
                            var opusPayload = extractSdp(sdpLines[i], /:(\d+) opus\/48000/i);
                            break;
                        }
                    }
                    for (var i = 0; i < sdpLines.length; i++) {
                        if (sdpLines[i].search('a=fmtp') !== -1) {
                            var payload = extractSdp(sdpLines[i], /a=fmtp:(\d+)/);
                            if (payload === opusPayload) {
                                fmtpLineIndex = i;
                                break;
                            }
                        }
                    }
                    if (fmtpLineIndex === null) return sdp;
                    sdpLines[fmtpLineIndex] = sdpLines[fmtpLineIndex].concat('; stereo=1; sprop-stereo=1');
                    sdp = sdpLines.join('\r\n');
                    return sdp;
                }

                return {
                    removeVPX: removeVPX,
                    disableNACK: disableNACK,
                    prioritize: prioritize,
                    removeNonG722: removeNonG722,
                    setApplicationSpecificBandwidth: function (sdp, bandwidth, isScreen) {
                        return setBAS(sdp, bandwidth, isScreen);
                    },
                    setVideoBitrates: function (sdp, params) {
                        return setVideoBitrates(sdp, params);
                    },
                    setOpusAttributes: function (sdp, params) {
                        return setOpusAttributes(sdp, params);
                    },
                    preferVP9: preferVP9,
                    forceStereoAudio: forceStereoAudio
                };
            }();

            // backward compatibility
            window.BandwidthHandler = CodecsHandler;

            // OnIceCandidateHandler.js

            var OnIceCandidateHandler = function () {
                function processCandidates(connection, icePair) {
                    var candidate = icePair.candidate;

                    var iceRestrictions = connection.candidates;
                    var stun = iceRestrictions.stun;
                    var turn = iceRestrictions.turn;

                    if (!isNull(iceRestrictions.reflexive)) {
                        stun = iceRestrictions.reflexive;
                    }

                    if (!isNull(iceRestrictions.relay)) {
                        turn = iceRestrictions.relay;
                    }

                    if (!iceRestrictions.host && !!candidate.match(/typ host/g)) {
                        return;
                    }

                    if (!turn && !!candidate.match(/typ relay/g)) {
                        return;
                    }

                    if (!stun && !!candidate.match(/typ srflx/g)) {
                        return;
                    }

                    var protocol = connection.iceProtocols;

                    if (!protocol.udp && !!candidate.match(/ udp /g)) {
                        return;
                    }

                    if (!protocol.tcp && !!candidate.match(/ tcp /g)) {
                        return;
                    }

                    if (connection.enableLogs) {
                        console.debug('Your candidate pairs:', candidate);
                    }

                    return {
                        candidate: candidate,
                        sdpMid: icePair.sdpMid,
                        sdpMLineIndex: icePair.sdpMLineIndex
                    };
                }

                return {
                    processCandidates: processCandidates
                };
            }();

            // IceServersHandler.js

            var IceServersHandler = function () {
                function getIceServers(connection) {
                    var iceServers = [];

                    iceServers.push(getSTUNObj('stun:stun.l.google.com:19302'));

                    iceServers.push(getTURNObj('stun:webrtcweb.com:7788', 'muazkh', 'muazkh')); // coTURN
                    iceServers.push(getTURNObj('turn:webrtcweb.com:7788', 'muazkh', 'muazkh')); // coTURN
                    iceServers.push(getTURNObj('turn:webrtcweb.com:8877', 'muazkh', 'muazkh')); // coTURN

                    iceServers.push(getTURNObj('turns:webrtcweb.com:7788', 'muazkh', 'muazkh')); // coTURN
                    iceServers.push(getTURNObj('turns:webrtcweb.com:8877', 'muazkh', 'muazkh')); // coTURN

                    // iceServers.push(getTURNObj('turn:webrtcweb.com:3344', 'muazkh', 'muazkh')); // resiprocate
                    // iceServers.push(getTURNObj('turn:webrtcweb.com:4433', 'muazkh', 'muazkh')); // resiprocate

                    // check if restund is still active: http://webrtcweb.com:4050/
                    iceServers.push(getTURNObj('stun:webrtcweb.com:4455', 'muazkh', 'muazkh')); // restund
                    iceServers.push(getTURNObj('turn:webrtcweb.com:4455', 'muazkh', 'muazkh')); // restund
                    iceServers.push(getTURNObj('turn:webrtcweb.com:5544?transport=tcp', 'muazkh', 'muazkh')); // restund

                    return iceServers;
                }

                function getSTUNObj(stunStr) {
                    var urlsParam = 'urls';
                    if (typeof isPluginRTC !== 'undefined') {
                        urlsParam = 'url';
                    }

                    var obj = {};
                    obj[urlsParam] = stunStr;
                    return obj;
                }

                function getTURNObj(turnStr, username, credential) {
                    var urlsParam = 'urls';
                    if (typeof isPluginRTC !== 'undefined') {
                        urlsParam = 'url';
                    }

                    var obj = {
                        username: username,
                        credential: credential
                    };
                    obj[urlsParam] = turnStr;
                    return obj;
                }

                return {
                    getIceServers: getIceServers
                };
            }();

            // getUserMediaHandler.js

            function setStreamType(constraints, stream) {
                if (constraints.mandatory && constraints.mandatory.chromeMediaSource) {
                    stream.isScreen = true;
                } else if (constraints.mozMediaSource || constraints.mediaSource) {
                    stream.isScreen = true;
                } else if (constraints.video) {
                    stream.isVideo = true;
                } else if (constraints.audio) {
                    stream.isAudio = true;
                }
            }

            // allow users to manage this object (to support re-capturing of screen/etc.)
            window.currentUserMediaRequest = {
                streams: [],
                mutex: false,
                queueRequests: [],
                remove: function (idInstance) {
                    this.mutex = false;

                    var stream = this.streams[idInstance];
                    if (!stream) {
                        return;
                    }

                    stream = stream.stream;

                    var options = stream.currentUserMediaRequestOptions;

                    if (this.queueRequests.indexOf(options)) {
                        delete this.queueRequests[this.queueRequests.indexOf(options)];
                        this.queueRequests = removeNullEntries(this.queueRequests);
                    }

                    this.streams[idInstance].stream = null;
                    delete this.streams[idInstance];
                }
            };

            function getUserMediaHandler(options) {
                if (currentUserMediaRequest.mutex === true) {
                    currentUserMediaRequest.queueRequests.push(options);
                    return;
                }
                currentUserMediaRequest.mutex = true;

                // easy way to match
                var idInstance = JSON.stringify(options.localMediaConstraints);

                function streaming(stream, returnBack) {
                    setStreamType(options.localMediaConstraints, stream);
                    options.onGettingLocalMedia(stream, returnBack);

                    var streamEndedEvent = 'ended';

                    if ('oninactive' in stream) {
                        streamEndedEvent = 'inactive';
                    }
                    stream.addEventListener(streamEndedEvent, function () {
                        delete currentUserMediaRequest.streams[idInstance];

                        currentUserMediaRequest.mutex = false;
                        if (currentUserMediaRequest.queueRequests.indexOf(options)) {
                            delete currentUserMediaRequest.queueRequests[currentUserMediaRequest.queueRequests.indexOf(options)];
                            currentUserMediaRequest.queueRequests = removeNullEntries(currentUserMediaRequest.queueRequests);
                        }
                    }, false);

                    currentUserMediaRequest.streams[idInstance] = {
                        stream: stream
                    };
                    currentUserMediaRequest.mutex = false;

                    if (currentUserMediaRequest.queueRequests.length) {
                        getUserMediaHandler(currentUserMediaRequest.queueRequests.shift());
                    }
                }

                if (currentUserMediaRequest.streams[idInstance]) {
                    streaming(currentUserMediaRequest.streams[idInstance].stream, true);
                } else {
                    if (isPluginRTC && window.PluginRTC) {
                        var mediaElement = document.createElement('video');
                        window.PluginRTC.getUserMedia({
                            audio: true,
                            video: true
                        }, function (stream) {
                            stream.streamid = stream.id || getRandomString();
                            streaming(stream);
                        }, function (error) {});

                        return;
                    }

                    var isBlackBerry = !!/BB10|BlackBerry/i.test(navigator.userAgent || '');
                    if (isBlackBerry || typeof navigator.mediaDevices === 'undefined' || typeof navigator.mediaDevices.getUserMedia !== 'function') {
                        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
                        navigator.getUserMedia(options.localMediaConstraints, function (stream) {
                            stream.streamid = stream.streamid || stream.id || getRandomString();
                            stream.idInstance = idInstance;
                            streaming(stream);
                        }, function (error) {
                            options.onLocalMediaError(error, options.localMediaConstraints);
                        });
                        return;
                    }

                    navigator.mediaDevices.getUserMedia(options.localMediaConstraints).then(function (stream) {
                        stream.streamid = stream.streamid || stream.id || getRandomString();
                        stream.idInstance = idInstance;
                        streaming(stream);
                    }).catch(function (error) {
                        options.onLocalMediaError(error, options.localMediaConstraints);
                    });
                }
            }

            // StreamsHandler.js

            var StreamsHandler = function () {
                function handleType(type) {
                    if (!type) {
                        return;
                    }

                    if (typeof type === 'string' || typeof type === 'undefined') {
                        return type;
                    }

                    if (type.audio && type.video) {
                        return null;
                    }

                    if (type.audio) {
                        return 'audio';
                    }

                    if (type.video) {
                        return 'video';
                    }

                    return;
                }

                function setHandlers(stream, syncAction, connection) {
                    if (!stream || !stream.addEventListener) return;

                    if (typeof syncAction == 'undefined' || syncAction == true) {
                        var streamEndedEvent = 'ended';

                        if ('oninactive' in stream) {
                            streamEndedEvent = 'inactive';
                        }

                        stream.addEventListener(streamEndedEvent, function () {
                            StreamsHandler.onSyncNeeded(this.streamid, streamEndedEvent);
                        }, false);
                    }

                    stream.mute = function (type, isSyncAction) {
                        type = handleType(type);

                        if (typeof isSyncAction !== 'undefined') {
                            syncAction = isSyncAction;
                        }

                        if (typeof type == 'undefined' || type == 'audio') {
                            stream.getAudioTracks().forEach(function (track) {
                                track.enabled = false;
                                connection.streamEvents[stream.streamid].isAudioMuted = true;
                            });
                        }

                        if (typeof type == 'undefined' || type == 'video') {
                            stream.getVideoTracks().forEach(function (track) {
                                track.enabled = false;
                            });
                        }

                        if (typeof syncAction == 'undefined' || syncAction == true) {
                            StreamsHandler.onSyncNeeded(stream.streamid, 'mute', type);
                        }

                        connection.streamEvents[stream.streamid].muteType = type || 'both';

                        fireEvent(stream, 'mute', type);
                    };

                    stream.unmute = function (type, isSyncAction) {
                        type = handleType(type);

                        if (typeof isSyncAction !== 'undefined') {
                            syncAction = isSyncAction;
                        }

                        graduallyIncreaseVolume();

                        if (typeof type == 'undefined' || type == 'audio') {
                            stream.getAudioTracks().forEach(function (track) {
                                track.enabled = true;
                                connection.streamEvents[stream.streamid].isAudioMuted = false;
                            });
                        }

                        if (typeof type == 'undefined' || type == 'video') {
                            stream.getVideoTracks().forEach(function (track) {
                                track.enabled = true;
                            });

                            // make sure that video unmute doesn't affects audio
                            if (typeof type !== 'undefined' && type == 'video' && connection.streamEvents[stream.streamid].isAudioMuted) {
                                (function looper(times) {
                                    if (!times) {
                                        times = 0;
                                    }

                                    times++;

                                    // check until five-seconds
                                    if (times < 100 && connection.streamEvents[stream.streamid].isAudioMuted) {
                                        stream.mute('audio');

                                        setTimeout(function () {
                                            looper(times);
                                        }, 50);
                                    }
                                })();
                            }
                        }

                        if (typeof syncAction == 'undefined' || syncAction == true) {
                            StreamsHandler.onSyncNeeded(stream.streamid, 'unmute', type);
                        }

                        connection.streamEvents[stream.streamid].unmuteType = type || 'both';

                        fireEvent(stream, 'unmute', type);
                    };

                    function graduallyIncreaseVolume() {
                        if (!connection.streamEvents[stream.streamid].mediaElement) {
                            return;
                        }

                        var mediaElement = connection.streamEvents[stream.streamid].mediaElement;
                        mediaElement.volume = 0;
                        afterEach(200, 5, function () {
                            try {
                                mediaElement.volume += .20;
                            } catch (e) {
                                mediaElement.volume = 1;
                            }
                        });
                    }
                }

                function afterEach(setTimeoutInteval, numberOfTimes, callback, startedTimes) {
                    startedTimes = (startedTimes || 0) + 1;
                    if (startedTimes >= numberOfTimes) return;

                    setTimeout(function () {
                        callback();
                        afterEach(setTimeoutInteval, numberOfTimes, callback, startedTimes);
                    }, setTimeoutInteval);
                }

                return {
                    setHandlers: setHandlers,
                    onSyncNeeded: function (streamid, action, type) {}
                };
            }();

            // Last time updated at Nov 07, 2016, 08:32:23

            // Latest file can be found here: https://cdn.webrtc-experiment.com/Screen-Capturing.js

            // Muaz Khan     - www.MuazKhan.com
            // MIT License   - www.WebRTC-Experiment.com/licence
            // Documentation - https://github.com/muaz-khan/Chrome-Extensions/tree/master/Screen-Capturing.js
            // Demo          - https://www.webrtc-experiment.com/Screen-Capturing/

            // ___________________
            // Screen-Capturing.js

            // Listen for postMessage handler
            // postMessage is used to exchange "sourceId" between chrome extension and you webpage.
            // though, there are tons other options as well, e.g. XHR-signaling, websockets, etc.
            window.addEventListener('message', function (event) {
                if (event.origin != window.location.origin) {
                    return;
                }

                onMessageCallback(event.data);
            });

            // via: https://bugs.chromium.org/p/chromium/issues/detail?id=487935#c17
            // you can capture screen on Android Chrome >= 55 with flag: "Experimental ScreenCapture android"
            window.IsAndroidChrome = false;
            try {
                if (navigator.userAgent.toLowerCase().indexOf("android") > -1 && /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor)) {
                    window.IsAndroidChrome = true;
                }
            } catch (e) {}

            // and the function that handles received messages

            function onMessageCallback(data) {
                // "cancel" button is clicked
                if (data == 'PermissionDeniedError') {
                    chromeMediaSource = 'PermissionDeniedError';
                    if (screenCallback) {
                        return screenCallback('PermissionDeniedError');
                    } else {
                        throw new Error('PermissionDeniedError: User rejected to share his screen.');
                    }
                }

                // extension notified his presence
                if (data == 'rtcmulticonnection-extension-loaded') {
                    chromeMediaSource = 'desktop';
                }

                // extension shared temp sourceId
                if (data.sourceId && screenCallback) {
                    sourceId = data.sourceId;
                    screenCallback(sourceId);
                }
            }

            // global variables
            var chromeMediaSource = 'screen';
            var sourceId;
            var screenCallback;

            // this method can be used to check if chrome extension is installed & enabled.
            function isChromeExtensionAvailable(callback) {
                if (!callback) return;

                if (isFirefox) return isFirefoxExtensionAvailable(callback);

                if (window.IsAndroidChrome) {
                    chromeMediaSource = 'screen';
                    callback(true);
                    return;
                }

                if (chromeMediaSource == 'desktop') {
                    callback(true);
                    return;
                }

                // ask extension if it is available
                window.postMessage('are-you-there', '*');

                setTimeout(function () {
                    if (chromeMediaSource == 'screen') {
                        callback(false);
                    } else callback(true);
                }, 2000);
            }

            function isFirefoxExtensionAvailable(callback) {
                if (!callback) return;

                if (!isFirefox) return isChromeExtensionAvailable(callback);

                var isFirefoxAddonResponded = false;

                function messageCallback(event) {
                    var addonMessage = event.data;

                    if (!addonMessage || typeof addonMessage.isScreenCapturingEnabled === 'undefined') return;

                    isFirefoxAddonResponded = true;

                    if (addonMessage.isScreenCapturingEnabled === true) {
                        callback(true);
                    } else {
                        callback(false);
                    }

                    window.removeEventListener("message", messageCallback, false);
                }

                window.addEventListener("message", messageCallback, false);

                window.postMessage({
                    checkIfScreenCapturingEnabled: true,
                    domains: [document.domain]
                }, "*");

                setTimeout(function () {
                    if (!isFirefoxAddonResponded) {
                        callback(true); // can be old firefox extension
                    }
                }, 2000); // wait 2-seconds-- todo: is this enough limit?
            }

            // this function can be used to get "source-id" from the extension
            function getSourceId(callback, audioPlusTab) {
                if (!callback) throw '"callback" parameter is mandatory.';
                if (sourceId) {
                    callback(sourceId);
                    sourceId = null;
                    return;
                }

                screenCallback = callback;

                if (!!audioPlusTab) {
                    window.postMessage('audio-plus-tab', '*');
                    return;
                }
                window.postMessage('get-sourceId', '*');
            }

            function getChromeExtensionStatus(extensionid, callback) {
                if (window.IsAndroidChrome) {
                    chromeMediaSource = 'screen';
                    callback('installed-enabled');
                    return;
                }

                if (arguments.length != 2) {
                    callback = extensionid;
                    extensionid = window.RMCExtensionID || 'ajhifddimkapgcifgcodmmfdlknahffk'; // default extension-id
                }

                if (isFirefox) return callback('not-chrome');

                var image = document.createElement('img');
                image.src = 'chrome-extension://' + extensionid + '/icon.png';
                image.onload = function () {
                    sourceId = null;
                    chromeMediaSource = 'screen';
                    window.postMessage('are-you-there', '*');
                    setTimeout(function () {
                        if (chromeMediaSource == 'screen') {
                            callback(extensionid == extensionid ? 'installed-enabled' : 'installed-disabled');
                        } else callback('installed-enabled');
                    }, 2000);
                };
                image.onerror = function () {
                    callback('not-installed');
                };
            }

            // this function explains how to use above methods/objects
            function getScreenConstraints(callback, audioPlusTab) {
                var firefoxScreenConstraints = {
                    mozMediaSource: 'window',
                    mediaSource: 'window',
                    width: 29999,
                    height: 8640
                };

                if (isFirefox) return callback(null, firefoxScreenConstraints);

                // support recapture again & again
                sourceId = null;

                isChromeExtensionAvailable(function (isAvailable) {
                    // this statement defines getUserMedia constraints
                    // that will be used to capture content of screen
                    var screen_constraints = {
                        mandatory: {
                            chromeMediaSource: chromeMediaSource,
                            maxWidth: 29999,
                            maxHeight: 8640,
                            minFrameRate: 30,
                            maxFrameRate: 128,
                            minAspectRatio: 1.77 // 2.39
                        },
                        optional: []
                    };

                    if (window.IsAndroidChrome) {
                        // now invoking native getUserMedia API
                        callback(null, screen_constraints);
                        return;
                    }

                    // this statement verifies chrome extension availability
                    // if installed and available then it will invoke extension API
                    // otherwise it will fallback to command-line based screen capturing API
                    if (chromeMediaSource == 'desktop' && !sourceId) {
                        getSourceId(function () {
                            screen_constraints.mandatory.chromeMediaSourceId = sourceId;
                            callback(sourceId == 'PermissionDeniedError' ? sourceId : null, screen_constraints);
                            sourceId = null;
                        }, audioPlusTab);
                        return;
                    }

                    // this statement sets gets 'sourceId" and sets "chromeMediaSourceId"
                    if (chromeMediaSource == 'desktop') {
                        screen_constraints.mandatory.chromeMediaSourceId = sourceId;
                    }

                    sourceId = null;
                    chromeMediaSource = 'screen'; // maybe this line is redundant?
                    screenCallback = null;

                    // now invoking native getUserMedia API
                    callback(null, screen_constraints);
                });
            }

            // TextReceiver.js & TextSender.js

            function TextReceiver(connection) {
                var content = {};

                function receive(data, userid, extra) {
                    // uuid is used to uniquely identify sending instance
                    var uuid = data.uuid;
                    if (!content[uuid]) {
                        content[uuid] = [];
                    }

                    content[uuid].push(data.message);

                    if (data.last) {
                        var message = content[uuid].join('');
                        if (data.isobject) {
                            message = JSON.parse(message);
                        }

                        // latency detection
                        var receivingTime = new Date().getTime();
                        var latency = receivingTime - data.sendingTime;

                        var e = {
                            data: message,
                            userid: userid,
                            extra: extra,
                            latency: latency
                        };

                        if (connection.autoTranslateText) {
                            e.original = e.data;
                            connection.Translator.TranslateText(e.data, function (translatedText) {
                                e.data = translatedText;
                                connection.onmessage(e);
                            });
                        } else {
                            connection.onmessage(e);
                        }

                        delete content[uuid];
                    }
                }

                return {
                    receive: receive
                };
            }

            // TextSender.js
            var TextSender = {
                send: function (config) {
                    var connection = config.connection;

                    var channel = config.channel,
                        remoteUserId = config.remoteUserId,
                        initialText = config.text,
                        packetSize = connection.chunkSize || 1000,
                        textToTransfer = '',
                        isobject = false;

                    if (!isString(initialText)) {
                        isobject = true;
                        initialText = JSON.stringify(initialText);
                    }

                    // uuid is used to uniquely identify sending instance
                    var uuid = getRandomString();
                    var sendingTime = new Date().getTime();

                    sendText(initialText);

                    function sendText(textMessage, text) {
                        var data = {
                            type: 'text',
                            uuid: uuid,
                            sendingTime: sendingTime
                        };

                        if (textMessage) {
                            text = textMessage;
                            data.packets = parseInt(text.length / packetSize);
                        }

                        if (text.length > packetSize) {
                            data.message = text.slice(0, packetSize);
                        } else {
                            data.message = text;
                            data.last = true;
                            data.isobject = isobject;
                        }

                        channel.send(data, remoteUserId);

                        textToTransfer = text.slice(data.message.length);

                        if (textToTransfer.length) {
                            setTimeout(function () {
                                sendText(null, textToTransfer);
                            }, connection.chunkInterval || 100);
                        }
                    }
                }
            };

            // FileProgressBarHandler.js

            var FileProgressBarHandler = function () {
                function handle(connection) {
                    var progressHelper = {};

                    // www.RTCMultiConnection.org/docs/onFileStart/
                    connection.onFileStart = function (file) {
                        var div = document.createElement('div');
                        div.title = file.name;
                        div.innerHTML = '<label>0%</label> <progress></progress>';

                        if (file.remoteUserId) {
                            div.innerHTML += ' (Sharing with:' + file.remoteUserId + ')';
                        }

                        if (!connection.filesContainer) {
                            connection.filesContainer = document.body || document.documentElement;
                        }

                        connection.filesContainer.insertBefore(div, connection.filesContainer.firstChild);

                        if (!file.remoteUserId) {
                            progressHelper[file.uuid] = {
                                div: div,
                                progress: div.querySelector('progress'),
                                label: div.querySelector('label')
                            };
                            progressHelper[file.uuid].progress.max = file.maxChunks;
                            return;
                        }

                        if (!progressHelper[file.uuid]) {
                            progressHelper[file.uuid] = {};
                        }

                        progressHelper[file.uuid][file.remoteUserId] = {
                            div: div,
                            progress: div.querySelector('progress'),
                            label: div.querySelector('label')
                        };
                        progressHelper[file.uuid][file.remoteUserId].progress.max = file.maxChunks;
                    };

                    // www.RTCMultiConnection.org/docs/onFileProgress/
                    connection.onFileProgress = function (chunk) {
                        var helper = progressHelper[chunk.uuid];
                        if (!helper) {
                            return;
                        }
                        if (chunk.remoteUserId) {
                            helper = progressHelper[chunk.uuid][chunk.remoteUserId];
                            if (!helper) {
                                return;
                            }
                        }

                        helper.progress.value = chunk.currentPosition || chunk.maxChunks || helper.progress.max;
                        updateLabel(helper.progress, helper.label);
                    };

                    // www.RTCMultiConnection.org/docs/onFileEnd/
                    connection.onFileEnd = function (file) {
                        var helper = progressHelper[file.uuid];
                        if (!helper) {
                            console.error('No such progress-helper element exist.', file);
                            return;
                        }

                        if (file.remoteUserId) {
                            helper = progressHelper[file.uuid][file.remoteUserId];
                            if (!helper) {
                                return;
                            }
                        }

                        var div = helper.div;
                        if (file.type.indexOf('image') != -1) {
                            div.innerHTML = '<a href="' + file.url + '" download="' + file.name + '">Download <strong style="color:red;">' + file.name + '</strong> </a><br /><img src="' + file.url + '" title="' + file.name + '" style="max-width: 80%;">';
                        } else {
                            div.innerHTML = '<a href="' + file.url + '" download="' + file.name + '">Download <strong style="color:red;">' + file.name + '</strong> </a><br /><iframe src="' + file.url + '" title="' + file.name + '" style="width: 80%;border: 0;height: inherit;margin-top:1em;"></iframe>';
                        }
                    };

                    function updateLabel(progress, label) {
                        if (progress.position === -1) {
                            return;
                        }

                        var position = +progress.position.toFixed(2).split('.')[1] || 100;
                        label.innerHTML = position + '%';
                    }
                }

                return {
                    handle: handle
                };
            }();

            // TranslationHandler.js

            var TranslationHandler = function () {
                function handle(connection) {
                    connection.autoTranslateText = false;
                    connection.language = 'en';
                    connection.googKey = 'AIzaSyCgB5hmFY74WYB-EoWkhr9cAGr6TiTHrEE';

                    // www.RTCMultiConnection.org/docs/Translator/
                    connection.Translator = {
                        TranslateText: function (text, callback) {
                            // if(location.protocol === 'https:') return callback(text);

                            var newScript = document.createElement('script');
                            newScript.type = 'text/javascript';

                            var sourceText = encodeURIComponent(text); // escape

                            var randomNumber = 'method' + connection.token();
                            window[randomNumber] = function (response) {
                                if (response.data && response.data.translations[0] && callback) {
                                    callback(response.data.translations[0].translatedText);
                                    return;
                                }

                                if (response.error && response.error.message === 'Daily Limit Exceeded') {
                                    console.error('Text translation failed. Error message: "Daily Limit Exceeded."');
                                    return;
                                }

                                if (response.error) {
                                    console.error(response.error.message);
                                    return;
                                }

                                console.error(response);
                            };

                            var source = 'https://www.googleapis.com/language/translate/v2?key=' + connection.googKey + '&target=' + (connection.language || 'en-US') + '&callback=window.' + randomNumber + '&q=' + sourceText;
                            newScript.src = source;
                            document.getElementsByTagName('head')[0].appendChild(newScript);
                        },
                        getListOfLanguages: function (callback) {
                            var xhr = new XMLHttpRequest();
                            xhr.onreadystatechange = function () {
                                if (xhr.readyState == XMLHttpRequest.DONE) {
                                    var response = JSON.parse(xhr.responseText);

                                    if (response && response.data && response.data.languages) {
                                        callback(response.data.languages);
                                        return;
                                    }

                                    if (response.error && response.error.message === 'Daily Limit Exceeded') {
                                        console.error('Text translation failed. Error message: "Daily Limit Exceeded."');
                                        return;
                                    }

                                    if (response.error) {
                                        console.error(response.error.message);
                                        return;
                                    }

                                    console.error(response);
                                }
                            };
                            var url = 'https://www.googleapis.com/language/translate/v2/languages?key=' + connection.googKey + '&target=en';
                            xhr.open('GET', url, true);
                            xhr.send(null);
                        }
                    };
                }

                return {
                    handle: handle
                };
            }();

            (function (connection) {
                forceOptions = forceOptions || {
                    useDefaultDevices: true
                };

                connection.channel = connection.sessionid = (roomid || location.href.replace(/\/|:|#|\?|\$|\^|%|\.|`|~|!|\+|@|\[|\||]|\|*. /g, '').split('\n').join('').split('\r').join('')) + '';

                var mPeer = new MultiPeers(connection);

                var preventDuplicateOnStreamEvents = {};
                mPeer.onGettingLocalMedia = function (stream) {
                    if (preventDuplicateOnStreamEvents[stream.streamid]) {
                        return;
                    }
                    preventDuplicateOnStreamEvents[stream.streamid] = true;

                    try {
                        stream.type = 'local';
                    } catch (e) {}

                    connection.setStreamEndHandler(stream);

                    getRMCMediaElement(stream, function (mediaElement) {
                        mediaElement.id = stream.streamid;
                        mediaElement.muted = true;
                        mediaElement.volume = 0;

                        if (connection.attachStreams.indexOf(stream) === -1) {
                            connection.attachStreams.push(stream);
                        }

                        if (typeof StreamsHandler !== 'undefined') {
                            StreamsHandler.setHandlers(stream, true, connection);
                        }

                        connection.streamEvents[stream.streamid] = {
                            stream: stream,
                            type: 'local',
                            mediaElement: mediaElement,
                            userid: connection.userid,
                            extra: connection.extra,
                            streamid: stream.streamid,
                            blobURL: mediaElement.src || URL.createObjectURL(stream),
                            isAudioMuted: true
                        };

                        setHarkEvents(connection, connection.streamEvents[stream.streamid]);
                        setMuteHandlers(connection, connection.streamEvents[stream.streamid]);

                        connection.onstream(connection.streamEvents[stream.streamid]);
                    }, connection);
                };

                mPeer.onGettingRemoteMedia = function (stream, remoteUserId) {
                    try {
                        stream.type = 'remote';
                    } catch (e) {}

                    connection.setStreamEndHandler(stream, 'remote-stream');

                    getRMCMediaElement(stream, function (mediaElement) {
                        mediaElement.id = stream.streamid;

                        if (typeof StreamsHandler !== 'undefined') {
                            StreamsHandler.setHandlers(stream, false, connection);
                        }

                        connection.streamEvents[stream.streamid] = {
                            stream: stream,
                            type: 'remote',
                            userid: remoteUserId,
                            extra: connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {},
                            mediaElement: mediaElement,
                            streamid: stream.streamid,
                            blobURL: mediaElement.src || URL.createObjectURL(stream)
                        };

                        setMuteHandlers(connection, connection.streamEvents[stream.streamid]);

                        connection.onstream(connection.streamEvents[stream.streamid]);
                    }, connection);
                };

                mPeer.onRemovingRemoteMedia = function (stream, remoteUserId) {
                    var streamEvent = connection.streamEvents[stream.streamid];
                    if (!streamEvent) {
                        streamEvent = {
                            stream: stream,
                            type: 'remote',
                            userid: remoteUserId,
                            extra: connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {},
                            streamid: stream.streamid,
                            mediaElement: connection.streamEvents[stream.streamid] ? connection.streamEvents[stream.streamid].mediaElement : null
                        };
                    }

                    if (connection.peersBackup[streamEvent.userid]) {
                        streamEvent.extra = connection.peersBackup[streamEvent.userid].extra;
                    }

                    connection.onstreamended(streamEvent);

                    delete connection.streamEvents[stream.streamid];
                };

                mPeer.onNegotiationNeeded = function (message, remoteUserId, callback) {
                    connectSocket(function () {
                        connection.socket.emit(connection.socketMessageEvent, 'password' in message ? message : {
                            remoteUserId: message.remoteUserId || remoteUserId,
                            message: message,
                            sender: connection.userid
                        }, callback || function () {});
                    });
                };

                function onUserLeft(remoteUserId) {
                    connection.deletePeer(remoteUserId);
                }

                mPeer.onUserLeft = onUserLeft;
                mPeer.disconnectWith = function (remoteUserId, callback) {
                    if (connection.socket) {
                        connection.socket.emit('disconnect-with', remoteUserId, callback || function () {});
                    }

                    connection.deletePeer(remoteUserId);
                };

                connection.broadcasters = [];

                connection.socketOptions = {
                    // 'force new connection': true, // For SocketIO version < 1.0
                    // 'forceNew': true, // For SocketIO version >= 1.0
                    'transport': 'polling' // fixing transport:unknown issues
                };

                function connectSocket(connectCallback) {
                    connection.socketAutoReConnect = true;

                    if (connection.socket) {
                        // todo: check here readySate/etc. to make sure socket is still opened
                        if (connectCallback) {
                            connectCallback(connection.socket);
                        }
                        return;
                    }

                    if (typeof SocketConnection === 'undefined') {
                        if (typeof FirebaseConnection !== 'undefined') {
                            window.SocketConnection = FirebaseConnection;
                        } else if (typeof PubNubConnection !== 'undefined') {
                            window.SocketConnection = PubNubConnection;
                        } else {
                            throw 'SocketConnection.js seems missed.';
                        }
                    }

                    new SocketConnection(connection, function (s) {
                        if (connectCallback) {
                            connectCallback(connection.socket);
                        }
                    });
                }

                connection.openOrJoin = function (localUserid, password) {
                    connection.checkPresence(localUserid, function (isRoomExists, roomid) {
                        if (typeof password === 'function') {
                            password(isRoomExists, roomid);
                            password = null;
                        }

                        if (isRoomExists) {
                            connection.sessionid = roomid;

                            var localPeerSdpConstraints = false;
                            var remotePeerSdpConstraints = false;
                            var isOneWay = !!connection.session.oneway;
                            var isDataOnly = isData(connection.session);

                            remotePeerSdpConstraints = {
                                OfferToReceiveAudio: connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                                OfferToReceiveVideo: connection.sdpConstraints.mandatory.OfferToReceiveVideo
                            };

                            localPeerSdpConstraints = {
                                OfferToReceiveAudio: isOneWay ? !!connection.session.audio : connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                                OfferToReceiveVideo: isOneWay ? !!connection.session.video || !!connection.session.screen : connection.sdpConstraints.mandatory.OfferToReceiveVideo
                            };

                            var connectionDescription = {
                                remoteUserId: connection.sessionid,
                                message: {
                                    newParticipationRequest: true,
                                    isOneWay: isOneWay,
                                    isDataOnly: isDataOnly,
                                    localPeerSdpConstraints: localPeerSdpConstraints,
                                    remotePeerSdpConstraints: remotePeerSdpConstraints
                                },
                                sender: connection.userid,
                                password: password || false
                            };

                            beforeJoin(connectionDescription.message, function () {
                                mPeer.onNegotiationNeeded(connectionDescription);
                            });
                            return;
                        }

                        var oldUserId = connection.userid;
                        connection.userid = connection.sessionid = localUserid || connection.sessionid;
                        connection.userid += '';

                        connection.socket.emit('changed-uuid', connection.userid);

                        if (password) {
                            connection.socket.emit('set-password', password);
                        }

                        connection.isInitiator = true;

                        if (isData(connection.session)) {
                            return;
                        }

                        connection.captureUserMedia();
                    });
                };

                connection.open = function (localUserid, isPublicModerator) {
                    var oldUserId = connection.userid;
                    connection.userid = connection.sessionid = localUserid || connection.sessionid;
                    connection.userid += '';

                    connection.isInitiator = true;

                    connectSocket(function () {
                        connection.socket.emit('changed-uuid', connection.userid);

                        if (isPublicModerator == true) {
                            connection.becomePublicModerator();
                        }
                    });

                    if (isData(connection.session)) {
                        if (typeof isPublicModerator === 'function') {
                            isPublicModerator();
                        }
                        return;
                    }

                    connection.captureUserMedia(typeof isPublicModerator === 'function' ? isPublicModerator : null);
                };

                connection.becomePublicModerator = function () {
                    if (!connection.isInitiator) return;
                    connection.socket.emit('become-a-public-moderator');
                };

                connection.dontMakeMeModerator = function () {
                    connection.socket.emit('dont-make-me-moderator');
                };

                connection.deletePeer = function (remoteUserId) {
                    if (!remoteUserId) {
                        return;
                    }

                    var eventObject = {
                        userid: remoteUserId,
                        extra: connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {}
                    };

                    if (connection.peersBackup[eventObject.userid]) {
                        eventObject.extra = connection.peersBackup[eventObject.userid].extra;
                    }

                    connection.onleave(eventObject);

                    if (!!connection.peers[remoteUserId]) {
                        connection.peers[remoteUserId].streams.forEach(function (stream) {
                            stream.stop();
                        });

                        var peer = connection.peers[remoteUserId].peer;
                        if (peer && peer.iceConnectionState !== 'closed') {
                            try {
                                peer.close();
                            } catch (e) {}
                        }

                        if (connection.peers[remoteUserId]) {
                            connection.peers[remoteUserId].peer = null;
                            delete connection.peers[remoteUserId];
                        }
                    }

                    if (connection.broadcasters.indexOf(remoteUserId) !== -1) {
                        var newArray = [];
                        connection.broadcasters.forEach(function (broadcaster) {
                            if (broadcaster !== remoteUserId) {
                                newArray.push(broadcaster);
                            }
                        });
                        connection.broadcasters = newArray;
                        keepNextBroadcasterOnServer();
                    }
                };

                connection.rejoin = function (connectionDescription) {
                    if (connection.isInitiator || !connectionDescription || !Object.keys(connectionDescription).length) {
                        return;
                    }

                    var extra = {};

                    if (connection.peers[connectionDescription.remoteUserId]) {
                        extra = connection.peers[connectionDescription.remoteUserId].extra;
                        connection.deletePeer(connectionDescription.remoteUserId);
                    }

                    if (connectionDescription && connectionDescription.remoteUserId) {
                        connection.join(connectionDescription.remoteUserId);

                        connection.onReConnecting({
                            userid: connectionDescription.remoteUserId,
                            extra: extra
                        });
                    }
                };

                connection.join = connection.connect = function (remoteUserId, options) {
                    connection.sessionid = (remoteUserId ? remoteUserId.sessionid || remoteUserId.remoteUserId || remoteUserId : false) || connection.sessionid;
                    connection.sessionid += '';

                    var localPeerSdpConstraints = false;
                    var remotePeerSdpConstraints = false;
                    var isOneWay = false;
                    var isDataOnly = false;

                    if (remoteUserId && remoteUserId.session || !remoteUserId || typeof remoteUserId === 'string') {
                        var session = remoteUserId ? remoteUserId.session || connection.session : connection.session;

                        isOneWay = !!session.oneway;
                        isDataOnly = isData(session);

                        remotePeerSdpConstraints = {
                            OfferToReceiveAudio: connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                            OfferToReceiveVideo: connection.sdpConstraints.mandatory.OfferToReceiveVideo
                        };

                        localPeerSdpConstraints = {
                            OfferToReceiveAudio: isOneWay ? !!connection.session.audio : connection.sdpConstraints.mandatory.OfferToReceiveAudio,
                            OfferToReceiveVideo: isOneWay ? !!connection.session.video || !!connection.session.screen : connection.sdpConstraints.mandatory.OfferToReceiveVideo
                        };
                    }

                    options = options || {};

                    var cb = function () {};
                    if (typeof options === 'function') {
                        cb = options;
                        options = {};
                    }

                    if (typeof options.localPeerSdpConstraints !== 'undefined') {
                        localPeerSdpConstraints = options.localPeerSdpConstraints;
                    }

                    if (typeof options.remotePeerSdpConstraints !== 'undefined') {
                        remotePeerSdpConstraints = options.remotePeerSdpConstraints;
                    }

                    if (typeof options.isOneWay !== 'undefined') {
                        isOneWay = options.isOneWay;
                    }

                    if (typeof options.isDataOnly !== 'undefined') {
                        isDataOnly = options.isDataOnly;
                    }

                    var connectionDescription = {
                        remoteUserId: connection.sessionid,
                        message: {
                            newParticipationRequest: true,
                            isOneWay: isOneWay,
                            isDataOnly: isDataOnly,
                            localPeerSdpConstraints: localPeerSdpConstraints,
                            remotePeerSdpConstraints: remotePeerSdpConstraints
                        },
                        sender: connection.userid,
                        password: false
                    };

                    beforeJoin(connectionDescription.message, function () {
                        connectSocket(function () {
                            if (!!connection.peers[connection.sessionid]) {
                                // on socket disconnect & reconnect
                                return;
                            }

                            mPeer.onNegotiationNeeded(connectionDescription);
                            cb();
                        });
                    });
                    return connectionDescription;
                };

                function beforeJoin(userPreferences, callback) {
                    if (connection.dontCaptureUserMedia || userPreferences.isDataOnly) {
                        callback();
                        return;
                    }

                    var localMediaConstraints = {};

                    if (userPreferences.localPeerSdpConstraints.OfferToReceiveAudio) {
                        localMediaConstraints.audio = connection.mediaConstraints.audio;
                    }

                    if (userPreferences.localPeerSdpConstraints.OfferToReceiveVideo) {
                        localMediaConstraints.video = connection.mediaConstraints.video;
                    }

                    var session = userPreferences.session || connection.session;

                    if (session.oneway && session.audio !== 'two-way' && session.video !== 'two-way' && session.screen !== 'two-way') {
                        callback();
                        return;
                    }

                    if (session.oneway && session.audio && session.audio === 'two-way') {
                        session = {
                            audio: true
                        };
                    }

                    if (session.audio || session.video || session.screen) {
                        if (session.screen) {
                            connection.getScreenConstraints(function (error, screen_constraints) {
                                connection.invokeGetUserMedia({
                                    audio: isAudioPlusTab(connection) ? getAudioScreenConstraints(screen_constraints) : false,
                                    video: screen_constraints,
                                    isScreen: true
                                }, (session.audio || session.video) && !isAudioPlusTab(connection) ? connection.invokeGetUserMedia(null, callback) : callback);
                            });
                        } else if (session.audio || session.video) {
                            connection.invokeGetUserMedia(null, callback, session);
                        }
                    }
                }

                connection.connectWithAllParticipants = function (remoteUserId) {
                    mPeer.onNegotiationNeeded('connectWithAllParticipants', remoteUserId || connection.sessionid);
                };

                connection.removeFromBroadcastersList = function (remoteUserId) {
                    mPeer.onNegotiationNeeded('removeFromBroadcastersList', remoteUserId || connection.sessionid);

                    connection.peers.getAllParticipants(remoteUserId || connection.sessionid).forEach(function (participant) {
                        mPeer.onNegotiationNeeded('dropPeerConnection', participant);
                        connection.deletePeer(participant);
                    });

                    connection.attachStreams.forEach(function (stream) {
                        stream.stop();
                    });
                };

                connection.getUserMedia = connection.captureUserMedia = function (callback, sessionForced) {
                    callback = callback || function () {};
                    var session = sessionForced || connection.session;

                    if (connection.dontCaptureUserMedia || isData(session)) {
                        callback();
                        return;
                    }

                    if (session.audio || session.video || session.screen) {
                        if (session.screen) {
                            connection.getScreenConstraints(function (error, screen_constraints) {
                                if (error) {
                                    throw error;
                                }

                                connection.invokeGetUserMedia({
                                    audio: isAudioPlusTab(connection) ? getAudioScreenConstraints(screen_constraints) : false,
                                    video: screen_constraints,
                                    isScreen: true
                                }, function (stream) {
                                    if ((session.audio || session.video) && !isAudioPlusTab(connection)) {
                                        var nonScreenSession = {};
                                        for (var s in session) {
                                            if (s !== 'screen') {
                                                nonScreenSession[s] = session[s];
                                            }
                                        }
                                        connection.invokeGetUserMedia(sessionForced, callback, nonScreenSession);
                                        return;
                                    }
                                    callback(stream);
                                });
                            });
                        } else if (session.audio || session.video) {
                            connection.invokeGetUserMedia(sessionForced, callback, session);
                        }
                    }
                };

                function beforeUnload(shiftModerationControlOnLeave, dontCloseSocket) {
                    if (!connection.closeBeforeUnload) {
                        return;
                    }

                    if (connection.isInitiator === true) {
                        connection.dontMakeMeModerator();
                    }

                    connection.peers.getAllParticipants().forEach(function (participant) {
                        mPeer.onNegotiationNeeded({
                            userLeft: true
                        }, participant);

                        if (connection.peers[participant] && connection.peers[participant].peer) {
                            connection.peers[participant].peer.close();
                        }

                        delete connection.peers[participant];
                    });

                    if (!dontCloseSocket) {
                        connection.closeSocket();
                    }

                    connection.broadcasters = [];
                    connection.isInitiator = false;
                }

                connection.closeBeforeUnload = true;
                window.addEventListener('beforeunload', beforeUnload, false);

                connection.userid = getRandomString();
                connection.changeUserId = function (newUserId, callback) {
                    callback = callback || function () {};
                    connection.userid = newUserId || getRandomString();
                    connection.socket.emit('changed-uuid', connection.userid, callback);
                };

                connection.extra = {};
                connection.attachStreams = [];

                connection.session = {
                    audio: true,
                    video: true
                };

                connection.enableFileSharing = false;

                // all values in kbps
                connection.bandwidth = {
                    screen: 512,
                    audio: 128,
                    video: 512
                };

                connection.codecs = {
                    audio: 'opus',
                    video: 'VP9'
                };

                connection.processSdp = function (sdp) {
                    if (isMobileDevice || isFirefox) {
                        return sdp;
                    }

                    sdp = CodecsHandler.setApplicationSpecificBandwidth(sdp, connection.bandwidth, !!connection.session.screen);
                    sdp = CodecsHandler.setVideoBitrates(sdp, {
                        min: connection.bandwidth.video * 8 * 1024,
                        max: connection.bandwidth.video * 8 * 1024
                    });
                    sdp = CodecsHandler.setOpusAttributes(sdp, {
                        maxaveragebitrate: connection.bandwidth.audio * 8 * 1024,
                        maxplaybackrate: connection.bandwidth.audio * 8 * 1024,
                        stereo: 1,
                        maxptime: 3
                    });

                    if (connection.codecs.video === 'VP9') {
                        sdp = CodecsHandler.preferVP9(sdp);
                    }

                    if (connection.codecs.video === 'H264') {
                        sdp = CodecsHandler.removeVPX(sdp);
                    }

                    if (connection.codecs.audio === 'G722') {
                        sdp = CodecsHandler.removeNonG722(sdp);
                    }

                    return sdp;
                };

                if (typeof CodecsHandler !== 'undefined') {
                    connection.BandwidthHandler = connection.CodecsHandler = CodecsHandler;
                }

                connection.mediaConstraints = {
                    audio: {
                        mandatory: {},
                        optional: [{
                            bandwidth: connection.bandwidth.audio * 8 * 1024 || 128 * 8 * 1024
                        }]
                    },
                    video: {
                        mandatory: {},
                        optional: [{
                            bandwidth: connection.bandwidth.video * 8 * 1024 || 128 * 8 * 1024
                        }, {
                            facingMode: 'user'
                        }]
                    }
                };

                if (isFirefox) {
                    connection.mediaConstraints = {
                        audio: true,
                        video: true
                    };
                }

                if (!forceOptions.useDefaultDevices && !isMobileDevice) {
                    DetectRTC.load(function () {
                        var lastAudioDevice, lastVideoDevice;
                        // it will force RTCMultiConnection to capture last-devices
                        // i.e. if external microphone is attached to system, we should prefer it over built-in devices.
                        DetectRTC.MediaDevices.forEach(function (device) {
                            if (device.kind === 'audioinput' && connection.mediaConstraints.audio !== false) {
                                lastAudioDevice = device;
                            }

                            if (device.kind === 'videoinput' && connection.mediaConstraints.video !== false) {
                                lastVideoDevice = device;
                            }
                        });

                        if (lastAudioDevice) {
                            if (isFirefox) {
                                if (connection.mediaConstraints.audio !== true) {
                                    connection.mediaConstraints.audio.deviceId = lastAudioDevice.id;
                                } else {
                                    connection.mediaConstraints.audio = {
                                        deviceId: lastAudioDevice.id
                                    };
                                }
                                return;
                            }

                            if (connection.mediaConstraints.audio == true) {
                                connection.mediaConstraints.audio = {
                                    mandatory: {},
                                    optional: []
                                };
                            }

                            if (!connection.mediaConstraints.audio.optional) {
                                connection.mediaConstraints.audio.optional = [];
                            }

                            var optional = [{
                                sourceId: lastAudioDevice.id
                            }];

                            connection.mediaConstraints.audio.optional = optional.concat(connection.mediaConstraints.audio.optional);
                        }

                        if (lastVideoDevice) {
                            if (isFirefox) {
                                if (connection.mediaConstraints.video !== true) {
                                    connection.mediaConstraints.video.deviceId = lastVideoDevice.id;
                                } else {
                                    connection.mediaConstraints.video = {
                                        deviceId: lastVideoDevice.id
                                    };
                                }
                                return;
                            }

                            if (connection.mediaConstraints.video == true) {
                                connection.mediaConstraints.video = {
                                    mandatory: {},
                                    optional: []
                                };
                            }

                            if (!connection.mediaConstraints.video.optional) {
                                connection.mediaConstraints.video.optional = [];
                            }

                            var optional = [{
                                sourceId: lastVideoDevice.id
                            }];

                            connection.mediaConstraints.video.optional = optional.concat(connection.mediaConstraints.video.optional);
                        }
                    });
                }

                connection.sdpConstraints = {
                    mandatory: {
                        OfferToReceiveAudio: true,
                        OfferToReceiveVideo: true
                    },
                    optional: [{
                        VoiceActivityDetection: false
                    }]
                };

                connection.rtcpMuxPolicy = 'negotiate'; // or "required"
                connection.iceTransportPolicy = null; // "relay" or "all"
                connection.optionalArgument = {
                    optional: [{
                        DtlsSrtpKeyAgreement: true
                    }, {
                        googImprovedWifiBwe: true
                    }, {
                        googScreencastMinBitrate: 300
                    }, {
                        googIPv6: true
                    }, {
                        googDscp: true
                    }, {
                        googCpuUnderuseThreshold: 55
                    }, {
                        googCpuOveruseThreshold: 85
                    }, {
                        googSuspendBelowMinBitrate: true
                    }, {
                        googCpuOveruseDetection: true
                    }],
                    mandatory: {}
                };

                connection.iceServers = IceServersHandler.getIceServers(connection);

                connection.candidates = {
                    host: true,
                    stun: true,
                    turn: true
                };

                connection.iceProtocols = {
                    tcp: true,
                    udp: true
                };

                // EVENTs
                connection.onopen = function (event) {
                    if (!!connection.enableLogs) {
                        console.info('Data connection has been opened between you & ', event.userid);
                    }
                };

                connection.onclose = function (event) {
                    if (!!connection.enableLogs) {
                        console.warn('Data connection has been closed between you & ', event.userid);
                    }
                };

                connection.onerror = function (error) {
                    if (!!connection.enableLogs) {
                        console.error(error.userid, 'data-error', error);
                    }
                };

                connection.onmessage = function (event) {
                    if (!!connection.enableLogs) {
                        console.debug('data-message', event.userid, event.data);
                    }
                };

                connection.send = function (data, remoteUserId) {
                    connection.peers.send(data, remoteUserId);
                };

                connection.close = connection.disconnect = connection.leave = function () {
                    beforeUnload(false, true);
                };

                connection.closeEntireSession = function (callback) {
                    callback = callback || function () {};
                    connection.socket.emit('close-entire-session', function looper() {
                        if (connection.getAllParticipants().length) {
                            setTimeout(looper, 100);
                            return;
                        }

                        connection.onEntireSessionClosed({
                            sessionid: connection.sessionid,
                            userid: connection.userid,
                            extra: connection.extra
                        });

                        connection.changeUserId(null, function () {
                            connection.close();
                            callback();
                        });
                    });
                };

                connection.onEntireSessionClosed = function (event) {
                    if (!connection.enableLogs) return;
                    console.info('Entire session is closed: ', event.sessionid, event.extra);
                };

                connection.onstream = function (e) {
                    var parentNode = connection.videosContainer;
                    parentNode.insertBefore(e.mediaElement, parentNode.firstChild);
                    e.mediaElement.play();
                    setTimeout(function () {
                        e.mediaElement.play();
                    }, 5000);
                };

                connection.onstreamended = function (e) {
                    if (!e.mediaElement) {
                        e.mediaElement = document.getElementById(e.streamid);
                    }

                    if (!e.mediaElement || !e.mediaElement.parentNode) {
                        return;
                    }

                    e.mediaElement.parentNode.removeChild(e.mediaElement);
                };

                connection.direction = 'many-to-many';

                connection.removeStream = function (streamid, remoteUserId) {
                    var stream;
                    connection.attachStreams.forEach(function (localStream) {
                        if (localStream.id === streamid) {
                            stream = localStream;
                        }
                    });

                    if (!stream) {
                        console.warn('No such stream exist.', streamid);
                        return;
                    }

                    connection.peers.getAllParticipants().forEach(function (participant) {
                        if (remoteUserId && participant !== remoteUserId) {
                            return;
                        }

                        var user = connection.peers[participant];
                        try {
                            user.peer.removeStream(stream);
                        } catch (e) {}
                    });

                    connection.renegotiate();
                };

                connection.addStream = function (session, remoteUserId) {
                    if (!!session.getAudioTracks) {
                        if (connection.attachStreams.indexOf(session) === -1) {
                            if (!session.streamid) {
                                session.streamid = session.id;
                            }

                            connection.attachStreams.push(session);
                        }
                        connection.renegotiate(remoteUserId);
                        return;
                    }

                    if (isData(session)) {
                        connection.renegotiate(remoteUserId);
                        return;
                    }

                    if (session.audio || session.video || session.screen) {
                        if (session.screen) {
                            connection.getScreenConstraints(function (error, screen_constraints) {
                                if (error) {
                                    if (error === 'PermissionDeniedError') {
                                        if (session.streamCallback) {
                                            session.streamCallback(null);
                                        }
                                        if (connection.enableLogs) {
                                            console.error('User rejected to share his screen.');
                                        }
                                        return;
                                    }
                                    return alert(error);
                                }

                                connection.invokeGetUserMedia({
                                    audio: isAudioPlusTab(connection) ? getAudioScreenConstraints(screen_constraints) : false,
                                    video: screen_constraints,
                                    isScreen: true
                                }, (session.audio || session.video) && !isAudioPlusTab(connection) ? connection.invokeGetUserMedia(null, gumCallback) : gumCallback);
                            });
                        } else if (session.audio || session.video) {
                            connection.invokeGetUserMedia(null, gumCallback);
                        }
                    }

                    function gumCallback(stream) {
                        if (session.streamCallback) {
                            session.streamCallback(stream);
                        }

                        connection.renegotiate(remoteUserId);
                    }
                };

                connection.invokeGetUserMedia = function (localMediaConstraints, callback, session) {
                    if (!session) {
                        session = connection.session;
                    }

                    if (!localMediaConstraints) {
                        localMediaConstraints = connection.mediaConstraints;
                    }

                    getUserMediaHandler({
                        onGettingLocalMedia: function (stream) {
                            var videoConstraints = localMediaConstraints.video;
                            if (videoConstraints) {
                                if (videoConstraints.mediaSource || videoConstraints.mozMediaSource) {
                                    stream.isScreen = true;
                                } else if (videoConstraints.mandatory && videoConstraints.mandatory.chromeMediaSource) {
                                    stream.isScreen = true;
                                }
                            }

                            if (!stream.isScreen) {
                                stream.isVideo = stream.getVideoTracks().length;
                                stream.isAudio = !stream.isVideo && stream.getAudioTracks().length;
                            }

                            mPeer.onGettingLocalMedia(stream);

                            if (callback) {
                                callback(stream);
                            }
                        },
                        onLocalMediaError: function (error, constraints) {
                            mPeer.onLocalMediaError(error, constraints);
                        },
                        localMediaConstraints: localMediaConstraints || {
                            audio: session.audio ? localMediaConstraints.audio : false,
                            video: session.video ? localMediaConstraints.video : false
                        }
                    });
                };

                function applyConstraints(stream, mediaConstraints) {
                    if (!stream) {
                        if (!!connection.enableLogs) {
                            console.error('No stream to applyConstraints.');
                        }
                        return;
                    }

                    if (mediaConstraints.audio) {
                        stream.getAudioTracks().forEach(function (track) {
                            track.applyConstraints(mediaConstraints.audio);
                        });
                    }

                    if (mediaConstraints.video) {
                        stream.getVideoTracks().forEach(function (track) {
                            track.applyConstraints(mediaConstraints.video);
                        });
                    }
                }

                connection.applyConstraints = function (mediaConstraints, streamid) {
                    if (!MediaStreamTrack || !MediaStreamTrack.prototype.applyConstraints) {
                        alert('track.applyConstraints is NOT supported in your browser.');
                        return;
                    }

                    if (streamid) {
                        var stream;
                        if (connection.streamEvents[streamid]) {
                            stream = connection.streamEvents[streamid].stream;
                        }
                        applyConstraints(stream, mediaConstraints);
                        return;
                    }

                    connection.attachStreams.forEach(function (stream) {
                        applyConstraints(stream, mediaConstraints);
                    });
                };

                function replaceTrack(track, remoteUserId, isVideoTrack) {
                    if (remoteUserId) {
                        mPeer.replaceTrack(track, remoteUserId, isVideoTrack);
                        return;
                    }

                    connection.peers.getAllParticipants().forEach(function (participant) {
                        mPeer.replaceTrack(track, participant, isVideoTrack);
                    });
                }

                connection.replaceTrack = function (session, remoteUserId, isVideoTrack) {
                    session = session || {};

                    if (!RTCPeerConnection.prototype.getSenders) {
                        connection.addStream(session);
                        return;
                    }

                    if (session instanceof MediaStreamTrack) {
                        replaceTrack(session, remoteUserId, isVideoTrack);
                        return;
                    }

                    if (session instanceof MediaStream) {
                        if (session.getVideoTracks().length) {
                            replaceTrack(session.getVideoTracks()[0], remoteUserId, true);
                        }

                        if (session.getAudioTracks().length) {
                            replaceTrack(session.getAudioTracks()[0], remoteUserId, false);
                        }
                        return;
                    }

                    if (isData(session)) {
                        throw 'connection.replaceTrack requires audio and/or video and/or screen.';
                        return;
                    }

                    if (session.audio || session.video || session.screen) {
                        if (session.screen) {
                            connection.getScreenConstraints(function (error, screen_constraints) {
                                if (error) {
                                    return alert(error);
                                }

                                connection.invokeGetUserMedia({
                                    audio: isAudioPlusTab(connection) ? getAudioScreenConstraints(screen_constraints) : false,
                                    video: screen_constraints,
                                    isScreen: true
                                }, (session.audio || session.video) && !isAudioPlusTab(connection) ? connection.invokeGetUserMedia(null, gumCallback) : gumCallback);
                            });
                        } else if (session.audio || session.video) {
                            connection.invokeGetUserMedia(null, gumCallback);
                        }
                    }

                    function gumCallback(stream) {
                        connection.replaceTrack(stream, remoteUserId, isVideoTrack || session.video || session.screen);
                    }
                };

                connection.resetTrack = function (remoteUsersIds, isVideoTrack) {
                    if (!remoteUsersIds) {
                        remoteUsersIds = connection.getAllParticipants();
                    }

                    if (typeof remoteUsersIds == 'string') {
                        remoteUsersIds = [remoteUsersIds];
                    }

                    remoteUsersIds.forEach(function (participant) {
                        var peer = connection.peers[participant].peer;

                        if ((typeof isVideoTrack === 'undefined' || isVideoTrack === true) && peer.lastVideoTrack) {
                            connection.replaceTrack(peer.lastVideoTrack, participant, true);
                        }

                        if ((typeof isVideoTrack === 'undefined' || isVideoTrack === false) && peer.lastAudioTrack) {
                            connection.replaceTrack(peer.lastAudioTrack, participant, false);
                        }
                    });
                };

                connection.renegotiate = function (remoteUserId) {
                    if (remoteUserId) {
                        mPeer.renegotiatePeer(remoteUserId);
                        return;
                    }

                    connection.peers.getAllParticipants().forEach(function (participant) {
                        mPeer.renegotiatePeer(participant);
                    });
                };

                connection.setStreamEndHandler = function (stream, isRemote) {
                    if (!stream || !stream.addEventListener) return;

                    isRemote = !!isRemote;

                    if (stream.alreadySetEndHandler) {
                        return;
                    }
                    stream.alreadySetEndHandler = true;

                    var streamEndedEvent = 'ended';

                    if ('oninactive' in stream) {
                        streamEndedEvent = 'inactive';
                    }

                    stream.addEventListener(streamEndedEvent, function () {
                        if (stream.idInstance) {
                            currentUserMediaRequest.remove(stream.idInstance);
                        }

                        if (!isRemote) {
                            // reset attachStreams
                            var streams = [];
                            connection.attachStreams.forEach(function (s) {
                                if (s.id != stream.id) {
                                    streams.push(s);
                                }
                            });
                            connection.attachStreams = streams;
                        }

                        // connection.renegotiate();

                        var streamEvent = connection.streamEvents[stream.streamid];
                        if (!streamEvent) {
                            streamEvent = {
                                stream: stream,
                                streamid: stream.streamid,
                                type: isRemote ? 'remote' : 'local',
                                userid: connection.userid,
                                extra: connection.extra,
                                mediaElement: connection.streamEvents[stream.streamid] ? connection.streamEvents[stream.streamid].mediaElement : null
                            };
                        }

                        if (isRemote && connection.peers[streamEvent.userid]) {
                            // reset remote "streams"
                            var peer = connection.peers[streamEvent.userid].peer;
                            var streams = [];
                            peer.getRemoteStreams().forEach(function (s) {
                                if (s.id != stream.id) {
                                    streams.push(s);
                                }
                            });
                            connection.peers[streamEvent.userid].streams = streams;
                        }

                        if (streamEvent.userid === connection.userid && streamEvent.type === 'remote') {
                            return;
                        }

                        if (connection.peersBackup[streamEvent.userid]) {
                            streamEvent.extra = connection.peersBackup[streamEvent.userid].extra;
                        }

                        connection.onstreamended(streamEvent);

                        delete connection.streamEvents[stream.streamid];
                    }, false);
                };

                connection.onMediaError = function (error, constraints) {
                    if (!!connection.enableLogs) {
                        console.error(error, constraints);
                    }
                };

                connection.addNewBroadcaster = function (broadcasterId, userPreferences) {
                    if (connection.socket.isIO) {
                        return;
                    }

                    if (connection.broadcasters.length) {
                        setTimeout(function () {
                            mPeer.connectNewParticipantWithAllBroadcasters(broadcasterId, userPreferences, connection.broadcasters.join('|-,-|'));
                        }, 10 * 1000);
                    }

                    if (!connection.session.oneway && !connection.session.broadcast && connection.direction === 'many-to-many' && connection.broadcasters.indexOf(broadcasterId) === -1) {
                        connection.broadcasters.push(broadcasterId);
                        keepNextBroadcasterOnServer();
                    }
                };

                connection.autoCloseEntireSession = false;

                function keepNextBroadcasterOnServer() {
                    if (!connection.isInitiator) return;

                    if (connection.session.oneway || connection.session.broadcast || connection.direction !== 'many-to-many') {
                        return;
                    }

                    var firstBroadcaster = connection.broadcasters[0];
                    var otherBroadcasters = [];
                    connection.broadcasters.forEach(function (broadcaster) {
                        if (broadcaster !== firstBroadcaster) {
                            otherBroadcasters.push(broadcaster);
                        }
                    });

                    if (connection.autoCloseEntireSession) return;
                    connection.shiftModerationControl(firstBroadcaster, otherBroadcasters, true);
                };

                connection.filesContainer = connection.videosContainer = document.body || document.documentElement;
                connection.isInitiator = false;

                connection.shareFile = mPeer.shareFile;
                if (typeof FileProgressBarHandler !== 'undefined') {
                    FileProgressBarHandler.handle(connection);
                }

                if (typeof TranslationHandler !== 'undefined') {
                    TranslationHandler.handle(connection);
                }

                connection.token = getRandomString;

                connection.onNewParticipant = function (participantId, userPreferences) {
                    connection.acceptParticipationRequest(participantId, userPreferences);
                };

                connection.acceptParticipationRequest = function (participantId, userPreferences) {
                    if (userPreferences.successCallback) {
                        userPreferences.successCallback();
                        delete userPreferences.successCallback;
                    }

                    mPeer.createNewPeer(participantId, userPreferences);
                };

                connection.onShiftedModerationControl = function (sender, existingBroadcasters) {
                    connection.acceptModerationControl(sender, existingBroadcasters);
                };

                connection.acceptModerationControl = function (sender, existingBroadcasters) {
                    connection.isInitiator = true; // NEW initiator!

                    connection.broadcasters = existingBroadcasters;
                    connection.peers.getAllParticipants().forEach(function (participant) {
                        mPeer.onNegotiationNeeded({
                            changedUUID: sender,
                            oldUUID: connection.userid,
                            newUUID: sender
                        }, participant);
                    });
                    connection.userid = sender;
                    connection.changeUserId(connection.userid);
                };

                connection.shiftModerationControl = function (remoteUserId, existingBroadcasters, firedOnLeave) {
                    mPeer.onNegotiationNeeded({
                        shiftedModerationControl: true,
                        broadcasters: existingBroadcasters,
                        firedOnLeave: !!firedOnLeave
                    }, remoteUserId);
                };

                if (typeof StreamsHandler !== 'undefined') {
                    connection.StreamsHandler = StreamsHandler;
                }

                connection.onleave = function (userid) {};

                connection.invokeSelectFileDialog = function (callback) {
                    var selector = new FileSelector();
                    selector.accept = '*.*';
                    selector.selectSingleFile(callback);
                };

                connection.getPublicModerators = function (userIdStartsWith, callback) {
                    if (typeof userIdStartsWith === 'function') {
                        callback = userIdStartsWith;
                    }

                    connectSocket(function () {
                        connection.socket.emit('get-public-moderators', typeof userIdStartsWith === 'string' ? userIdStartsWith : '', callback);
                    });
                };

                connection.onmute = function (e) {
                    if (!e || !e.mediaElement) {
                        return;
                    }

                    if (e.muteType === 'both' || e.muteType === 'video') {
                        e.mediaElement.src = null;
                        e.mediaElement.pause();
                        e.mediaElement.poster = e.snapshot || 'https://cdn.webrtc-experiment.com/images/muted.png';
                    } else if (e.muteType === 'audio') {
                        e.mediaElement.muted = true;
                    }
                };

                connection.onunmute = function (e) {
                    if (!e || !e.mediaElement || !e.stream) {
                        return;
                    }

                    if (e.unmuteType === 'both' || e.unmuteType === 'video') {
                        e.mediaElement.poster = null;
                        e.mediaElement.src = URL.createObjectURL(e.stream);
                        e.mediaElement.play();
                    } else if (e.unmuteType === 'audio') {
                        e.mediaElement.muted = false;
                    }
                };

                connection.onExtraDataUpdated = function (event) {
                    event.status = 'online';
                    connection.onUserStatusChanged(event, true);
                };

                connection.onJoinWithPassword = function (remoteUserId) {
                    console.warn(remoteUserId, 'is password protected. Please join with password.');
                };

                connection.onInvalidPassword = function (remoteUserId, oldPassword) {
                    console.warn(remoteUserId, 'is password protected. Please join with valid password. Your old password', oldPassword, 'is wrong.');
                };

                connection.onPasswordMaxTriesOver = function (remoteUserId) {
                    console.warn(remoteUserId, 'is password protected. Your max password tries exceeded the limit.');
                };

                connection.getAllParticipants = function (sender) {
                    return connection.peers.getAllParticipants(sender);
                };

                if (typeof StreamsHandler !== 'undefined') {
                    StreamsHandler.onSyncNeeded = function (streamid, action, type) {
                        connection.peers.getAllParticipants().forEach(function (participant) {
                            mPeer.onNegotiationNeeded({
                                streamid: streamid,
                                action: action,
                                streamSyncNeeded: true,
                                type: type || 'both'
                            }, participant);
                        });
                    };
                }

                connection.connectSocket = function (callback) {
                    connectSocket(callback);
                };

                connection.closeSocket = function () {
                    try {
                        io.sockets = {};
                    } catch (e) {};

                    if (!connection.socket) return;

                    if (typeof connection.socket.disconnect === 'function') {
                        connection.socket.disconnect();
                    }

                    if (typeof connection.socket.resetProps === 'function') {
                        connection.socket.resetProps();
                    }

                    connection.socket = null;
                };

                connection.getSocket = function (callback) {
                    if (!connection.socket) {
                        connectSocket(callback);
                    } else if (callback) {
                        callback(connection.socket);
                    }

                    return connection.socket;
                };

                connection.getRemoteStreams = mPeer.getRemoteStreams;

                var skipStreams = ['selectFirst', 'selectAll', 'forEach'];

                connection.streamEvents = {
                    selectFirst: function (options) {
                        if (!options) {
                            // in normal conferencing, it will always be "local-stream"
                            var firstStream;
                            for (var str in connection.streamEvents) {
                                if (skipStreams.indexOf(str) === -1 && !firstStream) {
                                    firstStream = connection.streamEvents[str];
                                    continue;
                                }
                            }
                            return firstStream;
                        }
                    },
                    selectAll: function () {}
                };

                connection.socketURL = '/'; // generated via config.json
                connection.socketMessageEvent = 'RTCMultiConnection-Message'; // generated via config.json
                connection.socketCustomEvent = 'RTCMultiConnection-Custom-Message'; // generated via config.json
                connection.DetectRTC = DetectRTC;

                connection.setCustomSocketEvent = function (customEvent) {
                    if (customEvent) {
                        connection.socketCustomEvent = customEvent;
                    }

                    if (!connection.socket) {
                        return;
                    }

                    connection.socket.emit('set-custom-socket-event-listener', connection.socketCustomEvent);
                };

                connection.getNumberOfBroadcastViewers = function (broadcastId, callback) {
                    if (!connection.socket || !broadcastId || !callback) return;

                    connection.socket.emit('get-number-of-users-in-specific-broadcast', broadcastId, callback);
                };

                connection.onNumberOfBroadcastViewersUpdated = function (event) {
                    if (!connection.enableLogs || !connection.isInitiator) return;
                    console.info('Number of broadcast (', event.broadcastId, ') viewers', event.numberOfBroadcastViewers);
                };

                connection.onUserStatusChanged = function (event, dontWriteLogs) {
                    if (!!connection.enableLogs && !dontWriteLogs) {
                        console.info(event.userid, event.status);
                    }
                };

                connection.getUserMediaHandler = getUserMediaHandler;
                connection.multiPeersHandler = mPeer;
                connection.enableLogs = true;
                connection.setCustomSocketHandler = function (customSocketHandler) {
                    if (typeof SocketConnection !== 'undefined') {
                        SocketConnection = customSocketHandler;
                    }
                };

                // default value is 15k because Firefox's receiving limit is 16k!
                // however 64k works chrome-to-chrome
                connection.chunkSize = 65 * 1000;

                connection.maxParticipantsAllowed = 1000;

                // eject or leave single user
                connection.disconnectWith = mPeer.disconnectWith;

                connection.checkPresence = function (remoteUserId, callback) {
                    if (!connection.socket) {
                        connection.connectSocket(function () {
                            connection.checkPresence(remoteUserId, callback);
                        });
                        return;
                    }
                    connection.socket.emit('check-presence', (remoteUserId || connection.sessionid) + '', callback);
                };

                connection.onReadyForOffer = function (remoteUserId, userPreferences) {
                    connection.multiPeersHandler.createNewPeer(remoteUserId, userPreferences);
                };

                connection.setUserPreferences = function (userPreferences) {
                    if (connection.dontAttachStream) {
                        userPreferences.dontAttachLocalStream = true;
                    }

                    if (connection.dontGetRemoteStream) {
                        userPreferences.dontGetRemoteStream = true;
                    }

                    return userPreferences;
                };

                connection.updateExtraData = function () {
                    connection.socket.emit('extra-data-updated', connection.extra);
                };

                connection.enableScalableBroadcast = false;
                connection.maxRelayLimitPerUser = 3; // each broadcast should serve only 3 users

                connection.dontCaptureUserMedia = false;
                connection.dontAttachStream = false;
                connection.dontGetRemoteStream = false;

                connection.onReConnecting = function (event) {
                    if (connection.enableLogs) {
                        console.info('ReConnecting with', event.userid, '...');
                    }
                };

                connection.beforeAddingStream = function (stream) {
                    return stream;
                };

                connection.beforeRemovingStream = function (stream) {
                    return stream;
                };

                if (typeof isChromeExtensionAvailable !== 'undefined') {
                    connection.checkIfChromeExtensionAvailable = isChromeExtensionAvailable;
                }

                if (typeof isFirefoxExtensionAvailable !== 'undefined') {
                    connection.checkIfChromeExtensionAvailable = isFirefoxExtensionAvailable;
                }

                if (typeof getChromeExtensionStatus !== 'undefined') {
                    connection.getChromeExtensionStatus = getChromeExtensionStatus;
                }

                connection.getScreenConstraints = function (callback, audioPlusTab) {
                    if (isAudioPlusTab(connection, audioPlusTab)) {
                        audioPlusTab = true;
                    }

                    getScreenConstraints(function (error, screen_constraints) {
                        if (!error) {
                            screen_constraints = connection.modifyScreenConstraints(screen_constraints);
                            callback(error, screen_constraints);
                        }
                    }, audioPlusTab);
                };

                connection.modifyScreenConstraints = function (screen_constraints) {
                    return screen_constraints;
                };

                connection.onPeerStateChanged = function (state) {
                    if (connection.enableLogs) {
                        if (state.iceConnectionState.search(/closed|failed/gi) !== -1) {
                            console.error('Peer connection is closed between you & ', state.userid, state.extra, 'state:', state.iceConnectionState);
                        }
                    }
                };

                connection.isOnline = true;

                listenEventHandler('online', function () {
                    connection.isOnline = true;
                });

                listenEventHandler('offline', function () {
                    connection.isOnline = false;
                });

                connection.isLowBandwidth = false;
                if (navigator && navigator.connection && navigator.connection.type) {
                    connection.isLowBandwidth = navigator.connection.type.toString().toLowerCase().search(/wifi|cell/g) !== -1;
                    if (connection.isLowBandwidth) {
                        connection.bandwidth = {
                            audio: 30,
                            video: 30,
                            screen: 30
                        };

                        if (connection.mediaConstraints.audio && connection.mediaConstraints.audio.optional && connection.mediaConstraints.audio.optional.length) {
                            var newArray = [];
                            connection.mediaConstraints.audio.optional.forEach(function (opt) {
                                if (typeof opt.bandwidth === 'undefined') {
                                    newArray.push(opt);
                                }
                            });
                            connection.mediaConstraints.audio.optional = newArray;
                        }

                        if (connection.mediaConstraints.video && connection.mediaConstraints.video.optional && connection.mediaConstraints.video.optional.length) {
                            var newArray = [];
                            connection.mediaConstraints.video.optional.forEach(function (opt) {
                                if (typeof opt.bandwidth === 'undefined') {
                                    newArray.push(opt);
                                }
                            });
                            connection.mediaConstraints.video.optional = newArray;
                        }
                    }
                }

                connection.getExtraData = function (remoteUserId) {
                    if (!remoteUserId) throw 'remoteUserId is required.';
                    if (!connection.peers[remoteUserId]) return {};
                    return connection.peers[remoteUserId].extra;
                };

                if (!!forceOptions.autoOpenOrJoin) {
                    connection.openOrJoin(connection.sessionid);
                }

                connection.onUserIdAlreadyTaken = function (useridAlreadyTaken, yourNewUserId) {
                    if (connection.enableLogs) {
                        console.warn('Userid already taken.', useridAlreadyTaken, 'Your new userid:', yourNewUserId);
                    }

                    connection.join(useridAlreadyTaken);
                };

                connection.onRoomFull = function (roomid) {
                    if (connection.enableLogs) {
                        console.warn(roomid, 'is full.');
                    }
                };

                connection.trickleIce = true;
                connection.version = '3.4.4';

                connection.onSettingLocalDescription = function (event) {
                    if (connection.enableLogs) {
                        console.info('Set local description for remote user', event.userid);
                    }
                };

                connection.oneRoomAlreadyExist = function (roomid) {
                    if (connection.enableLogs) {
                        console.info('Server says "Room ', roomid, 'already exist. Joining instead.');
                    }
                    connection.join(roomid);
                };
            })(this);
        };
    })(this);

    return _retrieveGlobal();
});
(function() {
var define = $__System.amdDefine;
(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd)
    define("1f", [], factory);
  else if (typeof exports === 'object')
    exports["io"] = factory();
  else
    root["io"] = factory();
})(this, function() {
  return (function(modules) {
    var installedModules = {};
    function __webpack_require__(moduleId) {
      if (installedModules[moduleId])
        return installedModules[moduleId].exports;
      var module = installedModules[moduleId] = {
        exports: {},
        id: moduleId,
        loaded: false
      };
      modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
      module.loaded = true;
      return module.exports;
    }
    __webpack_require__.m = modules;
    __webpack_require__.c = installedModules;
    __webpack_require__.p = "";
    return __webpack_require__(0);
  })([function(module, exports, __webpack_require__) {
    'use strict';
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var url = __webpack_require__(1);
    var parser = __webpack_require__(7);
    var Manager = __webpack_require__(17);
    var debug = __webpack_require__(3)('socket.io-client');
    module.exports = exports = lookup;
    var cache = exports.managers = {};
    function lookup(uri, opts) {
      if ((typeof uri === 'undefined' ? 'undefined' : _typeof(uri)) === 'object') {
        opts = uri;
        uri = undefined;
      }
      opts = opts || {};
      var parsed = url(uri);
      var source = parsed.source;
      var id = parsed.id;
      var path = parsed.path;
      var sameNamespace = cache[id] && path in cache[id].nsps;
      var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace;
      var io;
      if (newConnection) {
        debug('ignoring socket cache for %s', source);
        io = Manager(source, opts);
      } else {
        if (!cache[id]) {
          debug('new io instance for %s', source);
          cache[id] = Manager(source, opts);
        }
        io = cache[id];
      }
      if (parsed.query && !opts.query) {
        opts.query = parsed.query;
      } else if (opts && 'object' === _typeof(opts.query)) {
        opts.query = encodeQueryString(opts.query);
      }
      return io.socket(parsed.path, opts);
    }
    function encodeQueryString(obj) {
      var str = [];
      for (var p in obj) {
        if (obj.hasOwnProperty(p)) {
          str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));
        }
      }
      return str.join('&');
    }
    exports.protocol = parser.protocol;
    exports.connect = lookup;
    exports.Manager = __webpack_require__(17);
    exports.Socket = __webpack_require__(44);
  }, function(module, exports, __webpack_require__) {
    (function(global) {
      'use strict';
      var parseuri = __webpack_require__(2);
      var debug = __webpack_require__(3)('socket.io-client:url');
      module.exports = url;
      function url(uri, loc) {
        var obj = uri;
        loc = loc || global.location;
        if (null == uri)
          uri = loc.protocol + '//' + loc.host;
        if ('string' === typeof uri) {
          if ('/' === uri.charAt(0)) {
            if ('/' === uri.charAt(1)) {
              uri = loc.protocol + uri;
            } else {
              uri = loc.host + uri;
            }
          }
          if (!/^(https?|wss?):\/\//.test(uri)) {
            debug('protocol-less url %s', uri);
            if ('undefined' !== typeof loc) {
              uri = loc.protocol + '//' + uri;
            } else {
              uri = 'https://' + uri;
            }
          }
          debug('parse %s', uri);
          obj = parseuri(uri);
        }
        if (!obj.port) {
          if (/^(http|ws)$/.test(obj.protocol)) {
            obj.port = '80';
          } else if (/^(http|ws)s$/.test(obj.protocol)) {
            obj.port = '443';
          }
        }
        obj.path = obj.path || '/';
        var ipv6 = obj.host.indexOf(':') !== -1;
        var host = ipv6 ? '[' + obj.host + ']' : obj.host;
        obj.id = obj.protocol + '://' + host + ':' + obj.port;
        obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : ':' + obj.port);
        return obj;
      }
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports) {
    var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
    var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
    module.exports = function parseuri(str) {
      var src = str,
          b = str.indexOf('['),
          e = str.indexOf(']');
      if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
      }
      var m = re.exec(str || ''),
          uri = {},
          i = 14;
      while (i--) {
        uri[parts[i]] = m[i] || '';
      }
      if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
      }
      return uri;
    };
  }, function(module, exports, __webpack_require__) {
    (function(process) {
      exports = module.exports = __webpack_require__(5);
      exports.log = log;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
      exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
      function useColors() {
        return (typeof document !== 'undefined' && 'WebkitAppearance' in document.documentElement.style) || (window.console && (console.firebug || (console.exception && console.table))) || (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
      }
      exports.formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (err) {
          return '[UnexpectedJSONParseError]: ' + err.message;
        }
      };
      function formatArgs() {
        var args = arguments;
        var useColors = this.useColors;
        args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
        if (!useColors)
          return args;
        var c = 'color: ' + this.color;
        args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
        var index = 0;
        var lastC = 0;
        args[0].replace(/%[a-z%]/g, function(match) {
          if ('%%' === match)
            return;
          index++;
          if ('%c' === match) {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
        return args;
      }
      function log() {
        return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
      }
      function save(namespaces) {
        try {
          if (null == namespaces) {
            exports.storage.removeItem('debug');
          } else {
            exports.storage.debug = namespaces;
          }
        } catch (e) {}
      }
      function load() {
        var r;
        try {
          return exports.storage.debug;
        } catch (e) {}
        if (typeof process !== 'undefined' && 'env' in process) {
          return process.env.DEBUG;
        }
      }
      exports.enable(load());
      function localstorage() {
        try {
          return window.localStorage;
        } catch (e) {}
      }
    }.call(exports, __webpack_require__(4)));
  }, function(module, exports) {
    var process = module.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout() {
      throw new Error('clearTimeout has not been defined');
    }
    (function() {
      try {
        if (typeof setTimeout === 'function') {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === 'function') {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    }());
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = '';
    process.versions = {};
    function noop() {}
    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.binding = function(name) {
      throw new Error('process.binding is not supported');
    };
    process.cwd = function() {
      return '/';
    };
    process.chdir = function(dir) {
      throw new Error('process.chdir is not supported');
    };
    process.umask = function() {
      return 0;
    };
  }, function(module, exports, __webpack_require__) {
    exports = module.exports = debug.debug = debug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = __webpack_require__(6);
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevColor = 0;
    var prevTime;
    function selectColor() {
      return exports.colors[prevColor++ % exports.colors.length];
    }
    function debug(namespace) {
      function disabled() {}
      disabled.enabled = false;
      function enabled() {
        var self = enabled;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        if (null == self.useColors)
          self.useColors = exports.useColors();
        if (null == self.color && self.useColors)
          self.color = selectColor();
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if ('string' !== typeof args[0]) {
          args = ['%o'].concat(args);
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
          if (match === '%%')
            return match;
          index++;
          var formatter = exports.formatters[format];
          if ('function' === typeof formatter) {
            var val = args[index];
            match = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        args = exports.formatArgs.apply(self, args);
        var logFn = enabled.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }
      enabled.enabled = true;
      var fn = exports.enabled(namespace) ? enabled : disabled;
      fn.namespace = namespace;
      return fn;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      var split = (namespaces || '').split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/[\\^$+?.()|[\]{}]/g, '\\$&').replace(/\*/g, '.*?');
        if (namespaces[0] === '-') {
          exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          exports.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
    }
    function disable() {
      exports.enable('');
    }
    function enabled(name) {
      var i,
          len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }, function(module, exports) {
    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === 'string' && val.length > 0) {
        return parse(val);
      } else if (type === 'number' && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 10000) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
        default:
          return undefined;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + 'd';
      }
      if (ms >= h) {
        return Math.round(ms / h) + 'h';
      }
      if (ms >= m) {
        return Math.round(ms / m) + 'm';
      }
      if (ms >= s) {
        return Math.round(ms / s) + 's';
      }
      return ms + 'ms';
    }
    function fmtLong(ms) {
      return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + ' ' + name;
      }
      return Math.ceil(ms / n) + ' ' + name + 's';
    }
  }, function(module, exports, __webpack_require__) {
    var debug = __webpack_require__(8)('socket.io-parser');
    var json = __webpack_require__(11);
    var Emitter = __webpack_require__(13);
    var binary = __webpack_require__(14);
    var isBuf = __webpack_require__(16);
    exports.protocol = 4;
    exports.types = ['CONNECT', 'DISCONNECT', 'EVENT', 'ACK', 'ERROR', 'BINARY_EVENT', 'BINARY_ACK'];
    exports.CONNECT = 0;
    exports.DISCONNECT = 1;
    exports.EVENT = 2;
    exports.ACK = 3;
    exports.ERROR = 4;
    exports.BINARY_EVENT = 5;
    exports.BINARY_ACK = 6;
    exports.Encoder = Encoder;
    exports.Decoder = Decoder;
    function Encoder() {}
    Encoder.prototype.encode = function(obj, callback) {
      debug('encoding packet %j', obj);
      if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
        encodeAsBinary(obj, callback);
      } else {
        var encoding = encodeAsString(obj);
        callback([encoding]);
      }
    };
    function encodeAsString(obj) {
      var str = '';
      var nsp = false;
      str += obj.type;
      if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
        str += obj.attachments;
        str += '-';
      }
      if (obj.nsp && '/' != obj.nsp) {
        nsp = true;
        str += obj.nsp;
      }
      if (null != obj.id) {
        if (nsp) {
          str += ',';
          nsp = false;
        }
        str += obj.id;
      }
      if (null != obj.data) {
        if (nsp)
          str += ',';
        str += json.stringify(obj.data);
      }
      debug('encoded %j as %s', obj, str);
      return str;
    }
    function encodeAsBinary(obj, callback) {
      function writeEncoding(bloblessData) {
        var deconstruction = binary.deconstructPacket(bloblessData);
        var pack = encodeAsString(deconstruction.packet);
        var buffers = deconstruction.buffers;
        buffers.unshift(pack);
        callback(buffers);
      }
      binary.removeBlobs(obj, writeEncoding);
    }
    function Decoder() {
      this.reconstructor = null;
    }
    Emitter(Decoder.prototype);
    Decoder.prototype.add = function(obj) {
      var packet;
      if ('string' == typeof obj) {
        packet = decodeString(obj);
        if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) {
          this.reconstructor = new BinaryReconstructor(packet);
          if (this.reconstructor.reconPack.attachments === 0) {
            this.emit('decoded', packet);
          }
        } else {
          this.emit('decoded', packet);
        }
      } else if (isBuf(obj) || obj.base64) {
        if (!this.reconstructor) {
          throw new Error('got binary data when not reconstructing a packet');
        } else {
          packet = this.reconstructor.takeBinaryData(obj);
          if (packet) {
            this.reconstructor = null;
            this.emit('decoded', packet);
          }
        }
      } else {
        throw new Error('Unknown type: ' + obj);
      }
    };
    function decodeString(str) {
      var p = {};
      var i = 0;
      p.type = Number(str.charAt(0));
      if (null == exports.types[p.type])
        return error();
      if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
        var buf = '';
        while (str.charAt(++i) != '-') {
          buf += str.charAt(i);
          if (i == str.length)
            break;
        }
        if (buf != Number(buf) || str.charAt(i) != '-') {
          throw new Error('Illegal attachments');
        }
        p.attachments = Number(buf);
      }
      if ('/' == str.charAt(i + 1)) {
        p.nsp = '';
        while (++i) {
          var c = str.charAt(i);
          if (',' == c)
            break;
          p.nsp += c;
          if (i == str.length)
            break;
        }
      } else {
        p.nsp = '/';
      }
      var next = str.charAt(i + 1);
      if ('' !== next && Number(next) == next) {
        p.id = '';
        while (++i) {
          var c = str.charAt(i);
          if (null == c || Number(c) != c) {
            --i;
            break;
          }
          p.id += str.charAt(i);
          if (i == str.length)
            break;
        }
        p.id = Number(p.id);
      }
      if (str.charAt(++i)) {
        p = tryParse(p, str.substr(i));
      }
      debug('decoded %s as %j', str, p);
      return p;
    }
    function tryParse(p, str) {
      try {
        p.data = json.parse(str);
      } catch (e) {
        return error();
      }
      return p;
    }
    ;
    Decoder.prototype.destroy = function() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
      }
    };
    function BinaryReconstructor(packet) {
      this.reconPack = packet;
      this.buffers = [];
    }
    BinaryReconstructor.prototype.takeBinaryData = function(binData) {
      this.buffers.push(binData);
      if (this.buffers.length == this.reconPack.attachments) {
        var packet = binary.reconstructPacket(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }
      return null;
    };
    BinaryReconstructor.prototype.finishedReconstruction = function() {
      this.reconPack = null;
      this.buffers = [];
    };
    function error(data) {
      return {
        type: exports.ERROR,
        data: 'parser error'
      };
    }
  }, function(module, exports, __webpack_require__) {
    exports = module.exports = __webpack_require__(9);
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
    function useColors() {
      return ('WebkitAppearance' in document.documentElement.style) || (window.console && (console.firebug || (console.exception && console.table))) || (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
    }
    exports.formatters.j = function(v) {
      return JSON.stringify(v);
    };
    function formatArgs() {
      var args = arguments;
      var useColors = this.useColors;
      args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
      if (!useColors)
        return args;
      var c = 'color: ' + this.color;
      args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-z%]/g, function(match) {
        if ('%%' === match)
          return;
        index++;
        if ('%c' === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
      return args;
    }
    function log() {
      return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem('debug');
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {}
    }
    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {}
      return r;
    }
    exports.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {}
    }
  }, function(module, exports, __webpack_require__) {
    exports = module.exports = debug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = __webpack_require__(10);
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevColor = 0;
    var prevTime;
    function selectColor() {
      return exports.colors[prevColor++ % exports.colors.length];
    }
    function debug(namespace) {
      function disabled() {}
      disabled.enabled = false;
      function enabled() {
        var self = enabled;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        if (null == self.useColors)
          self.useColors = exports.useColors();
        if (null == self.color && self.useColors)
          self.color = selectColor();
        var args = Array.prototype.slice.call(arguments);
        args[0] = exports.coerce(args[0]);
        if ('string' !== typeof args[0]) {
          args = ['%o'].concat(args);
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
          if (match === '%%')
            return match;
          index++;
          var formatter = exports.formatters[format];
          if ('function' === typeof formatter) {
            var val = args[index];
            match = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        if ('function' === typeof exports.formatArgs) {
          args = exports.formatArgs.apply(self, args);
        }
        var logFn = enabled.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }
      enabled.enabled = true;
      var fn = exports.enabled(namespace) ? enabled : disabled;
      fn.namespace = namespace;
      return fn;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      var split = (namespaces || '').split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, '.*?');
        if (namespaces[0] === '-') {
          exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          exports.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
    }
    function disable() {
      exports.enable('');
    }
    function enabled(name) {
      var i,
          len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }, function(module, exports) {
    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      if ('string' == typeof val)
        return parse(val);
      return options.long ? long(val) : short(val);
    };
    function parse(str) {
      str = '' + str;
      if (str.length > 10000)
        return;
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match)
        return;
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
      }
    }
    function short(ms) {
      if (ms >= d)
        return Math.round(ms / d) + 'd';
      if (ms >= h)
        return Math.round(ms / h) + 'h';
      if (ms >= m)
        return Math.round(ms / m) + 'm';
      if (ms >= s)
        return Math.round(ms / s) + 's';
      return ms + 'ms';
    }
    function long(ms) {
      return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
    }
    function plural(ms, n, name) {
      if (ms < n)
        return;
      if (ms < n * 1.5)
        return Math.floor(ms / n) + ' ' + name;
      return Math.ceil(ms / n) + ' ' + name + 's';
    }
  }, function(module, exports, __webpack_require__) {
    (function(module, global) {
      var define = false;
      ;
      (function() {
        var isLoader = typeof define === "function" && define.amd;
        var objectTypes = {
          "function": true,
          "object": true
        };
        var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
        var root = objectTypes[typeof window] && window || this,
            freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;
        if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
          root = freeGlobal;
        }
        function runInContext(context, exports) {
          context || (context = root["Object"]());
          exports || (exports = root["Object"]());
          var Number = context["Number"] || root["Number"],
              String = context["String"] || root["String"],
              Object = context["Object"] || root["Object"],
              Date = context["Date"] || root["Date"],
              SyntaxError = context["SyntaxError"] || root["SyntaxError"],
              TypeError = context["TypeError"] || root["TypeError"],
              Math = context["Math"] || root["Math"],
              nativeJSON = context["JSON"] || root["JSON"];
          if (typeof nativeJSON == "object" && nativeJSON) {
            exports.stringify = nativeJSON.stringify;
            exports.parse = nativeJSON.parse;
          }
          var objectProto = Object.prototype,
              getClass = objectProto.toString,
              isProperty,
              forEach,
              undef;
          var isExtended = new Date(-3509827334573292);
          try {
            isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 && isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
          } catch (exception) {}
          function has(name) {
            if (has[name] !== undef) {
              return has[name];
            }
            var isSupported;
            if (name == "bug-string-char-index") {
              isSupported = "a"[0] != "a";
            } else if (name == "json") {
              isSupported = has("json-stringify") && has("json-parse");
            } else {
              var value,
                  serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
              if (name == "json-stringify") {
                var stringify = exports.stringify,
                    stringifySupported = typeof stringify == "function" && isExtended;
                if (stringifySupported) {
                  (value = function() {
                    return 1;
                  }).toJSON = value;
                  try {
                    stringifySupported = stringify(0) === "0" && stringify(new Number()) === "0" && stringify(new String()) == '""' && stringify(getClass) === undef && stringify(undef) === undef && stringify() === undef && stringify(value) === "1" && stringify([value]) == "[1]" && stringify([undef]) == "[null]" && stringify(null) == "null" && stringify([undef, getClass, null]) == "[null,null,null]" && stringify({"a": [value, true, false, null, "\x00\b\n\f\r\t"]}) == serialized && stringify(null, value) === "1" && stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" && stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' && stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' && stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' && stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
                  } catch (exception) {
                    stringifySupported = false;
                  }
                }
                isSupported = stringifySupported;
              }
              if (name == "json-parse") {
                var parse = exports.parse;
                if (typeof parse == "function") {
                  try {
                    if (parse("0") === 0 && !parse(false)) {
                      value = parse(serialized);
                      var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                      if (parseSupported) {
                        try {
                          parseSupported = !parse('"\t"');
                        } catch (exception) {}
                        if (parseSupported) {
                          try {
                            parseSupported = parse("01") !== 1;
                          } catch (exception) {}
                        }
                        if (parseSupported) {
                          try {
                            parseSupported = parse("1.") !== 1;
                          } catch (exception) {}
                        }
                      }
                    }
                  } catch (exception) {
                    parseSupported = false;
                  }
                }
                isSupported = parseSupported;
              }
            }
            return has[name] = !!isSupported;
          }
          if (!has("json")) {
            var functionClass = "[object Function]",
                dateClass = "[object Date]",
                numberClass = "[object Number]",
                stringClass = "[object String]",
                arrayClass = "[object Array]",
                booleanClass = "[object Boolean]";
            var charIndexBuggy = has("bug-string-char-index");
            if (!isExtended) {
              var floor = Math.floor;
              var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
              var getDay = function(year, month) {
                return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
              };
            }
            if (!(isProperty = objectProto.hasOwnProperty)) {
              isProperty = function(property) {
                var members = {},
                    constructor;
                if ((members.__proto__ = null, members.__proto__ = {"toString": 1}, members).toString != getClass) {
                  isProperty = function(property) {
                    var original = this.__proto__,
                        result = property in (this.__proto__ = null, this);
                    this.__proto__ = original;
                    return result;
                  };
                } else {
                  constructor = members.constructor;
                  isProperty = function(property) {
                    var parent = (this.constructor || constructor).prototype;
                    return property in this && !(property in parent && this[property] === parent[property]);
                  };
                }
                members = null;
                return isProperty.call(this, property);
              };
            }
            forEach = function(object, callback) {
              var size = 0,
                  Properties,
                  members,
                  property;
              (Properties = function() {
                this.valueOf = 0;
              }).prototype.valueOf = 0;
              members = new Properties();
              for (property in members) {
                if (isProperty.call(members, property)) {
                  size++;
                }
              }
              Properties = members = null;
              if (!size) {
                members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
                forEach = function(object, callback) {
                  var isFunction = getClass.call(object) == functionClass,
                      property,
                      length;
                  var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
                  for (property in object) {
                    if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                      callback(property);
                    }
                  }
                  for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property))
                    ;
                };
              } else if (size == 2) {
                forEach = function(object, callback) {
                  var members = {},
                      isFunction = getClass.call(object) == functionClass,
                      property;
                  for (property in object) {
                    if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                      callback(property);
                    }
                  }
                };
              } else {
                forEach = function(object, callback) {
                  var isFunction = getClass.call(object) == functionClass,
                      property,
                      isConstructor;
                  for (property in object) {
                    if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                      callback(property);
                    }
                  }
                  if (isConstructor || isProperty.call(object, (property = "constructor"))) {
                    callback(property);
                  }
                };
              }
              return forEach(object, callback);
            };
            if (!has("json-stringify")) {
              var Escapes = {
                92: "\\\\",
                34: '\\"',
                8: "\\b",
                12: "\\f",
                10: "\\n",
                13: "\\r",
                9: "\\t"
              };
              var leadingZeroes = "000000";
              var toPaddedString = function(width, value) {
                return (leadingZeroes + (value || 0)).slice(-width);
              };
              var unicodePrefix = "\\u00";
              var quote = function(value) {
                var result = '"',
                    index = 0,
                    length = value.length,
                    useCharIndex = !charIndexBuggy || length > 10;
                var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
                for (; index < length; index++) {
                  var charCode = value.charCodeAt(index);
                  switch (charCode) {
                    case 8:
                    case 9:
                    case 10:
                    case 12:
                    case 13:
                    case 34:
                    case 92:
                      result += Escapes[charCode];
                      break;
                    default:
                      if (charCode < 32) {
                        result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                        break;
                      }
                      result += useCharIndex ? symbols[index] : value.charAt(index);
                  }
                }
                return result + '"';
              };
              var serialize = function(property, object, callback, properties, whitespace, indentation, stack) {
                var value,
                    className,
                    year,
                    month,
                    date,
                    time,
                    hours,
                    minutes,
                    seconds,
                    milliseconds,
                    results,
                    element,
                    index,
                    length,
                    prefix,
                    result;
                try {
                  value = object[property];
                } catch (exception) {}
                if (typeof value == "object" && value) {
                  className = getClass.call(value);
                  if (className == dateClass && !isProperty.call(value, "toJSON")) {
                    if (value > -1 / 0 && value < 1 / 0) {
                      if (getDay) {
                        date = floor(value / 864e5);
                        for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++)
                          ;
                        for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++)
                          ;
                        date = 1 + date - getDay(year, month);
                        time = (value % 864e5 + 864e5) % 864e5;
                        hours = floor(time / 36e5) % 24;
                        minutes = floor(time / 6e4) % 60;
                        seconds = floor(time / 1e3) % 60;
                        milliseconds = time % 1e3;
                      } else {
                        year = value.getUTCFullYear();
                        month = value.getUTCMonth();
                        date = value.getUTCDate();
                        hours = value.getUTCHours();
                        minutes = value.getUTCMinutes();
                        seconds = value.getUTCSeconds();
                        milliseconds = value.getUTCMilliseconds();
                      }
                      value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) + "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) + "." + toPaddedString(3, milliseconds) + "Z";
                    } else {
                      value = null;
                    }
                  } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
                    value = value.toJSON(property);
                  }
                }
                if (callback) {
                  value = callback.call(object, property, value);
                }
                if (value === null) {
                  return "null";
                }
                className = getClass.call(value);
                if (className == booleanClass) {
                  return "" + value;
                } else if (className == numberClass) {
                  return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
                } else if (className == stringClass) {
                  return quote("" + value);
                }
                if (typeof value == "object") {
                  for (length = stack.length; length--; ) {
                    if (stack[length] === value) {
                      throw TypeError();
                    }
                  }
                  stack.push(value);
                  results = [];
                  prefix = indentation;
                  indentation += whitespace;
                  if (className == arrayClass) {
                    for (index = 0, length = value.length; index < length; index++) {
                      element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                      results.push(element === undef ? "null" : element);
                    }
                    result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
                  } else {
                    forEach(properties || value, function(property) {
                      var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                      if (element !== undef) {
                        results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                      }
                    });
                    result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
                  }
                  stack.pop();
                  return result;
                }
              };
              exports.stringify = function(source, filter, width) {
                var whitespace,
                    callback,
                    properties,
                    className;
                if (objectTypes[typeof filter] && filter) {
                  if ((className = getClass.call(filter)) == functionClass) {
                    callback = filter;
                  } else if (className == arrayClass) {
                    properties = {};
                    for (var index = 0,
                        length = filter.length,
                        value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1))
                      ;
                  }
                }
                if (width) {
                  if ((className = getClass.call(width)) == numberClass) {
                    if ((width -= width % 1) > 0) {
                      for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ")
                        ;
                    }
                  } else if (className == stringClass) {
                    whitespace = width.length <= 10 ? width : width.slice(0, 10);
                  }
                }
                return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
              };
            }
            if (!has("json-parse")) {
              var fromCharCode = String.fromCharCode;
              var Unescapes = {
                92: "\\",
                34: '"',
                47: "/",
                98: "\b",
                116: "\t",
                110: "\n",
                102: "\f",
                114: "\r"
              };
              var Index,
                  Source;
              var abort = function() {
                Index = Source = null;
                throw SyntaxError();
              };
              var lex = function() {
                var source = Source,
                    length = source.length,
                    value,
                    begin,
                    position,
                    isSigned,
                    charCode;
                while (Index < length) {
                  charCode = source.charCodeAt(Index);
                  switch (charCode) {
                    case 9:
                    case 10:
                    case 13:
                    case 32:
                      Index++;
                      break;
                    case 123:
                    case 125:
                    case 91:
                    case 93:
                    case 58:
                    case 44:
                      value = charIndexBuggy ? source.charAt(Index) : source[Index];
                      Index++;
                      return value;
                    case 34:
                      for (value = "@", Index++; Index < length; ) {
                        charCode = source.charCodeAt(Index);
                        if (charCode < 32) {
                          abort();
                        } else if (charCode == 92) {
                          charCode = source.charCodeAt(++Index);
                          switch (charCode) {
                            case 92:
                            case 34:
                            case 47:
                            case 98:
                            case 116:
                            case 110:
                            case 102:
                            case 114:
                              value += Unescapes[charCode];
                              Index++;
                              break;
                            case 117:
                              begin = ++Index;
                              for (position = Index + 4; Index < position; Index++) {
                                charCode = source.charCodeAt(Index);
                                if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                                  abort();
                                }
                              }
                              value += fromCharCode("0x" + source.slice(begin, Index));
                              break;
                            default:
                              abort();
                          }
                        } else {
                          if (charCode == 34) {
                            break;
                          }
                          charCode = source.charCodeAt(Index);
                          begin = Index;
                          while (charCode >= 32 && charCode != 92 && charCode != 34) {
                            charCode = source.charCodeAt(++Index);
                          }
                          value += source.slice(begin, Index);
                        }
                      }
                      if (source.charCodeAt(Index) == 34) {
                        Index++;
                        return value;
                      }
                      abort();
                    default:
                      begin = Index;
                      if (charCode == 45) {
                        isSigned = true;
                        charCode = source.charCodeAt(++Index);
                      }
                      if (charCode >= 48 && charCode <= 57) {
                        if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                          abort();
                        }
                        isSigned = false;
                        for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++)
                          ;
                        if (source.charCodeAt(Index) == 46) {
                          position = ++Index;
                          for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++)
                            ;
                          if (position == Index) {
                            abort();
                          }
                          Index = position;
                        }
                        charCode = source.charCodeAt(Index);
                        if (charCode == 101 || charCode == 69) {
                          charCode = source.charCodeAt(++Index);
                          if (charCode == 43 || charCode == 45) {
                            Index++;
                          }
                          for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++)
                            ;
                          if (position == Index) {
                            abort();
                          }
                          Index = position;
                        }
                        return +source.slice(begin, Index);
                      }
                      if (isSigned) {
                        abort();
                      }
                      if (source.slice(Index, Index + 4) == "true") {
                        Index += 4;
                        return true;
                      } else if (source.slice(Index, Index + 5) == "false") {
                        Index += 5;
                        return false;
                      } else if (source.slice(Index, Index + 4) == "null") {
                        Index += 4;
                        return null;
                      }
                      abort();
                  }
                }
                return "$";
              };
              var get = function(value) {
                var results,
                    hasMembers;
                if (value == "$") {
                  abort();
                }
                if (typeof value == "string") {
                  if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
                    return value.slice(1);
                  }
                  if (value == "[") {
                    results = [];
                    for (; ; hasMembers || (hasMembers = true)) {
                      value = lex();
                      if (value == "]") {
                        break;
                      }
                      if (hasMembers) {
                        if (value == ",") {
                          value = lex();
                          if (value == "]") {
                            abort();
                          }
                        } else {
                          abort();
                        }
                      }
                      if (value == ",") {
                        abort();
                      }
                      results.push(get(value));
                    }
                    return results;
                  } else if (value == "{") {
                    results = {};
                    for (; ; hasMembers || (hasMembers = true)) {
                      value = lex();
                      if (value == "}") {
                        break;
                      }
                      if (hasMembers) {
                        if (value == ",") {
                          value = lex();
                          if (value == "}") {
                            abort();
                          }
                        } else {
                          abort();
                        }
                      }
                      if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                        abort();
                      }
                      results[value.slice(1)] = get(lex());
                    }
                    return results;
                  }
                  abort();
                }
                return value;
              };
              var update = function(source, property, callback) {
                var element = walk(source, property, callback);
                if (element === undef) {
                  delete source[property];
                } else {
                  source[property] = element;
                }
              };
              var walk = function(source, property, callback) {
                var value = source[property],
                    length;
                if (typeof value == "object" && value) {
                  if (getClass.call(value) == arrayClass) {
                    for (length = value.length; length--; ) {
                      update(value, length, callback);
                    }
                  } else {
                    forEach(value, function(property) {
                      update(value, property, callback);
                    });
                  }
                }
                return callback.call(source, property, value);
              };
              exports.parse = function(source, callback) {
                var result,
                    value;
                Index = 0;
                Source = "" + source;
                result = get(lex());
                if (lex() != "$") {
                  abort();
                }
                Index = Source = null;
                return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
              };
            }
          }
          exports["runInContext"] = runInContext;
          return exports;
        }
        if (freeExports && !isLoader) {
          runInContext(root, freeExports);
        } else {
          var nativeJSON = root.JSON,
              previousJSON = root["JSON3"],
              isRestored = false;
          var JSON3 = runInContext(root, (root["JSON3"] = {"noConflict": function() {
              if (!isRestored) {
                isRestored = true;
                root.JSON = nativeJSON;
                root["JSON3"] = previousJSON;
                nativeJSON = previousJSON = null;
              }
              return JSON3;
            }}));
          root.JSON = {
            "parse": JSON3.parse,
            "stringify": JSON3.stringify
          };
        }
        if (isLoader) {
          define(function() {
            return JSON3;
          });
        }
      }).call(this);
    }.call(exports, __webpack_require__(12)(module), (function() {
      return this;
    }())));
  }, function(module, exports) {
    module.exports = function(module) {
      if (!module.webpackPolyfill) {
        module.deprecate = function() {};
        module.paths = [];
        module.children = [];
        module.webpackPolyfill = 1;
      }
      return module;
    };
  }, function(module, exports) {
    module.exports = Emitter;
    function Emitter(obj) {
      if (obj)
        return mixin(obj);
    }
    ;
    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }
    Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks[event] = this._callbacks[event] || []).push(fn);
      return this;
    };
    Emitter.prototype.once = function(event, fn) {
      var self = this;
      this._callbacks = this._callbacks || {};
      function on() {
        self.off(event, on);
        fn.apply(this, arguments);
      }
      on.fn = fn;
      this.on(event, on);
      return this;
    };
    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      }
      var callbacks = this._callbacks[event];
      if (!callbacks)
        return this;
      if (1 == arguments.length) {
        delete this._callbacks[event];
        return this;
      }
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      return this;
    };
    Emitter.prototype.emit = function(event) {
      this._callbacks = this._callbacks || {};
      var args = [].slice.call(arguments, 1),
          callbacks = this._callbacks[event];
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0,
            len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }
      return this;
    };
    Emitter.prototype.listeners = function(event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks[event] || [];
    };
    Emitter.prototype.hasListeners = function(event) {
      return !!this.listeners(event).length;
    };
  }, function(module, exports, __webpack_require__) {
    (function(global) {
      var isArray = __webpack_require__(15);
      var isBuf = __webpack_require__(16);
      exports.deconstructPacket = function(packet) {
        var buffers = [];
        var packetData = packet.data;
        function _deconstructPacket(data) {
          if (!data)
            return data;
          if (isBuf(data)) {
            var placeholder = {
              _placeholder: true,
              num: buffers.length
            };
            buffers.push(data);
            return placeholder;
          } else if (isArray(data)) {
            var newData = new Array(data.length);
            for (var i = 0; i < data.length; i++) {
              newData[i] = _deconstructPacket(data[i]);
            }
            return newData;
          } else if ('object' == typeof data && !(data instanceof Date)) {
            var newData = {};
            for (var key in data) {
              newData[key] = _deconstructPacket(data[key]);
            }
            return newData;
          }
          return data;
        }
        var pack = packet;
        pack.data = _deconstructPacket(packetData);
        pack.attachments = buffers.length;
        return {
          packet: pack,
          buffers: buffers
        };
      };
      exports.reconstructPacket = function(packet, buffers) {
        var curPlaceHolder = 0;
        function _reconstructPacket(data) {
          if (data && data._placeholder) {
            var buf = buffers[data.num];
            return buf;
          } else if (isArray(data)) {
            for (var i = 0; i < data.length; i++) {
              data[i] = _reconstructPacket(data[i]);
            }
            return data;
          } else if (data && 'object' == typeof data) {
            for (var key in data) {
              data[key] = _reconstructPacket(data[key]);
            }
            return data;
          }
          return data;
        }
        packet.data = _reconstructPacket(packet.data);
        packet.attachments = undefined;
        return packet;
      };
      exports.removeBlobs = function(data, callback) {
        function _removeBlobs(obj, curKey, containingObject) {
          if (!obj)
            return obj;
          if ((global.Blob && obj instanceof Blob) || (global.File && obj instanceof File)) {
            pendingBlobs++;
            var fileReader = new FileReader();
            fileReader.onload = function() {
              if (containingObject) {
                containingObject[curKey] = this.result;
              } else {
                bloblessData = this.result;
              }
              if (!--pendingBlobs) {
                callback(bloblessData);
              }
            };
            fileReader.readAsArrayBuffer(obj);
          } else if (isArray(obj)) {
            for (var i = 0; i < obj.length; i++) {
              _removeBlobs(obj[i], i, obj);
            }
          } else if (obj && 'object' == typeof obj && !isBuf(obj)) {
            for (var key in obj) {
              _removeBlobs(obj[key], key, obj);
            }
          }
        }
        var pendingBlobs = 0;
        var bloblessData = data;
        _removeBlobs(bloblessData);
        if (!pendingBlobs) {
          callback(bloblessData);
        }
      };
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports) {
    module.exports = Array.isArray || function(arr) {
      return Object.prototype.toString.call(arr) == '[object Array]';
    };
  }, function(module, exports) {
    (function(global) {
      module.exports = isBuf;
      function isBuf(obj) {
        return (global.Buffer && global.Buffer.isBuffer(obj)) || (global.ArrayBuffer && obj instanceof ArrayBuffer);
      }
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports, __webpack_require__) {
    'use strict';
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var eio = __webpack_require__(18);
    var Socket = __webpack_require__(44);
    var Emitter = __webpack_require__(35);
    var parser = __webpack_require__(7);
    var on = __webpack_require__(46);
    var bind = __webpack_require__(47);
    var debug = __webpack_require__(3)('socket.io-client:manager');
    var indexOf = __webpack_require__(42);
    var Backoff = __webpack_require__(48);
    var has = Object.prototype.hasOwnProperty;
    module.exports = Manager;
    function Manager(uri, opts) {
      if (!(this instanceof Manager))
        return new Manager(uri, opts);
      if (uri && 'object' === (typeof uri === 'undefined' ? 'undefined' : _typeof(uri))) {
        opts = uri;
        uri = undefined;
      }
      opts = opts || {};
      opts.path = opts.path || '/socket.io';
      this.nsps = {};
      this.subs = [];
      this.opts = opts;
      this.reconnection(opts.reconnection !== false);
      this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
      this.reconnectionDelay(opts.reconnectionDelay || 1000);
      this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
      this.randomizationFactor(opts.randomizationFactor || 0.5);
      this.backoff = new Backoff({
        min: this.reconnectionDelay(),
        max: this.reconnectionDelayMax(),
        jitter: this.randomizationFactor()
      });
      this.timeout(null == opts.timeout ? 20000 : opts.timeout);
      this.readyState = 'closed';
      this.uri = uri;
      this.connecting = [];
      this.lastPing = null;
      this.encoding = false;
      this.packetBuffer = [];
      this.encoder = new parser.Encoder();
      this.decoder = new parser.Decoder();
      this.autoConnect = opts.autoConnect !== false;
      if (this.autoConnect)
        this.open();
    }
    Manager.prototype.emitAll = function() {
      this.emit.apply(this, arguments);
      for (var nsp in this.nsps) {
        if (has.call(this.nsps, nsp)) {
          this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
        }
      }
    };
    Manager.prototype.updateSocketIds = function() {
      for (var nsp in this.nsps) {
        if (has.call(this.nsps, nsp)) {
          this.nsps[nsp].id = this.engine.id;
        }
      }
    };
    Emitter(Manager.prototype);
    Manager.prototype.reconnection = function(v) {
      if (!arguments.length)
        return this._reconnection;
      this._reconnection = !!v;
      return this;
    };
    Manager.prototype.reconnectionAttempts = function(v) {
      if (!arguments.length)
        return this._reconnectionAttempts;
      this._reconnectionAttempts = v;
      return this;
    };
    Manager.prototype.reconnectionDelay = function(v) {
      if (!arguments.length)
        return this._reconnectionDelay;
      this._reconnectionDelay = v;
      this.backoff && this.backoff.setMin(v);
      return this;
    };
    Manager.prototype.randomizationFactor = function(v) {
      if (!arguments.length)
        return this._randomizationFactor;
      this._randomizationFactor = v;
      this.backoff && this.backoff.setJitter(v);
      return this;
    };
    Manager.prototype.reconnectionDelayMax = function(v) {
      if (!arguments.length)
        return this._reconnectionDelayMax;
      this._reconnectionDelayMax = v;
      this.backoff && this.backoff.setMax(v);
      return this;
    };
    Manager.prototype.timeout = function(v) {
      if (!arguments.length)
        return this._timeout;
      this._timeout = v;
      return this;
    };
    Manager.prototype.maybeReconnectOnOpen = function() {
      if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
        this.reconnect();
      }
    };
    Manager.prototype.open = Manager.prototype.connect = function(fn, opts) {
      debug('readyState %s', this.readyState);
      if (~this.readyState.indexOf('open'))
        return this;
      debug('opening %s', this.uri);
      this.engine = eio(this.uri, this.opts);
      var socket = this.engine;
      var self = this;
      this.readyState = 'opening';
      this.skipReconnect = false;
      var openSub = on(socket, 'open', function() {
        self.onopen();
        fn && fn();
      });
      var errorSub = on(socket, 'error', function(data) {
        debug('connect_error');
        self.cleanup();
        self.readyState = 'closed';
        self.emitAll('connect_error', data);
        if (fn) {
          var err = new Error('Connection error');
          err.data = data;
          fn(err);
        } else {
          self.maybeReconnectOnOpen();
        }
      });
      if (false !== this._timeout) {
        var timeout = this._timeout;
        debug('connect attempt will timeout after %d', timeout);
        var timer = setTimeout(function() {
          debug('connect attempt timed out after %d', timeout);
          openSub.destroy();
          socket.close();
          socket.emit('error', 'timeout');
          self.emitAll('connect_timeout', timeout);
        }, timeout);
        this.subs.push({destroy: function destroy() {
            clearTimeout(timer);
          }});
      }
      this.subs.push(openSub);
      this.subs.push(errorSub);
      return this;
    };
    Manager.prototype.onopen = function() {
      debug('open');
      this.cleanup();
      this.readyState = 'open';
      this.emit('open');
      var socket = this.engine;
      this.subs.push(on(socket, 'data', bind(this, 'ondata')));
      this.subs.push(on(socket, 'ping', bind(this, 'onping')));
      this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
      this.subs.push(on(socket, 'error', bind(this, 'onerror')));
      this.subs.push(on(socket, 'close', bind(this, 'onclose')));
      this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
    };
    Manager.prototype.onping = function() {
      this.lastPing = new Date();
      this.emitAll('ping');
    };
    Manager.prototype.onpong = function() {
      this.emitAll('pong', new Date() - this.lastPing);
    };
    Manager.prototype.ondata = function(data) {
      this.decoder.add(data);
    };
    Manager.prototype.ondecoded = function(packet) {
      this.emit('packet', packet);
    };
    Manager.prototype.onerror = function(err) {
      debug('error', err);
      this.emitAll('error', err);
    };
    Manager.prototype.socket = function(nsp, opts) {
      var socket = this.nsps[nsp];
      if (!socket) {
        socket = new Socket(this, nsp, opts);
        this.nsps[nsp] = socket;
        var self = this;
        socket.on('connecting', onConnecting);
        socket.on('connect', function() {
          socket.id = self.engine.id;
        });
        if (this.autoConnect) {
          onConnecting();
        }
      }
      function onConnecting() {
        if (!~indexOf(self.connecting, socket)) {
          self.connecting.push(socket);
        }
      }
      return socket;
    };
    Manager.prototype.destroy = function(socket) {
      var index = indexOf(this.connecting, socket);
      if (~index)
        this.connecting.splice(index, 1);
      if (this.connecting.length)
        return;
      this.close();
    };
    Manager.prototype.packet = function(packet) {
      debug('writing packet %j', packet);
      var self = this;
      if (packet.query && packet.type === 0)
        packet.nsp += '?' + packet.query;
      if (!self.encoding) {
        self.encoding = true;
        this.encoder.encode(packet, function(encodedPackets) {
          for (var i = 0; i < encodedPackets.length; i++) {
            self.engine.write(encodedPackets[i], packet.options);
          }
          self.encoding = false;
          self.processPacketQueue();
        });
      } else {
        self.packetBuffer.push(packet);
      }
    };
    Manager.prototype.processPacketQueue = function() {
      if (this.packetBuffer.length > 0 && !this.encoding) {
        var pack = this.packetBuffer.shift();
        this.packet(pack);
      }
    };
    Manager.prototype.cleanup = function() {
      debug('cleanup');
      var subsLength = this.subs.length;
      for (var i = 0; i < subsLength; i++) {
        var sub = this.subs.shift();
        sub.destroy();
      }
      this.packetBuffer = [];
      this.encoding = false;
      this.lastPing = null;
      this.decoder.destroy();
    };
    Manager.prototype.close = Manager.prototype.disconnect = function() {
      debug('disconnect');
      this.skipReconnect = true;
      this.reconnecting = false;
      if ('opening' === this.readyState) {
        this.cleanup();
      }
      this.backoff.reset();
      this.readyState = 'closed';
      if (this.engine)
        this.engine.close();
    };
    Manager.prototype.onclose = function(reason) {
      debug('onclose');
      this.cleanup();
      this.backoff.reset();
      this.readyState = 'closed';
      this.emit('close', reason);
      if (this._reconnection && !this.skipReconnect) {
        this.reconnect();
      }
    };
    Manager.prototype.reconnect = function() {
      if (this.reconnecting || this.skipReconnect)
        return this;
      var self = this;
      if (this.backoff.attempts >= this._reconnectionAttempts) {
        debug('reconnect failed');
        this.backoff.reset();
        this.emitAll('reconnect_failed');
        this.reconnecting = false;
      } else {
        var delay = this.backoff.duration();
        debug('will wait %dms before reconnect attempt', delay);
        this.reconnecting = true;
        var timer = setTimeout(function() {
          if (self.skipReconnect)
            return;
          debug('attempting reconnect');
          self.emitAll('reconnect_attempt', self.backoff.attempts);
          self.emitAll('reconnecting', self.backoff.attempts);
          if (self.skipReconnect)
            return;
          self.open(function(err) {
            if (err) {
              debug('reconnect attempt error');
              self.reconnecting = false;
              self.reconnect();
              self.emitAll('reconnect_error', err.data);
            } else {
              debug('reconnect success');
              self.onreconnect();
            }
          });
        }, delay);
        this.subs.push({destroy: function destroy() {
            clearTimeout(timer);
          }});
      }
    };
    Manager.prototype.onreconnect = function() {
      var attempt = this.backoff.attempts;
      this.reconnecting = false;
      this.backoff.reset();
      this.updateSocketIds();
      this.emitAll('reconnect', attempt);
    };
  }, function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(19);
  }, function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(20);
    module.exports.parser = __webpack_require__(27);
  }, function(module, exports, __webpack_require__) {
    (function(global) {
      var transports = __webpack_require__(21);
      var Emitter = __webpack_require__(35);
      var debug = __webpack_require__(3)('engine.io-client:socket');
      var index = __webpack_require__(42);
      var parser = __webpack_require__(27);
      var parseuri = __webpack_require__(2);
      var parsejson = __webpack_require__(43);
      var parseqs = __webpack_require__(36);
      module.exports = Socket;
      function Socket(uri, opts) {
        if (!(this instanceof Socket))
          return new Socket(uri, opts);
        opts = opts || {};
        if (uri && 'object' === typeof uri) {
          opts = uri;
          uri = null;
        }
        if (uri) {
          uri = parseuri(uri);
          opts.hostname = uri.host;
          opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
          opts.port = uri.port;
          if (uri.query)
            opts.query = uri.query;
        } else if (opts.host) {
          opts.hostname = parseuri(opts.host).host;
        }
        this.secure = null != opts.secure ? opts.secure : (global.location && 'https:' === location.protocol);
        if (opts.hostname && !opts.port) {
          opts.port = this.secure ? '443' : '80';
        }
        this.agent = opts.agent || false;
        this.hostname = opts.hostname || (global.location ? location.hostname : 'localhost');
        this.port = opts.port || (global.location && location.port ? location.port : (this.secure ? 443 : 80));
        this.query = opts.query || {};
        if ('string' === typeof this.query)
          this.query = parseqs.decode(this.query);
        this.upgrade = false !== opts.upgrade;
        this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
        this.forceJSONP = !!opts.forceJSONP;
        this.jsonp = false !== opts.jsonp;
        this.forceBase64 = !!opts.forceBase64;
        this.enablesXDR = !!opts.enablesXDR;
        this.timestampParam = opts.timestampParam || 't';
        this.timestampRequests = opts.timestampRequests;
        this.transports = opts.transports || ['polling', 'websocket'];
        this.readyState = '';
        this.writeBuffer = [];
        this.prevBufferLen = 0;
        this.policyPort = opts.policyPort || 843;
        this.rememberUpgrade = opts.rememberUpgrade || false;
        this.binaryType = null;
        this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
        this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;
        if (true === this.perMessageDeflate)
          this.perMessageDeflate = {};
        if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
          this.perMessageDeflate.threshold = 1024;
        }
        this.pfx = opts.pfx || null;
        this.key = opts.key || null;
        this.passphrase = opts.passphrase || null;
        this.cert = opts.cert || null;
        this.ca = opts.ca || null;
        this.ciphers = opts.ciphers || null;
        this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? null : opts.rejectUnauthorized;
        this.forceNode = !!opts.forceNode;
        var freeGlobal = typeof global === 'object' && global;
        if (freeGlobal.global === freeGlobal) {
          if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
            this.extraHeaders = opts.extraHeaders;
          }
          if (opts.localAddress) {
            this.localAddress = opts.localAddress;
          }
        }
        this.id = null;
        this.upgrades = null;
        this.pingInterval = null;
        this.pingTimeout = null;
        this.pingIntervalTimer = null;
        this.pingTimeoutTimer = null;
        this.open();
      }
      Socket.priorWebsocketSuccess = false;
      Emitter(Socket.prototype);
      Socket.protocol = parser.protocol;
      Socket.Socket = Socket;
      Socket.Transport = __webpack_require__(26);
      Socket.transports = __webpack_require__(21);
      Socket.parser = __webpack_require__(27);
      Socket.prototype.createTransport = function(name) {
        debug('creating transport "%s"', name);
        var query = clone(this.query);
        query.EIO = parser.protocol;
        query.transport = name;
        if (this.id)
          query.sid = this.id;
        var transport = new transports[name]({
          agent: this.agent,
          hostname: this.hostname,
          port: this.port,
          secure: this.secure,
          path: this.path,
          query: query,
          forceJSONP: this.forceJSONP,
          jsonp: this.jsonp,
          forceBase64: this.forceBase64,
          enablesXDR: this.enablesXDR,
          timestampRequests: this.timestampRequests,
          timestampParam: this.timestampParam,
          policyPort: this.policyPort,
          socket: this,
          pfx: this.pfx,
          key: this.key,
          passphrase: this.passphrase,
          cert: this.cert,
          ca: this.ca,
          ciphers: this.ciphers,
          rejectUnauthorized: this.rejectUnauthorized,
          perMessageDeflate: this.perMessageDeflate,
          extraHeaders: this.extraHeaders,
          forceNode: this.forceNode,
          localAddress: this.localAddress
        });
        return transport;
      };
      function clone(obj) {
        var o = {};
        for (var i in obj) {
          if (obj.hasOwnProperty(i)) {
            o[i] = obj[i];
          }
        }
        return o;
      }
      Socket.prototype.open = function() {
        var transport;
        if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
          transport = 'websocket';
        } else if (0 === this.transports.length) {
          var self = this;
          setTimeout(function() {
            self.emit('error', 'No transports available');
          }, 0);
          return;
        } else {
          transport = this.transports[0];
        }
        this.readyState = 'opening';
        try {
          transport = this.createTransport(transport);
        } catch (e) {
          this.transports.shift();
          this.open();
          return;
        }
        transport.open();
        this.setTransport(transport);
      };
      Socket.prototype.setTransport = function(transport) {
        debug('setting transport %s', transport.name);
        var self = this;
        if (this.transport) {
          debug('clearing existing transport %s', this.transport.name);
          this.transport.removeAllListeners();
        }
        this.transport = transport;
        transport.on('drain', function() {
          self.onDrain();
        }).on('packet', function(packet) {
          self.onPacket(packet);
        }).on('error', function(e) {
          self.onError(e);
        }).on('close', function() {
          self.onClose('transport close');
        });
      };
      Socket.prototype.probe = function(name) {
        debug('probing transport "%s"', name);
        var transport = this.createTransport(name, {probe: 1});
        var failed = false;
        var self = this;
        Socket.priorWebsocketSuccess = false;
        function onTransportOpen() {
          if (self.onlyBinaryUpgrades) {
            var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
            failed = failed || upgradeLosesBinary;
          }
          if (failed)
            return;
          debug('probe transport "%s" opened', name);
          transport.send([{
            type: 'ping',
            data: 'probe'
          }]);
          transport.once('packet', function(msg) {
            if (failed)
              return;
            if ('pong' === msg.type && 'probe' === msg.data) {
              debug('probe transport "%s" pong', name);
              self.upgrading = true;
              self.emit('upgrading', transport);
              if (!transport)
                return;
              Socket.priorWebsocketSuccess = 'websocket' === transport.name;
              debug('pausing current transport "%s"', self.transport.name);
              self.transport.pause(function() {
                if (failed)
                  return;
                if ('closed' === self.readyState)
                  return;
                debug('changing transport and sending upgrade packet');
                cleanup();
                self.setTransport(transport);
                transport.send([{type: 'upgrade'}]);
                self.emit('upgrade', transport);
                transport = null;
                self.upgrading = false;
                self.flush();
              });
            } else {
              debug('probe transport "%s" failed', name);
              var err = new Error('probe error');
              err.transport = transport.name;
              self.emit('upgradeError', err);
            }
          });
        }
        function freezeTransport() {
          if (failed)
            return;
          failed = true;
          cleanup();
          transport.close();
          transport = null;
        }
        function onerror(err) {
          var error = new Error('probe error: ' + err);
          error.transport = transport.name;
          freezeTransport();
          debug('probe transport "%s" failed because of error: %s', name, err);
          self.emit('upgradeError', error);
        }
        function onTransportClose() {
          onerror('transport closed');
        }
        function onclose() {
          onerror('socket closed');
        }
        function onupgrade(to) {
          if (transport && to.name !== transport.name) {
            debug('"%s" works - aborting "%s"', to.name, transport.name);
            freezeTransport();
          }
        }
        function cleanup() {
          transport.removeListener('open', onTransportOpen);
          transport.removeListener('error', onerror);
          transport.removeListener('close', onTransportClose);
          self.removeListener('close', onclose);
          self.removeListener('upgrading', onupgrade);
        }
        transport.once('open', onTransportOpen);
        transport.once('error', onerror);
        transport.once('close', onTransportClose);
        this.once('close', onclose);
        this.once('upgrading', onupgrade);
        transport.open();
      };
      Socket.prototype.onOpen = function() {
        debug('socket open');
        this.readyState = 'open';
        Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
        this.emit('open');
        this.flush();
        if ('open' === this.readyState && this.upgrade && this.transport.pause) {
          debug('starting upgrade probes');
          for (var i = 0,
              l = this.upgrades.length; i < l; i++) {
            this.probe(this.upgrades[i]);
          }
        }
      };
      Socket.prototype.onPacket = function(packet) {
        if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
          debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
          this.emit('packet', packet);
          this.emit('heartbeat');
          switch (packet.type) {
            case 'open':
              this.onHandshake(parsejson(packet.data));
              break;
            case 'pong':
              this.setPing();
              this.emit('pong');
              break;
            case 'error':
              var err = new Error('server error');
              err.code = packet.data;
              this.onError(err);
              break;
            case 'message':
              this.emit('data', packet.data);
              this.emit('message', packet.data);
              break;
          }
        } else {
          debug('packet received with socket readyState "%s"', this.readyState);
        }
      };
      Socket.prototype.onHandshake = function(data) {
        this.emit('handshake', data);
        this.id = data.sid;
        this.transport.query.sid = data.sid;
        this.upgrades = this.filterUpgrades(data.upgrades);
        this.pingInterval = data.pingInterval;
        this.pingTimeout = data.pingTimeout;
        this.onOpen();
        if ('closed' === this.readyState)
          return;
        this.setPing();
        this.removeListener('heartbeat', this.onHeartbeat);
        this.on('heartbeat', this.onHeartbeat);
      };
      Socket.prototype.onHeartbeat = function(timeout) {
        clearTimeout(this.pingTimeoutTimer);
        var self = this;
        self.pingTimeoutTimer = setTimeout(function() {
          if ('closed' === self.readyState)
            return;
          self.onClose('ping timeout');
        }, timeout || (self.pingInterval + self.pingTimeout));
      };
      Socket.prototype.setPing = function() {
        var self = this;
        clearTimeout(self.pingIntervalTimer);
        self.pingIntervalTimer = setTimeout(function() {
          debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
          self.ping();
          self.onHeartbeat(self.pingTimeout);
        }, self.pingInterval);
      };
      Socket.prototype.ping = function() {
        var self = this;
        this.sendPacket('ping', function() {
          self.emit('ping');
        });
      };
      Socket.prototype.onDrain = function() {
        this.writeBuffer.splice(0, this.prevBufferLen);
        this.prevBufferLen = 0;
        if (0 === this.writeBuffer.length) {
          this.emit('drain');
        } else {
          this.flush();
        }
      };
      Socket.prototype.flush = function() {
        if ('closed' !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
          debug('flushing %d packets in socket', this.writeBuffer.length);
          this.transport.send(this.writeBuffer);
          this.prevBufferLen = this.writeBuffer.length;
          this.emit('flush');
        }
      };
      Socket.prototype.write = Socket.prototype.send = function(msg, options, fn) {
        this.sendPacket('message', msg, options, fn);
        return this;
      };
      Socket.prototype.sendPacket = function(type, data, options, fn) {
        if ('function' === typeof data) {
          fn = data;
          data = undefined;
        }
        if ('function' === typeof options) {
          fn = options;
          options = null;
        }
        if ('closing' === this.readyState || 'closed' === this.readyState) {
          return;
        }
        options = options || {};
        options.compress = false !== options.compress;
        var packet = {
          type: type,
          data: data,
          options: options
        };
        this.emit('packetCreate', packet);
        this.writeBuffer.push(packet);
        if (fn)
          this.once('flush', fn);
        this.flush();
      };
      Socket.prototype.close = function() {
        if ('opening' === this.readyState || 'open' === this.readyState) {
          this.readyState = 'closing';
          var self = this;
          if (this.writeBuffer.length) {
            this.once('drain', function() {
              if (this.upgrading) {
                waitForUpgrade();
              } else {
                close();
              }
            });
          } else if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        }
        function close() {
          self.onClose('forced close');
          debug('socket closing - telling transport to close');
          self.transport.close();
        }
        function cleanupAndClose() {
          self.removeListener('upgrade', cleanupAndClose);
          self.removeListener('upgradeError', cleanupAndClose);
          close();
        }
        function waitForUpgrade() {
          self.once('upgrade', cleanupAndClose);
          self.once('upgradeError', cleanupAndClose);
        }
        return this;
      };
      Socket.prototype.onError = function(err) {
        debug('socket error %j', err);
        Socket.priorWebsocketSuccess = false;
        this.emit('error', err);
        this.onClose('transport error', err);
      };
      Socket.prototype.onClose = function(reason, desc) {
        if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
          debug('socket close with reason: "%s"', reason);
          var self = this;
          clearTimeout(this.pingIntervalTimer);
          clearTimeout(this.pingTimeoutTimer);
          this.transport.removeAllListeners('close');
          this.transport.close();
          this.transport.removeAllListeners();
          this.readyState = 'closed';
          this.id = null;
          this.emit('close', reason, desc);
          self.writeBuffer = [];
          self.prevBufferLen = 0;
        }
      };
      Socket.prototype.filterUpgrades = function(upgrades) {
        var filteredUpgrades = [];
        for (var i = 0,
            j = upgrades.length; i < j; i++) {
          if (~index(this.transports, upgrades[i]))
            filteredUpgrades.push(upgrades[i]);
        }
        return filteredUpgrades;
      };
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports, __webpack_require__) {
    (function(global) {
      var XMLHttpRequest = __webpack_require__(22);
      var XHR = __webpack_require__(24);
      var JSONP = __webpack_require__(39);
      var websocket = __webpack_require__(40);
      exports.polling = polling;
      exports.websocket = websocket;
      function polling(opts) {
        var xhr;
        var xd = false;
        var xs = false;
        var jsonp = false !== opts.jsonp;
        if (global.location) {
          var isSSL = 'https:' === location.protocol;
          var port = location.port;
          if (!port) {
            port = isSSL ? 443 : 80;
          }
          xd = opts.hostname !== location.hostname || port !== opts.port;
          xs = opts.secure !== isSSL;
        }
        opts.xdomain = xd;
        opts.xscheme = xs;
        xhr = new XMLHttpRequest(opts);
        if ('open' in xhr && !opts.forceJSONP) {
          return new XHR(opts);
        } else {
          if (!jsonp)
            throw new Error('JSONP disabled');
          return new JSONP(opts);
        }
      }
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports, __webpack_require__) {
    (function(global) {
      var hasCORS = __webpack_require__(23);
      module.exports = function(opts) {
        var xdomain = opts.xdomain;
        var xscheme = opts.xscheme;
        var enablesXDR = opts.enablesXDR;
        try {
          if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
            return new XMLHttpRequest();
          }
        } catch (e) {}
        try {
          if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
            return new XDomainRequest();
          }
        } catch (e) {}
        if (!xdomain) {
          try {
            return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
          } catch (e) {}
        }
      };
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports) {
    try {
      module.exports = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();
    } catch (err) {
      module.exports = false;
    }
  }, function(module, exports, __webpack_require__) {
    (function(global) {
      var XMLHttpRequest = __webpack_require__(22);
      var Polling = __webpack_require__(25);
      var Emitter = __webpack_require__(35);
      var inherit = __webpack_require__(37);
      var debug = __webpack_require__(3)('engine.io-client:polling-xhr');
      module.exports = XHR;
      module.exports.Request = Request;
      function empty() {}
      function XHR(opts) {
        Polling.call(this, opts);
        this.requestTimeout = opts.requestTimeout;
        if (global.location) {
          var isSSL = 'https:' === location.protocol;
          var port = location.port;
          if (!port) {
            port = isSSL ? 443 : 80;
          }
          this.xd = opts.hostname !== global.location.hostname || port !== opts.port;
          this.xs = opts.secure !== isSSL;
        } else {
          this.extraHeaders = opts.extraHeaders;
        }
      }
      inherit(XHR, Polling);
      XHR.prototype.supportsBinary = true;
      XHR.prototype.request = function(opts) {
        opts = opts || {};
        opts.uri = this.uri();
        opts.xd = this.xd;
        opts.xs = this.xs;
        opts.agent = this.agent || false;
        opts.supportsBinary = this.supportsBinary;
        opts.enablesXDR = this.enablesXDR;
        opts.pfx = this.pfx;
        opts.key = this.key;
        opts.passphrase = this.passphrase;
        opts.cert = this.cert;
        opts.ca = this.ca;
        opts.ciphers = this.ciphers;
        opts.rejectUnauthorized = this.rejectUnauthorized;
        opts.requestTimeout = this.requestTimeout;
        opts.extraHeaders = this.extraHeaders;
        return new Request(opts);
      };
      XHR.prototype.doWrite = function(data, fn) {
        var isBinary = typeof data !== 'string' && data !== undefined;
        var req = this.request({
          method: 'POST',
          data: data,
          isBinary: isBinary
        });
        var self = this;
        req.on('success', fn);
        req.on('error', function(err) {
          self.onError('xhr post error', err);
        });
        this.sendXhr = req;
      };
      XHR.prototype.doPoll = function() {
        debug('xhr poll');
        var req = this.request();
        var self = this;
        req.on('data', function(data) {
          self.onData(data);
        });
        req.on('error', function(err) {
          self.onError('xhr poll error', err);
        });
        this.pollXhr = req;
      };
      function Request(opts) {
        this.method = opts.method || 'GET';
        this.uri = opts.uri;
        this.xd = !!opts.xd;
        this.xs = !!opts.xs;
        this.async = false !== opts.async;
        this.data = undefined !== opts.data ? opts.data : null;
        this.agent = opts.agent;
        this.isBinary = opts.isBinary;
        this.supportsBinary = opts.supportsBinary;
        this.enablesXDR = opts.enablesXDR;
        this.requestTimeout = opts.requestTimeout;
        this.pfx = opts.pfx;
        this.key = opts.key;
        this.passphrase = opts.passphrase;
        this.cert = opts.cert;
        this.ca = opts.ca;
        this.ciphers = opts.ciphers;
        this.rejectUnauthorized = opts.rejectUnauthorized;
        this.extraHeaders = opts.extraHeaders;
        this.create();
      }
      Emitter(Request.prototype);
      Request.prototype.create = function() {
        var opts = {
          agent: this.agent,
          xdomain: this.xd,
          xscheme: this.xs,
          enablesXDR: this.enablesXDR
        };
        opts.pfx = this.pfx;
        opts.key = this.key;
        opts.passphrase = this.passphrase;
        opts.cert = this.cert;
        opts.ca = this.ca;
        opts.ciphers = this.ciphers;
        opts.rejectUnauthorized = this.rejectUnauthorized;
        var xhr = this.xhr = new XMLHttpRequest(opts);
        var self = this;
        try {
          debug('xhr open %s: %s', this.method, this.uri);
          xhr.open(this.method, this.uri, this.async);
          try {
            if (this.extraHeaders) {
              xhr.setDisableHeaderCheck(true);
              for (var i in this.extraHeaders) {
                if (this.extraHeaders.hasOwnProperty(i)) {
                  xhr.setRequestHeader(i, this.extraHeaders[i]);
                }
              }
            }
          } catch (e) {}
          if (this.supportsBinary) {
            xhr.responseType = 'arraybuffer';
          }
          if ('POST' === this.method) {
            try {
              if (this.isBinary) {
                xhr.setRequestHeader('Content-type', 'application/octet-stream');
              } else {
                xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
              }
            } catch (e) {}
          }
          try {
            xhr.setRequestHeader('Accept', '*/*');
          } catch (e) {}
          if ('withCredentials' in xhr) {
            xhr.withCredentials = true;
          }
          if (this.requestTimeout) {
            xhr.timeout = this.requestTimeout;
          }
          if (this.hasXDR()) {
            xhr.onload = function() {
              self.onLoad();
            };
            xhr.onerror = function() {
              self.onError(xhr.responseText);
            };
          } else {
            xhr.onreadystatechange = function() {
              if (4 !== xhr.readyState)
                return;
              if (200 === xhr.status || 1223 === xhr.status) {
                self.onLoad();
              } else {
                setTimeout(function() {
                  self.onError(xhr.status);
                }, 0);
              }
            };
          }
          debug('xhr data %s', this.data);
          xhr.send(this.data);
        } catch (e) {
          setTimeout(function() {
            self.onError(e);
          }, 0);
          return;
        }
        if (global.document) {
          this.index = Request.requestsCount++;
          Request.requests[this.index] = this;
        }
      };
      Request.prototype.onSuccess = function() {
        this.emit('success');
        this.cleanup();
      };
      Request.prototype.onData = function(data) {
        this.emit('data', data);
        this.onSuccess();
      };
      Request.prototype.onError = function(err) {
        this.emit('error', err);
        this.cleanup(true);
      };
      Request.prototype.cleanup = function(fromError) {
        if ('undefined' === typeof this.xhr || null === this.xhr) {
          return;
        }
        if (this.hasXDR()) {
          this.xhr.onload = this.xhr.onerror = empty;
        } else {
          this.xhr.onreadystatechange = empty;
        }
        if (fromError) {
          try {
            this.xhr.abort();
          } catch (e) {}
        }
        if (global.document) {
          delete Request.requests[this.index];
        }
        this.xhr = null;
      };
      Request.prototype.onLoad = function() {
        var data;
        try {
          var contentType;
          try {
            contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
          } catch (e) {}
          if (contentType === 'application/octet-stream') {
            data = this.xhr.response || this.xhr.responseText;
          } else {
            if (!this.supportsBinary) {
              data = this.xhr.responseText;
            } else {
              try {
                data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
              } catch (e) {
                var ui8Arr = new Uint8Array(this.xhr.response);
                var dataArray = [];
                for (var idx = 0,
                    length = ui8Arr.length; idx < length; idx++) {
                  dataArray.push(ui8Arr[idx]);
                }
                data = String.fromCharCode.apply(null, dataArray);
              }
            }
          }
        } catch (e) {
          this.onError(e);
        }
        if (null != data) {
          this.onData(data);
        }
      };
      Request.prototype.hasXDR = function() {
        return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
      };
      Request.prototype.abort = function() {
        this.cleanup();
      };
      Request.requestsCount = 0;
      Request.requests = {};
      if (global.document) {
        if (global.attachEvent) {
          global.attachEvent('onunload', unloadHandler);
        } else if (global.addEventListener) {
          global.addEventListener('beforeunload', unloadHandler, false);
        }
      }
      function unloadHandler() {
        for (var i in Request.requests) {
          if (Request.requests.hasOwnProperty(i)) {
            Request.requests[i].abort();
          }
        }
      }
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports, __webpack_require__) {
    var Transport = __webpack_require__(26);
    var parseqs = __webpack_require__(36);
    var parser = __webpack_require__(27);
    var inherit = __webpack_require__(37);
    var yeast = __webpack_require__(38);
    var debug = __webpack_require__(3)('engine.io-client:polling');
    module.exports = Polling;
    var hasXHR2 = (function() {
      var XMLHttpRequest = __webpack_require__(22);
      var xhr = new XMLHttpRequest({xdomain: false});
      return null != xhr.responseType;
    })();
    function Polling(opts) {
      var forceBase64 = (opts && opts.forceBase64);
      if (!hasXHR2 || forceBase64) {
        this.supportsBinary = false;
      }
      Transport.call(this, opts);
    }
    inherit(Polling, Transport);
    Polling.prototype.name = 'polling';
    Polling.prototype.doOpen = function() {
      this.poll();
    };
    Polling.prototype.pause = function(onPause) {
      var self = this;
      this.readyState = 'pausing';
      function pause() {
        debug('paused');
        self.readyState = 'paused';
        onPause();
      }
      if (this.polling || !this.writable) {
        var total = 0;
        if (this.polling) {
          debug('we are currently polling - waiting to pause');
          total++;
          this.once('pollComplete', function() {
            debug('pre-pause polling complete');
            --total || pause();
          });
        }
        if (!this.writable) {
          debug('we are currently writing - waiting to pause');
          total++;
          this.once('drain', function() {
            debug('pre-pause writing complete');
            --total || pause();
          });
        }
      } else {
        pause();
      }
    };
    Polling.prototype.poll = function() {
      debug('polling');
      this.polling = true;
      this.doPoll();
      this.emit('poll');
    };
    Polling.prototype.onData = function(data) {
      var self = this;
      debug('polling got data %s', data);
      var callback = function(packet, index, total) {
        if ('opening' === self.readyState) {
          self.onOpen();
        }
        if ('close' === packet.type) {
          self.onClose();
          return false;
        }
        self.onPacket(packet);
      };
      parser.decodePayload(data, this.socket.binaryType, callback);
      if ('closed' !== this.readyState) {
        this.polling = false;
        this.emit('pollComplete');
        if ('open' === this.readyState) {
          this.poll();
        } else {
          debug('ignoring poll - transport state "%s"', this.readyState);
        }
      }
    };
    Polling.prototype.doClose = function() {
      var self = this;
      function close() {
        debug('writing close packet');
        self.write([{type: 'close'}]);
      }
      if ('open' === this.readyState) {
        debug('transport open - closing');
        close();
      } else {
        debug('transport not open - deferring close');
        this.once('open', close);
      }
    };
    Polling.prototype.write = function(packets) {
      var self = this;
      this.writable = false;
      var callbackfn = function() {
        self.writable = true;
        self.emit('drain');
      };
      parser.encodePayload(packets, this.supportsBinary, function(data) {
        self.doWrite(data, callbackfn);
      });
    };
    Polling.prototype.uri = function() {
      var query = this.query || {};
      var schema = this.secure ? 'https' : 'http';
      var port = '';
      if (false !== this.timestampRequests) {
        query[this.timestampParam] = yeast();
      }
      if (!this.supportsBinary && !query.sid) {
        query.b64 = 1;
      }
      query = parseqs.encode(query);
      if (this.port && (('https' === schema && Number(this.port) !== 443) || ('http' === schema && Number(this.port) !== 80))) {
        port = ':' + this.port;
      }
      if (query.length) {
        query = '?' + query;
      }
      var ipv6 = this.hostname.indexOf(':') !== -1;
      return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
    };
  }, function(module, exports, __webpack_require__) {
    var parser = __webpack_require__(27);
    var Emitter = __webpack_require__(35);
    module.exports = Transport;
    function Transport(opts) {
      this.path = opts.path;
      this.hostname = opts.hostname;
      this.port = opts.port;
      this.secure = opts.secure;
      this.query = opts.query;
      this.timestampParam = opts.timestampParam;
      this.timestampRequests = opts.timestampRequests;
      this.readyState = '';
      this.agent = opts.agent || false;
      this.socket = opts.socket;
      this.enablesXDR = opts.enablesXDR;
      this.pfx = opts.pfx;
      this.key = opts.key;
      this.passphrase = opts.passphrase;
      this.cert = opts.cert;
      this.ca = opts.ca;
      this.ciphers = opts.ciphers;
      this.rejectUnauthorized = opts.rejectUnauthorized;
      this.forceNode = opts.forceNode;
      this.extraHeaders = opts.extraHeaders;
      this.localAddress = opts.localAddress;
    }
    Emitter(Transport.prototype);
    Transport.prototype.onError = function(msg, desc) {
      var err = new Error(msg);
      err.type = 'TransportError';
      err.description = desc;
      this.emit('error', err);
      return this;
    };
    Transport.prototype.open = function() {
      if ('closed' === this.readyState || '' === this.readyState) {
        this.readyState = 'opening';
        this.doOpen();
      }
      return this;
    };
    Transport.prototype.close = function() {
      if ('opening' === this.readyState || 'open' === this.readyState) {
        this.doClose();
        this.onClose();
      }
      return this;
    };
    Transport.prototype.send = function(packets) {
      if ('open' === this.readyState) {
        this.write(packets);
      } else {
        throw new Error('Transport not open');
      }
    };
    Transport.prototype.onOpen = function() {
      this.readyState = 'open';
      this.writable = true;
      this.emit('open');
    };
    Transport.prototype.onData = function(data) {
      var packet = parser.decodePacket(data, this.socket.binaryType);
      this.onPacket(packet);
    };
    Transport.prototype.onPacket = function(packet) {
      this.emit('packet', packet);
    };
    Transport.prototype.onClose = function() {
      this.readyState = 'closed';
      this.emit('close');
    };
  }, function(module, exports, __webpack_require__) {
    (function(global) {
      var keys = __webpack_require__(28);
      var hasBinary = __webpack_require__(29);
      var sliceBuffer = __webpack_require__(30);
      var after = __webpack_require__(31);
      var utf8 = __webpack_require__(32);
      var base64encoder;
      if (global && global.ArrayBuffer) {
        base64encoder = __webpack_require__(33);
      }
      var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);
      var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);
      var dontSendBlobs = isAndroid || isPhantomJS;
      exports.protocol = 3;
      var packets = exports.packets = {
        open: 0,
        close: 1,
        ping: 2,
        pong: 3,
        message: 4,
        upgrade: 5,
        noop: 6
      };
      var packetslist = keys(packets);
      var err = {
        type: 'error',
        data: 'parser error'
      };
      var Blob = __webpack_require__(34);
      exports.encodePacket = function(packet, supportsBinary, utf8encode, callback) {
        if ('function' == typeof supportsBinary) {
          callback = supportsBinary;
          supportsBinary = false;
        }
        if ('function' == typeof utf8encode) {
          callback = utf8encode;
          utf8encode = null;
        }
        var data = (packet.data === undefined) ? undefined : packet.data.buffer || packet.data;
        if (global.ArrayBuffer && data instanceof ArrayBuffer) {
          return encodeArrayBuffer(packet, supportsBinary, callback);
        } else if (Blob && data instanceof global.Blob) {
          return encodeBlob(packet, supportsBinary, callback);
        }
        if (data && data.base64) {
          return encodeBase64Object(packet, callback);
        }
        var encoded = packets[packet.type];
        if (undefined !== packet.data) {
          encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
        }
        return callback('' + encoded);
      };
      function encodeBase64Object(packet, callback) {
        var message = 'b' + exports.packets[packet.type] + packet.data.data;
        return callback(message);
      }
      function encodeArrayBuffer(packet, supportsBinary, callback) {
        if (!supportsBinary) {
          return exports.encodeBase64Packet(packet, callback);
        }
        var data = packet.data;
        var contentArray = new Uint8Array(data);
        var resultBuffer = new Uint8Array(1 + data.byteLength);
        resultBuffer[0] = packets[packet.type];
        for (var i = 0; i < contentArray.length; i++) {
          resultBuffer[i + 1] = contentArray[i];
        }
        return callback(resultBuffer.buffer);
      }
      function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
        if (!supportsBinary) {
          return exports.encodeBase64Packet(packet, callback);
        }
        var fr = new FileReader();
        fr.onload = function() {
          packet.data = fr.result;
          exports.encodePacket(packet, supportsBinary, true, callback);
        };
        return fr.readAsArrayBuffer(packet.data);
      }
      function encodeBlob(packet, supportsBinary, callback) {
        if (!supportsBinary) {
          return exports.encodeBase64Packet(packet, callback);
        }
        if (dontSendBlobs) {
          return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
        }
        var length = new Uint8Array(1);
        length[0] = packets[packet.type];
        var blob = new Blob([length.buffer, packet.data]);
        return callback(blob);
      }
      exports.encodeBase64Packet = function(packet, callback) {
        var message = 'b' + exports.packets[packet.type];
        if (Blob && packet.data instanceof global.Blob) {
          var fr = new FileReader();
          fr.onload = function() {
            var b64 = fr.result.split(',')[1];
            callback(message + b64);
          };
          return fr.readAsDataURL(packet.data);
        }
        var b64data;
        try {
          b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
        } catch (e) {
          var typed = new Uint8Array(packet.data);
          var basic = new Array(typed.length);
          for (var i = 0; i < typed.length; i++) {
            basic[i] = typed[i];
          }
          b64data = String.fromCharCode.apply(null, basic);
        }
        message += global.btoa(b64data);
        return callback(message);
      };
      exports.decodePacket = function(data, binaryType, utf8decode) {
        if (data === undefined) {
          return err;
        }
        if (typeof data == 'string') {
          if (data.charAt(0) == 'b') {
            return exports.decodeBase64Packet(data.substr(1), binaryType);
          }
          if (utf8decode) {
            data = tryDecode(data);
            if (data === false) {
              return err;
            }
          }
          var type = data.charAt(0);
          if (Number(type) != type || !packetslist[type]) {
            return err;
          }
          if (data.length > 1) {
            return {
              type: packetslist[type],
              data: data.substring(1)
            };
          } else {
            return {type: packetslist[type]};
          }
        }
        var asArray = new Uint8Array(data);
        var type = asArray[0];
        var rest = sliceBuffer(data, 1);
        if (Blob && binaryType === 'blob') {
          rest = new Blob([rest]);
        }
        return {
          type: packetslist[type],
          data: rest
        };
      };
      function tryDecode(data) {
        try {
          data = utf8.decode(data);
        } catch (e) {
          return false;
        }
        return data;
      }
      exports.decodeBase64Packet = function(msg, binaryType) {
        var type = packetslist[msg.charAt(0)];
        if (!base64encoder) {
          return {
            type: type,
            data: {
              base64: true,
              data: msg.substr(1)
            }
          };
        }
        var data = base64encoder.decode(msg.substr(1));
        if (binaryType === 'blob' && Blob) {
          data = new Blob([data]);
        }
        return {
          type: type,
          data: data
        };
      };
      exports.encodePayload = function(packets, supportsBinary, callback) {
        if (typeof supportsBinary == 'function') {
          callback = supportsBinary;
          supportsBinary = null;
        }
        var isBinary = hasBinary(packets);
        if (supportsBinary && isBinary) {
          if (Blob && !dontSendBlobs) {
            return exports.encodePayloadAsBlob(packets, callback);
          }
          return exports.encodePayloadAsArrayBuffer(packets, callback);
        }
        if (!packets.length) {
          return callback('0:');
        }
        function setLengthHeader(message) {
          return message.length + ':' + message;
        }
        function encodeOne(packet, doneCallback) {
          exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
            doneCallback(null, setLengthHeader(message));
          });
        }
        map(packets, encodeOne, function(err, results) {
          return callback(results.join(''));
        });
      };
      function map(ary, each, done) {
        var result = new Array(ary.length);
        var next = after(ary.length, done);
        var eachWithIndex = function(i, el, cb) {
          each(el, function(error, msg) {
            result[i] = msg;
            cb(error, result);
          });
        };
        for (var i = 0; i < ary.length; i++) {
          eachWithIndex(i, ary[i], next);
        }
      }
      exports.decodePayload = function(data, binaryType, callback) {
        if (typeof data != 'string') {
          return exports.decodePayloadAsBinary(data, binaryType, callback);
        }
        if (typeof binaryType === 'function') {
          callback = binaryType;
          binaryType = null;
        }
        var packet;
        if (data == '') {
          return callback(err, 0, 1);
        }
        var length = '',
            n,
            msg;
        for (var i = 0,
            l = data.length; i < l; i++) {
          var chr = data.charAt(i);
          if (':' != chr) {
            length += chr;
          } else {
            if ('' == length || (length != (n = Number(length)))) {
              return callback(err, 0, 1);
            }
            msg = data.substr(i + 1, n);
            if (length != msg.length) {
              return callback(err, 0, 1);
            }
            if (msg.length) {
              packet = exports.decodePacket(msg, binaryType, true);
              if (err.type == packet.type && err.data == packet.data) {
                return callback(err, 0, 1);
              }
              var ret = callback(packet, i + n, l);
              if (false === ret)
                return;
            }
            i += n;
            length = '';
          }
        }
        if (length != '') {
          return callback(err, 0, 1);
        }
      };
      exports.encodePayloadAsArrayBuffer = function(packets, callback) {
        if (!packets.length) {
          return callback(new ArrayBuffer(0));
        }
        function encodeOne(packet, doneCallback) {
          exports.encodePacket(packet, true, true, function(data) {
            return doneCallback(null, data);
          });
        }
        map(packets, encodeOne, function(err, encodedPackets) {
          var totalLength = encodedPackets.reduce(function(acc, p) {
            var len;
            if (typeof p === 'string') {
              len = p.length;
            } else {
              len = p.byteLength;
            }
            return acc + len.toString().length + len + 2;
          }, 0);
          var resultArray = new Uint8Array(totalLength);
          var bufferIndex = 0;
          encodedPackets.forEach(function(p) {
            var isString = typeof p === 'string';
            var ab = p;
            if (isString) {
              var view = new Uint8Array(p.length);
              for (var i = 0; i < p.length; i++) {
                view[i] = p.charCodeAt(i);
              }
              ab = view.buffer;
            }
            if (isString) {
              resultArray[bufferIndex++] = 0;
            } else {
              resultArray[bufferIndex++] = 1;
            }
            var lenStr = ab.byteLength.toString();
            for (var i = 0; i < lenStr.length; i++) {
              resultArray[bufferIndex++] = parseInt(lenStr[i]);
            }
            resultArray[bufferIndex++] = 255;
            var view = new Uint8Array(ab);
            for (var i = 0; i < view.length; i++) {
              resultArray[bufferIndex++] = view[i];
            }
          });
          return callback(resultArray.buffer);
        });
      };
      exports.encodePayloadAsBlob = function(packets, callback) {
        function encodeOne(packet, doneCallback) {
          exports.encodePacket(packet, true, true, function(encoded) {
            var binaryIdentifier = new Uint8Array(1);
            binaryIdentifier[0] = 1;
            if (typeof encoded === 'string') {
              var view = new Uint8Array(encoded.length);
              for (var i = 0; i < encoded.length; i++) {
                view[i] = encoded.charCodeAt(i);
              }
              encoded = view.buffer;
              binaryIdentifier[0] = 0;
            }
            var len = (encoded instanceof ArrayBuffer) ? encoded.byteLength : encoded.size;
            var lenStr = len.toString();
            var lengthAry = new Uint8Array(lenStr.length + 1);
            for (var i = 0; i < lenStr.length; i++) {
              lengthAry[i] = parseInt(lenStr[i]);
            }
            lengthAry[lenStr.length] = 255;
            if (Blob) {
              var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
              doneCallback(null, blob);
            }
          });
        }
        map(packets, encodeOne, function(err, results) {
          return callback(new Blob(results));
        });
      };
      exports.decodePayloadAsBinary = function(data, binaryType, callback) {
        if (typeof binaryType === 'function') {
          callback = binaryType;
          binaryType = null;
        }
        var bufferTail = data;
        var buffers = [];
        var numberTooLong = false;
        while (bufferTail.byteLength > 0) {
          var tailArray = new Uint8Array(bufferTail);
          var isString = tailArray[0] === 0;
          var msgLength = '';
          for (var i = 1; ; i++) {
            if (tailArray[i] == 255)
              break;
            if (msgLength.length > 310) {
              numberTooLong = true;
              break;
            }
            msgLength += tailArray[i];
          }
          if (numberTooLong)
            return callback(err, 0, 1);
          bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
          msgLength = parseInt(msgLength);
          var msg = sliceBuffer(bufferTail, 0, msgLength);
          if (isString) {
            try {
              msg = String.fromCharCode.apply(null, new Uint8Array(msg));
            } catch (e) {
              var typed = new Uint8Array(msg);
              msg = '';
              for (var i = 0; i < typed.length; i++) {
                msg += String.fromCharCode(typed[i]);
              }
            }
          }
          buffers.push(msg);
          bufferTail = sliceBuffer(bufferTail, msgLength);
        }
        var total = buffers.length;
        buffers.forEach(function(buffer, i) {
          callback(exports.decodePacket(buffer, binaryType, true), i, total);
        });
      };
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports) {
    module.exports = Object.keys || function keys(obj) {
      var arr = [];
      var has = Object.prototype.hasOwnProperty;
      for (var i in obj) {
        if (has.call(obj, i)) {
          arr.push(i);
        }
      }
      return arr;
    };
  }, function(module, exports, __webpack_require__) {
    (function(global) {
      var isArray = __webpack_require__(15);
      module.exports = hasBinary;
      function hasBinary(data) {
        function _hasBinary(obj) {
          if (!obj)
            return false;
          if ((global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) || (global.ArrayBuffer && obj instanceof ArrayBuffer) || (global.Blob && obj instanceof Blob) || (global.File && obj instanceof File)) {
            return true;
          }
          if (isArray(obj)) {
            for (var i = 0; i < obj.length; i++) {
              if (_hasBinary(obj[i])) {
                return true;
              }
            }
          } else if (obj && 'object' == typeof obj) {
            if (obj.toJSON && 'function' == typeof obj.toJSON) {
              obj = obj.toJSON();
            }
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
                return true;
              }
            }
          }
          return false;
        }
        return _hasBinary(data);
      }
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports) {
    module.exports = function(arraybuffer, start, end) {
      var bytes = arraybuffer.byteLength;
      start = start || 0;
      end = end || bytes;
      if (arraybuffer.slice) {
        return arraybuffer.slice(start, end);
      }
      if (start < 0) {
        start += bytes;
      }
      if (end < 0) {
        end += bytes;
      }
      if (end > bytes) {
        end = bytes;
      }
      if (start >= bytes || start >= end || bytes === 0) {
        return new ArrayBuffer(0);
      }
      var abv = new Uint8Array(arraybuffer);
      var result = new Uint8Array(end - start);
      for (var i = start,
          ii = 0; i < end; i++, ii++) {
        result[ii] = abv[i];
      }
      return result.buffer;
    };
  }, function(module, exports) {
    module.exports = after;
    function after(count, callback, err_cb) {
      var bail = false;
      err_cb = err_cb || noop;
      proxy.count = count;
      return (count === 0) ? callback() : proxy;
      function proxy(err, result) {
        if (proxy.count <= 0) {
          throw new Error('after called too many times');
        }
        --proxy.count;
        if (err) {
          bail = true;
          callback(err);
          callback = err_cb;
        } else if (proxy.count === 0 && !bail) {
          callback(null, result);
        }
      }
    }
    function noop() {}
  }, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    (function(module, global) {
      ;
      (function(root) {
        var freeExports = typeof exports == 'object' && exports;
        var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;
        var freeGlobal = typeof global == 'object' && global;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
          root = freeGlobal;
        }
        var stringFromCharCode = String.fromCharCode;
        function ucs2decode(string) {
          var output = [];
          var counter = 0;
          var length = string.length;
          var value;
          var extra;
          while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
              extra = string.charCodeAt(counter++);
              if ((extra & 0xFC00) == 0xDC00) {
                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
              } else {
                output.push(value);
                counter--;
              }
            } else {
              output.push(value);
            }
          }
          return output;
        }
        function ucs2encode(array) {
          var length = array.length;
          var index = -1;
          var value;
          var output = '';
          while (++index < length) {
            value = array[index];
            if (value > 0xFFFF) {
              value -= 0x10000;
              output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
              value = 0xDC00 | value & 0x3FF;
            }
            output += stringFromCharCode(value);
          }
          return output;
        }
        function createByte(codePoint, shift) {
          return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
        }
        function encodeCodePoint(codePoint) {
          if ((codePoint & 0xFFFFFF80) == 0) {
            return stringFromCharCode(codePoint);
          }
          var symbol = '';
          if ((codePoint & 0xFFFFF800) == 0) {
            symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
          } else if ((codePoint & 0xFFFF0000) == 0) {
            symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
            symbol += createByte(codePoint, 6);
          } else if ((codePoint & 0xFFE00000) == 0) {
            symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
            symbol += createByte(codePoint, 12);
            symbol += createByte(codePoint, 6);
          }
          symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
          return symbol;
        }
        function wtf8encode(string) {
          var codePoints = ucs2decode(string);
          var length = codePoints.length;
          var index = -1;
          var codePoint;
          var byteString = '';
          while (++index < length) {
            codePoint = codePoints[index];
            byteString += encodeCodePoint(codePoint);
          }
          return byteString;
        }
        function readContinuationByte() {
          if (byteIndex >= byteCount) {
            throw Error('Invalid byte index');
          }
          var continuationByte = byteArray[byteIndex] & 0xFF;
          byteIndex++;
          if ((continuationByte & 0xC0) == 0x80) {
            return continuationByte & 0x3F;
          }
          throw Error('Invalid continuation byte');
        }
        function decodeSymbol() {
          var byte1;
          var byte2;
          var byte3;
          var byte4;
          var codePoint;
          if (byteIndex > byteCount) {
            throw Error('Invalid byte index');
          }
          if (byteIndex == byteCount) {
            return false;
          }
          byte1 = byteArray[byteIndex] & 0xFF;
          byteIndex++;
          if ((byte1 & 0x80) == 0) {
            return byte1;
          }
          if ((byte1 & 0xE0) == 0xC0) {
            var byte2 = readContinuationByte();
            codePoint = ((byte1 & 0x1F) << 6) | byte2;
            if (codePoint >= 0x80) {
              return codePoint;
            } else {
              throw Error('Invalid continuation byte');
            }
          }
          if ((byte1 & 0xF0) == 0xE0) {
            byte2 = readContinuationByte();
            byte3 = readContinuationByte();
            codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
            if (codePoint >= 0x0800) {
              return codePoint;
            } else {
              throw Error('Invalid continuation byte');
            }
          }
          if ((byte1 & 0xF8) == 0xF0) {
            byte2 = readContinuationByte();
            byte3 = readContinuationByte();
            byte4 = readContinuationByte();
            codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) | (byte3 << 0x06) | byte4;
            if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
              return codePoint;
            }
          }
          throw Error('Invalid WTF-8 detected');
        }
        var byteArray;
        var byteCount;
        var byteIndex;
        function wtf8decode(byteString) {
          byteArray = ucs2decode(byteString);
          byteCount = byteArray.length;
          byteIndex = 0;
          var codePoints = [];
          var tmp;
          while ((tmp = decodeSymbol()) !== false) {
            codePoints.push(tmp);
          }
          return ucs2encode(codePoints);
        }
        var wtf8 = {
          'version': '1.0.0',
          'encode': wtf8encode,
          'decode': wtf8decode
        };
        if (true) {
          !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
            return wtf8;
          }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else if (freeExports && !freeExports.nodeType) {
          if (freeModule) {
            freeModule.exports = wtf8;
          } else {
            var object = {};
            var hasOwnProperty = object.hasOwnProperty;
            for (var key in wtf8) {
              hasOwnProperty.call(wtf8, key) && (freeExports[key] = wtf8[key]);
            }
          }
        } else {
          root.wtf8 = wtf8;
        }
      }(this));
    }.call(exports, __webpack_require__(12)(module), (function() {
      return this;
    }())));
  }, function(module, exports) {
    (function() {
      "use strict";
      var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var lookup = new Uint8Array(256);
      for (var i = 0; i < chars.length; i++) {
        lookup[chars.charCodeAt(i)] = i;
      }
      exports.encode = function(arraybuffer) {
        var bytes = new Uint8Array(arraybuffer),
            i,
            len = bytes.length,
            base64 = "";
        for (i = 0; i < len; i += 3) {
          base64 += chars[bytes[i] >> 2];
          base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
          base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
          base64 += chars[bytes[i + 2] & 63];
        }
        if ((len % 3) === 2) {
          base64 = base64.substring(0, base64.length - 1) + "=";
        } else if (len % 3 === 1) {
          base64 = base64.substring(0, base64.length - 2) + "==";
        }
        return base64;
      };
      exports.decode = function(base64) {
        var bufferLength = base64.length * 0.75,
            len = base64.length,
            i,
            p = 0,
            encoded1,
            encoded2,
            encoded3,
            encoded4;
        if (base64[base64.length - 1] === "=") {
          bufferLength--;
          if (base64[base64.length - 2] === "=") {
            bufferLength--;
          }
        }
        var arraybuffer = new ArrayBuffer(bufferLength),
            bytes = new Uint8Array(arraybuffer);
        for (i = 0; i < len; i += 4) {
          encoded1 = lookup[base64.charCodeAt(i)];
          encoded2 = lookup[base64.charCodeAt(i + 1)];
          encoded3 = lookup[base64.charCodeAt(i + 2)];
          encoded4 = lookup[base64.charCodeAt(i + 3)];
          bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
          bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
          bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
        }
        return arraybuffer;
      };
    })();
  }, function(module, exports) {
    (function(global) {
      var BlobBuilder = global.BlobBuilder || global.WebKitBlobBuilder || global.MSBlobBuilder || global.MozBlobBuilder;
      var blobSupported = (function() {
        try {
          var a = new Blob(['hi']);
          return a.size === 2;
        } catch (e) {
          return false;
        }
      })();
      var blobSupportsArrayBufferView = blobSupported && (function() {
        try {
          var b = new Blob([new Uint8Array([1, 2])]);
          return b.size === 2;
        } catch (e) {
          return false;
        }
      })();
      var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;
      function mapArrayBufferViews(ary) {
        for (var i = 0; i < ary.length; i++) {
          var chunk = ary[i];
          if (chunk.buffer instanceof ArrayBuffer) {
            var buf = chunk.buffer;
            if (chunk.byteLength !== buf.byteLength) {
              var copy = new Uint8Array(chunk.byteLength);
              copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
              buf = copy.buffer;
            }
            ary[i] = buf;
          }
        }
      }
      function BlobBuilderConstructor(ary, options) {
        options = options || {};
        var bb = new BlobBuilder();
        mapArrayBufferViews(ary);
        for (var i = 0; i < ary.length; i++) {
          bb.append(ary[i]);
        }
        return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
      }
      ;
      function BlobConstructor(ary, options) {
        mapArrayBufferViews(ary);
        return new Blob(ary, options || {});
      }
      ;
      module.exports = (function() {
        if (blobSupported) {
          return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
        } else if (blobBuilderSupported) {
          return BlobBuilderConstructor;
        } else {
          return undefined;
        }
      })();
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports, __webpack_require__) {
    if (true) {
      module.exports = Emitter;
    }
    function Emitter(obj) {
      if (obj)
        return mixin(obj);
    }
    ;
    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }
    Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
      return this;
    };
    Emitter.prototype.once = function(event, fn) {
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }
      on.fn = fn;
      this.on(event, on);
      return this;
    };
    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      }
      var callbacks = this._callbacks['$' + event];
      if (!callbacks)
        return this;
      if (1 == arguments.length) {
        delete this._callbacks['$' + event];
        return this;
      }
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      return this;
    };
    Emitter.prototype.emit = function(event) {
      this._callbacks = this._callbacks || {};
      var args = [].slice.call(arguments, 1),
          callbacks = this._callbacks['$' + event];
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0,
            len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }
      return this;
    };
    Emitter.prototype.listeners = function(event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks['$' + event] || [];
    };
    Emitter.prototype.hasListeners = function(event) {
      return !!this.listeners(event).length;
    };
  }, function(module, exports) {
    exports.encode = function(obj) {
      var str = '';
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          if (str.length)
            str += '&';
          str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
        }
      }
      return str;
    };
    exports.decode = function(qs) {
      var qry = {};
      var pairs = qs.split('&');
      for (var i = 0,
          l = pairs.length; i < l; i++) {
        var pair = pairs[i].split('=');
        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
      }
      return qry;
    };
  }, function(module, exports) {
    module.exports = function(a, b) {
      var fn = function() {};
      fn.prototype = b.prototype;
      a.prototype = new fn;
      a.prototype.constructor = a;
    };
  }, function(module, exports) {
    'use strict';
    var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
        length = 64,
        map = {},
        seed = 0,
        i = 0,
        prev;
    function encode(num) {
      var encoded = '';
      do {
        encoded = alphabet[num % length] + encoded;
        num = Math.floor(num / length);
      } while (num > 0);
      return encoded;
    }
    function decode(str) {
      var decoded = 0;
      for (i = 0; i < str.length; i++) {
        decoded = decoded * length + map[str.charAt(i)];
      }
      return decoded;
    }
    function yeast() {
      var now = encode(+new Date());
      if (now !== prev)
        return seed = 0, prev = now;
      return now + '.' + encode(seed++);
    }
    for (; i < length; i++)
      map[alphabet[i]] = i;
    yeast.encode = encode;
    yeast.decode = decode;
    module.exports = yeast;
  }, function(module, exports, __webpack_require__) {
    (function(global) {
      var Polling = __webpack_require__(25);
      var inherit = __webpack_require__(37);
      module.exports = JSONPPolling;
      var rNewline = /\n/g;
      var rEscapedNewline = /\\n/g;
      var callbacks;
      function empty() {}
      function JSONPPolling(opts) {
        Polling.call(this, opts);
        this.query = this.query || {};
        if (!callbacks) {
          if (!global.___eio)
            global.___eio = [];
          callbacks = global.___eio;
        }
        this.index = callbacks.length;
        var self = this;
        callbacks.push(function(msg) {
          self.onData(msg);
        });
        this.query.j = this.index;
        if (global.document && global.addEventListener) {
          global.addEventListener('beforeunload', function() {
            if (self.script)
              self.script.onerror = empty;
          }, false);
        }
      }
      inherit(JSONPPolling, Polling);
      JSONPPolling.prototype.supportsBinary = false;
      JSONPPolling.prototype.doClose = function() {
        if (this.script) {
          this.script.parentNode.removeChild(this.script);
          this.script = null;
        }
        if (this.form) {
          this.form.parentNode.removeChild(this.form);
          this.form = null;
          this.iframe = null;
        }
        Polling.prototype.doClose.call(this);
      };
      JSONPPolling.prototype.doPoll = function() {
        var self = this;
        var script = document.createElement('script');
        if (this.script) {
          this.script.parentNode.removeChild(this.script);
          this.script = null;
        }
        script.async = true;
        script.src = this.uri();
        script.onerror = function(e) {
          self.onError('jsonp poll error', e);
        };
        var insertAt = document.getElementsByTagName('script')[0];
        if (insertAt) {
          insertAt.parentNode.insertBefore(script, insertAt);
        } else {
          (document.head || document.body).appendChild(script);
        }
        this.script = script;
        var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);
        if (isUAgecko) {
          setTimeout(function() {
            var iframe = document.createElement('iframe');
            document.body.appendChild(iframe);
            document.body.removeChild(iframe);
          }, 100);
        }
      };
      JSONPPolling.prototype.doWrite = function(data, fn) {
        var self = this;
        if (!this.form) {
          var form = document.createElement('form');
          var area = document.createElement('textarea');
          var id = this.iframeId = 'eio_iframe_' + this.index;
          var iframe;
          form.className = 'socketio';
          form.style.position = 'absolute';
          form.style.top = '-1000px';
          form.style.left = '-1000px';
          form.target = id;
          form.method = 'POST';
          form.setAttribute('accept-charset', 'utf-8');
          area.name = 'd';
          form.appendChild(area);
          document.body.appendChild(form);
          this.form = form;
          this.area = area;
        }
        this.form.action = this.uri();
        function complete() {
          initIframe();
          fn();
        }
        function initIframe() {
          if (self.iframe) {
            try {
              self.form.removeChild(self.iframe);
            } catch (e) {
              self.onError('jsonp polling iframe removal error', e);
            }
          }
          try {
            var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
            iframe = document.createElement(html);
          } catch (e) {
            iframe = document.createElement('iframe');
            iframe.name = self.iframeId;
            iframe.src = 'javascript:0';
          }
          iframe.id = self.iframeId;
          self.form.appendChild(iframe);
          self.iframe = iframe;
        }
        initIframe();
        data = data.replace(rEscapedNewline, '\\\n');
        this.area.value = data.replace(rNewline, '\\n');
        try {
          this.form.submit();
        } catch (e) {}
        if (this.iframe.attachEvent) {
          this.iframe.onreadystatechange = function() {
            if (self.iframe.readyState === 'complete') {
              complete();
            }
          };
        } else {
          this.iframe.onload = complete;
        }
      };
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports, __webpack_require__) {
    (function(global) {
      var Transport = __webpack_require__(26);
      var parser = __webpack_require__(27);
      var parseqs = __webpack_require__(36);
      var inherit = __webpack_require__(37);
      var yeast = __webpack_require__(38);
      var debug = __webpack_require__(3)('engine.io-client:websocket');
      var BrowserWebSocket = global.WebSocket || global.MozWebSocket;
      var NodeWebSocket;
      if (typeof window === 'undefined') {
        try {
          NodeWebSocket = __webpack_require__(41);
        } catch (e) {}
      }
      var WebSocket = BrowserWebSocket;
      if (!WebSocket && typeof window === 'undefined') {
        WebSocket = NodeWebSocket;
      }
      module.exports = WS;
      function WS(opts) {
        var forceBase64 = (opts && opts.forceBase64);
        if (forceBase64) {
          this.supportsBinary = false;
        }
        this.perMessageDeflate = opts.perMessageDeflate;
        this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
        if (!this.usingBrowserWebSocket) {
          WebSocket = NodeWebSocket;
        }
        Transport.call(this, opts);
      }
      inherit(WS, Transport);
      WS.prototype.name = 'websocket';
      WS.prototype.supportsBinary = true;
      WS.prototype.doOpen = function() {
        if (!this.check()) {
          return;
        }
        var uri = this.uri();
        var protocols = void(0);
        var opts = {
          agent: this.agent,
          perMessageDeflate: this.perMessageDeflate
        };
        opts.pfx = this.pfx;
        opts.key = this.key;
        opts.passphrase = this.passphrase;
        opts.cert = this.cert;
        opts.ca = this.ca;
        opts.ciphers = this.ciphers;
        opts.rejectUnauthorized = this.rejectUnauthorized;
        if (this.extraHeaders) {
          opts.headers = this.extraHeaders;
        }
        if (this.localAddress) {
          opts.localAddress = this.localAddress;
        }
        try {
          this.ws = this.usingBrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);
        } catch (err) {
          return this.emit('error', err);
        }
        if (this.ws.binaryType === undefined) {
          this.supportsBinary = false;
        }
        if (this.ws.supports && this.ws.supports.binary) {
          this.supportsBinary = true;
          this.ws.binaryType = 'nodebuffer';
        } else {
          this.ws.binaryType = 'arraybuffer';
        }
        this.addEventListeners();
      };
      WS.prototype.addEventListeners = function() {
        var self = this;
        this.ws.onopen = function() {
          self.onOpen();
        };
        this.ws.onclose = function() {
          self.onClose();
        };
        this.ws.onmessage = function(ev) {
          self.onData(ev.data);
        };
        this.ws.onerror = function(e) {
          self.onError('websocket error', e);
        };
      };
      WS.prototype.write = function(packets) {
        var self = this;
        this.writable = false;
        var total = packets.length;
        for (var i = 0,
            l = total; i < l; i++) {
          (function(packet) {
            parser.encodePacket(packet, self.supportsBinary, function(data) {
              if (!self.usingBrowserWebSocket) {
                var opts = {};
                if (packet.options) {
                  opts.compress = packet.options.compress;
                }
                if (self.perMessageDeflate) {
                  var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length;
                  if (len < self.perMessageDeflate.threshold) {
                    opts.compress = false;
                  }
                }
              }
              try {
                if (self.usingBrowserWebSocket) {
                  self.ws.send(data);
                } else {
                  self.ws.send(data, opts);
                }
              } catch (e) {
                debug('websocket closed before onclose event');
              }
              --total || done();
            });
          })(packets[i]);
        }
        function done() {
          self.emit('flush');
          setTimeout(function() {
            self.writable = true;
            self.emit('drain');
          }, 0);
        }
      };
      WS.prototype.onClose = function() {
        Transport.prototype.onClose.call(this);
      };
      WS.prototype.doClose = function() {
        if (typeof this.ws !== 'undefined') {
          this.ws.close();
        }
      };
      WS.prototype.uri = function() {
        var query = this.query || {};
        var schema = this.secure ? 'wss' : 'ws';
        var port = '';
        if (this.port && (('wss' === schema && Number(this.port) !== 443) || ('ws' === schema && Number(this.port) !== 80))) {
          port = ':' + this.port;
        }
        if (this.timestampRequests) {
          query[this.timestampParam] = yeast();
        }
        if (!this.supportsBinary) {
          query.b64 = 1;
        }
        query = parseqs.encode(query);
        if (query.length) {
          query = '?' + query;
        }
        var ipv6 = this.hostname.indexOf(':') !== -1;
        return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
      };
      WS.prototype.check = function() {
        return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
      };
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports) {}, function(module, exports) {
    var indexOf = [].indexOf;
    module.exports = function(arr, obj) {
      if (indexOf)
        return arr.indexOf(obj);
      for (var i = 0; i < arr.length; ++i) {
        if (arr[i] === obj)
          return i;
      }
      return -1;
    };
  }, function(module, exports) {
    (function(global) {
      var rvalidchars = /^[\],:{}\s]*$/;
      var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
      var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
      var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
      var rtrimLeft = /^\s+/;
      var rtrimRight = /\s+$/;
      module.exports = function parsejson(data) {
        if ('string' != typeof data || !data) {
          return null;
        }
        data = data.replace(rtrimLeft, '').replace(rtrimRight, '');
        if (global.JSON && JSON.parse) {
          return JSON.parse(data);
        }
        if (rvalidchars.test(data.replace(rvalidescape, '@').replace(rvalidtokens, ']').replace(rvalidbraces, ''))) {
          return (new Function('return ' + data))();
        }
      };
    }.call(exports, (function() {
      return this;
    }())));
  }, function(module, exports, __webpack_require__) {
    'use strict';
    var parser = __webpack_require__(7);
    var Emitter = __webpack_require__(35);
    var toArray = __webpack_require__(45);
    var on = __webpack_require__(46);
    var bind = __webpack_require__(47);
    var debug = __webpack_require__(3)('socket.io-client:socket');
    var hasBin = __webpack_require__(29);
    module.exports = exports = Socket;
    var events = {
      connect: 1,
      connect_error: 1,
      connect_timeout: 1,
      connecting: 1,
      disconnect: 1,
      error: 1,
      reconnect: 1,
      reconnect_attempt: 1,
      reconnect_failed: 1,
      reconnect_error: 1,
      reconnecting: 1,
      ping: 1,
      pong: 1
    };
    var emit = Emitter.prototype.emit;
    function Socket(io, nsp, opts) {
      this.io = io;
      this.nsp = nsp;
      this.json = this;
      this.ids = 0;
      this.acks = {};
      this.receiveBuffer = [];
      this.sendBuffer = [];
      this.connected = false;
      this.disconnected = true;
      if (opts && opts.query) {
        this.query = opts.query;
      }
      if (this.io.autoConnect)
        this.open();
    }
    Emitter(Socket.prototype);
    Socket.prototype.subEvents = function() {
      if (this.subs)
        return;
      var io = this.io;
      this.subs = [on(io, 'open', bind(this, 'onopen')), on(io, 'packet', bind(this, 'onpacket')), on(io, 'close', bind(this, 'onclose'))];
    };
    Socket.prototype.open = Socket.prototype.connect = function() {
      if (this.connected)
        return this;
      this.subEvents();
      this.io.open();
      if ('open' === this.io.readyState)
        this.onopen();
      this.emit('connecting');
      return this;
    };
    Socket.prototype.send = function() {
      var args = toArray(arguments);
      args.unshift('message');
      this.emit.apply(this, args);
      return this;
    };
    Socket.prototype.emit = function(ev) {
      if (events.hasOwnProperty(ev)) {
        emit.apply(this, arguments);
        return this;
      }
      var args = toArray(arguments);
      var parserType = parser.EVENT;
      if (hasBin(args)) {
        parserType = parser.BINARY_EVENT;
      }
      var packet = {
        type: parserType,
        data: args
      };
      packet.options = {};
      packet.options.compress = !this.flags || false !== this.flags.compress;
      if ('function' === typeof args[args.length - 1]) {
        debug('emitting packet with ack id %d', this.ids);
        this.acks[this.ids] = args.pop();
        packet.id = this.ids++;
      }
      if (this.connected) {
        this.packet(packet);
      } else {
        this.sendBuffer.push(packet);
      }
      delete this.flags;
      return this;
    };
    Socket.prototype.packet = function(packet) {
      packet.nsp = this.nsp;
      this.io.packet(packet);
    };
    Socket.prototype.onopen = function() {
      debug('transport is open - connecting');
      if ('/' !== this.nsp) {
        if (this.query) {
          this.packet({
            type: parser.CONNECT,
            query: this.query
          });
        } else {
          this.packet({type: parser.CONNECT});
        }
      }
    };
    Socket.prototype.onclose = function(reason) {
      debug('close (%s)', reason);
      this.connected = false;
      this.disconnected = true;
      delete this.id;
      this.emit('disconnect', reason);
    };
    Socket.prototype.onpacket = function(packet) {
      if (packet.nsp !== this.nsp)
        return;
      switch (packet.type) {
        case parser.CONNECT:
          this.onconnect();
          break;
        case parser.EVENT:
          this.onevent(packet);
          break;
        case parser.BINARY_EVENT:
          this.onevent(packet);
          break;
        case parser.ACK:
          this.onack(packet);
          break;
        case parser.BINARY_ACK:
          this.onack(packet);
          break;
        case parser.DISCONNECT:
          this.ondisconnect();
          break;
        case parser.ERROR:
          this.emit('error', packet.data);
          break;
      }
    };
    Socket.prototype.onevent = function(packet) {
      var args = packet.data || [];
      debug('emitting event %j', args);
      if (null != packet.id) {
        debug('attaching ack callback to event');
        args.push(this.ack(packet.id));
      }
      if (this.connected) {
        emit.apply(this, args);
      } else {
        this.receiveBuffer.push(args);
      }
    };
    Socket.prototype.ack = function(id) {
      var self = this;
      var sent = false;
      return function() {
        if (sent)
          return;
        sent = true;
        var args = toArray(arguments);
        debug('sending ack %j', args);
        var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
        self.packet({
          type: type,
          id: id,
          data: args
        });
      };
    };
    Socket.prototype.onack = function(packet) {
      var ack = this.acks[packet.id];
      if ('function' === typeof ack) {
        debug('calling ack %s with %j', packet.id, packet.data);
        ack.apply(this, packet.data);
        delete this.acks[packet.id];
      } else {
        debug('bad ack %s', packet.id);
      }
    };
    Socket.prototype.onconnect = function() {
      this.connected = true;
      this.disconnected = false;
      this.emit('connect');
      this.emitBuffered();
    };
    Socket.prototype.emitBuffered = function() {
      var i;
      for (i = 0; i < this.receiveBuffer.length; i++) {
        emit.apply(this, this.receiveBuffer[i]);
      }
      this.receiveBuffer = [];
      for (i = 0; i < this.sendBuffer.length; i++) {
        this.packet(this.sendBuffer[i]);
      }
      this.sendBuffer = [];
    };
    Socket.prototype.ondisconnect = function() {
      debug('server disconnect (%s)', this.nsp);
      this.destroy();
      this.onclose('io server disconnect');
    };
    Socket.prototype.destroy = function() {
      if (this.subs) {
        for (var i = 0; i < this.subs.length; i++) {
          this.subs[i].destroy();
        }
        this.subs = null;
      }
      this.io.destroy(this);
    };
    Socket.prototype.close = Socket.prototype.disconnect = function() {
      if (this.connected) {
        debug('performing disconnect (%s)', this.nsp);
        this.packet({type: parser.DISCONNECT});
      }
      this.destroy();
      if (this.connected) {
        this.onclose('io client disconnect');
      }
      return this;
    };
    Socket.prototype.compress = function(compress) {
      this.flags = this.flags || {};
      this.flags.compress = compress;
      return this;
    };
  }, function(module, exports) {
    module.exports = toArray;
    function toArray(list, index) {
      var array = [];
      index = index || 0;
      for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i];
      }
      return array;
    }
  }, function(module, exports) {
    "use strict";
    module.exports = on;
    function on(obj, ev, fn) {
      obj.on(ev, fn);
      return {destroy: function destroy() {
          obj.removeListener(ev, fn);
        }};
    }
  }, function(module, exports) {
    var slice = [].slice;
    module.exports = function(obj, fn) {
      if ('string' == typeof fn)
        fn = obj[fn];
      if ('function' != typeof fn)
        throw new Error('bind() requires a function');
      var args = slice.call(arguments, 2);
      return function() {
        return fn.apply(obj, args.concat(slice.call(arguments)));
      };
    };
  }, function(module, exports) {
    module.exports = Backoff;
    function Backoff(opts) {
      opts = opts || {};
      this.ms = opts.min || 100;
      this.max = opts.max || 10000;
      this.factor = opts.factor || 2;
      this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
      this.attempts = 0;
    }
    Backoff.prototype.duration = function() {
      var ms = this.ms * Math.pow(this.factor, this.attempts++);
      if (this.jitter) {
        var rand = Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
      }
      return Math.min(ms, this.max) | 0;
    };
    Backoff.prototype.reset = function() {
      this.attempts = 0;
    };
    Backoff.prototype.setMin = function(min) {
      this.ms = min;
    };
    Backoff.prototype.setMax = function(max) {
      this.max = max;
    };
    Backoff.prototype.setJitter = function(jitter) {
      this.jitter = jitter;
    };
  }]);
});
;

})();
(function() {
var define = $__System.amdDefine;
define("20", ["1f"], function(main) {
  return main;
});

})();
$__System.register('21', ['3', '7', '13', '15', '17', '20', 'a', 'b', '1d', '1e'], function (_export) {
	var SentMessage, _classCallCheck, Sender, ConnectionEvent, Requestor, io, _createClass, ReceivedMessage, Receiver, MasterWebRTC;

	return {
		setters: [function (_2) {
			SentMessage = _2.SentMessage;
		}, function (_) {
			_classCallCheck = _['default'];
		}, function (_3) {
			Sender = _3.Sender;
		}, function (_4) {
			ConnectionEvent = _4.ConnectionEvent;
		}, function (_5) {
			Requestor = _5.Requestor;
		}, function (_6) {
			io = _6['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_b) {
			ReceivedMessage = _b.ReceivedMessage;
		}, function (_d) {
			Receiver = _d.Receiver;
		}, function (_e) {}],
		execute: function () {
			/*jshint esnext: true */

			//import 'muaz-khan/RTCMultiConnection/dist/RTCMultiConnection.js';
			// adjusted: this.onDataChannelMessage line 2426
			'use strict';

			MasterWebRTC = (function () {
				function MasterWebRTC() {
					_classCallCheck(this, MasterWebRTC);

					// connection
					window.io = io;
					this.connection = window.sst && window.sst.isDebug && window.WebRTC && window.WebRTC.connection ? window.WebRTC.connection : new RTCMultiConnection();
					//this.connection.socketURL = window.sst && window.sst.isDebug ? `http://${window.location.hostname}:9001/` : 'http://default-environment.digvjm9b3i.us-west-2.elasticbeanstalk.com:9001/'; // cd into repo: npm install --production / node server.js
					this.connection.socketURL = window.sst && window.sst.isDebug ? 'http://' + window.location.hostname + ':9001/' : 'https://rtcmulticonnection.herokuapp.com/'; // cd into repo: npm install --production / node server.js
					this.connection.session = {
						data: true,
						audio: false,
						video: false,
						screen: false
					};
					// Helper
					this.SentMessage = new SentMessage();
					this.ReceivedMessage = new ReceivedMessage();
					// Classes
					this.Sender = new Sender(this.connection, this.SentMessage);
					this.ConnectionEvent = new ConnectionEvent(this.connection, this.Sender, this.SentMessage);
					this.Requestor = new Requestor(this.Sender, this.SentMessage);
					this.Receiver = new Receiver(this.connection, this.Requestor, this.ReceivedMessage);

					// hot-reloader clear all
					if (window.sst && window.sst.isDebug) {
						window.WebRTC = this;
					}
				}

				/**
     * (api hook)
     * 
     * @memberof MasterWebRTC
     */

				_createClass(MasterWebRTC, [{
					key: 'setIgnoreOption',
					value: function setIgnoreOption() {
						this.Sender.setIgnoreOption();
						this.Receiver.setIgnoreOption();
					}

					/**
      * (api hook)
      * 
      * @memberof MasterWebRTC
      */
				}, {
					key: 'unsetIgnoreOption',
					value: function unsetIgnoreOption() {
						this.Sender.unsetIgnoreOption();
						this.Receiver.unsetIgnoreOption();
					}
				}]);

				return MasterWebRTC;
			})();

			_export('MasterWebRTC', MasterWebRTC);
		}
	};
});
$__System.register('22', ['5', '6', '7', '21'], function (_export) {
	var _get, _inherits, _classCallCheck, MasterWebRTC, WebRTC;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_4) {
			MasterWebRTC = _4.MasterWebRTC;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			WebRTC = (function (_MasterWebRTC) {
				_inherits(WebRTC, _MasterWebRTC);

				function WebRTC() {
					_classCallCheck(this, WebRTC);

					_get(Object.getPrototypeOf(WebRTC.prototype), 'constructor', this).call(this);

					// hooks
					this.api = {
						/**
       * called from dom
       * 
       * @param {string} roomid 
       * @param {string} [message=''] 
       * @param {string} [elID=''] 
       * @memberof MasterConnectionEvent
       */
						openOrJoinEvent: this.ConnectionEvent.openOrJoinEvent.bind(this.ConnectionEvent), // roomid, message = '', elID = ''
						/**
       * message, elID (used for Diff_match_patch), remoteUserId (@user), requestID (used at sendRequest)
       * 
       * @param {string} message 
       * @param {string} [elID=this.SentMessage.elID] 
       * @param {string} [remoteUserId=this.SentMessage.remoteUserId] 
       * @param {string} [requestID=''] 
       * @param {boolean} [timeout=this.timeout] 
       * @param {Map([['diffed', [0, true]], ['compressed', [1, 'auto']]])} options
       * @memberof MasterSender
       */
						sendEvent: this.Sender.sendEvent.bind(this.Sender), // message, elID = 'sst_all', remoteUserId = 'sst_toAll', requestID = '', options = new Map([['diffed', [0, true]], ['compressed', [1, 'auto']]])
						/**
       * event handler .add (.remove takes [func, scope])
       * 
       * @param {Function} func 
       * @param {string} [scope = this]
       * @param {string} [args = [message = '', elID = '']]
       * @memberof Helper
       */
						onNewParticipant: this.ConnectionEvent.onNewParticipant, // func, scope = this, args = [] ==> has to return [message = '', elID = '']
						/**
       * event handler .add (.remove takes [func, scope])
       * 
       * @param {Function} func 
       * @param {string} [scope = this]
       * @param {string} [args = [message = '', elID = '']]
       * @memberof Helper
       */
						onReceive: this.Receiver.onReceive, // func, scope = this, args = []
						/**
       * 
       * @memberof MasterWebRTC
       */
						setIgnoreOption: this.setIgnoreOption.bind(this),
						/**
       * 
       * @memberof MasterWebRTC
       */
						unsetIgnoreOption: this.unsetIgnoreOption.bind(this),
						/**
       * Map
       * 
       * @param {Map([['diffed', [0, true]], ['compressed', [1, 'auto']]])} options
       * @memberof OptionSender
       */
						options: this.Sender.OptionSender.options
					};
				}

				return WebRTC;
			})(MasterWebRTC);

			_export('WebRTC', WebRTC);
		}
	};
});
(function() {
var define = $__System.amdDefine;
(function(f) {
  if (typeof exports === "object" && typeof module !== "undefined") {
    module.exports = f();
  } else if (typeof define === "function" && define.amd) {
    define("23", [], f);
  } else {
    var g;
    if (typeof window !== "undefined") {
      g = window;
    } else if (typeof global !== "undefined") {
      g = global;
    } else if (typeof self !== "undefined") {
      g = self;
    } else {
      g = this;
    }
    g.dom2hscript = f();
  }
})(function() {
  var define,
      module,
      exports;
  return (function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == "function" && require;
          if (!u && a)
            return a(o, !0);
          if (i)
            return i(o, !0);
          var f = new Error("Cannot find module '" + o + "'");
          throw f.code = "MODULE_NOT_FOUND", f;
        }
        var l = n[o] = {exports: {}};
        t[o][0].call(l.exports, function(e) {
          var n = t[o][1][e];
          return s(n ? n : e);
        }, l, l.exports, e, t, n, r);
      }
      return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++)
      s(r[o]);
    return s;
  })({
    1: [function(require, module, exports) {
      var parser = require('./parser');
      var parseStyle = function(el) {
        var style = el.style;
        var output = {};
        for (var i = 0; i < style.length; ++i) {
          var item = style.item(i);
          output[item] = style[item];
        }
        return output;
      };
      var parseDOM = function(el) {
        if (!el.tagName && el.nodeType === Node.TEXT_NODE) {
          return JSON.stringify(el.textContent);
        }
        if (!el.attributes) {
          return;
        }
        var attributes = {};
        for (var i = 0; i < el.attributes.length; i++) {
          var attr = el.attributes[i];
          if (attr.name && typeof attr.value !== "undefined") {
            if (attr.name == "style") {
              attributes.style = parseStyle(el);
            } else {
              attributes[attr.name] = attr.value;
            }
          }
        }
        var output = "h('" + el.tagName;
        if (attributes.id) {
          output = output + '#' + attributes.id;
          delete attributes.id;
        }
        if (attributes.class) {
          output = output + '.' + attributes.class.replace(/ /g, ".");
          delete attributes.class;
        }
        output += "',";
        output += JSON.stringify(attributes);
        var children = [];
        output += ',[';
        for (var i = 0; i < el.childNodes.length; i++) {
          output += parseDOM(el.childNodes[i]) + ",";
        }
        output += "])";
        return output;
      };
      var parseHTML = function(html) {
        return parseDOM(parser(html));
      };
      exports.parseDOM = parseDOM;
      exports.parseHTML = parseHTML;
      module.exports = exports;
    }, {"./parser": 2}],
    2: [function(require, module, exports) {
      var parser;
      if (!window.DOMParser) {
        throw new Error("DOMParser required");
      }
      (function(DOMParser) {
        "use strict";
        var proto = DOMParser.prototype,
            nativeParse = proto.parseFromString;
        ;
        try {
          if ((new DOMParser()).parseFromString("", "text/html")) {
            return;
          }
        } catch (ex) {}
        proto.parseFromString = function(markup, type) {
          if (/^\s*text\/html\s*(?:;|$)/i.test(type)) {
            var doc = document.implementation.createHTMLDocument("");
            ;
            if (markup.toLowerCase().indexOf('<!doctype') > -1) {
              doc.documentElement.innerHTML = markup;
            } else {
              doc.body.innerHTML = markup;
            }
            return doc;
          } else {
            return nativeParse.apply(this, arguments);
          }
        };
      }(DOMParser));
      parser = new DOMParser();
      module.exports = function(html, strictChecking) {
        var result = parser.parseFromString(html, 'text/html');
        var el;
        if (html.substring(0, 10).match(/\<body.+/ig)) {
          el = result.getElementsByTagName('body')[0];
        } else {
          el = result.getElementsByTagName('body')[0].firstChild;
        }
        var errors = el.getElementsByTagName('parsererror');
        if (errors && errors.length > 0) {
          if (strictChecking === true) {
            throw new Error(errors[0].textContent);
          }
          for (var i = 0; i < errors.length; i++) {
            errors[i].parentElement.removeChild(errors[i]);
          }
        }
        return el;
      };
    }, {}]
  }, {}, [1])(1);
});

})();
(function() {
var define = $__System.amdDefine;
!function(e) {
  if ("object" == typeof exports && "undefined" != typeof module)
    module.exports = e();
  else if ("function" == typeof define && define.amd)
    define("24", [], e);
  else {
    var f;
    "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), f.virtualDom = e();
  }
}(function() {
  var define,
      module,
      exports;
  return (function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == "function" && require;
          if (!u && a)
            return a(o, !0);
          if (i)
            return i(o, !0);
          var f = new Error("Cannot find module '" + o + "'");
          throw f.code = "MODULE_NOT_FOUND", f;
        }
        var l = n[o] = {exports: {}};
        t[o][0].call(l.exports, function(e) {
          var n = t[o][1][e];
          return s(n ? n : e);
        }, l, l.exports, e, t, n, r);
      }
      return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++)
      s(r[o]);
    return s;
  })({
    1: [function(require, module, exports) {
      var createElement = require("./vdom/create-element.js");
      module.exports = createElement;
    }, {"./vdom/create-element.js": 15}],
    2: [function(require, module, exports) {
      var diff = require("./vtree/diff.js");
      module.exports = diff;
    }, {"./vtree/diff.js": 35}],
    3: [function(require, module, exports) {
      var h = require("./virtual-hyperscript/index.js");
      module.exports = h;
    }, {"./virtual-hyperscript/index.js": 22}],
    4: [function(require, module, exports) {
      var diff = require("./diff.js");
      var patch = require("./patch.js");
      var h = require("./h.js");
      var create = require("./create-element.js");
      var VNode = require('./vnode/vnode.js');
      var VText = require('./vnode/vtext.js');
      module.exports = {
        diff: diff,
        patch: patch,
        h: h,
        create: create,
        VNode: VNode,
        VText: VText
      };
    }, {
      "./create-element.js": 1,
      "./diff.js": 2,
      "./h.js": 3,
      "./patch.js": 13,
      "./vnode/vnode.js": 31,
      "./vnode/vtext.js": 33
    }],
    5: [function(require, module, exports) {
      module.exports = (function split(undef) {
        var nativeSplit = String.prototype.split,
            compliantExecNpcg = /()??/.exec("")[1] === undef,
            self;
        self = function(str, separator, limit) {
          if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
            return nativeSplit.call(str, separator, limit);
          }
          var output = [],
              flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + (separator.sticky ? "y" : ""),
              lastLastIndex = 0,
              separator = new RegExp(separator.source, flags + "g"),
              separator2,
              match,
              lastIndex,
              lastLength;
          str += "";
          if (!compliantExecNpcg) {
            separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
          }
          limit = limit === undef ? -1 >>> 0 : limit >>> 0;
          while (match = separator.exec(str)) {
            lastIndex = match.index + match[0].length;
            if (lastIndex > lastLastIndex) {
              output.push(str.slice(lastLastIndex, match.index));
              if (!compliantExecNpcg && match.length > 1) {
                match[0].replace(separator2, function() {
                  for (var i = 1; i < arguments.length - 2; i++) {
                    if (arguments[i] === undef) {
                      match[i] = undef;
                    }
                  }
                });
              }
              if (match.length > 1 && match.index < str.length) {
                Array.prototype.push.apply(output, match.slice(1));
              }
              lastLength = match[0].length;
              lastLastIndex = lastIndex;
              if (output.length >= limit) {
                break;
              }
            }
            if (separator.lastIndex === match.index) {
              separator.lastIndex++;
            }
          }
          if (lastLastIndex === str.length) {
            if (lastLength || !separator.test("")) {
              output.push("");
            }
          } else {
            output.push(str.slice(lastLastIndex));
          }
          return output.length > limit ? output.slice(0, limit) : output;
        };
        return self;
      })();
    }, {}],
    6: [function(require, module, exports) {}, {}],
    7: [function(require, module, exports) {
      'use strict';
      var OneVersionConstraint = require('individual/one-version');
      var MY_VERSION = '7';
      OneVersionConstraint('ev-store', MY_VERSION);
      var hashKey = '__EV_STORE_KEY@' + MY_VERSION;
      module.exports = EvStore;
      function EvStore(elem) {
        var hash = elem[hashKey];
        if (!hash) {
          hash = elem[hashKey] = {};
        }
        return hash;
      }
    }, {"individual/one-version": 9}],
    8: [function(require, module, exports) {
      (function(global) {
        'use strict';
        var root = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {};
        module.exports = Individual;
        function Individual(key, value) {
          if (key in root) {
            return root[key];
          }
          root[key] = value;
          return value;
        }
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}],
    9: [function(require, module, exports) {
      'use strict';
      var Individual = require('./index.js');
      module.exports = OneVersion;
      function OneVersion(moduleName, version, defaultValue) {
        var key = '__INDIVIDUAL_ONE_VERSION_' + moduleName;
        var enforceKey = key + '_ENFORCE_SINGLETON';
        var versionValue = Individual(enforceKey, version);
        if (versionValue !== version) {
          throw new Error('Can only have one copy of ' + moduleName + '.\n' + 'You already have version ' + versionValue + ' installed.\n' + 'This means you cannot install version ' + version);
        }
        return Individual(key, defaultValue);
      }
    }, {"./index.js": 8}],
    10: [function(require, module, exports) {
      (function(global) {
        var topLevel = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : {};
        var minDoc = require('min-document');
        if (typeof document !== 'undefined') {
          module.exports = document;
        } else {
          var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];
          if (!doccy) {
            doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
          }
          module.exports = doccy;
        }
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {"min-document": 6}],
    11: [function(require, module, exports) {
      "use strict";
      module.exports = function isObject(x) {
        return typeof x === "object" && x !== null;
      };
    }, {}],
    12: [function(require, module, exports) {
      var nativeIsArray = Array.isArray;
      var toString = Object.prototype.toString;
      module.exports = nativeIsArray || isArray;
      function isArray(obj) {
        return toString.call(obj) === "[object Array]";
      }
    }, {}],
    13: [function(require, module, exports) {
      var patch = require("./vdom/patch.js");
      module.exports = patch;
    }, {"./vdom/patch.js": 18}],
    14: [function(require, module, exports) {
      var isObject = require("is-object");
      var isHook = require("../vnode/is-vhook.js");
      module.exports = applyProperties;
      function applyProperties(node, props, previous) {
        for (var propName in props) {
          var propValue = props[propName];
          if (propValue === undefined) {
            removeProperty(node, propName, propValue, previous);
          } else if (isHook(propValue)) {
            removeProperty(node, propName, propValue, previous);
            if (propValue.hook) {
              propValue.hook(node, propName, previous ? previous[propName] : undefined);
            }
          } else {
            if (isObject(propValue)) {
              patchObject(node, props, previous, propName, propValue);
            } else {
              propName === 'className' ? node[propName] = propValue : node.setAttribute(propName, propValue);
            }
          }
        }
      }
      function removeProperty(node, propName, propValue, previous) {
        if (previous) {
          var previousValue = previous[propName];
          if (!isHook(previousValue)) {
            if (propName === "attributes") {
              for (var attrName in previousValue) {
                node.removeAttribute(attrName);
              }
            } else if (propName === "style") {
              for (var i in previousValue) {
                node.style[i] = "";
              }
            } else if (typeof previousValue === "string") {
              node[propName] = "";
            } else {
              node[propName] = null;
            }
          } else if (previousValue.unhook) {
            previousValue.unhook(node, propName, propValue);
          }
        }
      }
      function patchObject(node, props, previous, propName, propValue) {
        var previousValue = previous ? previous[propName] : undefined;
        if (propName === "attributes") {
          for (var attrName in propValue) {
            var attrValue = propValue[attrName];
            if (attrValue === undefined) {
              node.removeAttribute(attrName);
            } else {
              node.setAttribute(attrName, attrValue);
            }
          }
          return;
        }
        if (previousValue && isObject(previousValue) && getPrototype(previousValue) !== getPrototype(propValue)) {
          node[propName] = propValue;
          return;
        }
        if (!isObject(node[propName])) {
          node[propName] = {};
        }
        var replacer = propName === "style" ? "" : undefined;
        for (var k in propValue) {
          var value = propValue[k];
          node[propName][k] = (value === undefined) ? replacer : value;
        }
      }
      function getPrototype(value) {
        if (Object.getPrototypeOf) {
          return Object.getPrototypeOf(value);
        } else if (value.__proto__) {
          return value.__proto__;
        } else if (value.constructor) {
          return value.constructor.prototype;
        }
      }
    }, {
      "../vnode/is-vhook.js": 26,
      "is-object": 11
    }],
    15: [function(require, module, exports) {
      var document = require("global/document");
      var applyProperties = require("./apply-properties");
      var isVNode = require("../vnode/is-vnode.js");
      var isVText = require("../vnode/is-vtext.js");
      var isWidget = require("../vnode/is-widget.js");
      var handleThunk = require("../vnode/handle-thunk.js");
      module.exports = createElement;
      function createElement(vnode, opts) {
        var doc = opts ? opts.document || document : document;
        var warn = opts ? opts.warn : null;
        vnode = handleThunk(vnode).a;
        if (isWidget(vnode)) {
          return vnode.init();
        } else if (isVText(vnode)) {
          return doc.createTextNode(vnode.text);
        } else if (!isVNode(vnode)) {
          if (warn) {
            warn("Item is not a valid virtual dom node", vnode);
          }
          return null;
        }
        var node = (vnode.namespace === null) ? doc.createElement(vnode.tagName) : doc.createElementNS(vnode.namespace, vnode.tagName);
        var props = vnode.properties;
        applyProperties(node, props);
        var children = vnode.children;
        for (var i = 0; i < children.length; i++) {
          var childNode = createElement(children[i], opts);
          if (childNode) {
            node.appendChild(childNode);
          }
        }
        return node;
      }
    }, {
      "../vnode/handle-thunk.js": 24,
      "../vnode/is-vnode.js": 27,
      "../vnode/is-vtext.js": 28,
      "../vnode/is-widget.js": 29,
      "./apply-properties": 14,
      "global/document": 10
    }],
    16: [function(require, module, exports) {
      var noChild = {};
      module.exports = domIndex;
      function domIndex(rootNode, tree, indices, nodes) {
        if (!indices || indices.length === 0) {
          return {};
        } else {
          indices.sort(ascending);
          return recurse(rootNode, tree, indices, nodes, 0);
        }
      }
      function recurse(rootNode, tree, indices, nodes, rootIndex) {
        nodes = nodes || {};
        if (rootNode) {
          if (indexInRange(indices, rootIndex, rootIndex)) {
            nodes[rootIndex] = rootNode;
          }
          var vChildren = tree.children;
          if (vChildren) {
            var childNodes = rootNode.childNodes;
            for (var i = 0; i < tree.children.length; i++) {
              rootIndex += 1;
              var vChild = vChildren[i] || noChild;
              var nextIndex = rootIndex + (vChild.count || 0);
              if (indexInRange(indices, rootIndex, nextIndex)) {
                recurse(childNodes[i], vChild, indices, nodes, rootIndex);
              }
              rootIndex = nextIndex;
            }
          }
        }
        return nodes;
      }
      function indexInRange(indices, left, right) {
        if (indices.length === 0) {
          return false;
        }
        var minIndex = 0;
        var maxIndex = indices.length - 1;
        var currentIndex;
        var currentItem;
        while (minIndex <= maxIndex) {
          currentIndex = ((maxIndex + minIndex) / 2) >> 0;
          currentItem = indices[currentIndex];
          if (minIndex === maxIndex) {
            return currentItem >= left && currentItem <= right;
          } else if (currentItem < left) {
            minIndex = currentIndex + 1;
          } else if (currentItem > right) {
            maxIndex = currentIndex - 1;
          } else {
            return true;
          }
        }
        return false;
      }
      function ascending(a, b) {
        return a > b ? 1 : -1;
      }
    }, {}],
    17: [function(require, module, exports) {
      var applyProperties = require("./apply-properties");
      var isWidget = require("../vnode/is-widget.js");
      var VPatch = require("../vnode/vpatch.js");
      var updateWidget = require("./update-widget");
      module.exports = applyPatch;
      function applyPatch(vpatch, domNode, renderOptions) {
        var type = vpatch.type;
        var vNode = vpatch.vNode;
        var patch = vpatch.patch;
        switch (type) {
          case VPatch.REMOVE:
            return removeNode(domNode, vNode);
          case VPatch.INSERT:
            return insertNode(domNode, patch, renderOptions);
          case VPatch.VTEXT:
            return stringPatch(domNode, vNode, patch, renderOptions);
          case VPatch.WIDGET:
            return widgetPatch(domNode, vNode, patch, renderOptions);
          case VPatch.VNODE:
            return vNodePatch(domNode, vNode, patch, renderOptions);
          case VPatch.ORDER:
            reorderChildren(domNode, patch);
            return domNode;
          case VPatch.PROPS:
            applyProperties(domNode, patch, vNode.properties);
            return domNode;
          case VPatch.THUNK:
            return replaceRoot(domNode, renderOptions.patch(domNode, patch, renderOptions));
          default:
            return domNode;
        }
      }
      function removeNode(domNode, vNode) {
        var parentNode = domNode.parentNode;
        if (parentNode) {
          parentNode.removeChild(domNode);
        }
        destroyWidget(domNode, vNode);
        return null;
      }
      function insertNode(parentNode, vNode, renderOptions) {
        var newNode = renderOptions.render(vNode, renderOptions);
        if (parentNode) {
          parentNode.appendChild(newNode);
        }
        return parentNode;
      }
      function stringPatch(domNode, leftVNode, vText, renderOptions) {
        var newNode;
        if (domNode.nodeType === 3) {
          domNode.replaceData(0, domNode.length, vText.text);
          newNode = domNode;
        } else {
          var parentNode = domNode.parentNode;
          newNode = renderOptions.render(vText, renderOptions);
          if (parentNode && newNode !== domNode) {
            parentNode.replaceChild(newNode, domNode);
          }
        }
        return newNode;
      }
      function widgetPatch(domNode, leftVNode, widget, renderOptions) {
        var updating = updateWidget(leftVNode, widget);
        var newNode;
        if (updating) {
          newNode = widget.update(leftVNode, domNode) || domNode;
        } else {
          newNode = renderOptions.render(widget, renderOptions);
        }
        var parentNode = domNode.parentNode;
        if (parentNode && newNode !== domNode) {
          parentNode.replaceChild(newNode, domNode);
        }
        if (!updating) {
          destroyWidget(domNode, leftVNode);
        }
        return newNode;
      }
      function vNodePatch(domNode, leftVNode, vNode, renderOptions) {
        var parentNode = domNode.parentNode;
        var newNode = renderOptions.render(vNode, renderOptions);
        if (parentNode && newNode !== domNode) {
          parentNode.replaceChild(newNode, domNode);
        }
        return newNode;
      }
      function destroyWidget(domNode, w) {
        if (typeof w.destroy === "function" && isWidget(w)) {
          w.destroy(domNode);
        }
      }
      function reorderChildren(domNode, moves) {
        var childNodes = domNode.childNodes;
        var keyMap = {};
        var node;
        var remove;
        var insert;
        for (var i = 0; i < moves.removes.length; i++) {
          remove = moves.removes[i];
          node = childNodes[remove.from];
          if (remove.key) {
            keyMap[remove.key] = node;
          }
          domNode.removeChild(node);
        }
        var length = childNodes.length;
        for (var j = 0; j < moves.inserts.length; j++) {
          insert = moves.inserts[j];
          node = keyMap[insert.key];
          domNode.insertBefore(node, insert.to >= length++ ? null : childNodes[insert.to]);
        }
      }
      function replaceRoot(oldRoot, newRoot) {
        if (oldRoot && newRoot && oldRoot !== newRoot && oldRoot.parentNode) {
          oldRoot.parentNode.replaceChild(newRoot, oldRoot);
        }
        return newRoot;
      }
    }, {
      "../vnode/is-widget.js": 29,
      "../vnode/vpatch.js": 32,
      "./apply-properties": 14,
      "./update-widget": 19
    }],
    18: [function(require, module, exports) {
      var document = require("global/document");
      var isArray = require("x-is-array");
      var render = require("./create-element");
      var domIndex = require("./dom-index");
      var patchOp = require("./patch-op");
      module.exports = patch;
      function patch(rootNode, patches, renderOptions) {
        renderOptions = renderOptions || {};
        renderOptions.patch = renderOptions.patch && renderOptions.patch !== patch ? renderOptions.patch : patchRecursive;
        renderOptions.render = renderOptions.render || render;
        return renderOptions.patch(rootNode, patches, renderOptions);
      }
      function patchRecursive(rootNode, patches, renderOptions) {
        var indices = patchIndices(patches);
        if (indices.length === 0) {
          return rootNode;
        }
        var index = domIndex(rootNode, patches.a, indices);
        var ownerDocument = rootNode.ownerDocument;
        if (!renderOptions.document && ownerDocument !== document) {
          renderOptions.document = ownerDocument;
        }
        for (var i = 0; i < indices.length; i++) {
          var nodeIndex = indices[i];
          rootNode = applyPatch(rootNode, index[nodeIndex], patches[nodeIndex], renderOptions);
        }
        return rootNode;
      }
      function applyPatch(rootNode, domNode, patchList, renderOptions) {
        if (!domNode) {
          return rootNode;
        }
        var newNode;
        if (isArray(patchList)) {
          for (var i = 0; i < patchList.length; i++) {
            newNode = patchOp(patchList[i], domNode, renderOptions);
            if (domNode === rootNode) {
              rootNode = newNode;
            }
          }
        } else {
          newNode = patchOp(patchList, domNode, renderOptions);
          if (domNode === rootNode) {
            rootNode = newNode;
          }
        }
        return rootNode;
      }
      function patchIndices(patches) {
        var indices = [];
        for (var key in patches) {
          if (key !== "a") {
            indices.push(Number(key));
          }
        }
        return indices;
      }
    }, {
      "./create-element": 15,
      "./dom-index": 16,
      "./patch-op": 17,
      "global/document": 10,
      "x-is-array": 12
    }],
    19: [function(require, module, exports) {
      var isWidget = require("../vnode/is-widget.js");
      module.exports = updateWidget;
      function updateWidget(a, b) {
        if (isWidget(a) && isWidget(b)) {
          if ("name" in a && "name" in b) {
            return a.id === b.id;
          } else {
            return a.init === b.init;
          }
        }
        return false;
      }
    }, {"../vnode/is-widget.js": 29}],
    20: [function(require, module, exports) {
      'use strict';
      var EvStore = require('ev-store');
      module.exports = EvHook;
      function EvHook(value) {
        if (!(this instanceof EvHook)) {
          return new EvHook(value);
        }
        this.value = value;
      }
      EvHook.prototype.hook = function(node, propertyName) {
        var es = EvStore(node);
        var propName = propertyName.substr(3);
        es[propName] = this.value;
      };
      EvHook.prototype.unhook = function(node, propertyName) {
        var es = EvStore(node);
        var propName = propertyName.substr(3);
        es[propName] = undefined;
      };
    }, {"ev-store": 7}],
    21: [function(require, module, exports) {
      'use strict';
      module.exports = SoftSetHook;
      function SoftSetHook(value) {
        if (!(this instanceof SoftSetHook)) {
          return new SoftSetHook(value);
        }
        this.value = value;
      }
      SoftSetHook.prototype.hook = function(node, propertyName) {
        if (node[propertyName] !== this.value) {
          node[propertyName] = this.value;
        }
      };
    }, {}],
    22: [function(require, module, exports) {
      'use strict';
      var isArray = require('x-is-array');
      var VNode = require('../vnode/vnode.js');
      var VText = require('../vnode/vtext.js');
      var isVNode = require('../vnode/is-vnode');
      var isVText = require('../vnode/is-vtext');
      var isWidget = require('../vnode/is-widget');
      var isHook = require('../vnode/is-vhook');
      var isVThunk = require('../vnode/is-thunk');
      var parseTag = require('./parse-tag.js');
      var softSetHook = require('./hooks/soft-set-hook.js');
      var evHook = require('./hooks/ev-hook.js');
      module.exports = h;
      function h(tagName, properties, children) {
        var childNodes = [];
        var tag,
            props,
            key,
            namespace;
        if (!children && isChildren(properties)) {
          children = properties;
          props = {};
        }
        props = props || properties || {};
        tag = parseTag(tagName, props);
        if (props.hasOwnProperty('key')) {
          key = props.key;
          props.key = undefined;
        }
        if (props.hasOwnProperty('namespace')) {
          namespace = props.namespace;
          props.namespace = undefined;
        }
        if (tag === 'INPUT' && !namespace && props.hasOwnProperty('value') && props.value !== undefined && !isHook(props.value)) {
          props.value = softSetHook(props.value);
        }
        transformProperties(props);
        if (children !== undefined && children !== null) {
          addChild(children, childNodes, tag, props);
        }
        return new VNode(tag, props, childNodes, key, namespace);
      }
      function addChild(c, childNodes, tag, props) {
        if (typeof c === 'string') {
          childNodes.push(new VText(c));
        } else if (typeof c === 'number') {
          childNodes.push(new VText(String(c)));
        } else if (isChild(c)) {
          childNodes.push(c);
        } else if (isArray(c)) {
          for (var i = 0; i < c.length; i++) {
            addChild(c[i], childNodes, tag, props);
          }
        } else if (c === null || c === undefined) {
          return;
        } else {
          throw UnexpectedVirtualElement({
            foreignObject: c,
            parentVnode: {
              tagName: tag,
              properties: props
            }
          });
        }
      }
      function transformProperties(props) {
        for (var propName in props) {
          if (props.hasOwnProperty(propName)) {
            var value = props[propName];
            if (isHook(value)) {
              continue;
            }
            if (propName.substr(0, 3) === 'ev-') {
              props[propName] = evHook(value);
            }
          }
        }
      }
      function isChild(x) {
        return isVNode(x) || isVText(x) || isWidget(x) || isVThunk(x);
      }
      function isChildren(x) {
        return typeof x === 'string' || isArray(x) || isChild(x);
      }
      function UnexpectedVirtualElement(data) {
        var err = new Error();
        err.type = 'virtual-hyperscript.unexpected.virtual-element';
        err.message = 'Unexpected virtual child passed to h().\n' + 'Expected a VNode / Vthunk / VWidget / string but:\n' + 'got:\n' + errorString(data.foreignObject) + '.\n' + 'The parent vnode is:\n' + errorString(data.parentVnode);
        '\n' + 'Suggested fix: change your `h(..., [ ... ])` callsite.';
        err.foreignObject = data.foreignObject;
        err.parentVnode = data.parentVnode;
        return err;
      }
      function errorString(obj) {
        try {
          return JSON.stringify(obj, null, '    ');
        } catch (e) {
          return String(obj);
        }
      }
    }, {
      "../vnode/is-thunk": 25,
      "../vnode/is-vhook": 26,
      "../vnode/is-vnode": 27,
      "../vnode/is-vtext": 28,
      "../vnode/is-widget": 29,
      "../vnode/vnode.js": 31,
      "../vnode/vtext.js": 33,
      "./hooks/ev-hook.js": 20,
      "./hooks/soft-set-hook.js": 21,
      "./parse-tag.js": 23,
      "x-is-array": 12
    }],
    23: [function(require, module, exports) {
      'use strict';
      var split = require('browser-split');
      var classIdSplit = /([\.#]?[a-zA-Z0-9\u007F-\uFFFF_:-]+)/;
      var notClassId = /^\.|#/;
      module.exports = parseTag;
      function parseTag(tag, props) {
        if (!tag) {
          return 'DIV';
        }
        var noId = !(props.hasOwnProperty('id'));
        var tagParts = split(tag, classIdSplit);
        var tagName = null;
        if (notClassId.test(tagParts[1])) {
          tagName = 'DIV';
        }
        var classes,
            part,
            type,
            i;
        for (i = 0; i < tagParts.length; i++) {
          part = tagParts[i];
          if (!part) {
            continue;
          }
          type = part.charAt(0);
          if (!tagName) {
            tagName = part;
          } else if (type === '.') {
            classes = classes || [];
            classes.push(part.substring(1, part.length));
          } else if (type === '#' && noId) {
            props.id = part.substring(1, part.length);
          }
        }
        if (classes) {
          if (props.className) {
            classes.push(props.className);
          }
          props.className = classes.join(' ');
        }
        return props.namespace ? tagName : tagName.toUpperCase();
      }
    }, {"browser-split": 5}],
    24: [function(require, module, exports) {
      var isVNode = require("./is-vnode");
      var isVText = require("./is-vtext");
      var isWidget = require("./is-widget");
      var isThunk = require("./is-thunk");
      module.exports = handleThunk;
      function handleThunk(a, b) {
        var renderedA = a;
        var renderedB = b;
        if (isThunk(b)) {
          renderedB = renderThunk(b, a);
        }
        if (isThunk(a)) {
          renderedA = renderThunk(a, null);
        }
        return {
          a: renderedA,
          b: renderedB
        };
      }
      function renderThunk(thunk, previous) {
        var renderedThunk = thunk.vnode;
        if (!renderedThunk) {
          renderedThunk = thunk.vnode = thunk.render(previous);
        }
        if (!(isVNode(renderedThunk) || isVText(renderedThunk) || isWidget(renderedThunk))) {
          throw new Error("thunk did not return a valid node");
        }
        return renderedThunk;
      }
    }, {
      "./is-thunk": 25,
      "./is-vnode": 27,
      "./is-vtext": 28,
      "./is-widget": 29
    }],
    25: [function(require, module, exports) {
      module.exports = isThunk;
      function isThunk(t) {
        return t && t.type === "Thunk";
      }
    }, {}],
    26: [function(require, module, exports) {
      module.exports = isHook;
      function isHook(hook) {
        return hook && (typeof hook.hook === "function" && !hook.hasOwnProperty("hook") || typeof hook.unhook === "function" && !hook.hasOwnProperty("unhook"));
      }
    }, {}],
    27: [function(require, module, exports) {
      var version = require("./version");
      module.exports = isVirtualNode;
      function isVirtualNode(x) {
        return x && x.type === "VirtualNode" && x.version === version;
      }
    }, {"./version": 30}],
    28: [function(require, module, exports) {
      var version = require("./version");
      module.exports = isVirtualText;
      function isVirtualText(x) {
        return x && x.type === "VirtualText" && x.version === version;
      }
    }, {"./version": 30}],
    29: [function(require, module, exports) {
      module.exports = isWidget;
      function isWidget(w) {
        return w && w.type === "Widget";
      }
    }, {}],
    30: [function(require, module, exports) {
      module.exports = "2";
    }, {}],
    31: [function(require, module, exports) {
      var version = require("./version");
      var isVNode = require("./is-vnode");
      var isWidget = require("./is-widget");
      var isThunk = require("./is-thunk");
      var isVHook = require("./is-vhook");
      module.exports = VirtualNode;
      var noProperties = {};
      var noChildren = [];
      function VirtualNode(tagName, properties, children, key, namespace) {
        this.tagName = tagName;
        this.properties = properties || noProperties;
        this.children = children || noChildren;
        this.key = key != null ? String(key) : undefined;
        this.namespace = (typeof namespace === "string") ? namespace : null;
        var count = (children && children.length) || 0;
        var descendants = 0;
        var hasWidgets = false;
        var hasThunks = false;
        var descendantHooks = false;
        var hooks;
        for (var propName in properties) {
          if (properties.hasOwnProperty(propName)) {
            var property = properties[propName];
            if (isVHook(property) && property.unhook) {
              if (!hooks) {
                hooks = {};
              }
              hooks[propName] = property;
            }
          }
        }
        for (var i = 0; i < count; i++) {
          var child = children[i];
          if (isVNode(child)) {
            descendants += child.count || 0;
            if (!hasWidgets && child.hasWidgets) {
              hasWidgets = true;
            }
            if (!hasThunks && child.hasThunks) {
              hasThunks = true;
            }
            if (!descendantHooks && (child.hooks || child.descendantHooks)) {
              descendantHooks = true;
            }
          } else if (!hasWidgets && isWidget(child)) {
            if (typeof child.destroy === "function") {
              hasWidgets = true;
            }
          } else if (!hasThunks && isThunk(child)) {
            hasThunks = true;
          }
        }
        this.count = count + descendants;
        this.hasWidgets = hasWidgets;
        this.hasThunks = hasThunks;
        this.hooks = hooks;
        this.descendantHooks = descendantHooks;
      }
      VirtualNode.prototype.version = version;
      VirtualNode.prototype.type = "VirtualNode";
    }, {
      "./is-thunk": 25,
      "./is-vhook": 26,
      "./is-vnode": 27,
      "./is-widget": 29,
      "./version": 30
    }],
    32: [function(require, module, exports) {
      var version = require("./version");
      VirtualPatch.NONE = 0;
      VirtualPatch.VTEXT = 1;
      VirtualPatch.VNODE = 2;
      VirtualPatch.WIDGET = 3;
      VirtualPatch.PROPS = 4;
      VirtualPatch.ORDER = 5;
      VirtualPatch.INSERT = 6;
      VirtualPatch.REMOVE = 7;
      VirtualPatch.THUNK = 8;
      module.exports = VirtualPatch;
      function VirtualPatch(type, vNode, patch) {
        this.type = Number(type);
        this.vNode = vNode;
        this.patch = patch;
      }
      VirtualPatch.prototype.version = version;
      VirtualPatch.prototype.type = "VirtualPatch";
    }, {"./version": 30}],
    33: [function(require, module, exports) {
      var version = require("./version");
      module.exports = VirtualText;
      function VirtualText(text) {
        this.text = String(text);
      }
      VirtualText.prototype.version = version;
      VirtualText.prototype.type = "VirtualText";
    }, {"./version": 30}],
    34: [function(require, module, exports) {
      var isObject = require("is-object");
      var isHook = require("../vnode/is-vhook");
      module.exports = diffProps;
      function diffProps(a, b) {
        var diff;
        for (var aKey in a) {
          if (!(aKey in b)) {
            diff = diff || {};
            diff[aKey] = undefined;
          }
          var aValue = a[aKey];
          var bValue = b[aKey];
          if (aValue === bValue) {
            continue;
          } else if (isObject(aValue) && isObject(bValue)) {
            if (getPrototype(bValue) !== getPrototype(aValue)) {
              diff = diff || {};
              diff[aKey] = bValue;
            } else if (isHook(bValue)) {
              diff = diff || {};
              diff[aKey] = bValue;
            } else {
              var objectDiff = diffProps(aValue, bValue);
              if (objectDiff) {
                diff = diff || {};
                diff[aKey] = objectDiff;
              }
            }
          } else {
            diff = diff || {};
            diff[aKey] = bValue;
          }
        }
        for (var bKey in b) {
          if (!(bKey in a)) {
            diff = diff || {};
            diff[bKey] = b[bKey];
          }
        }
        return diff;
      }
      function getPrototype(value) {
        if (Object.getPrototypeOf) {
          return Object.getPrototypeOf(value);
        } else if (value.__proto__) {
          return value.__proto__;
        } else if (value.constructor) {
          return value.constructor.prototype;
        }
      }
    }, {
      "../vnode/is-vhook": 26,
      "is-object": 11
    }],
    35: [function(require, module, exports) {
      var isArray = require("x-is-array");
      var VPatch = require("../vnode/vpatch");
      var isVNode = require("../vnode/is-vnode");
      var isVText = require("../vnode/is-vtext");
      var isWidget = require("../vnode/is-widget");
      var isThunk = require("../vnode/is-thunk");
      var handleThunk = require("../vnode/handle-thunk");
      var diffProps = require("./diff-props");
      module.exports = diff;
      function diff(a, b) {
        var patch = {a: a};
        walk(a, b, patch, 0);
        return patch;
      }
      function walk(a, b, patch, index) {
        if (a === b) {
          return;
        }
        var apply = patch[index];
        var applyClear = false;
        if (isThunk(a) || isThunk(b)) {
          thunks(a, b, patch, index);
        } else if (b == null) {
          if (!isWidget(a)) {
            clearState(a, patch, index);
            apply = patch[index];
          }
          apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b));
        } else if (isVNode(b)) {
          if (isVNode(a)) {
            if (a.tagName === b.tagName && a.namespace === b.namespace && a.key === b.key) {
              var propsPatch = diffProps(a.properties, b.properties);
              if (propsPatch) {
                apply = appendPatch(apply, new VPatch(VPatch.PROPS, a, propsPatch));
              }
              apply = diffChildren(a, b, patch, apply, index);
            } else {
              apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b));
              applyClear = true;
            }
          } else {
            apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b));
            applyClear = true;
          }
        } else if (isVText(b)) {
          if (!isVText(a)) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b));
            applyClear = true;
          } else if (a.text !== b.text) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b));
          }
        } else if (isWidget(b)) {
          if (!isWidget(a)) {
            applyClear = true;
          }
          apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b));
        }
        if (apply) {
          patch[index] = apply;
        }
        if (applyClear) {
          clearState(a, patch, index);
        }
      }
      function diffChildren(a, b, patch, apply, index) {
        var aChildren = a.children;
        var orderedSet = reorder(aChildren, b.children);
        var bChildren = orderedSet.children;
        var aLen = aChildren.length;
        var bLen = bChildren.length;
        var len = aLen > bLen ? aLen : bLen;
        for (var i = 0; i < len; i++) {
          var leftNode = aChildren[i];
          var rightNode = bChildren[i];
          index += 1;
          if (!leftNode) {
            if (rightNode) {
              apply = appendPatch(apply, new VPatch(VPatch.INSERT, null, rightNode));
            }
          } else {
            walk(leftNode, rightNode, patch, index);
          }
          if (isVNode(leftNode) && leftNode.count) {
            index += leftNode.count;
          }
        }
        if (orderedSet.moves) {
          apply = appendPatch(apply, new VPatch(VPatch.ORDER, a, orderedSet.moves));
        }
        return apply;
      }
      function clearState(vNode, patch, index) {
        unhook(vNode, patch, index);
        destroyWidgets(vNode, patch, index);
      }
      function destroyWidgets(vNode, patch, index) {
        if (isWidget(vNode)) {
          if (typeof vNode.destroy === "function") {
            patch[index] = appendPatch(patch[index], new VPatch(VPatch.REMOVE, vNode, null));
          }
        } else if (isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks)) {
          var children = vNode.children;
          var len = children.length;
          for (var i = 0; i < len; i++) {
            var child = children[i];
            index += 1;
            destroyWidgets(child, patch, index);
            if (isVNode(child) && child.count) {
              index += child.count;
            }
          }
        } else if (isThunk(vNode)) {
          thunks(vNode, null, patch, index);
        }
      }
      function thunks(a, b, patch, index) {
        var nodes = handleThunk(a, b);
        var thunkPatch = diff(nodes.a, nodes.b);
        if (hasPatches(thunkPatch)) {
          patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch);
        }
      }
      function hasPatches(patch) {
        for (var index in patch) {
          if (index !== "a") {
            return true;
          }
        }
        return false;
      }
      function unhook(vNode, patch, index) {
        if (isVNode(vNode)) {
          if (vNode.hooks) {
            patch[index] = appendPatch(patch[index], new VPatch(VPatch.PROPS, vNode, undefinedKeys(vNode.hooks)));
          }
          if (vNode.descendantHooks || vNode.hasThunks) {
            var children = vNode.children;
            var len = children.length;
            for (var i = 0; i < len; i++) {
              var child = children[i];
              index += 1;
              unhook(child, patch, index);
              if (isVNode(child) && child.count) {
                index += child.count;
              }
            }
          }
        } else if (isThunk(vNode)) {
          thunks(vNode, null, patch, index);
        }
      }
      function undefinedKeys(obj) {
        var result = {};
        for (var key in obj) {
          result[key] = undefined;
        }
        return result;
      }
      function reorder(aChildren, bChildren) {
        var bChildIndex = keyIndex(bChildren);
        var bKeys = bChildIndex.keys;
        var bFree = bChildIndex.free;
        if (bFree.length === bChildren.length) {
          return {
            children: bChildren,
            moves: null
          };
        }
        var aChildIndex = keyIndex(aChildren);
        var aKeys = aChildIndex.keys;
        var aFree = aChildIndex.free;
        if (aFree.length === aChildren.length) {
          return {
            children: bChildren,
            moves: null
          };
        }
        var newChildren = [];
        var freeIndex = 0;
        var freeCount = bFree.length;
        var deletedItems = 0;
        for (var i = 0; i < aChildren.length; i++) {
          var aItem = aChildren[i];
          var itemIndex;
          if (aItem.key) {
            if (bKeys.hasOwnProperty(aItem.key)) {
              itemIndex = bKeys[aItem.key];
              newChildren.push(bChildren[itemIndex]);
            } else {
              itemIndex = i - deletedItems++;
              newChildren.push(null);
            }
          } else {
            if (freeIndex < freeCount) {
              itemIndex = bFree[freeIndex++];
              newChildren.push(bChildren[itemIndex]);
            } else {
              itemIndex = i - deletedItems++;
              newChildren.push(null);
            }
          }
        }
        var lastFreeIndex = freeIndex >= bFree.length ? bChildren.length : bFree[freeIndex];
        for (var j = 0; j < bChildren.length; j++) {
          var newItem = bChildren[j];
          if (newItem.key) {
            if (!aKeys.hasOwnProperty(newItem.key)) {
              newChildren.push(newItem);
            }
          } else if (j >= lastFreeIndex) {
            newChildren.push(newItem);
          }
        }
        var simulate = newChildren.slice();
        var simulateIndex = 0;
        var removes = [];
        var inserts = [];
        var simulateItem;
        for (var k = 0; k < bChildren.length; ) {
          var wantedItem = bChildren[k];
          simulateItem = simulate[simulateIndex];
          while (simulateItem === null && simulate.length) {
            removes.push(remove(simulate, simulateIndex, null));
            simulateItem = simulate[simulateIndex];
          }
          if (!simulateItem || simulateItem.key !== wantedItem.key) {
            if (wantedItem.key) {
              if (simulateItem && simulateItem.key) {
                if (bKeys[simulateItem.key] !== k + 1) {
                  removes.push(remove(simulate, simulateIndex, simulateItem.key));
                  simulateItem = simulate[simulateIndex];
                  if (!simulateItem || simulateItem.key !== wantedItem.key) {
                    inserts.push({
                      key: wantedItem.key,
                      to: k
                    });
                  } else {
                    simulateIndex++;
                  }
                } else {
                  inserts.push({
                    key: wantedItem.key,
                    to: k
                  });
                }
              } else {
                inserts.push({
                  key: wantedItem.key,
                  to: k
                });
              }
              k++;
            } else if (simulateItem && simulateItem.key) {
              removes.push(remove(simulate, simulateIndex, simulateItem.key));
            }
          } else {
            simulateIndex++;
            k++;
          }
        }
        while (simulateIndex < simulate.length) {
          simulateItem = simulate[simulateIndex];
          removes.push(remove(simulate, simulateIndex, simulateItem && simulateItem.key));
        }
        if (removes.length === deletedItems && !inserts.length) {
          return {
            children: newChildren,
            moves: null
          };
        }
        return {
          children: newChildren,
          moves: {
            removes: removes,
            inserts: inserts
          }
        };
      }
      function remove(arr, index, key) {
        arr.splice(index, 1);
        return {
          from: index,
          key: key
        };
      }
      function keyIndex(children) {
        var keys = {};
        var free = [];
        var length = children.length;
        for (var i = 0; i < length; i++) {
          var child = children[i];
          if (child.key) {
            keys[child.key] = i;
          } else {
            free.push(i);
          }
        }
        return {
          keys: keys,
          free: free
        };
      }
      function appendPatch(apply, patch) {
        if (apply) {
          if (isArray(apply)) {
            apply.push(patch);
          } else {
            apply = [apply, patch];
          }
          return apply;
        } else {
          return patch;
        }
      }
    }, {
      "../vnode/handle-thunk": 24,
      "../vnode/is-thunk": 25,
      "../vnode/is-vnode": 27,
      "../vnode/is-vtext": 28,
      "../vnode/is-widget": 29,
      "../vnode/vpatch": 32,
      "./diff-props": 34,
      "x-is-array": 12
    }]
  }, {}, [4])(4);
});

})();
$__System.register('25', ['7', '23', '24', 'a'], function (_export) {
	var _classCallCheck, dom2hscript, diff, patch, h, _createClass, MasterDom;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			dom2hscript = _2['default'];
		}, function (_3) {
			diff = _3.diff;
			patch = _3.patch;
			h = _3.h;
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterDom = (function () {
				function MasterDom() {
					_classCallCheck(this, MasterDom);
				}

				_createClass(MasterDom, [{
					key: 'setData',
					value: function setData(container, oldContent, newContent) {
						if (oldContent && newContent) {
							// no use for webworkers =>
							// dom2hscript requires DomParser, which is not available inside webworkers
							// virtual-dom needs to access DOM directly to patch
							var newTree = eval(dom2hscript.parseHTML('<div>' + newContent + '</div>'));
							var oldTree = eval(dom2hscript.parseHTML('<div>' + oldContent + '</div>'));
							var patches = diff(oldTree, newTree);
							return patch(container[0], patches);
						} else {
							return container.html(newContent);
						}
					}
				}]);

				return MasterDom;
			})();

			_export('MasterDom', MasterDom);
		}
	};
});
$__System.register('26', ['5', '6', '7', '25'], function (_export) {
  var _get, _inherits, _classCallCheck, MasterDom, Dom;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _classCallCheck = _3['default'];
    }, function (_4) {
      MasterDom = _4.MasterDom;
    }],
    execute: function () {
      /*jshint esnext: true */

      'use strict';

      Dom = (function (_MasterDom) {
        _inherits(Dom, _MasterDom);

        function Dom() {
          _classCallCheck(this, Dom);

          _get(Object.getPrototypeOf(Dom.prototype), 'constructor', this).apply(this, arguments);
        }

        return Dom;
      })(MasterDom);

      _export('Dom', Dom);
    }
  };
});
$__System.register('27', ['7', '10', '26', '28', 'a'], function (_export) {
	var _classCallCheck, _Map, Dom, $, _createClass, MasterHTML;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			_Map = _2['default'];
		}, function (_4) {
			Dom = _4.Dom;
		}, function (_3) {
			$ = _3['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterHTML = (function () {
				function MasterHTML(WebTorrent) {
					_classCallCheck(this, MasterHTML);

					this.Dom = new Dom();
					this.WebTorrent = WebTorrent;
				}

				_createClass(MasterHTML, [{
					key: 'removeElements',
					value: function removeElements() {
						this.idNames.forEach(function (e) {
							$('#' + e).remove();
						});
					}
				}, {
					key: 'getData',
					value: function getData(container) {
						return container.html();
					}
				}, {
					key: 'setData',
					value: function setData(container, dataPack) {
						var oldMessage = this.getData(container);
						this.WebTorrent.api.addByText(dataPack.message, [
						// trigger the following, when the worker returns with dataPack.message -> this.Dom.setData(container, oldMessage, dataPack.message);
						new _Map([['function', this.Dom.setData], ['scope', this], ['attributes', [container, oldMessage]]]), new _Map([['function', this.WebTorrent.api.removeDeletedNodes], ['scope', this.WebTorrent], ['attributes', [this.WebTorrent.api.container]]])]);
					}
				}, {
					key: 'attachButtonEvent',
					// needs to get this as attribute, eventhough default val, otherwise it gets overwritten by returned txt
					value: function attachButtonEvent(button, sendCont, getDataFunc, event) {
						var _this = this;

						button.on('click', function () {
							event($('#' + _this.idNames[0]).val(), getDataFunc(sendCont), _this.idNames[2]);
						});
					}
				}]);

				return MasterHTML;
			})();

			_export('MasterHTML', MasterHTML);
		}
	};
});
$__System.register('29', ['5', '6', '7', '27', 'a'], function (_export) {
	var _get, _inherits, _classCallCheck, MasterHTML, _createClass, HTML;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_4) {
			MasterHTML = _4.MasterHTML;
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			HTML = (function (_MasterHTML) {
				_inherits(HTML, _MasterHTML);

				function HTML(WebTorrent) {
					_classCallCheck(this, HTML);

					_get(Object.getPrototypeOf(HTML.prototype), 'constructor', this).call(this, WebTorrent);
				}

				_createClass(HTML, [{
					key: 'createElements',
					value: function createElements(name) {
						var _this = this;

						var attach = arguments.length <= 1 || arguments[1] === undefined ? '#body' : arguments[1];
						var connection = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

						attach = $(attach).length > 0 ? attach : 'body';
						switch (name) {
							case 'open-or-join-room':
								this.idNames = ['txt-roomid', 'open-or-join-room', 'sender', 'receiver'];
								this.containers = [];
								var controls = $('<div id="controls"></div>');
								var input = $('<input id="' + this.idNames[0] + '" class="mui-panel" placeholder="' + connection.token() + '">');
								controls.append(input);
								var button = $('<button id="' + this.idNames[1] + '" class="mui-btn mui-btn--primary">Auto Open Or Join Room</button>');
								controls.append(button);
								this.containers.push(controls);
								var sender = $('<div id="' + this.idNames[2] + '"></div>');
								this.containers.push(sender);
								var receiver = $('<div id="' + this.idNames[3] + '"></div>');
								this.containers.push(receiver);
								button.on('click', function () {
									_this.disabled = true;
									$('#txt-roomid').val($('#txt-roomid').val().replace(/\s/g, ''));
									location.hash = $('#txt-roomid').val();
								});
								// hot-reloader
								if (window.sst && window.sst.isDebug) {
									input.val($('#' + this.idNames[0]).val());
									button.disabled = connection.sessionid == $('#' + this.idNames[0]).val();
									if ($.summernote) {
										$('#' + this.idNames[2]).summernote('destroy');
									}
									this.removeElements();
								}
								this.containers.forEach(function (e) {
									$(attach).append(e);
								});
								return [sender, receiver, button];
						}
						return false;
					}
				}]);

				return HTML;
			})(MasterHTML);

			_export('HTML', HTML);
		}
	};
});
$__System.register('2a', ['5', '6', '7', '2c', '2b'], function (_export) {
	var _get, _inherits, _classCallCheck, _Object$assign, MasterWebTorrent, WebTorrentSeeder;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_c) {
			_Object$assign = _c['default'];
		}, function (_b) {
			MasterWebTorrent = _b.MasterWebTorrent;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			WebTorrentSeeder = (function (_MasterWebTorrent) {
				_inherits(WebTorrentSeeder, _MasterWebTorrent);

				function WebTorrentSeeder(container) {
					_classCallCheck(this, WebTorrentSeeder);

					_get(Object.getPrototypeOf(WebTorrentSeeder.prototype), 'constructor', this).call(this, container);
					// onerror node error handling global
					this.appended_onerror = 'window.sst_WebTorrentSeeder_blobsRefresh';
					window.sst_WebTorrentSeeder_blobsRefresh = this.blobsRefresh.bind(this);

					// hooks
					this.api = _Object$assign(this.api, {
						/**
       * seed (upload) (api hook)
       * 
       * @param {File | FileList} files 
       * @param {string} text 
       * @param {HtmlNode} node 
       * @param {Object} [seedOpts=this.seedOpts] 
       * @param {Object} appendToOpts 
       * @param {Function} [seedCallback=(torrent) => {return this.appendTo(text, appendToOpts, appendToCallback, torrent);}] 
       * @param {Function} appendToCallback 
       * @returns 
       * @memberof MasterWebTorrent
       */
						seed: this.seed.bind(this),
						/**
       * Check if torrents are still loading
       * 
       * @returns boolean
       * @memberof MasterWebTorrent
       */
						areTorrentsLoading: this.areTorrentsLoading.bind(this)
					});
				}

				return WebTorrentSeeder;
			})(MasterWebTorrent);

			_export('WebTorrentSeeder', WebTorrentSeeder);
		}
	};
});
$__System.registerDynamic('2d', ['2e', '2f', '30', '31'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('2e'),
      toObject = $__require('2f'),
      IObject = $__require('30');
  module.exports = $__require('31')(function () {
    var a = Object.assign,
        A = {},
        B = {},
        S = Symbol(),
        K = 'abcdefghijklmnopqrst';
    A[S] = 7;
    K.split('').forEach(function (k) {
      B[k] = k;
    });
    return a({}, A)[S] != 7 || Object.keys(a({}, B)).join('') != K;
  }) ? function assign(target, source) {
    var T = toObject(target),
        $$ = arguments,
        $$len = $$.length,
        index = 1,
        getKeys = $.getKeys,
        getSymbols = $.getSymbols,
        isEnum = $.isEnum;
    while ($$len > index) {
      var S = IObject($$[index++]),
          keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S),
          length = keys.length,
          j = 0,
          key;
      while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
    }
    return T;
  } : Object.assign;
});
$__System.registerDynamic('32', ['33', '2d'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('33');
  $export($export.S + $export.F, 'Object', { assign: $__require('2d') });
});
$__System.registerDynamic('34', ['32', '35'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('32');
  module.exports = $__require('35').Object.assign;
});
$__System.registerDynamic("2c", ["34"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("34"), __esModule: true };
});
$__System.registerDynamic("36", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // 7.2.9 SameValue(x, y)
  module.exports = Object.is || function is(x, y) {
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  };
});
$__System.registerDynamic('37', ['38', '39', '3a'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var anObject = $__require('38'),
        aFunction = $__require('39'),
        SPECIES = $__require('3a')('species');
    module.exports = function (O, D) {
        var C = anObject(O).constructor,
            S;
        return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
    };
});
$__System.registerDynamic("3b", [], true, function ($__require, exports, module) {
                  var global = this || self,
                      GLOBAL = global;
                  // fast apply, http://jsperf.lnkit.com/fast-apply/5
                  module.exports = function (fn, args, that) {
                                    var un = that === undefined;
                                    switch (args.length) {
                                                      case 0:
                                                                        return un ? fn() : fn.call(that);
                                                      case 1:
                                                                        return un ? fn(args[0]) : fn.call(that, args[0]);
                                                      case 2:
                                                                        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
                                                      case 3:
                                                                        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
                                                      case 4:
                                                                        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
                                    }return fn.apply(that, args);
                  };
});
$__System.registerDynamic('3c', ['3d'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__require('3d').document && document.documentElement;
});
$__System.registerDynamic('3e', ['3f', '3d'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var isObject = $__require('3f'),
        document = $__require('3d').document,
        is = isObject(document) && isObject(document.createElement);
    module.exports = function (it) {
        return is ? document.createElement(it) : {};
    };
});
$__System.registerDynamic('40', ['41', '3b', '3c', '3e', '3d', '42', '43'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    var ctx = $__require('41'),
        invoke = $__require('3b'),
        html = $__require('3c'),
        cel = $__require('3e'),
        global = $__require('3d'),
        process = global.process,
        setTask = global.setImmediate,
        clearTask = global.clearImmediate,
        MessageChannel = global.MessageChannel,
        counter = 0,
        queue = {},
        ONREADYSTATECHANGE = 'onreadystatechange',
        defer,
        channel,
        port;
    var run = function () {
      var id = +this;
      if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var listner = function (event) {
      run.call(event.data);
    };
    if (!setTask || !clearTask) {
      setTask = function setImmediate(fn) {
        var args = [],
            i = 1;
        while (arguments.length > i) args.push(arguments[i++]);
        queue[++counter] = function () {
          invoke(typeof fn == 'function' ? fn : Function(fn), args);
        };
        defer(counter);
        return counter;
      };
      clearTask = function clearImmediate(id) {
        delete queue[id];
      };
      if ($__require('42')(process) == 'process') {
        defer = function (id) {
          process.nextTick(ctx(run, id, 1));
        };
      } else if (MessageChannel) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = listner;
        defer = ctx(port.postMessage, port, 1);
      } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
        defer = function (id) {
          global.postMessage(id + '', '*');
        };
        global.addEventListener('message', listner, false);
      } else if (ONREADYSTATECHANGE in cel('script')) {
        defer = function (id) {
          html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
            html.removeChild(this);
            run.call(id);
          };
        };
      } else {
        defer = function (id) {
          setTimeout(ctx(run, id, 1), 0);
        };
      }
    }
    module.exports = {
      set: setTask,
      clear: clearTask
    };
  })($__require('43'));
});
$__System.registerDynamic('44', ['3d', '40', '42', '43'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    var global = $__require('3d'),
        macrotask = $__require('40').set,
        Observer = global.MutationObserver || global.WebKitMutationObserver,
        process = global.process,
        Promise = global.Promise,
        isNode = $__require('42')(process) == 'process',
        head,
        last,
        notify;
    var flush = function () {
      var parent, domain, fn;
      if (isNode && (parent = process.domain)) {
        process.domain = null;
        parent.exit();
      }
      while (head) {
        domain = head.domain;
        fn = head.fn;
        if (domain) domain.enter();
        fn();
        if (domain) domain.exit();
        head = head.next;
      }
      last = undefined;
      if (parent) parent.enter();
    };
    if (isNode) {
      notify = function () {
        process.nextTick(flush);
      };
    } else if (Observer) {
      var toggle = 1,
          node = document.createTextNode('');
      new Observer(flush).observe(node, { characterData: true });
      notify = function () {
        node.data = toggle = -toggle;
      };
    } else if (Promise && Promise.resolve) {
      notify = function () {
        Promise.resolve().then(flush);
      };
    } else {
      notify = function () {
        macrotask.call(global, flush);
      };
    }
    module.exports = function asap(fn) {
      var task = {
        fn: fn,
        next: undefined,
        domain: isNode && process.domain
      };
      if (last) last.next = task;
      if (!head) {
        head = task;
        notify();
      }
      last = task;
    };
  })($__require('43'));
});
$__System.registerDynamic('45', [], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    // shim for using process in browser
    var process = module.exports = {};

    // cached from whatever global is present so that test runners that stub it
    // don't break things.  But we need to wrap it in a try catch in case it is
    // wrapped in strict mode code which doesn't define any globals.  It's inside a
    // function because try/catches deoptimize in certain engines.

    var cachedSetTimeout;
    var cachedClearTimeout;

    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
    }
    (function () {
        try {
            if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
            } else {
                cachedSetTimeout = defaultSetTimout;
            }
        } catch (e) {
            cachedSetTimeout = defaultSetTimout;
        }
        try {
            if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
            } else {
                cachedClearTimeout = defaultClearTimeout;
            }
        } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
        }
    })();
    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch (e) {
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }
    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e) {
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e) {
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }

    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;

        var len = queue.length;
        while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }

    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    };

    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;

    process.listeners = function (name) {
        return [];
    };

    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };

    process.cwd = function () {
        return '/';
    };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function () {
        return 0;
    };
});
$__System.registerDynamic("46", ["45"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("45");
});
$__System.registerDynamic('47', ['46'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__System._nodeRequire ? process : $__require('46');
});
$__System.registerDynamic("43", ["47"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("47");
});
$__System.registerDynamic('48', ['2e', '49', '3d', '41', '4a', '33', '3f', '38', '39', '4b', '4c', '4d', '36', '3a', '37', '44', '4e', '4f', '50', '51', '35', '52', '43'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  (function (process) {
    'use strict';

    var $ = $__require('2e'),
        LIBRARY = $__require('49'),
        global = $__require('3d'),
        ctx = $__require('41'),
        classof = $__require('4a'),
        $export = $__require('33'),
        isObject = $__require('3f'),
        anObject = $__require('38'),
        aFunction = $__require('39'),
        strictNew = $__require('4b'),
        forOf = $__require('4c'),
        setProto = $__require('4d').set,
        same = $__require('36'),
        SPECIES = $__require('3a')('species'),
        speciesConstructor = $__require('37'),
        asap = $__require('44'),
        PROMISE = 'Promise',
        process = global.process,
        isNode = classof(process) == 'process',
        P = global[PROMISE],
        empty = function () {},
        Wrapper;
    var testResolve = function (sub) {
      var test = new P(empty),
          promise;
      if (sub) test.constructor = function (exec) {
        exec(empty, empty);
      };
      (promise = P.resolve(test))['catch'](empty);
      return promise === test;
    };
    var USE_NATIVE = function () {
      var works = false;
      function P2(x) {
        var self = new P(x);
        setProto(self, P2.prototype);
        return self;
      }
      try {
        works = P && P.resolve && testResolve();
        setProto(P2, P);
        P2.prototype = $.create(P.prototype, { constructor: { value: P2 } });
        if (!(P2.resolve(5).then(function () {}) instanceof P2)) {
          works = false;
        }
        if (works && $__require('4e')) {
          var thenableThenGotten = false;
          P.resolve($.setDesc({}, 'then', { get: function () {
              thenableThenGotten = true;
            } }));
          works = thenableThenGotten;
        }
      } catch (e) {
        works = false;
      }
      return works;
    }();
    var sameConstructor = function (a, b) {
      if (LIBRARY && a === P && b === Wrapper) return true;
      return same(a, b);
    };
    var getConstructor = function (C) {
      var S = anObject(C)[SPECIES];
      return S != undefined ? S : C;
    };
    var isThenable = function (it) {
      var then;
      return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
    };
    var PromiseCapability = function (C) {
      var resolve, reject;
      this.promise = new C(function ($$resolve, $$reject) {
        if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aFunction(resolve), this.reject = aFunction(reject);
    };
    var perform = function (exec) {
      try {
        exec();
      } catch (e) {
        return { error: e };
      }
    };
    var notify = function (record, isReject) {
      if (record.n) return;
      record.n = true;
      var chain = record.c;
      asap(function () {
        var value = record.v,
            ok = record.s == 1,
            i = 0;
        var run = function (reaction) {
          var handler = ok ? reaction.ok : reaction.fail,
              resolve = reaction.resolve,
              reject = reaction.reject,
              result,
              then;
          try {
            if (handler) {
              if (!ok) record.h = true;
              result = handler === true ? value : handler(value);
              if (result === reaction.promise) {
                reject(TypeError('Promise-chain cycle'));
              } else if (then = isThenable(result)) {
                then.call(result, resolve, reject);
              } else resolve(result);
            } else reject(value);
          } catch (e) {
            reject(e);
          }
        };
        while (chain.length > i) run(chain[i++]);
        chain.length = 0;
        record.n = false;
        if (isReject) setTimeout(function () {
          var promise = record.p,
              handler,
              console;
          if (isUnhandled(promise)) {
            if (isNode) {
              process.emit('unhandledRejection', value, promise);
            } else if (handler = global.onunhandledrejection) {
              handler({
                promise: promise,
                reason: value
              });
            } else if ((console = global.console) && console.error) {
              console.error('Unhandled promise rejection', value);
            }
          }
          record.a = undefined;
        }, 1);
      });
    };
    var isUnhandled = function (promise) {
      var record = promise._d,
          chain = record.a || record.c,
          i = 0,
          reaction;
      if (record.h) return false;
      while (chain.length > i) {
        reaction = chain[i++];
        if (reaction.fail || !isUnhandled(reaction.promise)) return false;
      }
      return true;
    };
    var $reject = function (value) {
      var record = this;
      if (record.d) return;
      record.d = true;
      record = record.r || record;
      record.v = value;
      record.s = 2;
      record.a = record.c.slice();
      notify(record, true);
    };
    var $resolve = function (value) {
      var record = this,
          then;
      if (record.d) return;
      record.d = true;
      record = record.r || record;
      try {
        if (record.p === value) throw TypeError("Promise can't be resolved itself");
        if (then = isThenable(value)) {
          asap(function () {
            var wrapper = {
              r: record,
              d: false
            };
            try {
              then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
            } catch (e) {
              $reject.call(wrapper, e);
            }
          });
        } else {
          record.v = value;
          record.s = 1;
          notify(record, false);
        }
      } catch (e) {
        $reject.call({
          r: record,
          d: false
        }, e);
      }
    };
    if (!USE_NATIVE) {
      P = function Promise(executor) {
        aFunction(executor);
        var record = this._d = {
          p: strictNew(this, P, PROMISE),
          c: [],
          a: undefined,
          s: 0,
          d: false,
          v: undefined,
          h: false,
          n: false
        };
        try {
          executor(ctx($resolve, record, 1), ctx($reject, record, 1));
        } catch (err) {
          $reject.call(record, err);
        }
      };
      $__require('4f')(P.prototype, {
        then: function then(onFulfilled, onRejected) {
          var reaction = new PromiseCapability(speciesConstructor(this, P)),
              promise = reaction.promise,
              record = this._d;
          reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
          reaction.fail = typeof onRejected == 'function' && onRejected;
          record.c.push(reaction);
          if (record.a) record.a.push(reaction);
          if (record.s) notify(record, false);
          return promise;
        },
        'catch': function (onRejected) {
          return this.then(undefined, onRejected);
        }
      });
    }
    $export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: P });
    $__require('50')(P, PROMISE);
    $__require('51')(PROMISE);
    Wrapper = $__require('35')[PROMISE];
    $export($export.S + $export.F * !USE_NATIVE, PROMISE, { reject: function reject(r) {
        var capability = new PromiseCapability(this),
            $$reject = capability.reject;
        $$reject(r);
        return capability.promise;
      } });
    $export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, { resolve: function resolve(x) {
        if (x instanceof P && sameConstructor(x.constructor, this)) return x;
        var capability = new PromiseCapability(this),
            $$resolve = capability.resolve;
        $$resolve(x);
        return capability.promise;
      } });
    $export($export.S + $export.F * !(USE_NATIVE && $__require('52')(function (iter) {
      P.all(iter)['catch'](function () {});
    })), PROMISE, {
      all: function all(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            resolve = capability.resolve,
            reject = capability.reject,
            values = [];
        var abrupt = perform(function () {
          forOf(iterable, false, values.push, values);
          var remaining = values.length,
              results = Array(remaining);
          if (remaining) $.each.call(values, function (promise, index) {
            var alreadyCalled = false;
            C.resolve(promise).then(function (value) {
              if (alreadyCalled) return;
              alreadyCalled = true;
              results[index] = value;
              --remaining || resolve(results);
            }, reject);
          });else resolve(results);
        });
        if (abrupt) reject(abrupt.error);
        return capability.promise;
      },
      race: function race(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            reject = capability.reject;
        var abrupt = perform(function () {
          forOf(iterable, false, function (promise) {
            C.resolve(promise).then(capability.resolve, reject);
          });
        });
        if (abrupt) reject(abrupt.error);
        return capability.promise;
      }
    });
  })($__require('43'));
});
$__System.registerDynamic('53', ['54', '55', '56', '48', '35'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('54');
  $__require('55');
  $__require('56');
  $__require('48');
  module.exports = $__require('35').Promise;
});
$__System.registerDynamic("57", ["53"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("53"), __esModule: true };
});
$__System.register('d', ['7', '10', 'a'], function (_export) {
	var _classCallCheck, _Map, _createClass, MasterOption;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			_Map = _2['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterOption = (function () {
				function MasterOption() {
					var returnMap = arguments.length <= 0 || arguments[0] === undefined ? new _Map() : arguments[0];

					_classCallCheck(this, MasterOption);

					// returnMap needs to set ['funcName', [func, scope]]
					this.returnMap = returnMap;
				}

				_createClass(MasterOption, [{
					key: 'init',
					value: function init() {
						for (var _len = arguments.length, data = Array(_len), _key = 0; _key < _len; _key++) {
							data[_key] = arguments[_key];
						}

						this.returnApply('init', data);
					}
				}, {
					key: 'returnApply',
					value: function returnApply(name) {
						var result = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

						var funcScope = this.returnMap.get(name);
						if (funcScope) {
							funcScope[0].apply(funcScope[1], result);
							return true;
						}
						console.warn('SST: set returnMap at MasterOption to handle action: ' + name);
						return false;
					}
				}]);

				return MasterOption;
			})();

			_export('MasterOption', MasterOption);
		}
	};
});
$__System.register('18', ['7', 'a'], function (_export) {
	var _classCallCheck, _createClass, MasterWorker;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterWorker = (function () {
				function MasterWorker() {
					var spreadArgs = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

					_classCallCheck(this, MasterWorker);

					this.spreadArgs = spreadArgs;
					this.name = 'MasterWorker';
					this.workers = [];
					this.callbacks = [];
					this.trackers = []; // simply used to track if function has already been set as this.workers
					this.scripts = [];
				}

				// workerFunc can not reference anything outside (func becomes string), data has to be passed to the worker function

				_createClass(MasterWorker, [{
					key: 'create',
					value: function create(workerFunc, callback, scripts) {
						if (workerFunc === undefined) workerFunc = this.workerFunc;
						if (callback === undefined) callback = this.callbackFunc;

						var index = this.trackers.indexOf(workerFunc);
						if (index === -1) {
							this.workers.push(this.getWebWorker(workerFunc, scripts));
							this.callbacks.push(callback);
							this.trackers.push(workerFunc);
							return this.trackers.length - 1;
						}
						return index;
					}
				}, {
					key: 'run',
					value: function run() {
						var data = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

						var _this = this;

						var worker = arguments.length <= 1 || arguments[1] === undefined ? this.workers[0] : arguments[1];
						var callback = arguments.length <= 2 || arguments[2] === undefined ? this.callbacks[0] : arguments[2];

						worker(data, function (err, result) {
							if (err) return console.warn('SST: Error at ' + _this.name + ' -> ' + err.message);
							callback(result);
						});
					}

					// dummy examples
				}, {
					key: 'workerFunc',
					value: function workerFunc(data) {
						return data;
					}
				}, {
					key: 'callbackFunc',
					value: function callbackFunc(result) {
						console.log(result);
					}
				}, {
					key: 'getWebWorker',
					value: function getWebWorker(workerFunc) {
						var scripts = arguments.length <= 1 || arguments[1] === undefined ? this.scripts : arguments[1];

						// URL.createObjectURL
						window.URL = window.URL || window.webkitURL;

						// add scripts outside of event
						scripts = Array.isArray(scripts) && scripts.length ? 'importScripts(\'' + scripts.join("','") + '\');\n' : '';
						if (typeof workerFunc !== 'string') {
							workerFunc = workerFunc.toLocaleString();
							workerFunc = workerFunc.replace(/this\./g, '');
							if (/^\(.*?\).*?\=\>.*?\{/.test(workerFunc)) {
								// arrow functions need to be wrapped with ()
								workerFunc = '(' + workerFunc + ')';
							} else if (!/^function/.test(workerFunc)) {
								// class functions need the keyword function
								workerFunc = 'function ' + workerFunc;
							}
						}
						var response = 'onmessage=(event)=>{postMessage(' + workerFunc + '(' + (this.spreadArgs ? '...' : '') + 'event.data));}';

						var blob = undefined;
						try {
							blob = new Blob([scripts, response], { type: 'application/javascript' });
						} catch (e) {
							// Backwards-compatibility
							window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
							blob = new BlobBuilder();
							blob.append(scripts);
							blob.append(response);
							blob = blob.getBlob();
						}

						var worker = new Worker(URL.createObjectURL(blob));
						return function () {
							var data = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
							var callback = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];

							var ran = undefined;
							worker.onmessage = function (e) {
								if (ran) return;
								ran = true;
								callback(null, e.data);
							};
							worker.onerror = function (e) {
								if (ran) return;
								ran = true;
								callback(e);
								return false;
							};
							worker.postMessage.apply(worker, [data]); // can only have one argument as message
						};
					}
				}]);

				return MasterWorker;
			})();

			_export('MasterWorker', MasterWorker);
		}
	};
});
$__System.register('58', ['5', '6', '7', '18', 'a'], function (_export) {
	var _get, _inherits, _classCallCheck, MasterWorker, _createClass, RegexWorker;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_4) {
			MasterWorker = _4.MasterWorker;
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			RegexWorker = (function (_MasterWorker) {
				_inherits(RegexWorker, _MasterWorker);

				function RegexWorker() {
					_classCallCheck(this, RegexWorker);

					_get(Object.getPrototypeOf(RegexWorker.prototype), 'constructor', this).call(this, false);

					this.name = 'RegexWorker';
				}

				_createClass(RegexWorker, [{
					key: 'getMagnetURL',
					value: function getMagnetURL(data) {
						var txt = data[0],
						    attributes = data[1][0]; // [txt, [attributes, classes], workerID]
						// regex grabs id, [magnetURL and tagName] (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#Parameters)
						// attributes = ['data-id', 'data-magnetURL', 'data-blobs', 'onerror']
						var re = new RegExp('<(\\w*?)\\s[^<>]*?' + attributes[0] + '="(\\d*?)"[^<>]*?' + attributes[1] + '="([^"]*?)"[^<>]*?' + attributes[2] + '="([^"]*?)"', 'gui');
						var match = null;
						var magnetURLs = [];
						while (match = re.exec(txt)) {
							var id = match[2]; // id
							var val = [match[3], [match[4].split(','), [/* localBlob */]], match[1]]; // magnetURL, blob's, TagName
							magnetURLs.push([id, val]);
						}
						return [[data, magnetURLs]]; // MasterOption.returnApply needs to receive it wrapped in an array
					}
				}, {
					key: 'replaceBlobURL',
					value: function replaceBlobURL(data) {
						// [[txt, [attributes, classes], workerID], [nonExistingTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]], inProgressTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]], downloadedTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]]]]
						var txt = data[0][0],
						    attributes = data[0][1][0],
						    downloadedTorrents = data[1][2];
						// with tag name grab innerHTML
						downloadedTorrents.forEach(function (e) {
							var id = e[0],
							    remoteBlobs = e[1][1][0],
							    localBlobs = e[1][1][1],
							    onerror = e[1][1][2];
							if (remoteBlobs.length === localBlobs.length) {
								for (var i = 0; i < remoteBlobs.length; i++) {
									var _re = new RegExp('' + remoteBlobs[i].replace(/[-[\]{}()*+?.,\\/^$|#\s]/g, '\\$&'), 'g'); // escape special characters
									txt = txt.replace(_re, localBlobs[i]);
								}
							} else {
								console.warn('remoteBlobs and localBlobs length is uneven:', data);
							}
							// replace onerror
							// attributes = ['data-id', 'data-magnetURL', 'data-blobs', 'onerror']
							var re = new RegExp(attributes[3] + '="[^"]*?' + id + '[^"]*?"', 'gui');
							// classes = ['webTorrent', 'blobLoading', 'torrentLoading']
							txt = txt.replace(re, attributes[3] + '="' + onerror + '"');
						});
						data[0][0] = txt;
						return [data]; // MasterOption.returnApply needs to receive it wrapped in an array
					}
				}, {
					key: 'addProgressBar',
					value: function addProgressBar(data) {
						// [[txt, [attributes, classes], workerID], [nonExistingTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]], inProgressTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]], downloadedTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]]]]
						var txt = data[0][0],
						    attributes = data[0][1][0],
						    classes = data[0][1][1],
						    inProgressTorrents = data[1][0].concat(data[1][1]); // nonExistingTorrents + inProgressTorrents;
						// also empty innerHTML
						inProgressTorrents.forEach(function (e) {
							var id = e[0],
							    val = e[1]; // [[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]]
							var re = new RegExp('(<' + val[2] + '\\s[^<>]*?class=")[^"]*?("[^<>]*?' + attributes[0] + '="' + id + '"[^<>]*?>).*?(</' + val[2] + '>)', 'gui');
							// classes = ['webTorrent', 'blobLoading', 'torrentLoading']
							txt = txt.replace(re, '$1' + classes[0] + ' ' + classes[2] + '$2$3');
						});
						data[0][0] = txt;
						return [data]; // MasterOption.returnApply needs to receive it wrapped in an array
					}
				}]);

				return RegexWorker;
			})(MasterWorker);

			_export('RegexWorker', RegexWorker);
		}
	};
});
$__System.register('59', ['5', '6', '7', '10', '58', 'a', 'd'], function (_export) {
	var _get, _inherits, _classCallCheck, _Map, RegexWorker, _createClass, MasterOption, OptionRegex;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_4) {
			_Map = _4['default'];
		}, function (_5) {
			RegexWorker = _5.RegexWorker;
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_d) {
			MasterOption = _d.MasterOption;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			OptionRegex = (function (_MasterOption) {
				_inherits(OptionRegex, _MasterOption);

				function OptionRegex(WebTorrent, client, returnMap, addByTextReturn) {
					var _this = this;

					_classCallCheck(this, OptionRegex);

					_get(Object.getPrototypeOf(OptionRegex.prototype), 'constructor', this).call(this, returnMap);

					this.WebTorrent = WebTorrent;
					this.client = client;
					this.addByTextReturn = addByTextReturn;
					// workers
					this.RegexWorker = new RegexWorker();
					// this.RegexWorker.workers[0]
					this.RegexWorker.create(this.RegexWorker.getMagnetURL, function (result) {
						_this.returnApply('getMagnetURL', result);
					});
					// this.RegexWorker.workers[1]
					this.RegexWorker.create(this.RegexWorker.replaceBlobURL, function (result) {
						_this.returnApply('replaceBlobURL', result);
					});
					// this.RegexWorker.workers[2]
					this.RegexWorker.create(this.RegexWorker.addProgressBar, function (result) {
						_this.returnApply('addProgressBar', result);
					});
				}

				_createClass(OptionRegex, [{
					key: 'getMagnetURL',
					value: function getMagnetURL(txt, attributes) {
						if (txt === undefined) txt = '';
						var workerID = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];

						this.RegexWorker.run([txt, attributes, workerID]);
						return true;
					}
				}, {
					key: 'mapFoundMagnetURL',
					value: function mapFoundMagnetURL(data) {
						var _this2 = this;

						// data = [[txt, [attributes, classes], workerID], [[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]]
						// check if torrent exists
						var magnetURLs = data[1],
						    nonExistingTorrents = [],
						    inProgressTorrents = [],
						    downloadedTorrents = [];
						// let in
						magnetURLs.forEach(function (e) {
							var torrent = _this2.client.get(e[1][0]);
							if (torrent) {
								if (torrent.sst_localBlobs) {
									e[1][1][1] = torrent.sst_localBlobs;
									e[1][1][2] = torrent.sst_onerror;
									if (downloadedTorrents.indexOf(e) === -1) downloadedTorrents.push(e);
								} else {
									if (inProgressTorrents.indexOf(e) === -1) inProgressTorrents.push(e);
								}
							} else {
								if (nonExistingTorrents.indexOf(e) === -1) nonExistingTorrents.push(e);
							}
						});
						data[1] = [nonExistingTorrents, inProgressTorrents, downloadedTorrents]; // [nonExistingTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]], inProgressTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]], downloadedTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]]]
						this.returnApply('mapFoundMagnetURL', [data]);
					}
				}, {
					key: 'replaceBlobURL',
					value: function replaceBlobURL(data) {
						// downloadedTorrents replace remoteBlobs with localBlobs
						// data[1][2] = downloadedTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]]
						this.RegexWorker.run(data, this.RegexWorker.workers[1], this.RegexWorker.callbacks[1]);
						return true;
					}
				}, {
					key: 'addProgressBar',
					value: function addProgressBar(data) {
						// data[1][0] = nonExistingTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]]
						// data[1][1] = inProgressTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]]
						this.RegexWorker.run(data, this.RegexWorker.workers[2], this.RegexWorker.callbacks[2]);
						return true;
					}
				}, {
					key: 'addTorrent',
					value: function addTorrent(data) {
						var workerID = data[0][2];
						// nonExistingTorrents
						// !!! IMPORTANT !!! gets executed at _resultAddByText -> this function must be executed after the new text has been applied to dom and settled for 50ms otherwise nodes get mixed up -> see appendTo workaround bug
						var returnAndOptions = this.addByTextReturn.get(workerID); // [arrayReturnMap, [addOpts, appendToOpts, addCallback, appendToCallback]]
						if (returnAndOptions) returnAndOptions[0].push(new _Map([['function', function () {
							var _this3 = this;

							setTimeout(function () {
								// data[1][0] = nonExistingTorrents[[id, [magnetURL, [remoteBlobs, localBlobs, onerror], TagName]]]
								data[1][0].forEach(function (nonExistingTorrent) {
									var torrent = _this3.WebTorrent.add(nonExistingTorrent[1][0].replace(/amp;/g, ''), nonExistingTorrent[0], undefined, returnAndOptions[1][0], returnAndOptions[1][1], returnAndOptions[1][2], returnAndOptions[1][3]);
									if (torrent) torrent.sst_remoteBlobs = nonExistingTorrent[1][1][0];
								});
							}, 50);
						}], ['scope', this], ['attributes', []]]));
						this.returnApply('addTorrent', [data]);
					}
				}]);

				return OptionRegex;
			})(MasterOption);

			_export('OptionRegex', OptionRegex);
		}
	};
});
(function() {
var define = $__System.amdDefine;
(function(e) {
  if ("object" == typeof exports && "undefined" != typeof module)
    module.exports = e();
  else if ("function" == typeof define && define.amd)
    define("5a", [], e);
  else {
    var t;
    t = "undefined" == typeof window ? "undefined" == typeof global ? "undefined" == typeof self ? this : self : global : window, t.WebTorrent = e();
  }
})(function() {
  var t = Math.pow,
      r = Math.floor,
      o = Math.abs,
      e = String.fromCharCode,
      s = Math.ceil,
      n = Math.max,
      d = Math.min,
      i;
  return function() {
    function d(c, e, t) {
      function r(s, o) {
        if (!e[s]) {
          if (!c[s]) {
            var i = "function" == typeof require && require;
            if (!o && i)
              return i(s, !0);
            if (n)
              return n(s, !0);
            var a = new Error("Cannot find module '" + s + "'");
            throw a.code = "MODULE_NOT_FOUND", a;
          }
          var p = e[s] = {exports: {}};
          c[s][0].call(p.exports, function(t) {
            var e = c[s][1][t];
            return r(e ? e : t);
          }, p, p.exports, d, c, e, t);
        }
        return e[s].exports;
      }
      for (var n = "function" == typeof require && require,
          s = 0; s < t.length; s++)
        r(t[s]);
      return r;
    }
    return d;
  }()({
    1: [function(e, t) {
      function n(e, t) {
        s.Readable.call(this, t), this.destroyed = !1, this._torrent = e._torrent;
        var n = t && t.start || 0,
            r = t && t.end && t.end < e.length ? t.end : e.length - 1,
            o = e._torrent.pieceLength;
        this._startPiece = 0 | (n + e.offset) / o, this._endPiece = 0 | (r + e.offset) / o, this._piece = this._startPiece, this._offset = n + e.offset - this._startPiece * o, this._missing = r - n + 1, this._reading = !1, this._notifying = !1, this._criticalLength = d(0 | 1048576 / o, 2);
      }
      t.exports = n;
      var r = e("debug")("webtorrent:file-stream"),
          o = e("inherits"),
          s = e("readable-stream");
      o(n, s.Readable), n.prototype._read = function() {
        this._reading || (this._reading = !0, this._notify());
      }, n.prototype._notify = function() {
        var e = this;
        if (e._reading && 0 !== e._missing) {
          if (!e._torrent.bitfield.get(e._piece))
            return e._torrent.critical(e._piece, e._piece + e._criticalLength);
          if (!e._notifying) {
            if (e._notifying = !0, e._torrent.destroyed)
              return e._destroy(new Error("Torrent removed"));
            var t = e._piece;
            e._torrent.store.get(t, function(n, o) {
              return e._notifying = !1, e.destroyed ? void 0 : n ? e._destroy(n) : void(r("read %s (length %s) (err %s)", t, o.length, n && n.message), e._offset && (o = o.slice(e._offset), e._offset = 0), e._missing < o.length && (o = o.slice(0, e._missing)), e._missing -= o.length, r("pushing buffer of length %s", o.length), e._reading = !1, e.push(o), 0 === e._missing && e.push(null));
            }), e._piece += 1;
          }
        }
      }, n.prototype.destroy = function(e) {
        this._destroy(null, e);
      }, n.prototype._destroy = function(e, t) {
        this.destroyed || (this.destroyed = !0, !this._torrent.destroyed && this._torrent.deselect(this._startPiece, this._endPiece, !0), e && this.emit("error", e), this.emit("close"), t && t());
      };
    }, {
      debug: 31,
      inherits: 42,
      "readable-stream": 84
    }],
    2: [function(e, t) {
      (function(n) {
        function r(e, t) {
          s.call(this), this._torrent = e, this._destroyed = !1, this.name = t.name, this.path = t.path, this.length = t.length, this.offset = t.offset, this.done = !1;
          var n = t.offset,
              r = n + t.length - 1;
          this._startPiece = 0 | n / this._torrent.pieceLength, this._endPiece = 0 | r / this._torrent.pieceLength, 0 === this.length && (this.done = !0, this.emit("done"));
        }
        t.exports = r;
        var o = e("end-of-stream"),
            s = e("events").EventEmitter,
            i = e("./file-stream"),
            d = e("inherits"),
            a = e("path"),
            c = e("render-media"),
            l = e("readable-stream"),
            p = e("stream-to-blob"),
            u = e("stream-to-blob-url"),
            f = e("stream-with-known-length-to-buffer");
        d(r, s), Object.defineProperty(r.prototype, "downloaded", {get: function() {
            if (!this._torrent.bitfield)
              return 0;
            for (var e = 0,
                t = this._startPiece; t <= this._endPiece; ++t)
              if (this._torrent.bitfield.get(t))
                e += t === this._endPiece ? this._torrent.lastPieceLength : this._torrent.pieceLength;
              else {
                var n = this._torrent.pieces[t];
                e += n.length - n.missing;
              }
            return e;
          }}), Object.defineProperty(r.prototype, "progress", {get: function() {
            return this.length ? this.downloaded / this.length : 0;
          }}), r.prototype.select = function(e) {
          0 === this.length || this._torrent.select(this._startPiece, this._endPiece, e);
        }, r.prototype.deselect = function() {
          0 === this.length || this._torrent.deselect(this._startPiece, this._endPiece, !1);
        }, r.prototype.createReadStream = function(e) {
          var t = this;
          if (0 === this.length) {
            var r = new l.PassThrough;
            return n.nextTick(function() {
              r.end();
            }), r;
          }
          var s = new i(t, e);
          return t._torrent.select(s._startPiece, s._endPiece, !0, function() {
            s._notify();
          }), o(s, function() {
            t._destroyed || !t._torrent.destroyed && t._torrent.deselect(s._startPiece, s._endPiece, !0);
          }), s;
        }, r.prototype.getBuffer = function(e) {
          f(this.createReadStream(), this.length, e);
        }, r.prototype.getBlob = function(e) {
          if ("undefined" == typeof window)
            throw new Error("browser-only method");
          p(this.createReadStream(), this._getMimeType(), e);
        }, r.prototype.getBlobURL = function(e) {
          if ("undefined" == typeof window)
            throw new Error("browser-only method");
          u(this.createReadStream(), this._getMimeType(), e);
        }, r.prototype.appendTo = function(e, t, n) {
          if ("undefined" == typeof window)
            throw new Error("browser-only method");
          c.append(this, e, t, n);
        }, r.prototype.renderTo = function(e, t, n) {
          if ("undefined" == typeof window)
            throw new Error("browser-only method");
          c.render(this, e, t, n);
        }, r.prototype._getMimeType = function() {
          return c.mime[a.extname(this.name).toLowerCase()];
        }, r.prototype._destroy = function() {
          this._destroyed = !0, this._torrent = null;
        };
      }).call(this, e("_process"));
    }, {
      "./file-stream": 1,
      _process: 67,
      "end-of-stream": 34,
      events: 35,
      inherits: 42,
      path: 64,
      "readable-stream": 84,
      "render-media": 85,
      "stream-to-blob": 104,
      "stream-to-blob-url": 103,
      "stream-with-known-length-to-buffer": 105
    }],
    3: [function(e, t, n) {
      function r(e, t) {
        var n = this;
        n.id = e, n.type = t, i("new Peer %s", e), n.addr = null, n.conn = null, n.swarm = null, n.wire = null, n.connected = !1, n.destroyed = !1, n.timeout = null, n.retries = 0, n.sentHandshake = !1;
      }
      function o() {}
      var s = e("unordered-array-remove"),
          i = e("debug")("webtorrent:peer"),
          d = e("bittorrent-protocol"),
          a = e("./webconn");
      n.createWebRTCPeer = function(e, t) {
        var n = new r(e.id, "webrtc");
        return n.conn = e, n.swarm = t, n.conn.connected ? n.onConnect() : (n.conn.once("connect", function() {
          n.onConnect();
        }), n.conn.once("error", function(e) {
          n.destroy(e);
        }), n.startConnectTimeout()), n;
      }, n.createTCPIncomingPeer = function(e) {
        var t = e.remoteAddress + ":" + e.remotePort,
            n = new r(t, "tcpIncoming");
        return n.conn = e, n.addr = t, n.onConnect(), n;
      }, n.createTCPOutgoingPeer = function(e, t) {
        var n = new r(e, "tcpOutgoing");
        return n.addr = e, n.swarm = t, n;
      }, n.createWebSeedPeer = function(e, t) {
        var n = new r(e, "webSeed");
        return n.swarm = t, n.conn = new a(e, t), n.onConnect(), n;
      }, r.prototype.onConnect = function() {
        var e = this;
        if (!e.destroyed) {
          e.connected = !0, i("Peer %s connected", e.id), clearTimeout(e.connectTimeout);
          var t = e.conn;
          t.once("end", function() {
            e.destroy();
          }), t.once("close", function() {
            e.destroy();
          }), t.once("finish", function() {
            e.destroy();
          }), t.once("error", function(t) {
            e.destroy(t);
          });
          var n = e.wire = new d;
          n.type = e.type, n.once("end", function() {
            e.destroy();
          }), n.once("close", function() {
            e.destroy();
          }), n.once("finish", function() {
            e.destroy();
          }), n.once("error", function(t) {
            e.destroy(t);
          }), n.once("handshake", function(t, n) {
            e.onHandshake(t, n);
          }), e.startHandshakeTimeout(), t.pipe(n).pipe(t), e.swarm && !e.sentHandshake && e.handshake();
        }
      }, r.prototype.onHandshake = function(e, t) {
        var n = this;
        if (n.swarm && !n.destroyed) {
          if (n.swarm.destroyed)
            return n.destroy(new Error("swarm already destroyed"));
          if (e !== n.swarm.infoHash)
            return n.destroy(new Error("unexpected handshake info hash for this swarm"));
          if (t === n.swarm.peerId)
            return n.destroy(new Error("refusing to connect to ourselves"));
          i("Peer %s got handshake %s", n.id, e), clearTimeout(n.handshakeTimeout), n.retries = 0;
          var r = n.addr;
          !r && n.conn.remoteAddress && (r = n.conn.remoteAddress + ":" + n.conn.remotePort), n.swarm._onWire(n.wire, r), n.swarm && !n.swarm.destroyed && (n.sentHandshake || n.handshake());
        }
      }, r.prototype.handshake = function() {
        var e = this,
            t = {dht: !e.swarm.private && !!e.swarm.client.dht};
        e.wire.handshake(e.swarm.infoHash, e.swarm.client.peerId, t), e.sentHandshake = !0;
      }, r.prototype.startConnectTimeout = function() {
        var e = this;
        clearTimeout(e.connectTimeout), e.connectTimeout = setTimeout(function() {
          e.destroy(new Error("connect timeout"));
        }, "webrtc" === e.type ? 25000 : 5e3), e.connectTimeout.unref && e.connectTimeout.unref();
      }, r.prototype.startHandshakeTimeout = function() {
        var e = this;
        clearTimeout(e.handshakeTimeout), e.handshakeTimeout = setTimeout(function() {
          e.destroy(new Error("handshake timeout"));
        }, 25000), e.handshakeTimeout.unref && e.handshakeTimeout.unref();
      }, r.prototype.destroy = function(e) {
        var t = this;
        if (!t.destroyed) {
          t.destroyed = !0, t.connected = !1, i("destroy %s (error: %s)", t.id, e && (e.message || e)), clearTimeout(t.connectTimeout), clearTimeout(t.handshakeTimeout);
          var n = t.swarm,
              r = t.conn,
              d = t.wire;
          t.swarm = null, t.conn = null, t.wire = null, n && d && s(n.wires, n.wires.indexOf(d)), r && (r.on("error", o), r.destroy()), d && d.destroy(), n && n.removePeer(t.id);
        }
      };
    }, {
      "./webconn": 6,
      "bittorrent-protocol": 14,
      debug: 31,
      "unordered-array-remove": 115
    }],
    4: [function(e, t) {
      function n(e) {
        var t = this;
        t._torrent = e, t._numPieces = e.pieces.length, t._pieces = [], t._onWire = function(e) {
          t.recalculate(), t._initWire(e);
        }, t._onWireHave = function(e) {
          t._pieces[e] += 1;
        }, t._onWireBitfield = function() {
          t.recalculate();
        }, t._torrent.wires.forEach(function(e) {
          t._initWire(e);
        }), t._torrent.on("wire", t._onWire), t.recalculate();
      }
      function r() {
        return !0;
      }
      t.exports = n, n.prototype.getRarestPiece = function(e) {
        e || (e = r);
        for (var t = [],
            n = Infinity,
            o = 0; o < this._numPieces; ++o)
          if (e(o)) {
            var s = this._pieces[o];
            s === n ? t.push(o) : s < n && (t = [o], n = s);
          }
        return 0 < t.length ? t[0 | Math.random() * t.length] : -1;
      }, n.prototype.destroy = function() {
        var e = this;
        e._torrent.removeListener("wire", e._onWire), e._torrent.wires.forEach(function(t) {
          e._cleanupWireEvents(t);
        }), e._torrent = null, e._pieces = null, e._onWire = null, e._onWireHave = null, e._onWireBitfield = null;
      }, n.prototype._initWire = function(e) {
        var t = this;
        e._onClose = function() {
          t._cleanupWireEvents(e);
          for (var n = 0; n < this._numPieces; ++n)
            t._pieces[n] -= e.peerPieces.get(n);
        }, e.on("have", t._onWireHave), e.on("bitfield", t._onWireBitfield), e.once("close", e._onClose);
      }, n.prototype.recalculate = function() {
        var e;
        for (e = 0; e < this._numPieces; ++e)
          this._pieces[e] = 0;
        var t = this._torrent.wires.length;
        for (e = 0; e < t; ++e)
          for (var n = this._torrent.wires[e],
              r = 0; r < this._numPieces; ++r)
            this._pieces[r] += n.peerPieces.get(r);
      }, n.prototype._cleanupWireEvents = function(e) {
        e.removeListener("have", this._onWireHave), e.removeListener("bitfield", this._onWireBitfield), e._onClose && e.removeListener("close", e._onClose), e._onClose = null;
      };
    }, {}],
    5: [function(e, t) {
      (function(r, o) {
        function i(e, t, n) {
          _.call(this), this._debugId = "unknown infohash", this.client = t, this.announce = n.announce, this.urlList = n.urlList, this.path = n.path, this._store = n.store || k, this._getAnnounceOpts = n.getAnnounceOpts, this.strategy = n.strategy || "sequential", this.maxWebConns = n.maxWebConns || 4, this._rechokeNumSlots = !1 === n.uploads || 0 === n.uploads ? 0 : +n.uploads || 10, this._rechokeOptimisticWire = null, this._rechokeOptimisticTime = 0, this._rechokeIntervalId = null, this.ready = !1, this.destroyed = !1, this.paused = !1, this.done = !1, this.metadata = null, this.store = null, this.files = [], this.pieces = [], this._amInterested = !1, this._selections = [], this._critical = [], this.wires = [], this._queue = [], this._peers = {}, this._peersLength = 0, this.received = 0, this.uploaded = 0, this._downloadSpeed = H(), this._uploadSpeed = H(), this._servers = [], this._xsRequests = [], this._fileModtimes = n.fileModtimes, null !== e && this._onTorrentId(e), this._debug("new torrent");
        }
        function a(e, t) {
          return 2 + s(t * e.downloadSpeed() / U.BLOCK_LENGTH);
        }
        function c(e, t, n) {
          return 1 + s(t * e.downloadSpeed() / n);
        }
        function l(e) {
          return 0 | Math.random() * e;
        }
        function p() {}
        t.exports = i;
        var u = e("addr-to-ip-port"),
            f = e("bitfield"),
            h = e("chunk-store-stream/write"),
            m = e("debug")("webtorrent:torrent"),
            g = e("torrent-discovery"),
            _ = e("events").EventEmitter,
            y = e("xtend"),
            b = e("xtend/mutable"),
            w = e("fs"),
            k = e("fs-chunk-store"),
            x = e("simple-get"),
            v = e("immediate-chunk-store"),
            S = e("inherits"),
            C = e("multistream"),
            E = e("net"),
            B = e("os"),
            I = e("run-parallel"),
            L = e("run-parallel-limit"),
            T = e("parse-torrent"),
            A = e("path"),
            U = e("torrent-piece"),
            R = e("pump"),
            P = e("random-iterate"),
            O = e("simple-sha1"),
            H = e("speedometer"),
            M = e("uniq"),
            q = e("ut_metadata"),
            j = e("ut_pex"),
            F = e("./file"),
            N = e("./peer"),
            D = e("./rarity-map"),
            W = e("./server"),
            z = 5e3,
            V = 3 * U.BLOCK_LENGTH,
            G = 1,
            K = 2,
            X = [1000, 5000, 15000],
            Y = e("../package.json").version,
            $ = "WebTorrent/" + Y + " (https://webtorrent.io)",
            J;
        try {
          J = A.join(w.statSync("/tmp") && "/tmp", "webtorrent");
        } catch (e) {
          J = A.join("function" == typeof B.tmpdir ? B.tmpdir() : "/", "webtorrent");
        }
        S(i, _), Object.defineProperty(i.prototype, "timeRemaining", {get: function() {
            return this.done ? 0 : 0 === this.downloadSpeed ? Infinity : 1e3 * ((this.length - this.downloaded) / this.downloadSpeed);
          }}), Object.defineProperty(i.prototype, "downloaded", {get: function() {
            if (!this.bitfield)
              return 0;
            for (var e = 0,
                t = 0,
                n = this.pieces.length; t < n; ++t)
              if (this.bitfield.get(t))
                e += t === n - 1 ? this.lastPieceLength : this.pieceLength;
              else {
                var r = this.pieces[t];
                e += r.length - r.missing;
              }
            return e;
          }}), Object.defineProperty(i.prototype, "downloadSpeed", {get: function() {
            return this._downloadSpeed();
          }}), Object.defineProperty(i.prototype, "uploadSpeed", {get: function() {
            return this._uploadSpeed();
          }}), Object.defineProperty(i.prototype, "progress", {get: function() {
            return this.length ? this.downloaded / this.length : 0;
          }}), Object.defineProperty(i.prototype, "ratio", {get: function() {
            return this.uploaded / (this.received || 1);
          }}), Object.defineProperty(i.prototype, "numPeers", {get: function() {
            return this.wires.length;
          }}), Object.defineProperty(i.prototype, "torrentFileBlobURL", {get: function() {
            if ("undefined" == typeof window)
              throw new Error("browser-only property");
            return this.torrentFile ? URL.createObjectURL(new Blob([this.torrentFile], {type: "application/x-bittorrent"})) : null;
          }}), Object.defineProperty(i.prototype, "_numQueued", {get: function() {
            return this._queue.length + (this._peersLength - this._numConns);
          }}), Object.defineProperty(i.prototype, "_numConns", {get: function() {
            var e = this,
                t = 0;
            for (var n in e._peers)
              e._peers[n].connected && (t += 1);
            return t;
          }}), Object.defineProperty(i.prototype, "swarm", {get: function() {
            return console.warn("WebTorrent: `torrent.swarm` is deprecated. Use `torrent` directly instead."), this;
          }}), i.prototype._onTorrentId = function(e) {
          var t = this;
          if (!t.destroyed) {
            var n;
            try {
              n = T(e);
            } catch (e) {}
            n ? (t.infoHash = n.infoHash, t._debugId = n.infoHash.toString("hex").substring(0, 7), r.nextTick(function() {
              t.destroyed || t._onParsedTorrent(n);
            })) : T.remote(e, function(e, n) {
              return t.destroyed ? void 0 : e ? t._destroy(e) : void t._onParsedTorrent(n);
            });
          }
        }, i.prototype._onParsedTorrent = function(e) {
          var t = this;
          if (!t.destroyed) {
            if (t._processParsedTorrent(e), !t.infoHash)
              return t._destroy(new Error("Malformed torrent data: No info hash"));
            (t.path || (t.path = A.join(J, t.infoHash)), t._rechokeIntervalId = setInterval(function() {
              t._rechoke();
            }, 1e4), t._rechokeIntervalId.unref && t._rechokeIntervalId.unref(), t.emit("_infoHash", t.infoHash), !t.destroyed) && (t.emit("infoHash", t.infoHash), t.destroyed || (t.client.listening ? t._onListening() : t.client.once("listening", function() {
              t._onListening();
            })));
          }
        }, i.prototype._processParsedTorrent = function(e) {
          this._debugId = e.infoHash.toString("hex").substring(0, 7), this.announce && (e.announce = e.announce.concat(this.announce)), this.client.tracker && o.WEBTORRENT_ANNOUNCE && !this.private && (e.announce = e.announce.concat(o.WEBTORRENT_ANNOUNCE)), this.urlList && (e.urlList = e.urlList.concat(this.urlList)), M(e.announce), M(e.urlList), b(this, e), this.magnetURI = T.toMagnetURI(e), this.torrentFile = T.toTorrentFile(e);
        }, i.prototype._onListening = function() {
          function e(e) {
            i._destroy(e);
          }
          function t(e) {
            "string" == typeof e && i.done || i.addPeer(e);
          }
          function r() {
            i.emit("trackerAnnounce"), 0 === i.numPeers && i.emit("noPeers", "tracker");
          }
          function o() {
            i.emit("dhtAnnounce"), 0 === i.numPeers && i.emit("noPeers", "dht");
          }
          function s(e) {
            i.emit("warning", e);
          }
          var i = this;
          if (!(i.discovery || i.destroyed)) {
            var d = i.client.tracker;
            d && (d = y(i.client.tracker, {getAnnounceOpts: function() {
                var e = {
                  uploaded: i.uploaded,
                  downloaded: i.downloaded,
                  left: n(i.length - i.downloaded, 0)
                };
                return i.client.tracker.getAnnounceOpts && b(e, i.client.tracker.getAnnounceOpts()), i._getAnnounceOpts && b(e, i._getAnnounceOpts()), e;
              }})), i.discovery = new g({
              infoHash: i.infoHash,
              announce: i.announce,
              peerId: i.client.peerId,
              dht: !i.private && i.client.dht,
              tracker: d,
              port: i.client.torrentPort,
              userAgent: $
            }), i.discovery.on("error", e), i.discovery.on("peer", t), i.discovery.on("trackerAnnounce", r), i.discovery.on("dhtAnnounce", o), i.discovery.on("warning", s), i.info ? i._onMetadata(i) : i.xs && i._getMetadataFromServer();
          }
        }, i.prototype._getMetadataFromServer = function() {
          function e(e, n) {
            function r(r, o, s) {
              if (t.destroyed)
                return n(null);
              if (t.metadata)
                return n(null);
              if (r)
                return t.emit("warning", new Error("http error from xs param: " + e)), n(null);
              if (200 !== o.statusCode)
                return t.emit("warning", new Error("non-200 status code " + o.statusCode + " from xs param: " + e)), n(null);
              var i;
              try {
                i = T(s);
              } catch (e) {}
              return i ? i.infoHash === t.infoHash ? void(t._onMetadata(i), n(null)) : (t.emit("warning", new Error("got torrent file with incorrect info hash from xs param: " + e)), n(null)) : (t.emit("warning", new Error("got invalid torrent file from xs param: " + e)), n(null));
            }
            if (0 !== e.indexOf("http://") && 0 !== e.indexOf("https://"))
              return t.emit("warning", new Error("skipping non-http xs param: " + e)), n(null);
            var o;
            try {
              o = x.concat({
                url: e,
                method: "GET",
                headers: {"user-agent": $}
              }, r);
            } catch (r) {
              return t.emit("warning", new Error("skipping invalid url xs param: " + e)), n(null);
            }
            t._xsRequests.push(o);
          }
          var t = this,
              n = Array.isArray(t.xs) ? t.xs : [t.xs],
              r = n.map(function(t) {
                return function(n) {
                  e(t, n);
                };
              });
          I(r);
        }, i.prototype._onMetadata = function(e) {
          var t = this;
          if (!(t.metadata || t.destroyed)) {
            t._debug("got metadata"), t._xsRequests.forEach(function(e) {
              e.abort();
            }), t._xsRequests = [];
            var n;
            if (e && e.infoHash)
              n = e;
            else
              try {
                n = T(e);
              } catch (e) {
                return t._destroy(e);
              }
            t._processParsedTorrent(n), t.metadata = t.torrentFile, t.client.enableWebSeeds && t.urlList.forEach(function(e) {
              t.addWebSeed(e);
            }), 0 !== t.pieces.length && t.select(0, t.pieces.length - 1, !1), t._rarityMap = new D(t), t.store = new v(new t._store(t.pieceLength, {
              torrent: {infoHash: t.infoHash},
              files: t.files.map(function(e) {
                return {
                  path: A.join(t.path, e.path),
                  length: e.length,
                  offset: e.offset
                };
              }),
              length: t.length
            })), t.files = t.files.map(function(e) {
              return new F(t, e);
            }), t._hashes = t.pieces, t.pieces = t.pieces.map(function(e, n) {
              var r = n === t.pieces.length - 1 ? t.lastPieceLength : t.pieceLength;
              return new U(r);
            }), t._reservations = t.pieces.map(function() {
              return [];
            }), t.bitfield = new f(t.pieces.length), t.wires.forEach(function(e) {
              e.ut_metadata && e.ut_metadata.setMetadata(t.metadata), t._onWireWithMetadata(e);
            }), t._debug("verifying existing torrent data"), t._fileModtimes && t._store === k ? t.getFileModtimes(function(e, n) {
              if (e)
                return t._destroy(e);
              var r = t.files.map(function(e, r) {
                return n[r] === t._fileModtimes[r];
              }).every(function(e) {
                return e;
              });
              if (r) {
                for (var o = 0; o < t.pieces.length; o++)
                  t._markVerified(o);
                t._onStore();
              } else
                t._verifyPieces();
            }) : t._verifyPieces(), t.emit("metadata");
          }
        }, i.prototype.getFileModtimes = function(e) {
          var t = this,
              n = [];
          L(t.files.map(function(e, r) {
            return function(o) {
              w.stat(A.join(t.path, e.path), function(e, t) {
                return e && "ENOENT" !== e.code ? o(e) : void(n[r] = t && t.mtime.getTime(), o(null));
              });
            };
          }), K, function(r) {
            t._debug("done getting file modtimes"), e(r, n);
          });
        }, i.prototype._verifyPieces = function() {
          var e = this;
          L(e.pieces.map(function(t, n) {
            return function(t) {
              return e.destroyed ? t(new Error("torrent is destroyed")) : void e.store.get(n, function(o, s) {
                return e.destroyed ? t(new Error("torrent is destroyed")) : o ? r.nextTick(t, null) : void O(s, function(r) {
                  if (e.destroyed)
                    return t(new Error("torrent is destroyed"));
                  if (r === e._hashes[n]) {
                    if (!e.pieces[n])
                      return;
                    e._debug("piece verified %s", n), e._markVerified(n);
                  } else
                    e._debug("piece invalid %s", n);
                  t(null);
                });
              });
            };
          }), K, function(t) {
            return t ? e._destroy(t) : void(e._debug("done verifying"), e._onStore());
          });
        }, i.prototype._markVerified = function(e) {
          this.pieces[e] = null, this._reservations[e] = null, this.bitfield.set(e, !0);
        }, i.prototype._onStore = function() {
          var e = this;
          e.destroyed || (e._debug("on store"), e.ready = !0, e.emit("ready"), e._checkDone(), e._updateSelections());
        }, i.prototype.destroy = function(e) {
          var t = this;
          t._destroy(null, e);
        }, i.prototype._destroy = function(e, t) {
          var n = this;
          if (!n.destroyed) {
            for (var r in n.destroyed = !0, n._debug("destroy"), n.client._remove(n), clearInterval(n._rechokeIntervalId), n._xsRequests.forEach(function(e) {
              e.abort();
            }), n._rarityMap && n._rarityMap.destroy(), n._peers)
              n.removePeer(r);
            n.files.forEach(function(e) {
              e instanceof F && e._destroy();
            });
            var o = n._servers.map(function(e) {
              return function(t) {
                e.destroy(t);
              };
            });
            n.discovery && o.push(function(e) {
              n.discovery.destroy(e);
            }), n.store && o.push(function(e) {
              n.store.close(e);
            }), I(o, t), e && (0 === n.listenerCount("error") ? n.client.emit("error", e) : n.emit("error", e)), n.emit("close"), n.client = null, n.files = [], n.discovery = null, n.store = null, n._rarityMap = null, n._peers = null, n._servers = null, n._xsRequests = null;
          }
        }, i.prototype.addPeer = function(e) {
          var t = this;
          if (t.destroyed)
            throw new Error("torrent is destroyed");
          if (!t.infoHash)
            throw new Error("addPeer() must not be called before the `infoHash` event");
          if (t.client.blocked) {
            var n;
            if ("string" == typeof e) {
              var r;
              try {
                r = u(e);
              } catch (n) {
                return t._debug("ignoring peer: invalid %s", e), t.emit("invalidPeer", e), !1;
              }
              n = r[0];
            } else
              "string" == typeof e.remoteAddress && (n = e.remoteAddress);
            if (n && t.client.blocked.contains(n))
              return t._debug("ignoring peer: blocked %s", e), "string" != typeof e && e.destroy(), t.emit("blockedPeer", e), !1;
          }
          var o = !!t._addPeer(e);
          return o ? t.emit("peer", e) : t.emit("invalidPeer", e), o;
        }, i.prototype._addPeer = function(e) {
          var t = this;
          if (t.destroyed)
            return "string" != typeof e && e.destroy(), null;
          if ("string" == typeof e && !t._validAddr(e))
            return t._debug("ignoring peer: invalid %s", e), null;
          var n = e && e.id || e;
          if (t._peers[n])
            return t._debug("ignoring peer: duplicate (%s)", n), "string" != typeof e && e.destroy(), null;
          if (t.paused)
            return t._debug("ignoring peer: torrent is paused"), "string" != typeof e && e.destroy(), null;
          t._debug("add peer %s", n);
          var r;
          return r = "string" == typeof e ? N.createTCPOutgoingPeer(e, t) : N.createWebRTCPeer(e, t), t._peers[r.id] = r, t._peersLength += 1, "string" == typeof e && (t._queue.push(r), t._drain()), r;
        }, i.prototype.addWebSeed = function(e) {
          if (this.destroyed)
            throw new Error("torrent is destroyed");
          if (!/^https?:\/\/.+/.test(e))
            return this.emit("warning", new Error("ignoring invalid web seed: " + e)), void this.emit("invalidPeer", e);
          if (this._peers[e])
            return this.emit("warning", new Error("ignoring duplicate web seed: " + e)), void this.emit("invalidPeer", e);
          this._debug("add web seed %s", e);
          var t = N.createWebSeedPeer(e, this);
          this._peers[t.id] = t, this._peersLength += 1, this.emit("peer", e);
        }, i.prototype._addIncomingPeer = function(e) {
          var t = this;
          return t.destroyed ? e.destroy(new Error("torrent is destroyed")) : t.paused ? e.destroy(new Error("torrent is paused")) : void(this._debug("add incoming peer %s", e.id), t._peers[e.id] = e, t._peersLength += 1);
        }, i.prototype.removePeer = function(e) {
          var t = this,
              n = e && e.id || e;
          e = t._peers[n];
          e && (this._debug("removePeer %s", n), delete t._peers[n], t._peersLength -= 1, e.destroy(), t._drain());
        }, i.prototype.select = function(e, t, n, r) {
          var o = this;
          if (o.destroyed)
            throw new Error("torrent is destroyed");
          if (0 > e || t < e || o.pieces.length <= t)
            throw new Error("invalid selection ", e, ":", t);
          n = +n || 0, o._debug("select %s-%s (priority %s)", e, t, n), o._selections.push({
            from: e,
            to: t,
            offset: 0,
            priority: n,
            notify: r || p
          }), o._selections.sort(function(e, t) {
            return t.priority - e.priority;
          }), o._updateSelections();
        }, i.prototype.deselect = function(e, t, n) {
          var r = this;
          if (r.destroyed)
            throw new Error("torrent is destroyed");
          n = +n || 0, r._debug("deselect %s-%s (priority %s)", e, t, n);
          for (var o = 0,
              i; o < r._selections.length; ++o)
            if (i = r._selections[o], i.from === e && i.to === t && i.priority === n) {
              r._selections.splice(o, 1);
              break;
            }
          r._updateSelections();
        }, i.prototype.critical = function(e, t) {
          var n = this;
          if (n.destroyed)
            throw new Error("torrent is destroyed");
          n._debug("critical %s-%s", e, t);
          for (var r = e; r <= t; ++r)
            n._critical[r] = !0;
          n._updateSelections();
        }, i.prototype._onWire = function(e, t) {
          var n = this;
          if (n._debug("got wire %s (%s)", e._debugId, t || "Unknown"), e.on("download", function(e) {
            n.destroyed || (n.received += e, n._downloadSpeed(e), n.client._downloadSpeed(e), n.emit("download", e), n.client.emit("download", e));
          }), e.on("upload", function(e) {
            n.destroyed || (n.uploaded += e, n._uploadSpeed(e), n.client._uploadSpeed(e), n.emit("upload", e), n.client.emit("upload", e));
          }), n.wires.push(e), t) {
            var o = u(t);
            e.remoteAddress = o[0], e.remotePort = o[1];
          }
          n.client.dht && n.client.dht.listening && e.on("port", function(r) {
            return n.destroyed || n.client.dht.destroyed ? void 0 : e.remoteAddress ? 0 === r || 65536 < r ? n._debug("ignoring invalid PORT from peer") : void(n._debug("port: %s (from %s)", r, t), n.client.dht.addNode({
              host: e.remoteAddress,
              port: r
            })) : n._debug("ignoring PORT from peer with no address");
          }), e.on("timeout", function() {
            n._debug("wire timeout (%s)", t), e.destroy();
          }), e.setTimeout(3e4, !0), e.setKeepAlive(!0), e.use(q(n.metadata)), e.ut_metadata.on("warning", function(e) {
            n._debug("ut_metadata warning: %s", e.message);
          }), n.metadata || (e.ut_metadata.on("metadata", function(e) {
            n._debug("got metadata via ut_metadata"), n._onMetadata(e);
          }), e.ut_metadata.fetch()), "function" != typeof j || n.private || (e.use(j()), e.ut_pex.on("peer", function(e) {
            n.done || (n._debug("ut_pex: got peer: %s (from %s)", e, t), n.addPeer(e));
          }), e.ut_pex.on("dropped", function(e) {
            var r = n._peers[e];
            r && !r.connected && (n._debug("ut_pex: dropped peer: %s (from %s)", e, t), n.removePeer(e));
          }), e.once("close", function() {
            e.ut_pex.reset();
          })), n.emit("wire", e, t), n.metadata && r.nextTick(function() {
            n._onWireWithMetadata(e);
          });
        }, i.prototype._onWireWithMetadata = function(e) {
          function t() {
            r.destroyed || e.destroyed || (r._numQueued > 2 * (r._numConns - r.numPeers) && e.amInterested ? e.destroy() : (o = setTimeout(t, z), o.unref && o.unref()));
          }
          function n() {
            if (e.peerPieces.buffer.length === r.bitfield.buffer.length) {
              for (s = 0; s < r.pieces.length; ++s)
                if (!e.peerPieces.get(s))
                  return;
              e.isSeeder = !0, e.choke();
            }
          }
          var r = this,
              o = null,
              s;
          e.on("bitfield", function() {
            n(), r._update();
          }), e.on("have", function() {
            n(), r._update();
          }), e.once("interested", function() {
            e.unchoke();
          }), e.once("close", function() {
            clearTimeout(o);
          }), e.on("choke", function() {
            clearTimeout(o), o = setTimeout(t, z), o.unref && o.unref();
          }), e.on("unchoke", function() {
            clearTimeout(o), r._update();
          }), e.on("request", function(t, n, o, s) {
            return o > 131072 ? e.destroy() : void(r.pieces[t] || r.store.get(t, {
              offset: n,
              length: o
            }, s));
          }), e.bitfield(r.bitfield), e.interested(), e.peerExtensions.dht && r.client.dht && r.client.dht.listening && e.port(r.client.dht.address().port), "webSeed" !== e.type && (o = setTimeout(t, z), o.unref && o.unref()), e.isSeeder = !1, n();
        }, i.prototype._updateSelections = function() {
          var e = this;
          !e.ready || e.destroyed || (r.nextTick(function() {
            e._gcSelections();
          }), e._updateInterest(), e._update());
        }, i.prototype._gcSelections = function() {
          for (var e = this,
              t = 0; t < e._selections.length; ++t) {
            for (var n = e._selections[t],
                r = n.offset; e.bitfield.get(n.from + n.offset) && n.from + n.offset < n.to; )
              n.offset += 1;
            r !== n.offset && n.notify(), n.to === n.from + n.offset && e.bitfield.get(n.from + n.offset) && (e._selections.splice(t, 1), t -= 1, n.notify(), e._updateInterest());
          }
          e._selections.length || e.emit("idle");
        }, i.prototype._updateInterest = function() {
          var e = this,
              t = e._amInterested;
          e._amInterested = !!e._selections.length, e.wires.forEach(function(t) {
            e._amInterested ? t.interested() : t.uninterested();
          });
          t === e._amInterested || (e._amInterested ? e.emit("interested") : e.emit("uninterested"));
        }, i.prototype._update = function() {
          var e = this;
          if (!e.destroyed)
            for (var t = P(e.wires),
                n; n = t(); )
              e._updateWire(n);
        }, i.prototype._updateWire = function(e) {
          function t(t, n, r, o) {
            return function(s) {
              return s >= t && s <= n && !(s in r) && e.peerPieces.get(s) && (!o || o(s));
            };
          }
          function r() {
            if (!e.requests.length)
              for (var n = d._selections.length; n--; ) {
                var r = d._selections[n],
                    o;
                if ("rarest" === d.strategy)
                  for (var s = r.from + r.offset,
                      i = r.to,
                      a = {},
                      c = 0,
                      l = t(s, i, a); c < i - s + 1 && (o = d._rarityMap.getRarestPiece(l), !(0 > o)); ) {
                    if (d._request(e, o, !1))
                      return;
                    a[o] = !0, c += 1;
                  }
                else
                  for (o = r.to; o >= r.from + r.offset; --o)
                    if (e.peerPieces.get(o) && d._request(e, o, !1))
                      return;
              }
          }
          function o() {
            var t = e.downloadSpeed() || 1;
            if (t > V)
              return function() {
                return !0;
              };
            var r = n(1, e.requests.length) * U.BLOCK_LENGTH / t,
                o = 10,
                s = 0;
            return function(e) {
              if (!o || d.bitfield.get(e))
                return !0;
              for (var n = d.pieces[e].missing; s < d.wires.length; s++) {
                var i = d.wires[s],
                    a = i.downloadSpeed();
                if (!(a < V) && !(a <= t) && i.peerPieces.get(e) && !(0 < (n -= a * r)))
                  return o--, !1;
              }
              return !0;
            };
          }
          function s(e) {
            for (var t = e,
                n = e; n < d._selections.length && d._selections[n].priority; n++)
              t = n;
            var r = d._selections[e];
            d._selections[e] = d._selections[t], d._selections[t] = r;
          }
          function i(n) {
            if (e.requests.length >= l)
              return !0;
            for (var r = o(),
                a = 0; a < d._selections.length; a++) {
              var i = d._selections[a],
                  c;
              if ("rarest" === d.strategy)
                for (var p = i.from + i.offset,
                    u = i.to,
                    f = {},
                    h = 0,
                    m = t(p, u, f, r); h < u - p + 1 && (c = d._rarityMap.getRarestPiece(m), !(0 > c)); ) {
                  for (; d._request(e, c, d._critical[c] || n); )
                    ;
                  if (e.requests.length < l) {
                    f[c] = !0, h++;
                    continue;
                  }
                  return i.priority && s(a), !0;
                }
              else
                for (c = i.from + i.offset; c <= i.to; c++)
                  if (e.peerPieces.get(c) && r(c)) {
                    for (; d._request(e, c, d._critical[c] || n); )
                      ;
                    if (!(e.requests.length < l))
                      return i.priority && s(a), !0;
                  }
            }
            return !1;
          }
          var d = this;
          if (!e.peerChoking) {
            if (!e.downloaded)
              return r();
            var c = a(e, 0.5);
            if (!(e.requests.length >= c)) {
              var l = a(e, G);
              i(!1) || i(!0);
            }
          }
        }, i.prototype._rechoke = function() {
          function e(e, t) {
            return e.downloadSpeed === t.downloadSpeed ? e.uploadSpeed === t.uploadSpeed ? e.wire.amChoking === t.wire.amChoking ? e.salt - t.salt : e.wire.amChoking ? 1 : -1 : t.uploadSpeed - e.uploadSpeed : t.downloadSpeed - e.downloadSpeed;
          }
          var t = this;
          if (t.ready) {
            0 < t._rechokeOptimisticTime ? t._rechokeOptimisticTime -= 1 : t._rechokeOptimisticWire = null;
            var n = [];
            t.wires.forEach(function(e) {
              e.isSeeder || e === t._rechokeOptimisticWire || n.push({
                wire: e,
                downloadSpeed: e.downloadSpeed(),
                uploadSpeed: e.uploadSpeed(),
                salt: Math.random(),
                isChoked: !0
              });
            }), n.sort(e);
            for (var r = 0,
                o = 0; o < n.length && r < t._rechokeNumSlots; ++o)
              n[o].isChoked = !1, n[o].wire.peerInterested && (r += 1);
            if (!t._rechokeOptimisticWire && o < n.length && t._rechokeNumSlots) {
              var s = n.slice(o).filter(function(e) {
                return e.wire.peerInterested;
              }),
                  i = s[l(s.length)];
              i && (i.isChoked = !1, t._rechokeOptimisticWire = i.wire, t._rechokeOptimisticTime = 2);
            }
            n.forEach(function(e) {
              e.wire.amChoking !== e.isChoked && (e.isChoked ? e.wire.choke() : e.wire.unchoke());
            });
          }
        }, i.prototype._hotswap = function(e, t) {
          var n = this,
              o = e.downloadSpeed();
          if (o < U.BLOCK_LENGTH)
            return !1;
          if (!n._reservations[t])
            return !1;
          var s = n._reservations[t];
          if (!s)
            return !1;
          var d = Infinity,
              a,
              c;
          for (c = 0; c < s.length; c++) {
            var i = s[c];
            if (i && i !== e) {
              var l = i.downloadSpeed();
              l >= V || 2 * l > o || l > d || (a = i, d = l);
            }
          }
          if (!a)
            return !1;
          for (c = 0; c < s.length; c++)
            s[c] === a && (s[c] = null);
          for (c = 0; c < a.requests.length; c++) {
            var p = a.requests[c];
            p.piece === t && n.pieces[t].cancel(0 | p.offset / U.BLOCK_LENGTH);
          }
          return n.emit("hotswap", a, e, t), !0;
        }, i.prototype._request = function(e, t, n) {
          function o() {
            r.nextTick(function() {
              s._update();
            });
          }
          var s = this,
              l = e.requests.length,
              p = "webSeed" === e.type;
          if (s.bitfield.get(t))
            return !1;
          var u = p ? d(c(e, G, s.pieceLength), s.maxWebConns) : a(e, G);
          if (l >= u)
            return !1;
          var f = s.pieces[t],
              h = p ? f.reserveRemaining() : f.reserve();
          if (-1 === h && n && s._hotswap(e, t) && (h = p ? f.reserveRemaining() : f.reserve()), -1 === h)
            return !1;
          var m = s._reservations[t];
          m || (m = s._reservations[t] = []);
          var g = m.indexOf(null);
          -1 === g && (g = m.length), m[g] = e;
          var i = f.chunkOffset(h),
              _ = p ? f.chunkLengthRemaining(h) : f.chunkLength(h);
          return e.request(t, i, _, function n(r, d) {
            if (!s.destroyed) {
              if (!s.ready)
                return s.once("ready", function() {
                  n(r, d);
                });
              if (m[g] === e && (m[g] = null), f !== s.pieces[t])
                return o();
              if (r)
                return s._debug("error getting piece %s (offset: %s length: %s) from %s: %s", t, i, _, e.remoteAddress + ":" + e.remotePort, r.message), p ? f.cancelRemaining(h) : f.cancel(h), void o();
              if (s._debug("got piece %s (offset: %s length: %s) from %s", t, i, _, e.remoteAddress + ":" + e.remotePort), !f.set(h, d, e))
                return o();
              var a = f.flush();
              O(a, function(e) {
                if (!s.destroyed) {
                  if (e === s._hashes[t]) {
                    if (!s.pieces[t])
                      return;
                    s._debug("piece verified %s", t), s.pieces[t] = null, s._reservations[t] = null, s.bitfield.set(t, !0), s.store.put(t, a), s.wires.forEach(function(e) {
                      e.have(t);
                    }), s._checkDone() && !s.destroyed && s.discovery.complete();
                  } else
                    s.pieces[t] = new U(f.length), s.emit("warning", new Error("Piece " + t + " failed verification"));
                  o();
                }
              });
            }
          }), !0;
        }, i.prototype._checkDone = function() {
          var e = this;
          if (!e.destroyed) {
            e.files.forEach(function(t) {
              if (!t.done) {
                for (var n = t._startPiece; n <= t._endPiece; ++n)
                  if (!e.bitfield.get(n))
                    return;
                t.done = !0, t.emit("done"), e._debug("file done: " + t.name);
              }
            });
            for (var t = !0,
                n = 0,
                r; n < e._selections.length; n++) {
              r = e._selections[n];
              for (var o = r.from; o <= r.to; o++)
                if (!e.bitfield.get(o)) {
                  t = !1;
                  break;
                }
              if (!t)
                break;
            }
            return !e.done && t && (e.done = !0, e._debug("torrent done: " + e.infoHash), e.emit("done")), e._gcSelections(), t;
          }
        }, i.prototype.load = function(e, t) {
          var n = this;
          if (n.destroyed)
            throw new Error("torrent is destroyed");
          if (!n.ready)
            return n.once("ready", function() {
              n.load(e, t);
            });
          Array.isArray(e) || (e = [e]), t || (t = p);
          var r = new C(e),
              o = new h(n.store, n.pieceLength);
          R(r, o, function(e) {
            return e ? t(e) : void(n.pieces.forEach(function(e, t) {
              n.pieces[t] = null, n._reservations[t] = null, n.bitfield.set(t, !0);
            }), n._checkDone(), t(null));
          });
        }, i.prototype.createServer = function(e) {
          if ("function" != typeof W)
            throw new Error("node.js-only method");
          if (this.destroyed)
            throw new Error("torrent is destroyed");
          var t = new W(this, e);
          return this._servers.push(t), t;
        }, i.prototype.pause = function() {
          this.destroyed || (this._debug("pause"), this.paused = !0);
        }, i.prototype.resume = function() {
          this.destroyed || (this._debug("resume"), this.paused = !1, this._drain());
        }, i.prototype._debug = function() {
          if (!this.destroyed) {
            var e = [].slice.call(arguments);
            e[0] = "[" + this.client._debugId + "] [" + this._debugId + "] " + e[0], m.apply(null, e);
          }
        }, i.prototype._drain = function() {
          var e = this;
          if (this._debug("_drain numConns %s maxConns %s", e._numConns, e.client.maxConns), !("function" != typeof E.connect || e.destroyed || e.paused || e._numConns >= e.client.maxConns)) {
            this._debug("drain (%s queued, %s/%s peers)", e._numQueued, e.numPeers, e.client.maxConns);
            var t = e._queue.shift();
            if (t) {
              this._debug("tcp connect attempt to %s", t.addr);
              var n = u(t.addr),
                  r = {
                    host: n[0],
                    port: n[1]
                  },
                  o = t.conn = E.connect(r);
              o.once("connect", function() {
                t.onConnect();
              }), o.once("error", function(e) {
                t.destroy(e);
              }), t.startConnectTimeout(), o.on("close", function() {
                if (!e.destroyed) {
                  if (t.retries >= X.length)
                    return void e._debug("conn %s closed: will not re-add (max %s attempts)", t.addr, X.length);
                  var n = X[t.retries];
                  e._debug("conn %s closed: will re-add to queue in %sms (attempt %s)", t.addr, n, t.retries + 1);
                  var r = setTimeout(function() {
                    var n = e._addPeer(t.addr);
                    n && (n.retries = t.retries + 1);
                  }, n);
                  r.unref && r.unref();
                }
              });
            }
          }
        }, i.prototype._validAddr = function(e) {
          var t;
          try {
            t = u(e);
          } catch (t) {
            return !1;
          }
          var n = t[0],
              r = t[1];
          return 0 < r && 65535 > r && ("127.0.0.1" !== n || r !== this.client.torrentPort);
        };
      }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
    }, {
      "../package.json": 129,
      "./file": 2,
      "./peer": 3,
      "./rarity-map": 4,
      "./server": 23,
      _process: 67,
      "addr-to-ip-port": 7,
      bitfield: 13,
      "chunk-store-stream/write": 27,
      debug: 31,
      events: 35,
      fs: 24,
      "fs-chunk-store": 51,
      "immediate-chunk-store": 41,
      inherits: 42,
      multistream: 59,
      net: 23,
      os: 23,
      "parse-torrent": 63,
      path: 64,
      pump: 68,
      "random-iterate": 73,
      "run-parallel": 90,
      "run-parallel-limit": 89,
      "simple-get": 94,
      "simple-sha1": 96,
      speedometer: 98,
      "torrent-discovery": 110,
      "torrent-piece": 111,
      uniq: 114,
      ut_metadata: 118,
      ut_pex: 23,
      xtend: 126,
      "xtend/mutable": 127
    }],
    6: [function(e, t) {
      function r(e, t) {
        p.call(this), this.url = e, this.webPeerId = l.sync(e), this._torrent = t, this._init();
      }
      t.exports = r;
      var o = e("bitfield"),
          s = e("safe-buffer").Buffer,
          i = e("debug")("webtorrent:webconn"),
          a = e("simple-get"),
          c = e("inherits"),
          l = e("simple-sha1"),
          p = e("bittorrent-protocol"),
          u = e("../package.json").version;
      c(r, p), r.prototype._init = function() {
        var e = this;
        e.setKeepAlive(!0), e.once("handshake", function(t) {
          if (!e.destroyed) {
            e.handshake(t, e.webPeerId);
            for (var n = e._torrent.pieces.length,
                r = new o(n),
                s = 0; s <= n; s++)
              r.set(s, !0);
            e.bitfield(r);
          }
        }), e.once("interested", function() {
          i("interested"), e.unchoke();
        }), e.on("uninterested", function() {
          i("uninterested");
        }), e.on("choke", function() {
          i("choke");
        }), e.on("unchoke", function() {
          i("unchoke");
        }), e.on("bitfield", function() {
          i("bitfield");
        }), e.on("request", function(t, n, r, o) {
          i("request pieceIndex=%d offset=%d length=%d", t, n, r), e.httpRequest(t, n, r, o);
        });
      }, r.prototype.httpRequest = function(e, t, r, o) {
        var c = this,
            l = e * c._torrent.pieceLength,
            p = l + t,
            f = p + r - 1,
            h = c._torrent.files,
            m;
        if (1 >= h.length)
          m = [{
            url: c.url,
            start: p,
            end: f
          }];
        else {
          var g = h.filter(function(e) {
            return e.offset <= f && e.offset + e.length > p;
          });
          if (1 > g.length)
            return o(new Error("Could not find file corresponnding to web seed range request"));
          m = g.map(function(e) {
            var t = e.offset + e.length - 1,
                r = c.url + ("/" === c.url[c.url.length - 1] ? "" : "/") + e.path;
            return {
              url: r,
              fileOffsetInRange: n(e.offset - p, 0),
              start: n(p - e.offset, 0),
              end: d(t, f - e.offset)
            };
          });
        }
        var _ = 0,
            y = !1,
            b;
        1 < m.length && (b = s.alloc(r)), m.forEach(function(n) {
          function s(e, t) {
            return 200 > e.statusCode || 300 <= e.statusCode ? (y = !0, o(new Error("Unexpected HTTP status code " + e.statusCode))) : void(i("Got data of length %d", t.length), 1 === m.length ? o(null, t) : (t.copy(b, n.fileOffsetInRange), ++_ === m.length && o(null, b)));
          }
          var d = n.url,
              c = n.start,
              l = n.end;
          i("Requesting url=%s pieceIndex=%d offset=%d length=%d start=%d end=%d", d, e, t, r, c, l);
          var p = {
            url: d,
            method: "GET",
            headers: {
              "user-agent": "WebTorrent/" + u + " (https://webtorrent.io)",
              range: "bytes=" + c + "-" + l
            }
          };
          a.concat(p, function(e, t, n) {
            return y ? void 0 : e ? "undefined" == typeof window || d.startsWith(window.location.origin + "/") ? (y = !0, o(e)) : a.head(d, function(t, n) {
              return y ? void 0 : t ? (y = !0, o(t)) : 200 > n.statusCode || 300 <= n.statusCode ? (y = !0, o(new Error("Unexpected HTTP status code " + n.statusCode))) : n.url === d ? (y = !0, o(e)) : void(p.url = n.url, a.concat(p, function(e, t, n) {
                return y ? void 0 : e ? (y = !0, o(e)) : void s(t, n);
              }));
            }) : void s(t, n);
          });
        });
      }, r.prototype.destroy = function() {
        p.prototype.destroy.call(this), this._torrent = null;
      };
    }, {
      "../package.json": 129,
      bitfield: 13,
      "bittorrent-protocol": 14,
      debug: 31,
      inherits: 42,
      "safe-buffer": 92,
      "simple-get": 94,
      "simple-sha1": 96
    }],
    7: [function(e, t) {
      var n = /^\[?([^\]]+)\]?:(\d+)$/,
          r = {},
          o = 0;
      t.exports = function(e) {
        if (1e5 == o && t.exports.reset(), !r[e]) {
          var s = n.exec(e);
          if (!s)
            throw new Error("invalid addr: " + e);
          r[e] = [s[1], +s[2]], o += 1;
        }
        return r[e];
      }, t.exports.reset = function() {
        r = {}, o = 0;
      };
    }, {}],
    8: [function(e, t, n) {
      "use strict";
      function r(e) {
        var t = e.length;
        if (0 < t % 4)
          throw new Error("Invalid string. Length must be a multiple of 4");
        return "=" === e[t - 2] ? 2 : "=" === e[t - 1] ? 1 : 0;
      }
      function o(e) {
        return d[63 & e >> 18] + d[63 & e >> 12] + d[63 & e >> 6] + d[63 & e];
      }
      function s(e, t, n) {
        for (var r = [],
            s = t,
            i; s < n; s += 3)
          i = (16711680 & e[s] << 16) + (65280 & e[s + 1] << 8) + (255 & e[s + 2]), r.push(o(i));
        return r.join("");
      }
      n.byteLength = function(e) {
        return 3 * e.length / 4 - r(e);
      }, n.toByteArray = function(e) {
        var t = e.length,
            n,
            o,
            s,
            i,
            d;
        i = r(e), d = new c(3 * t / 4 - i), o = 0 < i ? t - 4 : t;
        var l = 0;
        for (n = 0; n < o; n += 4)
          s = a[e.charCodeAt(n)] << 18 | a[e.charCodeAt(n + 1)] << 12 | a[e.charCodeAt(n + 2)] << 6 | a[e.charCodeAt(n + 3)], d[l++] = 255 & s >> 16, d[l++] = 255 & s >> 8, d[l++] = 255 & s;
        return 2 === i ? (s = a[e.charCodeAt(n)] << 2 | a[e.charCodeAt(n + 1)] >> 4, d[l++] = 255 & s) : 1 === i && (s = a[e.charCodeAt(n)] << 10 | a[e.charCodeAt(n + 1)] << 4 | a[e.charCodeAt(n + 2)] >> 2, d[l++] = 255 & s >> 8, d[l++] = 255 & s), d;
      }, n.fromByteArray = function(e) {
        for (var t = e.length,
            n = t % 3,
            r = "",
            o = [],
            a = 16383,
            c = 0,
            i = t - n,
            l; c < i; c += a)
          o.push(s(e, c, c + a > i ? i : c + a));
        return 1 == n ? (l = e[t - 1], r += d[l >> 2], r += d[63 & l << 4], r += "==") : 2 == n && (l = (e[t - 2] << 8) + e[t - 1], r += d[l >> 10], r += d[63 & l >> 4], r += d[63 & l << 2], r += "="), o.push(r), o.join("");
      };
      for (var d = [],
          a = [],
          c = "undefined" == typeof Uint8Array ? Array : Uint8Array,
          l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          p = 0,
          i = l.length; p < i; ++p)
        d[p] = l[p], a[l.charCodeAt(p)] = p;
      a[45] = 62, a[95] = 63;
    }, {}],
    9: [function(t, n) {
      (function(t) {
        function r(e, t, n) {
          for (var r = 0,
              o = 1,
              s = t,
              i; s < n; s++) {
            if (i = e[s], 58 > i && 48 <= i) {
              r = 10 * r + (i - 48);
              continue;
            }
            if (s !== t || 43 !== i) {
              if (s === t && 45 === i) {
                o = -1;
                continue;
              }
              if (46 === i)
                break;
              throw new Error("not a number: buffer[" + s + "] = " + i);
            }
          }
          return r * o;
        }
        function o(e, n, r, s) {
          return null == e || 0 === e.length ? null : ("number" != typeof n && null == s && (s = n, n = void 0), "number" != typeof r && null == s && (s = r, r = void 0), o.position = 0, o.encoding = s || null, o.data = t.isBuffer(e) ? e.slice(n, r) : new t(e), o.bytes = o.data.length, o.next());
        }
        const s = 101;
        o.bytes = 0, o.position = 0, o.data = null, o.encoding = null, o.next = function() {
          switch (o.data[o.position]) {
            case 100:
              return o.dictionary();
            case 108:
              return o.list();
            case 105:
              return o.integer();
            default:
              return o.buffer();
          }
        }, o.find = function(t) {
          for (var n = o.position,
              r = o.data.length,
              s = o.data; n < r; ) {
            if (s[n] === t)
              return n;
            n++;
          }
          throw new Error("Invalid data: Missing delimiter \"" + e(t) + "\" [0x" + t.toString(16) + "]");
        }, o.dictionary = function() {
          o.position++;
          for (var e = {}; o.data[o.position] !== s; )
            e[o.buffer()] = o.next();
          return o.position++, e;
        }, o.list = function() {
          o.position++;
          for (var e = []; o.data[o.position] !== s; )
            e.push(o.next());
          return o.position++, e;
        }, o.integer = function() {
          var e = o.find(s),
              t = r(o.data, o.position + 1, e);
          return o.position += e + 1 - o.position, t;
        }, o.buffer = function() {
          var e = o.find(58),
              t = r(o.data, o.position, e),
              n = ++e + t;
          return o.position = n, o.encoding ? o.data.toString(o.encoding, e, n) : o.data.slice(e, n);
        }, n.exports = o;
      }).call(this, t("buffer").Buffer);
    }, {buffer: 25}],
    10: [function(e, t) {
      function n(e, t, o) {
        var s = [],
            i = null;
        return n._encode(s, e), i = r.concat(s), n.bytes = i.length, r.isBuffer(t) ? (i.copy(t, o), t) : i;
      }
      var r = e("safe-buffer").Buffer;
      n.bytes = -1, n._floatConversionDetected = !1, n._encode = function(e, t) {
        if (r.isBuffer(t))
          return e.push(r.from(t.length + ":")), void e.push(t);
        if (null != t)
          switch (typeof t) {
            case "string":
              n.buffer(e, t);
              break;
            case "number":
              n.number(e, t);
              break;
            case "object":
              t.constructor === Array ? n.list(e, t) : n.dict(e, t);
              break;
            case "boolean":
              n.number(e, t ? 1 : 0);
          }
      };
      var o = r.from("e"),
          s = r.from("d"),
          d = r.from("l");
      n.buffer = function(e, t) {
        e.push(r.from(r.byteLength(t) + ":" + t));
      }, n.number = function(e, t) {
        var o = 2147483648,
            s = (t / o << 0) * o + (t % o << 0);
        e.push(r.from("i" + s + "e")), s === t || n._floatConversionDetected || (n._floatConversionDetected = !0, console.warn("WARNING: Possible data corruption detected with value \"" + t + "\":", "Bencoding only defines support for integers, value was converted to \"" + s + "\""), console.trace());
      }, n.dict = function(e, t) {
        e.push(s);
        for (var r = 0,
            i = Object.keys(t).sort(),
            d = i.length,
            a; r < d; r++)
          a = i[r], null == t[a] || (n.buffer(e, a), n._encode(e, t[a]));
        e.push(o);
      }, n.list = function(e, t) {
        var r = 0,
            s = t.length;
        for (e.push(d); r < s; r++)
          null != t[r] && n._encode(e, t[r]);
        e.push(o);
      }, t.exports = n;
    }, {"safe-buffer": 92}],
    11: [function(e, t) {
      var n = t.exports;
      n.encode = e("./encode"), n.decode = e("./decode"), n.byteLength = n.encodingLength = function(e) {
        return n.encode(e).length;
      };
    }, {
      "./decode": 9,
      "./encode": 10
    }],
    12: [function(e, t) {
      t.exports = function(e, t, n, r, o) {
        var s,
            i;
        if (void 0 === r)
          r = 0;
        else if (r |= 0, 0 > r || r >= e.length)
          throw new RangeError("invalid lower bound");
        if (void 0 === o)
          o = e.length - 1;
        else if (o |= 0, o < r || o >= e.length)
          throw new RangeError("invalid upper bound");
        for (; r <= o; )
          if (s = r + (o - r >> 1), i = +n(e[s], t, s, e), 0 > i)
            r = s + 1;
          else if (0 < i)
            o = s - 1;
          else
            return s;
        return ~r;
      };
    }, {}],
    13: [function(e, t) {
      (function(e) {
        function r(e, t) {
          return this instanceof r ? void(0 === arguments.length && (e = 0), this.grow = t && (isFinite(t.grow) && o(t.grow) || t.grow) || 0, ("number" == typeof e || e === void 0) && (e = new s(o(e)), e.fill && !e._isBuffer && e.fill(0)), this.buffer = e) : new r(e, t);
        }
        function o(e) {
          var t = e >> 3;
          return 0 != e % 8 && t++, t;
        }
        var s = "undefined" == typeof e ? "undefined" == typeof Int8Array ? function(e) {
          for (var t = Array(e),
              n = 0; n < e; n++)
            t[n] = 0;
        } : Int8Array : e;
        r.prototype.get = function(e) {
          var t = e >> 3;
          return t < this.buffer.length && !!(this.buffer[t] & 128 >> e % 8);
        }, r.prototype.set = function(e, t) {
          var r = e >> 3;
          t || 1 === arguments.length ? (this.buffer.length < r + 1 && this._grow(n(r + 1, d(2 * this.buffer.length, this.grow))), this.buffer[r] |= 128 >> e % 8) : r < this.buffer.length && (this.buffer[r] &= ~(128 >> e % 8));
        }, r.prototype._grow = function(e) {
          if (this.buffer.length < e && e <= this.grow) {
            var t = new s(e);
            if (t.fill && t.fill(0), this.buffer.copy)
              this.buffer.copy(t, 0);
            else
              for (var n = 0; n < this.buffer.length; n++)
                t[n] = this.buffer[n];
            this.buffer = t;
          }
        }, "undefined" != typeof t && (t.exports = r);
      }).call(this, e("buffer").Buffer);
    }, {buffer: 25}],
    14: [function(e, t) {
      function n(e, t, n, r) {
        this.piece = e, this.offset = t, this.length = n, this.callback = r;
      }
      function r() {
        return this instanceof r ? void(h.Duplex.call(this), this._debugId = u(4).toString("hex"), this._debug("new wire"), this.peerId = null, this.peerIdBuffer = null, this.type = null, this.amChoking = !0, this.amInterested = !1, this.peerChoking = !0, this.peerInterested = !1, this.peerPieces = new d(0, {grow: m}), this.peerExtensions = {}, this.requests = [], this.peerRequests = [], this.extendedMapping = {}, this.peerExtendedMapping = {}, this.extendedHandshake = {}, this.peerExtendedHandshake = {}, this._ext = {}, this._nextExt = 1, this.uploaded = 0, this.downloaded = 0, this.uploadSpeed = f(), this.downloadSpeed = f(), this._keepAliveInterval = null, this._timeout = null, this._timeoutMs = 0, this.destroyed = !1, this._finished = !1, this._parserSize = 0, this._parser = null, this._buffer = [], this._bufferSize = 0, this.on("finish", this._onFinish), this._parseHandshake()) : new r;
      }
      function o(e, t, n, r) {
        for (var o = 0,
            i; o < e.length; o++)
          if (i = e[o], i.piece === t && i.offset === n && i.length === r)
            return s(e, o), i;
        return null;
      }
      t.exports = r;
      var s = e("unordered-array-remove"),
          i = e("bencode"),
          d = e("bitfield"),
          a = e("safe-buffer").Buffer,
          c = e("debug")("bittorrent-protocol"),
          l = e("xtend"),
          p = e("inherits"),
          u = e("randombytes"),
          f = e("speedometer"),
          h = e("readable-stream"),
          m = 4e5,
          g = a.from("\x13BitTorrent protocol"),
          _ = a.from([0, 0, 0, 0]),
          y = a.from([0, 0, 0, 1, 0]),
          b = a.from([0, 0, 0, 1, 1]),
          w = a.from([0, 0, 0, 1, 2]),
          k = a.from([0, 0, 0, 1, 3]),
          x = [0, 0, 0, 0, 0, 0, 0, 0],
          v = [0, 0, 0, 3, 9, 0, 0];
      p(r, h.Duplex), r.prototype.setKeepAlive = function(e) {
        var t = this;
        t._debug("setKeepAlive %s", e), clearInterval(t._keepAliveInterval);
        !1 === e || (t._keepAliveInterval = setInterval(function() {
          t.keepAlive();
        }, 55000));
      }, r.prototype.setTimeout = function(e, t) {
        this._debug("setTimeout ms=%d unref=%s", e, t), this._clearTimeout(), this._timeoutMs = e, this._timeoutUnref = !!t, this._updateTimeout();
      }, r.prototype.destroy = function() {
        this.destroyed || (this.destroyed = !0, this._debug("destroy"), this.emit("close"), this.end());
      }, r.prototype.end = function() {
        this._debug("end"), this._onUninterested(), this._onChoke(), h.Duplex.prototype.end.apply(this, arguments);
      }, r.prototype.use = function(e) {
        function t() {}
        var n = e.prototype.name;
        if (!n)
          throw new Error("Extension class requires a \"name\" property on the prototype");
        this._debug("use extension.name=%s", n);
        var r = this._nextExt,
            o = new e(this);
        "function" != typeof o.onHandshake && (o.onHandshake = t), "function" != typeof o.onExtendedHandshake && (o.onExtendedHandshake = t), "function" != typeof o.onMessage && (o.onMessage = t), this.extendedMapping[r] = n, this._ext[n] = o, this[n] = o, this._nextExt += 1;
      }, r.prototype.keepAlive = function() {
        this._debug("keep-alive"), this._push(_);
      }, r.prototype.handshake = function(e, t, n) {
        var r,
            o;
        if ("string" == typeof e ? r = a.from(e, "hex") : (r = e, e = r.toString("hex")), "string" == typeof t ? o = a.from(t, "hex") : (o = t, t = o.toString("hex")), 20 !== r.length || 20 !== o.length)
          throw new Error("infoHash and peerId MUST have length 20");
        this._debug("handshake i=%s p=%s exts=%o", e, t, n);
        var s = a.from(x);
        s[5] |= 16, n && n.dht && (s[7] |= 1), this._push(a.concat([g, s, r, o])), this._handshakeSent = !0, this.peerExtensions.extended && !this._extendedHandshakeSent && this._sendExtendedHandshake();
      }, r.prototype._sendExtendedHandshake = function() {
        var e = l(this.extendedHandshake);
        for (var t in e.m = {}, this.extendedMapping) {
          var n = this.extendedMapping[t];
          e.m[n] = +t;
        }
        this.extended(0, i.encode(e)), this._extendedHandshakeSent = !0;
      }, r.prototype.choke = function() {
        if (!this.amChoking) {
          for (this.amChoking = !0, this._debug("choke"); this.peerRequests.length; )
            this.peerRequests.pop();
          this._push(y);
        }
      }, r.prototype.unchoke = function() {
        this.amChoking && (this.amChoking = !1, this._debug("unchoke"), this._push(b));
      }, r.prototype.interested = function() {
        this.amInterested || (this.amInterested = !0, this._debug("interested"), this._push(w));
      }, r.prototype.uninterested = function() {
        this.amInterested && (this.amInterested = !1, this._debug("uninterested"), this._push(k));
      }, r.prototype.have = function(e) {
        this._debug("have %d", e), this._message(4, [e], null);
      }, r.prototype.bitfield = function(e) {
        this._debug("bitfield"), a.isBuffer(e) || (e = e.buffer), this._message(5, [], e);
      }, r.prototype.request = function(e, t, r, o) {
        return o || (o = function() {}), this._finished ? o(new Error("wire is closed")) : this.peerChoking ? o(new Error("peer is choking")) : void(this._debug("request index=%d offset=%d length=%d", e, t, r), this.requests.push(new n(e, t, r, o)), this._updateTimeout(), this._message(6, [e, t, r], null));
      }, r.prototype.piece = function(e, t, n) {
        this._debug("piece index=%d offset=%d", e, t), this.uploaded += n.length, this.uploadSpeed(n.length), this.emit("upload", n.length), this._message(7, [e, t], n);
      }, r.prototype.cancel = function(e, t, n) {
        this._debug("cancel index=%d offset=%d length=%d", e, t, n), this._callback(o(this.requests, e, t, n), new Error("request was cancelled"), null), this._message(8, [e, t, n], null);
      }, r.prototype.port = function(e) {
        this._debug("port %d", e);
        var t = a.from(v);
        t.writeUInt16BE(e, 5), this._push(t);
      }, r.prototype.extended = function(e, t) {
        if (this._debug("extended ext=%s", e), "string" == typeof e && this.peerExtendedMapping[e] && (e = this.peerExtendedMapping[e]), "number" == typeof e) {
          var n = a.from([e]),
              r = a.isBuffer(t) ? t : i.encode(t);
          this._message(20, [], a.concat([n, r]));
        } else
          throw new Error("Unrecognized extension: " + e);
      }, r.prototype._read = function() {}, r.prototype._message = function(e, t, n) {
        var r = n ? n.length : 0,
            o = a.allocUnsafe(5 + 4 * t.length);
        o.writeUInt32BE(o.length + r - 4, 0), o[4] = e;
        for (var s = 0; s < t.length; s++)
          o.writeUInt32BE(t[s], 5 + 4 * s);
        this._push(o), n && this._push(n);
      }, r.prototype._push = function(e) {
        return this._finished ? void 0 : this.push(e);
      }, r.prototype._onKeepAlive = function() {
        this._debug("got keep-alive"), this.emit("keep-alive");
      }, r.prototype._onHandshake = function(e, t, n) {
        var r = e.toString("hex"),
            o = t.toString("hex");
        this._debug("got handshake i=%s p=%s exts=%o", r, o, n), this.peerId = o, this.peerIdBuffer = t, this.peerExtensions = n, this.emit("handshake", r, o, n);
        for (var s in this._ext)
          this._ext[s].onHandshake(r, o, n);
        n.extended && this._handshakeSent && !this._extendedHandshakeSent && this._sendExtendedHandshake();
      }, r.prototype._onChoke = function() {
        for (this.peerChoking = !0, this._debug("got choke"), this.emit("choke"); this.requests.length; )
          this._callback(this.requests.pop(), new Error("peer is choking"), null);
      }, r.prototype._onUnchoke = function() {
        this.peerChoking = !1, this._debug("got unchoke"), this.emit("unchoke");
      }, r.prototype._onInterested = function() {
        this.peerInterested = !0, this._debug("got interested"), this.emit("interested");
      }, r.prototype._onUninterested = function() {
        this.peerInterested = !1, this._debug("got uninterested"), this.emit("uninterested");
      }, r.prototype._onHave = function(e) {
        this.peerPieces.get(e) || (this._debug("got have %d", e), this.peerPieces.set(e, !0), this.emit("have", e));
      }, r.prototype._onBitField = function(e) {
        this.peerPieces = new d(e), this._debug("got bitfield"), this.emit("bitfield", this.peerPieces);
      }, r.prototype._onRequest = function(e, t, r) {
        var s = this;
        if (!s.amChoking) {
          s._debug("got request index=%d offset=%d length=%d", e, t, r);
          var i = function(n, i) {
            return d === o(s.peerRequests, e, t, r) ? n ? s._debug("error satisfying request index=%d offset=%d length=%d (%s)", e, t, r, n.message) : void s.piece(e, t, i) : void 0;
          },
              d = new n(e, t, r, i);
          s.peerRequests.push(d), s.emit("request", e, t, r, i);
        }
      }, r.prototype._onPiece = function(e, t, n) {
        this._debug("got piece index=%d offset=%d", e, t), this._callback(o(this.requests, e, t, n.length), null, n), this.downloaded += n.length, this.downloadSpeed(n.length), this.emit("download", n.length), this.emit("piece", e, t, n);
      }, r.prototype._onCancel = function(e, t, n) {
        this._debug("got cancel index=%d offset=%d length=%d", e, t, n), o(this.peerRequests, e, t, n), this.emit("cancel", e, t, n);
      }, r.prototype._onPort = function(e) {
        this._debug("got port %d", e), this.emit("port", e);
      }, r.prototype._onExtended = function(e, t) {
        if (0 === e) {
          var n;
          try {
            n = i.decode(t);
          } catch (e) {
            this._debug("ignoring invalid extended handshake: %s", e.message || e);
          }
          if (!n)
            return;
          this.peerExtendedHandshake = n;
          if ("object" == typeof n.m)
            for (var r in n.m)
              this.peerExtendedMapping[r] = +n.m[r].toString();
          for (r in this._ext)
            this.peerExtendedMapping[r] && this._ext[r].onExtendedHandshake(this.peerExtendedHandshake);
          this._debug("got extended handshake"), this.emit("extended", "handshake", this.peerExtendedHandshake);
        } else
          this.extendedMapping[e] && (e = this.extendedMapping[e], this._ext[e] && this._ext[e].onMessage(t)), this._debug("got extended message ext=%s", e), this.emit("extended", e, t);
      }, r.prototype._onTimeout = function() {
        this._debug("request timed out"), this._callback(this.requests.shift(), new Error("request has timed out"), null), this.emit("timeout");
      }, r.prototype._write = function(e, t, n) {
        for (this._bufferSize += e.length, this._buffer.push(e); this._bufferSize >= this._parserSize; ) {
          var r = 1 === this._buffer.length ? this._buffer[0] : a.concat(this._buffer);
          this._bufferSize -= this._parserSize, this._buffer = this._bufferSize ? [r.slice(this._parserSize)] : [], this._parser(r.slice(0, this._parserSize));
        }
        n(null);
      }, r.prototype._callback = function(e, t, n) {
        e && (this._clearTimeout(), !this.peerChoking && !this._finished && this._updateTimeout(), e.callback(t, n));
      }, r.prototype._clearTimeout = function() {
        this._timeout && (clearTimeout(this._timeout), this._timeout = null);
      }, r.prototype._updateTimeout = function() {
        var e = this;
        e._timeoutMs && e.requests.length && !e._timeout && (e._timeout = setTimeout(function() {
          e._onTimeout();
        }, e._timeoutMs), e._timeoutUnref && e._timeout.unref && e._timeout.unref());
      }, r.prototype._parse = function(e, t) {
        this._parserSize = e, this._parser = t;
      }, r.prototype._onMessageLength = function(e) {
        var t = e.readUInt32BE(0);
        0 < t ? this._parse(t, this._onMessage) : (this._onKeepAlive(), this._parse(4, this._onMessageLength));
      }, r.prototype._onMessage = function(e) {
        switch (this._parse(4, this._onMessageLength), e[0]) {
          case 0:
            return this._onChoke();
          case 1:
            return this._onUnchoke();
          case 2:
            return this._onInterested();
          case 3:
            return this._onUninterested();
          case 4:
            return this._onHave(e.readUInt32BE(1));
          case 5:
            return this._onBitField(e.slice(1));
          case 6:
            return this._onRequest(e.readUInt32BE(1), e.readUInt32BE(5), e.readUInt32BE(9));
          case 7:
            return this._onPiece(e.readUInt32BE(1), e.readUInt32BE(5), e.slice(9));
          case 8:
            return this._onCancel(e.readUInt32BE(1), e.readUInt32BE(5), e.readUInt32BE(9));
          case 9:
            return this._onPort(e.readUInt16BE(1));
          case 20:
            return this._onExtended(e.readUInt8(1), e.slice(2));
          default:
            return this._debug("got unknown message"), this.emit("unknownmessage", e);
        }
      }, r.prototype._parseHandshake = function() {
        var e = this;
        e._parse(1, function(t) {
          var n = t.readUInt8(0);
          e._parse(n + 48, function(t) {
            var r = t.slice(0, n);
            return "BitTorrent protocol" === r.toString() ? void(t = t.slice(n), e._onHandshake(t.slice(8, 28), t.slice(28, 48), {
              dht: !!(1 & t[7]),
              extended: !!(16 & t[5])
            }), e._parse(4, e._onMessageLength)) : (e._debug("Error: wire not speaking BitTorrent protocol (%s)", r.toString()), void e.end());
          });
        });
      }, r.prototype._onFinish = function() {
        for (this._finished = !0, this.push(null); this.read(); )
          ;
        for (clearInterval(this._keepAliveInterval), this._parse(Number.MAX_VALUE, function() {}); this.peerRequests.length; )
          this.peerRequests.pop();
        for (; this.requests.length; )
          this._callback(this.requests.pop(), new Error("wire was closed"), null);
      }, r.prototype._debug = function() {
        var e = [].slice.call(arguments);
        e[0] = "[" + this._debugId + "] " + e[0], c.apply(null, e);
      };
    }, {
      bencode: 11,
      bitfield: 13,
      debug: 15,
      inherits: 42,
      randombytes: 74,
      "readable-stream": 84,
      "safe-buffer": 92,
      speedometer: 98,
      "unordered-array-remove": 115,
      xtend: 126
    }],
    15: [function(e, t, n) {
      (function(o) {
        function r() {
          var e;
          try {
            e = n.storage.debug;
          } catch (t) {}
          return !e && "undefined" != typeof o && "env" in o && (e = o.env.DEBUG), e;
        }
        n = t.exports = e("./debug"), n.log = function() {
          return "object" == typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
        }, n.formatArgs = function(e) {
          var t = this.useColors;
          if (e[0] = (t ? "%c" : "") + this.namespace + (t ? " %c" : " ") + e[0] + (t ? "%c " : " ") + "+" + n.humanize(this.diff), !!t) {
            var r = "color: " + this.color;
            e.splice(1, 0, r, "color: inherit");
            var o = 0,
                s = 0;
            e[0].replace(/%[a-zA-Z%]/g, function(e) {
              "%%" === e || (o++, "%c" === e && (s = o));
            }), e.splice(s, 0, r);
          }
        }, n.save = function(e) {
          try {
            null == e ? n.storage.removeItem("debug") : n.storage.debug = e;
          } catch (t) {}
        }, n.load = r, n.useColors = function() {
          return "undefined" != typeof window && window.process && "renderer" === window.process.type || "undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && 31 <= parseInt(RegExp.$1, 10) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        }, n.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : function() {
          try {
            return window.localStorage;
          } catch (t) {}
        }(), n.colors = ["lightseagreen", "forestgreen", "goldenrod", "dodgerblue", "darkorchid", "crimson"], n.formatters.j = function(e) {
          try {
            return JSON.stringify(e);
          } catch (e) {
            return "[UnexpectedJSONParseError]: " + e.message;
          }
        }, n.enable(r());
      }).call(this, e("_process"));
    }, {
      "./debug": 16,
      _process: 67
    }],
    16: [function(e, t, n) {
      function r(e) {
        var t = 0,
            r;
        for (r in e)
          t = (t << 5) - t + e.charCodeAt(r), t |= 0;
        return n.colors[o(t) % n.colors.length];
      }
      function s(e) {
        function t() {
          if (t.enabled) {
            var e = t,
                r = +new Date,
                o = r - (d || r);
            e.diff = o, e.prev = d, e.curr = r, d = r;
            for (var s = Array(arguments.length),
                a = 0; a < s.length; a++)
              s[a] = arguments[a];
            s[0] = n.coerce(s[0]), "string" != typeof s[0] && s.unshift("%O");
            var i = 0;
            s[0] = s[0].replace(/%([a-zA-Z%])/g, function(t, r) {
              if ("%%" === t)
                return t;
              i++;
              var o = n.formatters[r];
              if ("function" == typeof o) {
                var d = s[i];
                t = o.call(e, d), s.splice(i, 1), i--;
              }
              return t;
            }), n.formatArgs.call(e, s);
            var c = t.log || n.log || console.log.bind(console);
            c.apply(e, s);
          }
        }
        return t.namespace = e, t.enabled = n.enabled(e), t.useColors = n.useColors(), t.color = r(e), "function" == typeof n.init && n.init(t), t;
      }
      n = t.exports = s.debug = s["default"] = s, n.coerce = function(e) {
        return e instanceof Error ? e.stack || e.message : e;
      }, n.disable = function() {
        n.enable("");
      }, n.enable = function(e) {
        n.save(e), n.names = [], n.skips = [];
        for (var t = ("string" == typeof e ? e : "").split(/[\s,]+/),
            r = t.length,
            o = 0; o < r; o++)
          t[o] && (e = t[o].replace(/\*/g, ".*?"), "-" === e[0] ? n.skips.push(new RegExp("^" + e.substr(1) + "$")) : n.names.push(new RegExp("^" + e + "$")));
      }, n.enabled = function(e) {
        var t,
            r;
        for (t = 0, r = n.skips.length; t < r; t++)
          if (n.skips[t].test(e))
            return !1;
        for (t = 0, r = n.names.length; t < r; t++)
          if (n.names[t].test(e))
            return !0;
        return !1;
      }, n.humanize = e("ms"), n.names = [], n.skips = [], n.formatters = {};
      var d;
    }, {ms: 58}],
    17: [function(e, t) {
      (function(n) {
        function r(e) {
          function t(e) {
            n.nextTick(function() {
              d.emit("warning", e);
            });
          }
          var d = this;
          if (!(d instanceof r))
            return new r(e);
          if (i.call(d), e || (e = {}), !e.peerId)
            throw new Error("Option `peerId` is required");
          if (!e.infoHash)
            throw new Error("Option `infoHash` is required");
          if (!e.announce)
            throw new Error("Option `announce` is required");
          if (!n.browser && !e.port)
            throw new Error("Option `port` is required");
          d.peerId = "string" == typeof e.peerId ? e.peerId : e.peerId.toString("hex"), d._peerIdBuffer = o.from(d.peerId, "hex"), d._peerIdBinary = d._peerIdBuffer.toString("binary"), d.infoHash = "string" == typeof e.infoHash ? e.infoHash : e.infoHash.toString("hex"), d._infoHashBuffer = o.from(d.infoHash, "hex"), d._infoHashBinary = d._infoHashBuffer.toString("binary"), s("new client %s", d.infoHash), d.destroyed = !1, d._port = e.port, d._getAnnounceOpts = e.getAnnounceOpts, d._rtcConfig = e.rtcConfig, d._userAgent = e.userAgent, d._wrtc = "function" == typeof e.wrtc ? e.wrtc() : e.wrtc;
          var a = "string" == typeof e.announce ? [e.announce] : null == e.announce ? [] : e.announce;
          a = a.map(function(e) {
            return e = e.toString(), "/" === e[e.length - 1] && (e = e.substring(0, e.length - 1)), e;
          }), a = u(a);
          var c = !1 !== d._wrtc && (!!d._wrtc || p.WEBRTC_SUPPORT);
          d._trackers = a.map(function(e) {
            var n = f.parse(e).protocol;
            return ("http:" === n || "https:" === n) && "function" == typeof m ? new m(d, e) : "udp:" === n && "function" == typeof g ? new g(d, e) : ("ws:" === n || "wss:" === n) && c ? "ws:" === n && "undefined" != typeof window && "https:" === window.location.protocol ? (t(new Error("Unsupported tracker protocol: " + e)), null) : new _(d, e) : (t(new Error("Unsupported tracker protocol: " + e)), null);
          }).filter(Boolean);
        }
        t.exports = r;
        var o = e("safe-buffer").Buffer,
            s = e("debug")("bittorrent-tracker:client"),
            i = e("events").EventEmitter,
            d = e("xtend"),
            a = e("inherits"),
            c = e("once"),
            l = e("run-parallel"),
            p = e("simple-peer"),
            u = e("uniq"),
            f = e("url"),
            h = e("./lib/common"),
            m = e("./lib/client/http-tracker"),
            g = e("./lib/client/udp-tracker"),
            _ = e("./lib/client/websocket-tracker");
        a(r, i), r.scrape = function(e, t) {
          if (t = c(t), !e.infoHash)
            throw new Error("Option `infoHash` is required");
          if (!e.announce)
            throw new Error("Option `announce` is required");
          var n = d(e, {
            infoHash: Array.isArray(e.infoHash) ? e.infoHash[0] : e.infoHash,
            peerId: o.from("01234567890123456789"),
            port: 6881
          }),
              s = new r(n);
          s.once("error", t), s.once("warning", t);
          var i = Array.isArray(e.infoHash) ? e.infoHash.length : 1,
              a = {};
          return s.on("scrape", function(e) {
            if (i -= 1, a[e.infoHash] = e, 0 === i) {
              s.destroy();
              var n = Object.keys(a);
              1 === n.length ? t(null, a[n[0]]) : t(null, a);
            }
          }), e.infoHash = Array.isArray(e.infoHash) ? e.infoHash.map(function(e) {
            return o.from(e, "hex");
          }) : o.from(e.infoHash, "hex"), s.scrape({infoHash: e.infoHash}), s;
        }, r.prototype.start = function(e) {
          var t = this;
          s("send `start`"), e = t._defaultAnnounceOpts(e), e.event = "started", t._announce(e), t._trackers.forEach(function(e) {
            e.setInterval();
          });
        }, r.prototype.stop = function(e) {
          var t = this;
          s("send `stop`"), e = t._defaultAnnounceOpts(e), e.event = "stopped", t._announce(e);
        }, r.prototype.complete = function(e) {
          var t = this;
          s("send `complete`"), e || (e = {}), e = t._defaultAnnounceOpts(e), e.event = "completed", t._announce(e);
        }, r.prototype.update = function(e) {
          var t = this;
          s("send `update`"), e = t._defaultAnnounceOpts(e), e.event && delete e.event, t._announce(e);
        }, r.prototype._announce = function(e) {
          var t = this;
          t._trackers.forEach(function(t) {
            t.announce(e);
          });
        }, r.prototype.scrape = function(e) {
          var t = this;
          s("send `scrape`"), e || (e = {}), t._trackers.forEach(function(t) {
            t.scrape(e);
          });
        }, r.prototype.setInterval = function(e) {
          var t = this;
          s("setInterval %d", e), t._trackers.forEach(function(t) {
            t.setInterval(e);
          });
        }, r.prototype.destroy = function(e) {
          var t = this;
          if (!t.destroyed) {
            t.destroyed = !0, s("destroy");
            var n = t._trackers.map(function(e) {
              return function(t) {
                e.destroy(t);
              };
            });
            l(n, e), t._trackers = [], t._getAnnounceOpts = null;
          }
        }, r.prototype._defaultAnnounceOpts = function(e) {
          var t = this;
          return e || (e = {}), null == e.numwant && (e.numwant = h.DEFAULT_ANNOUNCE_PEERS), null == e.uploaded && (e.uploaded = 0), null == e.downloaded && (e.downloaded = 0), t._getAnnounceOpts && (e = d(e, t._getAnnounceOpts())), e;
        };
      }).call(this, e("_process"));
    }, {
      "./lib/client/http-tracker": 23,
      "./lib/client/udp-tracker": 23,
      "./lib/client/websocket-tracker": 19,
      "./lib/common": 20,
      _process: 67,
      debug: 31,
      events: 35,
      inherits: 42,
      once: 61,
      "run-parallel": 90,
      "safe-buffer": 92,
      "simple-peer": 95,
      uniq: 114,
      url: 116,
      xtend: 126
    }],
    18: [function(e, t) {
      function n(e, t) {
        var n = this;
        r.call(n), n.client = e, n.announceUrl = t, n.interval = null, n.destroyed = !1;
      }
      t.exports = n;
      var r = e("events").EventEmitter,
          o = e("inherits");
      o(n, r), n.prototype.setInterval = function(e) {
        var t = this;
        null == e && (e = t.DEFAULT_ANNOUNCE_INTERVAL), clearInterval(t.interval), e && (t.interval = setInterval(function() {
          t.announce(t.client._defaultAnnounceOpts());
        }, e), t.interval.unref && t.interval.unref());
      };
    }, {
      events: 35,
      inherits: 42
    }],
    19: [function(e, n) {
      function o(e, t) {
        var n = this;
        h.call(n, e, t), a("new websocket tracker %s", t), n.peers = {}, n.socket = null, n.reconnecting = !1, n.retries = 0, n.reconnectTimer = null, n.expectingResponse = !1, n._openSocket();
      }
      function s() {}
      n.exports = o;
      var a = e("debug")("bittorrent-tracker:websocket-tracker"),
          i = e("xtend"),
          c = e("inherits"),
          l = e("simple-peer"),
          p = e("randombytes"),
          u = e("simple-websocket"),
          f = e("../common"),
          h = e("./tracker"),
          m = {};
      c(o, h), o.prototype.DEFAULT_ANNOUNCE_INTERVAL = 30000, o.prototype.announce = function(e) {
        var t = this;
        if (!(t.destroyed || t.reconnecting)) {
          if (!t.socket.connected)
            return void t.socket.once("connect", function() {
              t.announce(e);
            });
          var n = i(e, {
            action: "announce",
            info_hash: t.client._infoHashBinary,
            peer_id: t.client._peerIdBinary
          });
          if (t._trackerId && (n.trackerid = t._trackerId), "stopped" === e.event || "completed" === e.event)
            t._send(n);
          else {
            var r = d(e.numwant, 10);
            t._generateOffers(r, function(e) {
              n.numwant = r, n.offers = e, t._send(n);
            });
          }
        }
      }, o.prototype.scrape = function(e) {
        var t = this;
        if (!(t.destroyed || t.reconnecting)) {
          if (!t.socket.connected)
            return void t.socket.once("connect", function() {
              t.scrape(e);
            });
          var n = Array.isArray(e.infoHash) && 0 < e.infoHash.length ? e.infoHash.map(function(e) {
            return e.toString("binary");
          }) : e.infoHash && e.infoHash.toString("binary") || t.client._infoHashBinary;
          t._send({
            action: "scrape",
            info_hash: n
          });
        }
      }, o.prototype.destroy = function(e) {
        function t() {
          d && (clearTimeout(d), d = null), i.removeListener("data", t), i.destroy(), i = null;
        }
        var n = this;
        if (e || (e = s), n.destroyed)
          return e(null);
        for (var r in n.destroyed = !0, clearInterval(n.interval), clearTimeout(n.reconnectTimer), n.peers) {
          var o = n.peers[r];
          clearTimeout(o.trackerTimeout), o.destroy();
        }
        if (n.peers = null, n.socket && (n.socket.removeListener("connect", n._onSocketConnectBound), n.socket.removeListener("data", n._onSocketDataBound), n.socket.removeListener("close", n._onSocketCloseBound), n.socket.removeListener("error", n._onSocketErrorBound), n.socket = null), n._onSocketConnectBound = null, n._onSocketErrorBound = null, n._onSocketDataBound = null, n._onSocketCloseBound = null, m[n.announceUrl] && (m[n.announceUrl].consumers -= 1), 0 < m[n.announceUrl].consumers)
          return e();
        var i = m[n.announceUrl];
        if (delete m[n.announceUrl], i.on("error", s), i.once("close", e), !n.expectingResponse)
          return t();
        var d = setTimeout(t, f.DESTROY_TIMEOUT);
        i.once("data", t);
      }, o.prototype._openSocket = function() {
        var e = this;
        e.destroyed = !1, e.peers || (e.peers = {}), e._onSocketConnectBound = function() {
          e._onSocketConnect();
        }, e._onSocketErrorBound = function(t) {
          e._onSocketError(t);
        }, e._onSocketDataBound = function(t) {
          e._onSocketData(t);
        }, e._onSocketCloseBound = function() {
          e._onSocketClose();
        }, e.socket = m[e.announceUrl], e.socket ? m[e.announceUrl].consumers += 1 : (e.socket = m[e.announceUrl] = new u(e.announceUrl), e.socket.consumers = 1, e.socket.once("connect", e._onSocketConnectBound)), e.socket.on("data", e._onSocketDataBound), e.socket.once("close", e._onSocketCloseBound), e.socket.once("error", e._onSocketErrorBound);
      }, o.prototype._onSocketConnect = function() {
        var e = this;
        e.destroyed || e.reconnecting && (e.reconnecting = !1, e.retries = 0, e.announce(e.client._defaultAnnounceOpts()));
      }, o.prototype._onSocketData = function(e) {
        var t = this;
        if (!t.destroyed) {
          t.expectingResponse = !1;
          try {
            e = JSON.parse(e);
          } catch (e) {
            return void t.client.emit("warning", new Error("Invalid tracker response"));
          }
          "announce" === e.action ? t._onAnnounceResponse(e) : "scrape" === e.action ? t._onScrapeResponse(e) : t._onSocketError(new Error("invalid action in WS response: " + e.action));
        }
      }, o.prototype._onAnnounceResponse = function(e) {
        var t = this;
        if (e.info_hash !== t.client._infoHashBinary)
          return void a("ignoring websocket data from %s for %s (looking for %s: reused socket)", t.announceUrl, f.binaryToHex(e.info_hash), t.client.infoHash);
        if (!(e.peer_id && e.peer_id === t.client._peerIdBinary)) {
          a("received %s from %s for %s", JSON.stringify(e), t.announceUrl, t.client.infoHash);
          var n = e["failure reason"];
          if (n)
            return t.client.emit("warning", new Error(n));
          var r = e["warning message"];
          r && t.client.emit("warning", new Error(r));
          var o = e.interval || e["min interval"];
          o && t.setInterval(1e3 * o);
          var s = e["tracker id"];
          if (s && (t._trackerId = s), null != e.complete) {
            var i = Object.assign({}, e, {
              announce: t.announceUrl,
              infoHash: f.binaryToHex(e.info_hash)
            });
            t.client.emit("update", i);
          }
          var d;
          if (e.offer && e.peer_id && (a("creating peer (from remote offer)"), d = t._createPeer(), d.id = f.binaryToHex(e.peer_id), d.once("signal", function(n) {
            var r = {
              action: "announce",
              info_hash: t.client._infoHashBinary,
              peer_id: t.client._peerIdBinary,
              to_peer_id: e.peer_id,
              answer: n,
              offer_id: e.offer_id
            };
            t._trackerId && (r.trackerid = t._trackerId), t._send(r);
          }), d.signal(e.offer), t.client.emit("peer", d)), e.answer && e.peer_id) {
            var c = f.binaryToHex(e.offer_id);
            d = t.peers[c], d ? (d.id = f.binaryToHex(e.peer_id), d.signal(e.answer), t.client.emit("peer", d), clearTimeout(d.trackerTimeout), d.trackerTimeout = null, delete t.peers[c]) : a("got unexpected answer: " + JSON.stringify(e.answer));
          }
        }
      }, o.prototype._onScrapeResponse = function(e) {
        var t = this;
        e = e.files || {};
        var n = Object.keys(e);
        return 0 === n.length ? void t.client.emit("warning", new Error("invalid scrape response")) : void n.forEach(function(n) {
          var r = Object.assign(e[n], {
            announce: t.announceUrl,
            infoHash: f.binaryToHex(n)
          });
          t.client.emit("scrape", r);
        });
      }, o.prototype._onSocketClose = function() {
        var e = this;
        e.destroyed || (e.destroy(), e._startReconnectTimer());
      }, o.prototype._onSocketError = function(e) {
        var t = this;
        t.destroyed || (t.destroy(), t.client.emit("warning", e), t._startReconnectTimer());
      }, o.prototype._startReconnectTimer = function() {
        var e = this,
            n = r(Math.random() * 30000) + d(t(2, e.retries) * 15000, 1800000);
        e.reconnecting = !0, clearTimeout(e.reconnectTimer), e.reconnectTimer = setTimeout(function() {
          e.retries++, e._openSocket();
        }, n), e.reconnectTimer.unref && e.reconnectTimer.unref(), a("reconnecting socket in %s ms", n);
      }, o.prototype._send = function(e) {
        var t = this;
        if (!t.destroyed) {
          t.expectingResponse = !0;
          var n = JSON.stringify(e);
          a("send %s", n), t.socket.send(n);
        }
      }, o.prototype._generateOffers = function(e, t) {
        function n() {
          var e = p(20).toString("hex");
          a("creating peer (from _generateOffers)");
          var t = o.peers[e] = o._createPeer({initiator: !0});
          t.once("signal", function(t) {
            s.push({
              offer: t,
              offer_id: f.hexToBinary(e)
            }), r();
          }), t.trackerTimeout = setTimeout(function() {
            a("tracker timeout: destroying peer"), t.trackerTimeout = null, delete o.peers[e], t.destroy();
          }, 50000), t.trackerTimeout.unref && t.trackerTimeout.unref();
        }
        function r() {
          s.length === e && (a("generated %s offers", e), t(s));
        }
        var o = this,
            s = [];
        a("generating %s offers", e);
        for (var d = 0; d < e; ++d)
          n();
        r();
      }, o.prototype._createPeer = function(e) {
        function t(e) {
          r.client.emit("warning", new Error("Connection error: " + e.message)), o.destroy();
        }
        function n() {
          o.removeListener("error", t), o.removeListener("connect", n);
        }
        var r = this;
        e = Object.assign({
          trickle: !1,
          config: r.client._rtcConfig,
          wrtc: r.client._wrtc
        }, e);
        var o = new l(e);
        return o.once("error", t), o.once("connect", n), o;
      };
    }, {
      "../common": 20,
      "./tracker": 18,
      debug: 31,
      inherits: 42,
      randombytes: 74,
      "simple-peer": 95,
      "simple-websocket": 97,
      xtend: 126
    }],
    20: [function(e, t, n) {
      var r = e("safe-buffer").Buffer,
          o = e("xtend/mutable");
      n.DEFAULT_ANNOUNCE_PEERS = 50, n.MAX_ANNOUNCE_PEERS = 82, n.binaryToHex = function(e) {
        return "string" != typeof e && (e += ""), r.from(e, "binary").toString("hex");
      }, n.hexToBinary = function(e) {
        return "string" != typeof e && (e += ""), r.from(e, "hex").toString("binary");
      };
      var s = e("./common-node");
      o(n, s);
    }, {
      "./common-node": 23,
      "safe-buffer": 92,
      "xtend/mutable": 127
    }],
    21: [function(e, t) {
      (function(n) {
        t.exports = function(e, t) {
          function r(s) {
            o.removeEventListener("loadend", r, !1), s.error ? t(s.error) : t(null, n.from(o.result));
          }
          if ("undefined" == typeof Blob || !(e instanceof Blob))
            throw new Error("first argument must be a Blob");
          if ("function" != typeof t)
            throw new Error("second argument must be a function");
          var o = new FileReader;
          o.addEventListener("loadend", r, !1), o.readAsArrayBuffer(e);
        };
      }).call(this, e("buffer").Buffer);
    }, {buffer: 25}],
    22: [function(e, t) {
      (function(n) {
        function r(e, t) {
          return this instanceof r ? void(s.call(this), !t && (t = {}), "object" == typeof e && (t = e, e = t.size), this.size = e || 512, this._zeroPadding = !t.nopad && i(t.zeroPadding, !0), this._buffered = [], this._bufferedBytes = 0) : new r(e, t);
        }
        var o = e("inherits"),
            s = e("readable-stream").Transform,
            i = e("defined");
        t.exports = r, o(r, s), r.prototype._transform = function(e, t, r) {
          for (this._bufferedBytes += e.length, this._buffered.push(e); this._bufferedBytes >= this.size; ) {
            var o = n.concat(this._buffered);
            this._bufferedBytes -= this.size, this.push(o.slice(0, this.size)), this._buffered = [o.slice(this.size, o.length)];
          }
          r();
        }, r.prototype._flush = function() {
          if (this._bufferedBytes && this._zeroPadding) {
            var e = new n(this.size - this._bufferedBytes);
            e.fill(0), this._buffered.push(e), this.push(n.concat(this._buffered)), this._buffered = null;
          } else
            this._bufferedBytes && (this.push(n.concat(this._buffered)), this._buffered = null);
          this.push(null);
        };
      }).call(this, e("buffer").Buffer);
    }, {
      buffer: 25,
      defined: 33,
      inherits: 42,
      "readable-stream": 84
    }],
    23: [function() {}, {}],
    24: [function(e, t, n) {
      arguments[4][23][0].apply(n, arguments);
    }, {dup: 23}],
    25: [function(n, r, o) {
      "use strict";
      function s(e) {
        if (e > J)
          throw new RangeError("Invalid typed array length");
        var t = new Uint8Array(e);
        return t.__proto__ = c.prototype, t;
      }
      function c(e, t, n) {
        if ("number" == typeof e) {
          if ("string" == typeof t)
            throw new Error("If encoding is specified then the first argument must be a string");
          return p(e);
        }
        return i(e, t, n);
      }
      function i(e, t, n) {
        if ("number" == typeof e)
          throw new TypeError("\"value\" argument must not be a number");
        return K(e) || e && K(e.buffer) ? h(e, t, n) : "string" == typeof e ? u(e, t) : m(e);
      }
      function a(e) {
        if ("number" != typeof e)
          throw new TypeError("\"size\" argument must be of type number");
        else if (0 > e)
          throw new RangeError("\"size\" argument must not be negative");
      }
      function l(e, t, n) {
        return a(e), 0 >= e ? s(e) : void 0 === t ? s(e) : "string" == typeof n ? s(e).fill(t, n) : s(e).fill(t);
      }
      function p(e) {
        return a(e), s(0 > e ? 0 : 0 | g(e));
      }
      function u(e, t) {
        if (("string" != typeof t || "" === t) && (t = "utf8"), !c.isEncoding(t))
          throw new TypeError("Unknown encoding: " + t);
        var n = 0 | _(e, t),
            r = s(n),
            o = r.write(e, t);
        return o !== n && (r = r.slice(0, o)), r;
      }
      function f(e) {
        for (var t = 0 > e.length ? 0 : 0 | g(e.length),
            n = s(t),
            r = 0; r < t; r += 1)
          n[r] = 255 & e[r];
        return n;
      }
      function h(e, t, n) {
        if (0 > t || e.byteLength < t)
          throw new RangeError("\"offset\" is outside of buffer bounds");
        if (e.byteLength < t + (n || 0))
          throw new RangeError("\"length\" is outside of buffer bounds");
        var r;
        return r = void 0 === t && void 0 === n ? new Uint8Array(e) : void 0 === n ? new Uint8Array(e, t) : new Uint8Array(e, t, n), r.__proto__ = c.prototype, r;
      }
      function m(e) {
        if (c.isBuffer(e)) {
          var t = 0 | g(e.length),
              n = s(t);
          return 0 === n.length ? n : (e.copy(n, 0, 0, t), n);
        }
        if (e) {
          if (ArrayBuffer.isView(e) || "length" in e)
            return "number" != typeof e.length || X(e.length) ? s(0) : f(e);
          if ("Buffer" === e.type && Array.isArray(e.data))
            return f(e.data);
        }
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.");
      }
      function g(e) {
        if (e >= J)
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + J.toString(16) + " bytes");
        return 0 | e;
      }
      function _(e, t) {
        if (c.isBuffer(e))
          return e.length;
        if (ArrayBuffer.isView(e) || K(e))
          return e.byteLength;
        "string" != typeof e && (e = "" + e);
        var n = e.length;
        if (0 === n)
          return 0;
        for (var r = !1; ; )
          switch (t) {
            case "ascii":
            case "latin1":
            case "binary":
              return n;
            case "utf8":
            case "utf-8":
            case void 0:
              return D(e).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * n;
            case "hex":
              return n >>> 1;
            case "base64":
              return V(e).length;
            default:
              if (r)
                return D(e).length;
              t = ("" + t).toLowerCase(), r = !0;
          }
      }
      function y(e, t, n) {
        var r = !1;
        if ((void 0 === t || 0 > t) && (t = 0), t > this.length)
          return "";
        if ((void 0 === n || n > this.length) && (n = this.length), 0 >= n)
          return "";
        if (n >>>= 0, t >>>= 0, n <= t)
          return "";
        for (e || (e = "utf8"); ; )
          switch (e) {
            case "hex":
              return R(this, t, n);
            case "utf8":
            case "utf-8":
              return L(this, t, n);
            case "ascii":
              return A(this, t, n);
            case "latin1":
            case "binary":
              return U(this, t, n);
            case "base64":
              return I(this, t, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return P(this, t, n);
            default:
              if (r)
                throw new TypeError("Unknown encoding: " + e);
              e = (e + "").toLowerCase(), r = !0;
          }
      }
      function b(e, t, n) {
        var r = e[t];
        e[t] = e[n], e[n] = r;
      }
      function w(e, t, n, r, o) {
        if (0 === e.length)
          return -1;
        if ("string" == typeof n ? (r = n, n = 0) : 2147483647 < n ? n = 2147483647 : -2147483648 > n && (n = -2147483648), n = +n, X(n) && (n = o ? 0 : e.length - 1), 0 > n && (n = e.length + n), n >= e.length) {
          if (o)
            return -1;
          n = e.length - 1;
        } else if (0 > n)
          if (o)
            n = 0;
          else
            return -1;
        if ("string" == typeof t && (t = c.from(t, r)), c.isBuffer(t))
          return 0 === t.length ? -1 : k(e, t, n, r, o);
        if ("number" == typeof t)
          return t &= 255, "function" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(e, t, n) : Uint8Array.prototype.lastIndexOf.call(e, t, n) : k(e, [t], n, r, o);
        throw new TypeError("val must be string, number or Buffer");
      }
      function k(e, t, n, r, o) {
        function s(e, t) {
          return 1 == d ? e[t] : e.readUInt16BE(t * d);
        }
        var d = 1,
            a = e.length,
            c = t.length;
        if (void 0 !== r && (r = (r + "").toLowerCase(), "ucs2" === r || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) {
          if (2 > e.length || 2 > t.length)
            return -1;
          d = 2, a /= 2, c /= 2, n /= 2;
        }
        var l;
        if (o) {
          var i = -1;
          for (l = n; l < a; l++)
            if (s(e, l) !== s(t, -1 == i ? 0 : l - i))
              -1 != i && (l -= l - i), i = -1;
            else if (-1 == i && (i = l), l - i + 1 === c)
              return i * d;
        } else
          for (n + c > a && (n = a - c), l = n; 0 <= l; l--) {
            for (var p = !0,
                u = 0; u < c; u++)
              if (s(e, l + u) !== s(t, u)) {
                p = !1;
                break;
              }
            if (p)
              return l;
          }
        return -1;
      }
      function x(e, t, n, r) {
        n = +n || 0;
        var o = e.length - n;
        r ? (r = +r, r > o && (r = o)) : r = o;
        var s = t.length;
        r > s / 2 && (r = s / 2);
        for (var d = 0,
            i; d < r; ++d) {
          if (i = parseInt(t.substr(2 * d, 2), 16), X(i))
            return d;
          e[n + d] = i;
        }
        return d;
      }
      function v(e, t, n, r) {
        return G(D(t, e.length - n), e, n, r);
      }
      function S(e, t, n, r) {
        return G(W(t), e, n, r);
      }
      function C(e, t, n, r) {
        return S(e, t, n, r);
      }
      function E(e, t, n, r) {
        return G(V(t), e, n, r);
      }
      function B(e, t, n, r) {
        return G(z(t, e.length - n), e, n, r);
      }
      function I(e, t, n) {
        return 0 === t && n === e.length ? Y.fromByteArray(e) : Y.fromByteArray(e.slice(t, n));
      }
      function L(e, t, n) {
        n = d(e.length, n);
        for (var r = [],
            o = t; o < n; ) {
          var s = e[o],
              i = null,
              a = 239 < s ? 4 : 223 < s ? 3 : 191 < s ? 2 : 1;
          if (o + a <= n) {
            var c,
                l,
                p,
                u;
            1 == a ? 128 > s && (i = s) : 2 == a ? (c = e[o + 1], 128 == (192 & c) && (u = (31 & s) << 6 | 63 & c, 127 < u && (i = u))) : 3 == a ? (c = e[o + 1], l = e[o + 2], 128 == (192 & c) && 128 == (192 & l) && (u = (15 & s) << 12 | (63 & c) << 6 | 63 & l, 2047 < u && (55296 > u || 57343 < u) && (i = u))) : 4 == a ? (c = e[o + 1], l = e[o + 2], p = e[o + 3], 128 == (192 & c) && 128 == (192 & l) && 128 == (192 & p) && (u = (15 & s) << 18 | (63 & c) << 12 | (63 & l) << 6 | 63 & p, 65535 < u && 1114112 > u && (i = u))) : void 0;
          }
          null === i ? (i = 65533, a = 1) : 65535 < i && (i -= 65536, r.push(55296 | 1023 & i >>> 10), i = 56320 | 1023 & i), r.push(i), o += a;
        }
        return T(r);
      }
      function T(t) {
        var n = t.length;
        if (n <= Q)
          return e.apply(String, t);
        for (var r = "",
            o = 0; o < n; )
          r += e.apply(String, t.slice(o, o += Q));
        return r;
      }
      function A(t, n, r) {
        var o = "";
        r = d(t.length, r);
        for (var s = n; s < r; ++s)
          o += e(127 & t[s]);
        return o;
      }
      function U(t, n, r) {
        var o = "";
        r = d(t.length, r);
        for (var s = n; s < r; ++s)
          o += e(t[s]);
        return o;
      }
      function R(e, t, n) {
        var r = e.length;
        (!t || 0 > t) && (t = 0), (!n || 0 > n || n > r) && (n = r);
        for (var o = "",
            s = t; s < n; ++s)
          o += N(e[s]);
        return o;
      }
      function P(t, n, r) {
        for (var o = t.slice(n, r),
            s = "",
            d = 0; d < o.length; d += 2)
          s += e(o[d] + 256 * o[d + 1]);
        return s;
      }
      function O(e, t, n) {
        if (0 != e % 1 || 0 > e)
          throw new RangeError("offset is not uint");
        if (e + t > n)
          throw new RangeError("Trying to access beyond buffer length");
      }
      function H(e, t, n, r, o, s) {
        if (!c.isBuffer(e))
          throw new TypeError("\"buffer\" argument must be a Buffer instance");
        if (t > o || t < s)
          throw new RangeError("\"value\" argument is out of bounds");
        if (n + r > e.length)
          throw new RangeError("Index out of range");
      }
      function M(e, t, n, r) {
        if (n + r > e.length)
          throw new RangeError("Index out of range");
        if (0 > n)
          throw new RangeError("Index out of range");
      }
      function q(e, t, n, r, o) {
        return t = +t, n >>>= 0, o || M(e, t, n, 4, 3.4028234663852886e38, -3.4028234663852886e38), $.write(e, t, n, r, 23, 4), n + 4;
      }
      function j(e, t, n, r, o) {
        return t = +t, n >>>= 0, o || M(e, t, n, 8, 1.7976931348623157e308, -1.7976931348623157e308), $.write(e, t, n, r, 52, 8), n + 8;
      }
      function F(e) {
        if (e = e.split("=")[0], e = e.trim().replace(Z, ""), 2 > e.length)
          return "";
        for (; 0 != e.length % 4; )
          e += "=";
        return e;
      }
      function N(e) {
        return 16 > e ? "0" + e.toString(16) : e.toString(16);
      }
      function D(e, t) {
        t = t || Infinity;
        for (var n = e.length,
            r = null,
            o = [],
            s = 0,
            i; s < n; ++s) {
          if (i = e.charCodeAt(s), 55295 < i && 57344 > i) {
            if (!r) {
              if (56319 < i) {
                -1 < (t -= 3) && o.push(239, 191, 189);
                continue;
              } else if (s + 1 === n) {
                -1 < (t -= 3) && o.push(239, 191, 189);
                continue;
              }
              r = i;
              continue;
            }
            if (56320 > i) {
              -1 < (t -= 3) && o.push(239, 191, 189), r = i;
              continue;
            }
            i = (r - 55296 << 10 | i - 56320) + 65536;
          } else
            r && -1 < (t -= 3) && o.push(239, 191, 189);
          if (r = null, 128 > i) {
            if (0 > (t -= 1))
              break;
            o.push(i);
          } else if (2048 > i) {
            if (0 > (t -= 2))
              break;
            o.push(192 | i >> 6, 128 | 63 & i);
          } else if (65536 > i) {
            if (0 > (t -= 3))
              break;
            o.push(224 | i >> 12, 128 | 63 & i >> 6, 128 | 63 & i);
          } else if (1114112 > i) {
            if (0 > (t -= 4))
              break;
            o.push(240 | i >> 18, 128 | 63 & i >> 12, 128 | 63 & i >> 6, 128 | 63 & i);
          } else
            throw new Error("Invalid code point");
        }
        return o;
      }
      function W(e) {
        for (var t = [],
            n = 0; n < e.length; ++n)
          t.push(255 & e.charCodeAt(n));
        return t;
      }
      function z(e, t) {
        for (var n = [],
            r = 0,
            o,
            s,
            i; r < e.length && !(0 > (t -= 2)); ++r)
          o = e.charCodeAt(r), s = o >> 8, i = o % 256, n.push(i), n.push(s);
        return n;
      }
      function V(e) {
        return Y.toByteArray(F(e));
      }
      function G(e, t, n, r) {
        for (var o = 0; o < r && !(o + n >= t.length || o >= e.length); ++o)
          t[o + n] = e[o];
        return o;
      }
      function K(e) {
        return e instanceof ArrayBuffer || null != e && null != e.constructor && "ArrayBuffer" === e.constructor.name && "number" == typeof e.byteLength;
      }
      function X(e) {
        return e !== e;
      }
      var Y = n("base64-js"),
          $ = n("ieee754");
      o.Buffer = c, o.SlowBuffer = function(e) {
        return +e != e && (e = 0), c.alloc(+e);
      }, o.INSPECT_MAX_BYTES = 50;
      var J = 2147483647;
      o.kMaxLength = J, c.TYPED_ARRAY_SUPPORT = function() {
        try {
          var e = new Uint8Array(1);
          return e.__proto__ = {
            __proto__: Uint8Array.prototype,
            foo: function() {
              return 42;
            }
          }, 42 === e.foo();
        } catch (t) {
          return !1;
        }
      }(), c.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(c.prototype, "parent", {get: function() {
          return this instanceof c ? this.buffer : void 0;
        }}), Object.defineProperty(c.prototype, "offset", {get: function() {
          return this instanceof c ? this.byteOffset : void 0;
        }}), "undefined" != typeof Symbol && Symbol.species && c[Symbol.species] === c && Object.defineProperty(c, Symbol.species, {
        value: null,
        configurable: !0,
        enumerable: !1,
        writable: !1
      }), c.poolSize = 8192, c.from = function(e, t, n) {
        return i(e, t, n);
      }, c.prototype.__proto__ = Uint8Array.prototype, c.__proto__ = Uint8Array, c.alloc = function(e, t, n) {
        return l(e, t, n);
      }, c.allocUnsafe = function(e) {
        return p(e);
      }, c.allocUnsafeSlow = function(e) {
        return p(e);
      }, c.isBuffer = function(e) {
        return null != e && !0 === e._isBuffer;
      }, c.compare = function(e, t) {
        if (!c.isBuffer(e) || !c.isBuffer(t))
          throw new TypeError("Arguments must be Buffers");
        if (e === t)
          return 0;
        for (var n = e.length,
            r = t.length,
            o = 0,
            s = d(n, r); o < s; ++o)
          if (e[o] !== t[o]) {
            n = e[o], r = t[o];
            break;
          }
        return n < r ? -1 : r < n ? 1 : 0;
      }, c.isEncoding = function(e) {
        switch ((e + "").toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return !0;
          default:
            return !1;
        }
      }, c.concat = function(e, t) {
        if (!Array.isArray(e))
          throw new TypeError("\"list\" argument must be an Array of Buffers");
        if (0 === e.length)
          return c.alloc(0);
        var n;
        if (t === void 0)
          for (t = 0, n = 0; n < e.length; ++n)
            t += e[n].length;
        var r = c.allocUnsafe(t),
            o = 0;
        for (n = 0; n < e.length; ++n) {
          var s = e[n];
          if (ArrayBuffer.isView(s) && (s = c.from(s)), !c.isBuffer(s))
            throw new TypeError("\"list\" argument must be an Array of Buffers");
          s.copy(r, o), o += s.length;
        }
        return r;
      }, c.byteLength = _, c.prototype._isBuffer = !0, c.prototype.swap16 = function() {
        var e = this.length;
        if (0 != e % 2)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (var t = 0; t < e; t += 2)
          b(this, t, t + 1);
        return this;
      }, c.prototype.swap32 = function() {
        var e = this.length;
        if (0 != e % 4)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (var t = 0; t < e; t += 4)
          b(this, t, t + 3), b(this, t + 1, t + 2);
        return this;
      }, c.prototype.swap64 = function() {
        var e = this.length;
        if (0 != e % 8)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (var t = 0; t < e; t += 8)
          b(this, t, t + 7), b(this, t + 1, t + 6), b(this, t + 2, t + 5), b(this, t + 3, t + 4);
        return this;
      }, c.prototype.toString = function() {
        var e = this.length;
        return 0 === e ? "" : 0 === arguments.length ? L(this, 0, e) : y.apply(this, arguments);
      }, c.prototype.toLocaleString = c.prototype.toString, c.prototype.equals = function(e) {
        if (!c.isBuffer(e))
          throw new TypeError("Argument must be a Buffer");
        return this === e || 0 === c.compare(this, e);
      }, c.prototype.inspect = function() {
        var e = "",
            t = o.INSPECT_MAX_BYTES;
        return 0 < this.length && (e = this.toString("hex", 0, t).match(/.{2}/g).join(" "), this.length > t && (e += " ... ")), "<Buffer " + e + ">";
      }, c.prototype.compare = function(e, t, n, r, o) {
        if (!c.isBuffer(e))
          throw new TypeError("Argument must be a Buffer");
        if (void 0 === t && (t = 0), void 0 === n && (n = e ? e.length : 0), void 0 === r && (r = 0), void 0 === o && (o = this.length), 0 > t || n > e.length || 0 > r || o > this.length)
          throw new RangeError("out of range index");
        if (r >= o && t >= n)
          return 0;
        if (r >= o)
          return -1;
        if (t >= n)
          return 1;
        if (t >>>= 0, n >>>= 0, r >>>= 0, o >>>= 0, this === e)
          return 0;
        for (var s = o - r,
            a = n - t,
            l = d(s, a),
            p = this.slice(r, o),
            u = e.slice(t, n),
            f = 0; f < l; ++f)
          if (p[f] !== u[f]) {
            s = p[f], a = u[f];
            break;
          }
        return s < a ? -1 : a < s ? 1 : 0;
      }, c.prototype.includes = function(e, t, n) {
        return -1 !== this.indexOf(e, t, n);
      }, c.prototype.indexOf = function(e, t, n) {
        return w(this, e, t, n, !0);
      }, c.prototype.lastIndexOf = function(e, t, n) {
        return w(this, e, t, n, !1);
      }, c.prototype.write = function(e, t, n, r) {
        if (void 0 === t)
          r = "utf8", n = this.length, t = 0;
        else if (void 0 === n && "string" == typeof t)
          r = t, n = this.length, t = 0;
        else if (isFinite(t))
          t >>>= 0, isFinite(n) ? (n >>>= 0, void 0 === r && (r = "utf8")) : (r = n, n = void 0);
        else
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        var o = this.length - t;
        if ((void 0 === n || n > o) && (n = o), 0 < e.length && (0 > n || 0 > t) || t > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        r || (r = "utf8");
        for (var s = !1; ; )
          switch (r) {
            case "hex":
              return x(this, e, t, n);
            case "utf8":
            case "utf-8":
              return v(this, e, t, n);
            case "ascii":
              return S(this, e, t, n);
            case "latin1":
            case "binary":
              return C(this, e, t, n);
            case "base64":
              return E(this, e, t, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return B(this, e, t, n);
            default:
              if (s)
                throw new TypeError("Unknown encoding: " + r);
              r = ("" + r).toLowerCase(), s = !0;
          }
      }, c.prototype.toJSON = function() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      var Q = 4096;
      c.prototype.slice = function(e, t) {
        var n = this.length;
        e = ~~e, t = void 0 === t ? n : ~~t, 0 > e ? (e += n, 0 > e && (e = 0)) : e > n && (e = n), 0 > t ? (t += n, 0 > t && (t = 0)) : t > n && (t = n), t < e && (t = e);
        var r = this.subarray(e, t);
        return r.__proto__ = c.prototype, r;
      }, c.prototype.readUIntLE = function(e, t, n) {
        e >>>= 0, t >>>= 0, n || O(e, t, this.length);
        for (var r = this[e],
            o = 1,
            s = 0; ++s < t && (o *= 256); )
          r += this[e + s] * o;
        return r;
      }, c.prototype.readUIntBE = function(e, t, n) {
        e >>>= 0, t >>>= 0, n || O(e, t, this.length);
        for (var r = this[e + --t],
            o = 1; 0 < t && (o *= 256); )
          r += this[e + --t] * o;
        return r;
      }, c.prototype.readUInt8 = function(e, t) {
        return e >>>= 0, t || O(e, 1, this.length), this[e];
      }, c.prototype.readUInt16LE = function(e, t) {
        return e >>>= 0, t || O(e, 2, this.length), this[e] | this[e + 1] << 8;
      }, c.prototype.readUInt16BE = function(e, t) {
        return e >>>= 0, t || O(e, 2, this.length), this[e] << 8 | this[e + 1];
      }, c.prototype.readUInt32LE = function(e, t) {
        return e >>>= 0, t || O(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3];
      }, c.prototype.readUInt32BE = function(e, t) {
        return e >>>= 0, t || O(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
      }, c.prototype.readIntLE = function(e, n, r) {
        e >>>= 0, n >>>= 0, r || O(e, n, this.length);
        for (var o = this[e],
            s = 1,
            d = 0; ++d < n && (s *= 256); )
          o += this[e + d] * s;
        return s *= 128, o >= s && (o -= t(2, 8 * n)), o;
      }, c.prototype.readIntBE = function(e, n, r) {
        e >>>= 0, n >>>= 0, r || O(e, n, this.length);
        for (var o = n,
            s = 1,
            i = this[e + --o]; 0 < o && (s *= 256); )
          i += this[e + --o] * s;
        return s *= 128, i >= s && (i -= t(2, 8 * n)), i;
      }, c.prototype.readInt8 = function(e, t) {
        return e >>>= 0, t || O(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e];
      }, c.prototype.readInt16LE = function(e, t) {
        e >>>= 0, t || O(e, 2, this.length);
        var n = this[e] | this[e + 1] << 8;
        return 32768 & n ? 4294901760 | n : n;
      }, c.prototype.readInt16BE = function(e, t) {
        e >>>= 0, t || O(e, 2, this.length);
        var n = this[e + 1] | this[e] << 8;
        return 32768 & n ? 4294901760 | n : n;
      }, c.prototype.readInt32LE = function(e, t) {
        return e >>>= 0, t || O(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
      }, c.prototype.readInt32BE = function(e, t) {
        return e >>>= 0, t || O(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
      }, c.prototype.readFloatLE = function(e, t) {
        return e >>>= 0, t || O(e, 4, this.length), $.read(this, e, !0, 23, 4);
      }, c.prototype.readFloatBE = function(e, t) {
        return e >>>= 0, t || O(e, 4, this.length), $.read(this, e, !1, 23, 4);
      }, c.prototype.readDoubleLE = function(e, t) {
        return e >>>= 0, t || O(e, 8, this.length), $.read(this, e, !0, 52, 8);
      }, c.prototype.readDoubleBE = function(e, t) {
        return e >>>= 0, t || O(e, 8, this.length), $.read(this, e, !1, 52, 8);
      }, c.prototype.writeUIntLE = function(e, n, r, o) {
        if (e = +e, n >>>= 0, r >>>= 0, !o) {
          var s = t(2, 8 * r) - 1;
          H(this, e, n, r, s, 0);
        }
        var d = 1,
            a = 0;
        for (this[n] = 255 & e; ++a < r && (d *= 256); )
          this[n + a] = 255 & e / d;
        return n + r;
      }, c.prototype.writeUIntBE = function(e, n, r, o) {
        if (e = +e, n >>>= 0, r >>>= 0, !o) {
          var s = t(2, 8 * r) - 1;
          H(this, e, n, r, s, 0);
        }
        var d = r - 1,
            i = 1;
        for (this[n + d] = 255 & e; 0 <= --d && (i *= 256); )
          this[n + d] = 255 & e / i;
        return n + r;
      }, c.prototype.writeUInt8 = function(e, t, n) {
        return e = +e, t >>>= 0, n || H(this, e, t, 1, 255, 0), this[t] = 255 & e, t + 1;
      }, c.prototype.writeUInt16LE = function(e, t, n) {
        return e = +e, t >>>= 0, n || H(this, e, t, 2, 65535, 0), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2;
      }, c.prototype.writeUInt16BE = function(e, t, n) {
        return e = +e, t >>>= 0, n || H(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2;
      }, c.prototype.writeUInt32LE = function(e, t, n) {
        return e = +e, t >>>= 0, n || H(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e, t + 4;
      }, c.prototype.writeUInt32BE = function(e, t, n) {
        return e = +e, t >>>= 0, n || H(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4;
      }, c.prototype.writeIntLE = function(e, n, r, o) {
        if (e = +e, n >>>= 0, !o) {
          var s = t(2, 8 * r - 1);
          H(this, e, n, r, s - 1, -s);
        }
        var d = 0,
            i = 1,
            a = 0;
        for (this[n] = 255 & e; ++d < r && (i *= 256); )
          0 > e && 0 == a && 0 !== this[n + d - 1] && (a = 1), this[n + d] = 255 & (e / i >> 0) - a;
        return n + r;
      }, c.prototype.writeIntBE = function(e, n, r, o) {
        if (e = +e, n >>>= 0, !o) {
          var s = t(2, 8 * r - 1);
          H(this, e, n, r, s - 1, -s);
        }
        var d = r - 1,
            i = 1,
            a = 0;
        for (this[n + d] = 255 & e; 0 <= --d && (i *= 256); )
          0 > e && 0 == a && 0 !== this[n + d + 1] && (a = 1), this[n + d] = 255 & (e / i >> 0) - a;
        return n + r;
      }, c.prototype.writeInt8 = function(e, t, n) {
        return e = +e, t >>>= 0, n || H(this, e, t, 1, 127, -128), 0 > e && (e = 255 + e + 1), this[t] = 255 & e, t + 1;
      }, c.prototype.writeInt16LE = function(e, t, n) {
        return e = +e, t >>>= 0, n || H(this, e, t, 2, 32767, -32768), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2;
      }, c.prototype.writeInt16BE = function(e, t, n) {
        return e = +e, t >>>= 0, n || H(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2;
      }, c.prototype.writeInt32LE = function(e, t, n) {
        return e = +e, t >>>= 0, n || H(this, e, t, 4, 2147483647, -2147483648), this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4;
      }, c.prototype.writeInt32BE = function(e, t, n) {
        return e = +e, t >>>= 0, n || H(this, e, t, 4, 2147483647, -2147483648), 0 > e && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4;
      }, c.prototype.writeFloatLE = function(e, t, n) {
        return q(this, e, t, !0, n);
      }, c.prototype.writeFloatBE = function(e, t, n) {
        return q(this, e, t, !1, n);
      }, c.prototype.writeDoubleLE = function(e, t, n) {
        return j(this, e, t, !0, n);
      }, c.prototype.writeDoubleBE = function(e, t, n) {
        return j(this, e, t, !1, n);
      }, c.prototype.copy = function(e, t, n, r) {
        if (!c.isBuffer(e))
          throw new TypeError("argument should be a Buffer");
        if (n || (n = 0), r || 0 === r || (r = this.length), t >= e.length && (t = e.length), t || (t = 0), 0 < r && r < n && (r = n), r === n)
          return 0;
        if (0 === e.length || 0 === this.length)
          return 0;
        if (0 > t)
          throw new RangeError("targetStart out of bounds");
        if (0 > n || n >= this.length)
          throw new RangeError("Index out of range");
        if (0 > r)
          throw new RangeError("sourceEnd out of bounds");
        r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n);
        var o = r - n;
        if (this === e && "function" == typeof Uint8Array.prototype.copyWithin)
          this.copyWithin(t, n, r);
        else if (this === e && n < t && t < r)
          for (var s = o - 1; 0 <= s; --s)
            e[s + t] = this[s + n];
        else
          Uint8Array.prototype.set.call(e, this.subarray(n, r), t);
        return o;
      }, c.prototype.fill = function(e, t, n, r) {
        if ("string" == typeof e) {
          if ("string" == typeof t ? (r = t, t = 0, n = this.length) : "string" == typeof n && (r = n, n = this.length), void 0 !== r && "string" != typeof r)
            throw new TypeError("encoding must be a string");
          if ("string" == typeof r && !c.isEncoding(r))
            throw new TypeError("Unknown encoding: " + r);
          if (1 === e.length) {
            var o = e.charCodeAt(0);
            ("utf8" === r && 128 > o || "latin1" === r) && (e = o);
          }
        } else
          "number" == typeof e && (e &= 255);
        if (0 > t || this.length < t || this.length < n)
          throw new RangeError("Out of range index");
        if (n <= t)
          return this;
        t >>>= 0, n = n === void 0 ? this.length : n >>> 0, e || (e = 0);
        var s;
        if ("number" == typeof e)
          for (s = t; s < n; ++s)
            this[s] = e;
        else {
          var i = c.isBuffer(e) ? e : new c(e, r),
              d = i.length;
          if (0 === d)
            throw new TypeError("The value \"" + e + "\" is invalid for argument \"value\"");
          for (s = 0; s < n - t; ++s)
            this[s + t] = i[s % d];
        }
        return this;
      };
      var Z = /[^+/0-9A-Za-z-_]/g;
    }, {
      "base64-js": 8,
      ieee754: 40
    }],
    26: [function(e, t) {
      t.exports = {
        100: "Continue",
        101: "Switching Protocols",
        102: "Processing",
        200: "OK",
        201: "Created",
        202: "Accepted",
        203: "Non-Authoritative Information",
        204: "No Content",
        205: "Reset Content",
        206: "Partial Content",
        207: "Multi-Status",
        208: "Already Reported",
        226: "IM Used",
        300: "Multiple Choices",
        301: "Moved Permanently",
        302: "Found",
        303: "See Other",
        304: "Not Modified",
        305: "Use Proxy",
        307: "Temporary Redirect",
        308: "Permanent Redirect",
        400: "Bad Request",
        401: "Unauthorized",
        402: "Payment Required",
        403: "Forbidden",
        404: "Not Found",
        405: "Method Not Allowed",
        406: "Not Acceptable",
        407: "Proxy Authentication Required",
        408: "Request Timeout",
        409: "Conflict",
        410: "Gone",
        411: "Length Required",
        412: "Precondition Failed",
        413: "Payload Too Large",
        414: "URI Too Long",
        415: "Unsupported Media Type",
        416: "Range Not Satisfiable",
        417: "Expectation Failed",
        418: "I'm a teapot",
        421: "Misdirected Request",
        422: "Unprocessable Entity",
        423: "Locked",
        424: "Failed Dependency",
        425: "Unordered Collection",
        426: "Upgrade Required",
        428: "Precondition Required",
        429: "Too Many Requests",
        431: "Request Header Fields Too Large",
        451: "Unavailable For Legal Reasons",
        500: "Internal Server Error",
        501: "Not Implemented",
        502: "Bad Gateway",
        503: "Service Unavailable",
        504: "Gateway Timeout",
        505: "HTTP Version Not Supported",
        506: "Variant Also Negotiates",
        507: "Insufficient Storage",
        508: "Loop Detected",
        509: "Bandwidth Limit Exceeded",
        510: "Not Extended",
        511: "Network Authentication Required"
      };
    }, {}],
    27: [function(e, t) {
      function n(e, t, o) {
        var i = this;
        if (!(i instanceof n))
          return new n(e, t, o);
        if (s.Writable.call(i, o), o || (o = {}), !e || !e.put || !e.get)
          throw new Error("First argument must be an abstract-chunk-store compliant store");
        if (t = +t, !t)
          throw new Error("Second argument must be a chunk length");
        i._blockstream = new r(t, {zeroPadding: !1}), i._blockstream.on("data", function(t) {
          i.destroyed || (e.put(d, t), d += 1);
        }).on("error", function(e) {
          i.destroy(e);
        });
        var d = 0;
        i.on("finish", function() {
          this._blockstream.end();
        });
      }
      t.exports = n;
      var r = e("block-stream2"),
          o = e("inherits"),
          s = e("readable-stream");
      o(n, s.Writable), n.prototype._write = function(e, t, n) {
        this._blockstream.write(e, t, n);
      }, n.prototype.destroy = function(e) {
        this.destroyed || (this.destroyed = !0, e && this.emit("error", e), this.emit("close"));
      };
    }, {
      "block-stream2": 22,
      inherits: 42,
      "readable-stream": 84
    }],
    28: [function(e, t) {
      t.exports = function(e, t, n) {
        for (var r = Infinity,
            s = 0,
            d = t.length - 1,
            a,
            i,
            c; s <= d && (a = s + (d - s >> 1), c = t[a] - e, 0 > c ? s = a + 1 : 0 < c ? d = a - 1 : void 0, c = o(c), c < r && (r = c, i = a), t[a] !== e); )
          ;
        return n ? i : t[i];
      };
    }, {}],
    29: [function(e, t, n) {
      (function(e) {
        function t(e) {
          return Object.prototype.toString.call(e);
        }
        n.isArray = function(e) {
          return Array.isArray ? Array.isArray(e) : "[object Array]" === t(e);
        }, n.isBoolean = function(e) {
          return "boolean" == typeof e;
        }, n.isNull = function(e) {
          return null === e;
        }, n.isNullOrUndefined = function(e) {
          return null == e;
        }, n.isNumber = function(e) {
          return "number" == typeof e;
        }, n.isString = function(e) {
          return "string" == typeof e;
        }, n.isSymbol = function(e) {
          return "symbol" == typeof e;
        }, n.isUndefined = function(e) {
          return void 0 === e;
        }, n.isRegExp = function(e) {
          return "[object RegExp]" === t(e);
        }, n.isObject = function(e) {
          return "object" == typeof e && null !== e;
        }, n.isDate = function(e) {
          return "[object Date]" === t(e);
        }, n.isError = function(n) {
          return "[object Error]" === t(n) || n instanceof Error;
        }, n.isFunction = function(e) {
          return "function" == typeof e;
        }, n.isPrimitive = function(e) {
          return null === e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || "symbol" == typeof e || "undefined" == typeof e;
        }, n.isBuffer = e.isBuffer;
      }).call(this, {isBuffer: e("../../is-buffer/index.js")});
    }, {"../../is-buffer/index.js": 44}],
    30: [function(e, t) {
      (function(n, r, o) {
        function i(e, t, n) {
          return "function" == typeof t ? i(e, null, t) : void(t = t ? B(t) : {}, a(e, t, function(e, r, o) {
            return e ? n(e) : void(t.singleFileTorrent = o, h(r, t, n));
          }));
        }
        function d(e, t, n) {
          return "function" == typeof t ? d(e, null, t) : void(t = t ? B(t) : {}, a(e, t, n));
        }
        function a(e, t, r) {
          function s() {
            O(e.map(function(e) {
              return function(t) {
                var n = {};
                if (g(e))
                  n.getStream = b(e), n.length = e.size;
                else if (o.isBuffer(e))
                  n.getStream = w(e), n.length = e.length;
                else if (y(e))
                  n.getStream = x(e, n), n.length = 0;
                else {
                  if ("string" == typeof e) {
                    if ("function" != typeof T.stat)
                      throw new Error("filesystem paths do not work in the browser");
                    var r = 1 < i || a;
                    return void c(e, r, t);
                  }
                  throw new Error("invalid input type");
                }
                n.path = e.path, t(null, n);
              };
            }), function(e, t) {
              return e ? r(e) : void(t = L(t), r(null, t, a));
            });
          }
          if (Array.isArray(e) && 0 === e.length)
            throw new Error("invalid input type");
          _(e) && (e = Array.prototype.slice.call(e)), Array.isArray(e) || (e = [e]), e = e.map(function(e) {
            return g(e) && "string" == typeof e.path && "function" == typeof T.stat ? e.path : e;
          }), 1 !== e.length || "string" == typeof e[0] || e[0].name || (e[0].name = t.name);
          var d = null;
          e.forEach(function(t, n) {
            if ("string" != typeof t) {
              var r = t.fullPath || t.name;
              r || (r = "Unknown File " + (n + 1), t.unknownName = !0), t.path = r.split("/"), t.path[0] || t.path.shift(), 2 > t.path.length ? d = null : 0 === n && 1 < e.length ? d = t.path[0] : t.path[0] !== d && (d = null);
            }
          }), e = e.filter(function(e) {
            if ("string" == typeof e)
              return !0;
            var t = e.path[e.path.length - 1];
            return u(t) && U.not(t);
          }), d && e.forEach(function(e) {
            var t = (o.isBuffer(e) || y(e)) && !e.path;
            "string" == typeof e || t || e.path.shift();
          }), !t.name && d && (t.name = d), t.name || e.some(function(e) {
            return "string" == typeof e ? (t.name = E.basename(e), !0) : e.unknownName ? void 0 : (t.name = e.path[e.path.length - 1], !0);
          }), t.name || (t.name = "Unnamed Torrent " + Date.now());
          var i = e.reduce(function(e, t) {
            return e + +("string" == typeof t);
          }, 0),
              a = 1 === e.length;
          if (1 === e.length && "string" == typeof e[0]) {
            if ("function" != typeof T.stat)
              throw new Error("filesystem paths do not work in the browser");
            A(e[0], function(e, t) {
              return e ? r(e) : void(a = t, s());
            });
          } else
            n.nextTick(function() {
              s();
            });
        }
        function c(e, t, n) {
          p(e, l, function(r, o) {
            return r ? n(r) : void(o = Array.isArray(o) ? L(o) : [o], e = E.normalize(e), t && (e = e.slice(0, e.lastIndexOf(E.sep) + 1)), e[e.length - 1] !== E.sep && (e += E.sep), o.forEach(function(t) {
              t.getStream = k(t.path), t.path = t.path.replace(e, "").split(E.sep);
            }), n(null, o));
          });
        }
        function l(e, t) {
          t = P(t), T.stat(e, function(n, r) {
            if (n)
              return t(n);
            var o = {
              length: r.size,
              path: e
            };
            t(null, o);
          });
        }
        function p(e, t, n) {
          T.stat(e, function(r, o) {
            return r ? n(r) : void(o.isDirectory() ? T.readdir(e, function(r, o) {
              return r ? n(r) : void O(o.filter(u).filter(U.not).map(function(n) {
                return function(r) {
                  p(E.join(e, n), t, r);
                };
              }), n);
            }) : o.isFile() && t(e, n));
          });
        }
        function u(e) {
          return "." !== e[0];
        }
        function f(e, t, n) {
          function r(e) {
            l += e.length;
            var t = f;
            H(e, function(e) {
              c[t] = e, u -= 1, a();
            }), u += 1, f += 1;
          }
          function s() {
            h = !0, a();
          }
          function i(e) {
            d(), n(e);
          }
          function d() {
            m.removeListener("error", i), g.removeListener("data", r), g.removeListener("end", s), g.removeListener("error", i);
          }
          function a() {
            h && 0 == u && (d(), n(null, o.from(c.join(""), "hex"), l));
          }
          n = P(n);
          var c = [],
              l = 0,
              p = e.map(function(e) {
                return e.getStream;
              }),
              u = 0,
              f = 0,
              h = !1,
              m = new R(p),
              g = new S(t, {zeroPadding: !1});
          m.on("error", i), m.pipe(g).on("data", r).on("end", s).on("error", i);
        }
        function h(e, n, o) {
          var i = n.announceList;
          i || ("string" == typeof n.announce ? i = [[n.announce]] : Array.isArray(n.announce) && (i = n.announce.map(function(e) {
            return [e];
          }))), i || (i = []), r.WEBTORRENT_ANNOUNCE && ("string" == typeof r.WEBTORRENT_ANNOUNCE ? i.push([[r.WEBTORRENT_ANNOUNCE]]) : Array.isArray(r.WEBTORRENT_ANNOUNCE) && (i = i.concat(r.WEBTORRENT_ANNOUNCE.map(function(e) {
            return [e];
          })))), n.announce === void 0 && n.announceList === void 0 && (i = i.concat(t.exports.announceList)), "string" == typeof n.urlList && (n.urlList = [n.urlList]);
          var d = {
            info: {name: n.name},
            "creation date": s((+n.creationDate || Date.now()) / 1e3),
            encoding: "UTF-8"
          };
          0 !== i.length && (d.announce = i[0][0], d["announce-list"] = i), n.comment !== void 0 && (d.comment = n.comment), n.createdBy !== void 0 && (d["created by"] = n.createdBy), n.private !== void 0 && (d.info.private = +n.private), n.sslCert !== void 0 && (d.info["ssl-cert"] = n.sslCert), n.urlList !== void 0 && (d["url-list"] = n.urlList);
          var a = n.pieceLength || C(e.reduce(m, 0));
          d.info["piece length"] = a, f(e, a, function(t, r, s) {
            return t ? o(t) : void(d.info.pieces = r, e.forEach(function(e) {
              delete e.getStream;
            }), n.singleFileTorrent ? d.info.length = s : d.info.files = e, o(null, v.encode(d)));
          });
        }
        function m(e, t) {
          return e + t.length;
        }
        function g(e) {
          return "undefined" != typeof Blob && e instanceof Blob;
        }
        function _(e) {
          return "undefined" != typeof FileList && e instanceof FileList;
        }
        function y(e) {
          return "object" == typeof e && null != e && "function" == typeof e.pipe;
        }
        function b(e) {
          return function() {
            return new I(e);
          };
        }
        function w(e) {
          return function() {
            var t = new M.PassThrough;
            return t.end(e), t;
          };
        }
        function k(e) {
          return function() {
            return T.createReadStream(e);
          };
        }
        function x(e, t) {
          return function() {
            var n = new M.Transform;
            return n._transform = function(e, n, r) {
              t.length += e.length, this.push(e), r();
            }, e.pipe(n), n;
          };
        }
        t.exports = i, t.exports.parseInput = d, t.exports.announceList = [["udp://tracker.leechers-paradise.org:6969"], ["udp://tracker.coppersurfer.tk:6969"], ["udp://tracker.opentrackr.org:1337"], ["udp://explodie.org:6969"], ["udp://tracker.empire-js.us:1337"], ["wss://tracker.btorrent.xyz"], ["wss://tracker.openwebtorrent.com"], ["wss://tracker.fastcast.nz"]];
        var v = e("bencode"),
            S = e("block-stream2"),
            C = e("piece-length"),
            E = e("path"),
            B = e("xtend"),
            I = e("filestream/read"),
            L = e("flatten"),
            T = e("fs"),
            A = e("is-file"),
            U = e("junk"),
            R = e("multistream"),
            P = e("once"),
            O = e("run-parallel"),
            H = e("simple-sha1"),
            M = e("readable-stream");
      }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global, e("buffer").Buffer);
    }, {
      _process: 67,
      bencode: 11,
      "block-stream2": 22,
      buffer: 25,
      "filestream/read": 36,
      flatten: 37,
      fs: 24,
      "is-file": 45,
      junk: 48,
      multistream: 59,
      once: 61,
      path: 64,
      "piece-length": 65,
      "readable-stream": 84,
      "run-parallel": 90,
      "simple-sha1": 96,
      xtend: 126
    }],
    31: [function(e, t, n) {
      (function(o) {
        function r() {
          var e;
          try {
            e = n.storage.debug;
          } catch (t) {}
          return !e && "undefined" != typeof o && "env" in o && (e = o.env.DEBUG), e;
        }
        n = t.exports = e("./debug"), n.log = function() {
          return "object" == typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
        }, n.formatArgs = function(e) {
          var t = this.useColors;
          if (e[0] = (t ? "%c" : "") + this.namespace + (t ? " %c" : " ") + e[0] + (t ? "%c " : " ") + "+" + n.humanize(this.diff), !!t) {
            var r = "color: " + this.color;
            e.splice(1, 0, r, "color: inherit");
            var o = 0,
                s = 0;
            e[0].replace(/%[a-zA-Z%]/g, function(e) {
              "%%" === e || (o++, "%c" === e && (s = o));
            }), e.splice(s, 0, r);
          }
        }, n.save = function(e) {
          try {
            null == e ? n.storage.removeItem("debug") : n.storage.debug = e;
          } catch (t) {}
        }, n.load = r, n.useColors = function() {
          return "undefined" != typeof window && window.process && "renderer" === window.process.type || ("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : "undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && 31 <= parseInt(RegExp.$1, 10) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
        }, n.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : function() {
          try {
            return window.localStorage;
          } catch (t) {}
        }(), n.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], n.formatters.j = function(e) {
          try {
            return JSON.stringify(e);
          } catch (e) {
            return "[UnexpectedJSONParseError]: " + e.message;
          }
        }, n.enable(r());
      }).call(this, e("_process"));
    }, {
      "./debug": 32,
      _process: 67
    }],
    32: [function(e, t, n) {
      function r(e) {
        var t = 0,
            r;
        for (r in e)
          t = (t << 5) - t + e.charCodeAt(r), t |= 0;
        return n.colors[o(t) % n.colors.length];
      }
      function s(e) {
        function t() {
          if (t.enabled) {
            var e = t,
                r = +new Date,
                s = r - (o || r);
            e.diff = s, e.prev = o, e.curr = r, o = r;
            for (var d = Array(arguments.length),
                a = 0; a < d.length; a++)
              d[a] = arguments[a];
            d[0] = n.coerce(d[0]), "string" != typeof d[0] && d.unshift("%O");
            var i = 0;
            d[0] = d[0].replace(/%([a-zA-Z%])/g, function(t, r) {
              if ("%%" === t)
                return t;
              i++;
              var o = n.formatters[r];
              if ("function" == typeof o) {
                var s = d[i];
                t = o.call(e, s), d.splice(i, 1), i--;
              }
              return t;
            }), n.formatArgs.call(e, d);
            var c = t.log || n.log || console.log.bind(console);
            c.apply(e, d);
          }
        }
        var o;
        return t.namespace = e, t.enabled = n.enabled(e), t.useColors = n.useColors(), t.color = r(e), t.destroy = i, "function" == typeof n.init && n.init(t), n.instances.push(t), t;
      }
      function i() {
        var e = n.instances.indexOf(this);
        return -1 !== e && (n.instances.splice(e, 1), !0);
      }
      n = t.exports = s.debug = s["default"] = s, n.coerce = function(e) {
        return e instanceof Error ? e.stack || e.message : e;
      }, n.disable = function() {
        n.enable("");
      }, n.enable = function(e) {
        n.save(e), n.names = [], n.skips = [];
        var t = ("string" == typeof e ? e : "").split(/[\s,]+/),
            r = t.length,
            o;
        for (o = 0; o < r; o++)
          t[o] && (e = t[o].replace(/\*/g, ".*?"), "-" === e[0] ? n.skips.push(new RegExp("^" + e.substr(1) + "$")) : n.names.push(new RegExp("^" + e + "$")));
        for (o = 0; o < n.instances.length; o++) {
          var s = n.instances[o];
          s.enabled = n.enabled(s.namespace);
        }
      }, n.enabled = function(e) {
        if ("*" === e[e.length - 1])
          return !0;
        var t,
            r;
        for (t = 0, r = n.skips.length; t < r; t++)
          if (n.skips[t].test(e))
            return !1;
        for (t = 0, r = n.names.length; t < r; t++)
          if (n.names[t].test(e))
            return !0;
        return !1;
      }, n.humanize = e("ms"), n.instances = [], n.names = [], n.skips = [], n.formatters = {};
    }, {ms: 58}],
    33: [function(e, t) {
      t.exports = function() {
        for (var e = 0; e < arguments.length; e++)
          if (arguments[e] !== void 0)
            return arguments[e];
      };
    }, {}],
    34: [function(e, t) {
      var n = e("once"),
          r = function() {},
          o = function(e) {
            return e.setHeader && "function" == typeof e.abort;
          },
          s = function(e) {
            return e.stdio && Array.isArray(e.stdio) && 3 === e.stdio.length;
          },
          i = function(e, t, d) {
            if ("function" == typeof t)
              return i(e, null, t);
            t || (t = {}), d = n(d || r);
            var a = e._writableState,
                c = e._readableState,
                l = t.readable || !1 !== t.readable && e.readable,
                p = t.writable || !1 !== t.writable && e.writable,
                u = function() {
                  e.writable || f();
                },
                f = function() {
                  p = !1, l || d.call(e);
                },
                h = function() {
                  l = !1, p || d.call(e);
                },
                m = function(t) {
                  d.call(e, t ? new Error("exited with error code: " + t) : null);
                },
                g = function(t) {
                  d.call(e, t);
                },
                _ = function() {
                  return l && !(c && c.ended) ? d.call(e, new Error("premature close")) : p && !(a && a.ended) ? d.call(e, new Error("premature close")) : void 0;
                },
                y = function() {
                  e.req.on("finish", f);
                };
            return o(e) ? (e.on("complete", f), e.on("abort", _), e.req ? y() : e.on("request", y)) : p && !a && (e.on("end", u), e.on("close", u)), s(e) && e.on("exit", m), e.on("end", h), e.on("finish", f), !1 !== t.error && e.on("error", g), e.on("close", _), function() {
              e.removeListener("complete", f), e.removeListener("abort", _), e.removeListener("request", y), e.req && e.req.removeListener("finish", f), e.removeListener("end", u), e.removeListener("close", u), e.removeListener("finish", f), e.removeListener("exit", m), e.removeListener("end", h), e.removeListener("error", g), e.removeListener("close", _);
            };
          };
      t.exports = i;
    }, {once: 61}],
    35: [function(e, t) {
      function n() {
        this._events && Object.prototype.hasOwnProperty.call(this, "_events") || (this._events = _(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }
      function r(e) {
        return void 0 === e._maxListeners ? n.defaultMaxListeners : e._maxListeners;
      }
      function s(e, t, n) {
        if (t)
          e.call(n);
        else
          for (var r = e.length,
              o = m(e, r),
              s = 0; s < r; ++s)
            o[s].call(n);
      }
      function d(e, t, n, r) {
        if (t)
          e.call(n, r);
        else
          for (var o = e.length,
              s = m(e, o),
              d = 0; d < o; ++d)
            s[d].call(n, r);
      }
      function a(e, t, n, r, o) {
        if (t)
          e.call(n, r, o);
        else
          for (var s = e.length,
              d = m(e, s),
              a = 0; a < s; ++a)
            d[a].call(n, r, o);
      }
      function c(e, t, n, r, o, s) {
        if (t)
          e.call(n, r, o, s);
        else
          for (var d = e.length,
              a = m(e, d),
              c = 0; c < d; ++c)
            a[c].call(n, r, o, s);
      }
      function l(e, t, n, r) {
        if (t)
          e.apply(n, r);
        else
          for (var o = e.length,
              s = m(e, o),
              d = 0; d < o; ++d)
            s[d].apply(n, r);
      }
      function i(e, t, n, o) {
        var s,
            i,
            d;
        if ("function" != typeof n)
          throw new TypeError("\"listener\" argument must be a function");
        if (i = e._events, i ? (i.newListener && (e.emit("newListener", t, n.listener ? n.listener : n), i = e._events), d = i[t]) : (i = e._events = _(null), e._eventsCount = 0), !d)
          d = i[t] = n, ++e._eventsCount;
        else if ("function" == typeof d ? d = i[t] = o ? [n, d] : [d, n] : o ? d.unshift(n) : d.push(n), !d.warned && (s = r(e), s && 0 < s && d.length > s)) {
          d.warned = !0;
          var a = new Error("Possible EventEmitter memory leak detected. " + d.length + " \"" + (t + "\" listeners added. Use emitter.setMaxListeners() to increase limit."));
          a.name = "MaxListenersExceededWarning", a.emitter = e, a.type = t, a.count = d.length, "object" == typeof console && console.warn && console.warn("%s: %s", a.name, a.message);
        }
        return e;
      }
      function p() {
        if (!this.fired)
          switch (this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length) {
            case 0:
              return this.listener.call(this.target);
            case 1:
              return this.listener.call(this.target, arguments[0]);
            case 2:
              return this.listener.call(this.target, arguments[0], arguments[1]);
            case 3:
              return this.listener.call(this.target, arguments[0], arguments[1], arguments[2]);
            default:
              for (var e = Array(arguments.length),
                  t = 0; t < e.length; ++t)
                e[t] = arguments[t];
              this.listener.apply(this.target, e);
          }
      }
      function u(e, t, n) {
        var r = {
          fired: !1,
          wrapFn: void 0,
          target: e,
          type: t,
          listener: n
        },
            o = b.call(p, r);
        return o.listener = n, r.wrapFn = o, o;
      }
      function f(e) {
        var t = this._events;
        if (t) {
          var n = t[e];
          if ("function" == typeof n)
            return 1;
          if (n)
            return n.length;
        }
        return 0;
      }
      function h(e, t) {
        for (var r = t,
            o = r + 1,
            s = e.length; o < s; r += 1, o += 1)
          e[r] = e[o];
        e.pop();
      }
      function m(e, t) {
        for (var n = Array(t),
            r = 0; r < t; ++r)
          n[r] = e[r];
        return n;
      }
      function g(e) {
        for (var t = Array(e.length),
            n = 0; n < t.length; ++n)
          t[n] = e[n].listener || e[n];
        return t;
      }
      var _ = Object.create || function(e) {
        var t = function() {};
        return t.prototype = e, new t;
      },
          y = Object.keys || function(e) {
            var t = [];
            for (var n in e)
              Object.prototype.hasOwnProperty.call(e, n) && t.push(n);
            return n;
          },
          b = Function.prototype.bind || function(e) {
            var t = this;
            return function() {
              return t.apply(e, arguments);
            };
          };
      t.exports = n, n.EventEmitter = n, n.prototype._events = void 0, n.prototype._maxListeners = void 0;
      var w = 10,
          k;
      try {
        var x = {};
        Object.defineProperty && Object.defineProperty(x, "x", {value: 0}), k = 0 === x.x;
      } catch (e) {
        k = !1;
      }
      k ? Object.defineProperty(n, "defaultMaxListeners", {
        enumerable: !0,
        get: function() {
          return w;
        },
        set: function(e) {
          if ("number" != typeof e || 0 > e || e !== e)
            throw new TypeError("\"defaultMaxListeners\" must be a positive number");
          w = e;
        }
      }) : n.defaultMaxListeners = w, n.prototype.setMaxListeners = function(e) {
        if ("number" != typeof e || 0 > e || isNaN(e))
          throw new TypeError("\"n\" argument must be a positive number");
        return this._maxListeners = e, this;
      }, n.prototype.getMaxListeners = function() {
        return r(this);
      }, n.prototype.emit = function(e) {
        var t = "error" === e,
            n,
            r,
            o,
            p,
            u,
            i;
        if (i = this._events, i)
          t = t && null == i.error;
        else if (!t)
          return !1;
        if (t) {
          if (1 < arguments.length && (n = arguments[1]), n instanceof Error)
            throw n;
          else {
            var f = new Error("Unhandled \"error\" event. (" + n + ")");
            throw f.context = n, f;
          }
          return !1;
        }
        if (r = i[e], !r)
          return !1;
        var h = "function" == typeof r;
        switch (o = arguments.length, o) {
          case 1:
            s(r, h, this);
            break;
          case 2:
            d(r, h, this, arguments[1]);
            break;
          case 3:
            a(r, h, this, arguments[1], arguments[2]);
            break;
          case 4:
            c(r, h, this, arguments[1], arguments[2], arguments[3]);
            break;
          default:
            for (p = Array(o - 1), u = 1; u < o; u++)
              p[u - 1] = arguments[u];
            l(r, h, this, p);
        }
        return !0;
      }, n.prototype.addListener = function(e, t) {
        return i(this, e, t, !1);
      }, n.prototype.on = n.prototype.addListener, n.prototype.prependListener = function(e, t) {
        return i(this, e, t, !0);
      }, n.prototype.once = function(e, t) {
        if ("function" != typeof t)
          throw new TypeError("\"listener\" argument must be a function");
        return this.on(e, u(this, e, t)), this;
      }, n.prototype.prependOnceListener = function(e, t) {
        if ("function" != typeof t)
          throw new TypeError("\"listener\" argument must be a function");
        return this.prependListener(e, u(this, e, t)), this;
      }, n.prototype.removeListener = function(e, t) {
        var n,
            r,
            o,
            s,
            i;
        if ("function" != typeof t)
          throw new TypeError("\"listener\" argument must be a function");
        if (r = this._events, !r)
          return this;
        if (n = r[e], !n)
          return this;
        if (n === t || n.listener === t)
          0 == --this._eventsCount ? this._events = _(null) : (delete r[e], r.removeListener && this.emit("removeListener", e, n.listener || t));
        else if ("function" != typeof n) {
          for (o = -1, s = n.length - 1; 0 <= s; s--)
            if (n[s] === t || n[s].listener === t) {
              i = n[s].listener, o = s;
              break;
            }
          if (0 > o)
            return this;
          0 === o ? n.shift() : h(n, o), 1 === n.length && (r[e] = n[0]), r.removeListener && this.emit("removeListener", e, i || t);
        }
        return this;
      }, n.prototype.removeAllListeners = function(e) {
        var t,
            n,
            r;
        if (n = this._events, !n)
          return this;
        if (!n.removeListener)
          return 0 === arguments.length ? (this._events = _(null), this._eventsCount = 0) : n[e] && (0 == --this._eventsCount ? this._events = _(null) : delete n[e]), this;
        if (0 === arguments.length) {
          var o = y(n),
              s;
          for (r = 0; r < o.length; ++r)
            s = o[r], "removeListener" === s || this.removeAllListeners(s);
          return this.removeAllListeners("removeListener"), this._events = _(null), this._eventsCount = 0, this;
        }
        if (t = n[e], "function" == typeof t)
          this.removeListener(e, t);
        else if (t)
          for (r = t.length - 1; 0 <= r; r--)
            this.removeListener(e, t[r]);
        return this;
      }, n.prototype.listeners = function(e) {
        var t = this._events,
            n,
            r;
        return t ? (n = t[e], r = n ? "function" == typeof n ? [n.listener || n] : g(n) : []) : r = [], r;
      }, n.listenerCount = function(e, t) {
        return "function" == typeof e.listenerCount ? e.listenerCount(t) : f.call(e, t);
      }, n.prototype.listenerCount = f, n.prototype.eventNames = function() {
        return 0 < this._eventsCount ? Reflect.ownKeys(this._events) : [];
      };
    }, {}],
    36: [function(e, t) {
      function r(e, t) {
        var s = this;
        return this instanceof r ? void(t = t || {}, o.call(this, t), this._offset = 0, this._ready = !1, this._file = e, this._size = e.size, this._chunkSize = t.chunkSize || n(this._size / 1e3, 204800), this.reader = new FileReader, this._generateHeaderBlocks(e, t, function(e, t) {
          return e ? s.emit("error", e) : void(Array.isArray(t) && t.forEach(function(e) {
            s.push(e);
          }), s._ready = !0, s.emit("_ready"));
        })) : new r(e, t);
      }
      var o = e("readable-stream").Readable,
          s = e("inherits"),
          i = /^.*\.(\w+)$/,
          d = e("typedarray-to-buffer");
      s(r, o), t.exports = r, r.prototype._generateHeaderBlocks = function(e, t, n) {
        n(null, []);
      }, r.prototype._read = function() {
        if (!this._ready)
          return void this.once("_ready", this._read.bind(this));
        var e = this,
            t = this.reader,
            n = this._offset,
            r = this._offset + this._chunkSize;
        return r > this._size && (r = this._size), n === this._size ? (this.destroy(), void this.push(null)) : void(t.onload = function() {
          e._offset = r, e.push(d(t.result));
        }, t.onerror = function() {
          e.emit("error", t.error);
        }, t.readAsArrayBuffer(this._file.slice(n, r)));
      }, r.prototype.destroy = function() {
        if (this._file = null, this.reader) {
          this.reader.onload = null, this.reader.onerror = null;
          try {
            this.reader.abort();
          } catch (t) {}
        }
        this.reader = null;
      };
    }, {
      inherits: 42,
      "readable-stream": 84,
      "typedarray-to-buffer": 112
    }],
    37: [function(e, t) {
      t.exports = function(e, t) {
        function n(e, r) {
          return e.reduce(function(e, o) {
            return Array.isArray(o) && r < t ? e.concat(n(o, r + 1)) : e.concat(o);
          }, []);
        }
        return t = "number" == typeof t ? t : Infinity, t ? n(e, 1) : Array.isArray(e) ? e.map(function(e) {
          return e;
        }) : e;
      };
    }, {}],
    38: [function(e, t) {
      t.exports = function() {
        if ("undefined" == typeof window)
          return null;
        var e = {
          RTCPeerConnection: window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection,
          RTCSessionDescription: window.RTCSessionDescription || window.mozRTCSessionDescription || window.webkitRTCSessionDescription,
          RTCIceCandidate: window.RTCIceCandidate || window.mozRTCIceCandidate || window.webkitRTCIceCandidate
        };
        return e.RTCPeerConnection ? e : null;
      };
    }, {}],
    39: [function(e, t) {
      function n(e) {
        if ("string" == typeof e && (e = o.parse(e)), e.protocol || (e.protocol = "https:"), "https:" !== e.protocol)
          throw new Error("Protocol \"" + e.protocol + "\" not supported. Expected \"https:\"");
        return e;
      }
      var r = e("http"),
          o = e("url"),
          s = t.exports;
      for (var i in r)
        r.hasOwnProperty(i) && (s[i] = r[i]);
      s.request = function(e, t) {
        return e = n(e), r.request.call(this, e, t);
      }, s.get = function(e, t) {
        return e = n(e), r.get.call(this, e, t);
      };
    }, {
      http: 99,
      url: 116
    }],
    40: [function(e, n, s) {
      s.read = function(n, r, o, a, c) {
        var l = 8 * c - a - 1,
            p = (1 << l) - 1,
            u = p >> 1,
            f = -7,
            h = o ? c - 1 : 0,
            i = o ? -1 : 1,
            d = n[r + h],
            s,
            e;
        for (h += i, s = d & (1 << -f) - 1, d >>= -f, f += l; 0 < f; s = 256 * s + n[r + h], h += i, f -= 8)
          ;
        for (e = s & (1 << -f) - 1, s >>= -f, f += a; 0 < f; e = 256 * e + n[r + h], h += i, f -= 8)
          ;
        if (0 === s)
          s = 1 - u;
        else {
          if (s === p)
            return e ? NaN : (d ? -1 : 1) * Infinity;
          e += t(2, a), s -= u;
        }
        return (d ? -1 : 1) * e * t(2, s - a);
      }, s.write = function(n, a, l, p, u, f) {
        var h = 8 * f - u - 1,
            g = (1 << h) - 1,
            _ = g >> 1,
            y = 23 === u ? 5.960464477539063e-8 - 6.617444900424222e-24 : 0,
            b = p ? 0 : f - 1,
            i = p ? 1 : -1,
            d = 0 > a || 0 === a && 0 > 1 / a ? 1 : 0,
            s,
            w,
            m;
        for (a = o(a), isNaN(a) || a === Infinity ? (w = isNaN(a) ? 1 : 0, s = g) : (s = r(Math.log(a) / Math.LN2), 1 > a * (m = t(2, -s)) && (s--, m *= 2), a += 1 <= s + _ ? y / m : y * t(2, 1 - _), 2 <= a * m && (s++, m /= 2), s + _ >= g ? (w = 0, s = g) : 1 <= s + _ ? (w = (a * m - 1) * t(2, u), s += _) : (w = a * t(2, _ - 1) * t(2, u), s = 0)); 8 <= u; n[l + b] = 255 & w, b += i, w /= 256, u -= 8)
          ;
        for (s = s << u | w, h += u; 0 < h; n[l + b] = 255 & s, b += i, s /= 256, h -= 8)
          ;
        n[l + b - i] |= 128 * d;
      };
    }, {}],
    41: [function(e, t) {
      (function(e) {
        function n(e) {
          if (!(this instanceof n))
            return new n(e);
          if (this.store = e, this.chunkLength = e.chunkLength, !this.store || !this.store.get || !this.store.put)
            throw new Error("First argument must be abstract-chunk-store compliant");
          this.mem = [];
        }
        function r(t, n, r) {
          e.nextTick(function() {
            t && t(n, r);
          });
        }
        t.exports = n, n.prototype.put = function(e, t, n) {
          var r = this;
          r.mem[e] = t, r.store.put(e, t, function(t) {
            r.mem[e] = null, n && n(t);
          });
        }, n.prototype.get = function(e, t, n) {
          if ("function" == typeof t)
            return this.get(e, null, t);
          var o = t && t.offset || 0,
              s = t && t.length && o + t.length,
              i = this.mem[e];
          return i ? r(n, null, t ? i.slice(o, s) : i) : void this.store.get(e, t, n);
        }, n.prototype.close = function(e) {
          this.store.close(e);
        }, n.prototype.destroy = function(e) {
          this.store.destroy(e);
        };
      }).call(this, e("_process"));
    }, {_process: 67}],
    42: [function(e, t) {
      t.exports = "function" == typeof Object.create ? function(e, t) {
        e.super_ = t, e.prototype = Object.create(t.prototype, {constructor: {
            value: e,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }});
      } : function(e, t) {
        e.super_ = t;
        var n = function() {};
        n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e;
      };
    }, {}],
    43: [function(e, t) {
      t.exports = function(e) {
        for (var t = 0,
            n = e.length; t < n; ++t)
          if (e.charCodeAt(t) > 127)
            return !1;
        return !0;
      };
    }, {}],
    44: [function(e, t) {
      function n(e) {
        return !!e.constructor && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e);
      }
      function r(e) {
        return "function" == typeof e.readFloatLE && "function" == typeof e.slice && n(e.slice(0, 0));
      }
      t.exports = function(e) {
        return null != e && (n(e) || r(e) || !!e._isBuffer);
      };
    }, {}],
    45: [function(e, t) {
      "use strict";
      function n(e) {
        return r.existsSync(e) && r.statSync(e).isFile();
      }
      var r = e("fs");
      t.exports = function(e, t) {
        return t ? void r.stat(e, function(e, n) {
          return e ? t(e) : t(null, n.isFile());
        }) : n(e);
      }, t.exports.sync = n;
    }, {fs: 24}],
    46: [function(e, t) {
      function n(e) {
        return r(e) || o(e);
      }
      function r(e) {
        return e instanceof Int8Array || e instanceof Int16Array || e instanceof Int32Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Uint16Array || e instanceof Uint32Array || e instanceof Float32Array || e instanceof Float64Array;
      }
      function o(e) {
        return i[s.call(e)];
      }
      t.exports = n, n.strict = r, n.loose = o;
      var s = Object.prototype.toString,
          i = {
            "[object Int8Array]": !0,
            "[object Int16Array]": !0,
            "[object Int32Array]": !0,
            "[object Uint8Array]": !0,
            "[object Uint8ClampedArray]": !0,
            "[object Uint16Array]": !0,
            "[object Uint32Array]": !0,
            "[object Float32Array]": !0,
            "[object Float64Array]": !0
          };
    }, {}],
    47: [function(e, t) {
      var n = {}.toString;
      t.exports = Array.isArray || function(e) {
        return "[object Array]" == n.call(e);
      };
    }, {}],
    48: [function(e, t, n) {
      "use strict";
      n.regex = n.re = /^npm-debug\.log$|^\..*\.swp$|^\.DS_Store$|^\.AppleDouble$|^\.LSOverride$|^Icon\r$|^\._.*|^\.Spotlight-V100(?:$|\/)|\.Trashes|^__MACOSX$|~$|^Thumbs\.db$|^ehthumbs\.db$|^Desktop\.ini$|^@eaDir$/, n.is = (e) => n.re.test(e), n.not = (e) => !n.is(e);
    }, {}],
    49: [function(e, t) {
      function n(e) {
        var t = {},
            n = e.split("magnet:?")[1],
            s = n && 0 <= n.length ? n.split("&") : [];
        s.forEach(function(e) {
          var n = e.split("=");
          if (2 === n.length) {
            var r = n[0],
                o = n[1];
            if ("dn" === r && (o = decodeURIComponent(o).replace(/\+/g, " ")), ("tr" === r || "xs" === r || "as" === r || "ws" === r) && (o = decodeURIComponent(o)), "kt" === r && (o = decodeURIComponent(o).split("+")), "ix" === r && (o = +o), !t[r])
              t[r] = o;
            else if (Array.isArray(t[r]))
              t[r].push(o);
            else {
              var s = t[r];
              t[r] = [s, o];
            }
          }
        });
        var d;
        if (t.xt) {
          var a = Array.isArray(t.xt) ? t.xt : [t.xt];
          a.forEach(function(e) {
            if (d = e.match(/^urn:btih:(.{40})/))
              t.infoHash = d[1].toLowerCase();
            else if (d = e.match(/^urn:btih:(.{32})/)) {
              var n = r.decode(d[1]);
              t.infoHash = o.from(n, "binary").toString("hex");
            }
          });
        }
        return t.infoHash && (t.infoHashBuffer = o.from(t.infoHash, "hex")), t.dn && (t.name = t.dn), t.kt && (t.keywords = t.kt), t.announce = "string" == typeof t.tr ? [t.tr] : Array.isArray(t.tr) ? t.tr : [], t.urlList = [], ("string" == typeof t.as || Array.isArray(t.as)) && (t.urlList = t.urlList.concat(t.as)), ("string" == typeof t.ws || Array.isArray(t.ws)) && (t.urlList = t.urlList.concat(t.ws)), i(t.announce), i(t.urlList), t;
      }
      t.exports = n, t.exports.decode = n, t.exports.encode = function(e) {
        e = s(e), e.infoHashBuffer && (e.xt = "urn:btih:" + e.infoHashBuffer.toString("hex")), e.infoHash && (e.xt = "urn:btih:" + e.infoHash), e.name && (e.dn = e.name), e.keywords && (e.kt = e.keywords), e.announce && (e.tr = e.announce), e.urlList && (e.ws = e.urlList, delete e.as);
        var t = "magnet:?";
        return Object.keys(e).filter(function(e) {
          return 2 === e.length;
        }).forEach(function(n, r) {
          var o = Array.isArray(e[n]) ? e[n] : [e[n]];
          o.forEach(function(e, o) {
            (0 < r || 0 < o) && ("kt" !== n || 0 === o) && (t += "&"), "dn" === n && (e = encodeURIComponent(e).replace(/%20/g, "+")), ("tr" === n || "xs" === n || "as" === n || "ws" === n) && (e = encodeURIComponent(e)), "kt" === n && (e = encodeURIComponent(e)), t += "kt" === n && 0 < o ? "+" + e : n + "=" + e;
          });
        }), t;
      };
      var r = e("thirty-two"),
          o = e("safe-buffer").Buffer,
          s = e("xtend"),
          i = e("uniq");
    }, {
      "safe-buffer": 92,
      "thirty-two": 107,
      uniq: 114,
      xtend: 126
    }],
    50: [function(e, t) {
      function n(e, t) {
        var r = this;
        if (!(r instanceof n))
          return new n(e, t);
        if (!d)
          throw new Error("web browser lacks MediaSource support");
        t || (t = {}), r._bufferDuration = t.bufferDuration || a, r._elem = e, r._mediaSource = new d, r._streams = [], r.detailedError = null, r._errorHandler = function() {
          r._elem.removeEventListener("error", r._errorHandler);
          var e = r._streams.slice();
          e.forEach(function(e) {
            e.destroy(r._elem.error);
          });
        }, r._elem.addEventListener("error", r._errorHandler), r._elem.src = window.URL.createObjectURL(r._mediaSource);
      }
      function r(e, t) {
        var n = this;
        if (s.Writable.call(n), n._wrapper = e, n._elem = e._elem, n._mediaSource = e._mediaSource, n._allStreams = e._streams, n._allStreams.push(n), n._bufferDuration = e._bufferDuration, n._sourceBuffer = null, n._openHandler = function() {
          n._onSourceOpen();
        }, n._flowHandler = function() {
          n._flow();
        }, "string" == typeof t)
          n._type = t, "open" === n._mediaSource.readyState ? n._createSourceBuffer() : n._mediaSource.addEventListener("sourceopen", n._openHandler);
        else if (null === t._sourceBuffer)
          t.destroy(), n._type = t._type, n._mediaSource.addEventListener("sourceopen", n._openHandler);
        else if (t._sourceBuffer)
          t.destroy(), n._type = t._type, n._sourceBuffer = t._sourceBuffer, n._sourceBuffer.addEventListener("updateend", n._flowHandler);
        else
          throw new Error("The argument to MediaElementWrapper.createWriteStream must be a string or a previous stream returned from that function");
        n._elem.addEventListener("timeupdate", n._flowHandler), n.on("error", function(e) {
          n._wrapper.error(e);
        }), n.on("finish", function() {
          if (!n.destroyed && (n._finished = !0, n._allStreams.every(function(e) {
            return e._finished;
          })))
            try {
              n._mediaSource.endOfStream();
            } catch (e) {}
        });
      }
      t.exports = n;
      var o = e("inherits"),
          s = e("readable-stream"),
          i = e("to-arraybuffer"),
          d = "undefined" != typeof window && window.MediaSource,
          a = 60;
      n.prototype.createWriteStream = function(e) {
        var t = this;
        return new r(t, e);
      }, n.prototype.error = function(e) {
        var t = this;
        t.detailedError || (t.detailedError = e);
        try {
          t._mediaSource.endOfStream("decode");
        } catch (e) {}
      }, o(r, s.Writable), r.prototype._onSourceOpen = function() {
        var e = this;
        e.destroyed || (e._mediaSource.removeEventListener("sourceopen", e._openHandler), e._createSourceBuffer());
      }, r.prototype.destroy = function(e) {
        var t = this;
        t.destroyed || (t.destroyed = !0, t._allStreams.splice(t._allStreams.indexOf(t), 1), t._mediaSource.removeEventListener("sourceopen", t._openHandler), t._elem.removeEventListener("timeupdate", t._flowHandler), t._sourceBuffer && (t._sourceBuffer.removeEventListener("updateend", t._flowHandler), "open" === t._mediaSource.readyState && t._sourceBuffer.abort()), e && t.emit("error", e), t.emit("close"));
      }, r.prototype._createSourceBuffer = function() {
        var e = this;
        if (!e.destroyed)
          if (!d.isTypeSupported(e._type))
            e.destroy(new Error("The provided type is not supported"));
          else if (e._sourceBuffer = e._mediaSource.addSourceBuffer(e._type), e._sourceBuffer.addEventListener("updateend", e._flowHandler), e._cb) {
            var t = e._cb;
            e._cb = null, t();
          }
      }, r.prototype._write = function(e, t, n) {
        var r = this;
        if (!r.destroyed) {
          if (!r._sourceBuffer)
            return void(r._cb = function(o) {
              return o ? n(o) : void r._write(e, t, n);
            });
          if (r._sourceBuffer.updating)
            return n(new Error("Cannot append buffer while source buffer updating"));
          try {
            r._sourceBuffer.appendBuffer(i(e));
          } catch (e) {
            return void r.destroy(e);
          }
          r._cb = n;
        }
      }, r.prototype._flow = function() {
        var e = this;
        if (!(e.destroyed || !e._sourceBuffer || e._sourceBuffer.updating) && !("open" === e._mediaSource.readyState && e._getBufferDuration() > e._bufferDuration) && e._cb) {
          var t = e._cb;
          e._cb = null, t();
        }
      };
      r.prototype._getBufferDuration = function() {
        for (var e = this,
            t = e._sourceBuffer.buffered,
            n = e._elem.currentTime,
            r = -1,
            o = 0; o < t.length; o++) {
          var s = t.start(o),
              i = t.end(o) + 0;
          if (s > n)
            break;
          else
            (0 <= r || n <= i) && (r = i);
        }
        var d = r - n;
        return 0 > d && (d = 0), d;
      };
    }, {
      inherits: 42,
      "readable-stream": 84,
      "to-arraybuffer": 109
    }],
    51: [function(e, t) {
      (function(e) {
        function n(e, t) {
          if (!(this instanceof n))
            return new n(e, t);
          if (t || (t = {}), this.chunkLength = +e, !this.chunkLength)
            throw new Error("First argument must be a chunk length");
          this.chunks = [], this.closed = !1, this.length = +t.length || Infinity, this.length !== Infinity && (this.lastChunkLength = this.length % this.chunkLength || this.chunkLength, this.lastChunkIndex = s(this.length / this.chunkLength) - 1);
        }
        function r(t, n, r) {
          e.nextTick(function() {
            t && t(n, r);
          });
        }
        t.exports = n, n.prototype.put = function(e, t, n) {
          if (this.closed)
            return r(n, new Error("Storage is closed"));
          var o = e === this.lastChunkIndex;
          return o && t.length !== this.lastChunkLength ? r(n, new Error("Last chunk length must be " + this.lastChunkLength)) : o || t.length === this.chunkLength ? void(this.chunks[e] = t, r(n, null)) : r(n, new Error("Chunk length must be " + this.chunkLength));
        }, n.prototype.get = function(e, t, n) {
          if ("function" == typeof t)
            return this.get(e, null, t);
          if (this.closed)
            return r(n, new Error("Storage is closed"));
          var o = this.chunks[e];
          if (!o) {
            var s = new Error("Chunk not found");
            return s.notFound = !0, r(n, s);
          }
          if (!t)
            return r(n, null, o);
          var i = t.offset || 0,
              d = t.length || o.length - i;
          r(n, null, o.slice(i, d + i));
        }, n.prototype.close = n.prototype.destroy = function(e) {
          return this.closed ? r(e, new Error("Storage is closed")) : void(this.closed = !0, this.chunks = null, r(e, null));
        };
      }).call(this, e("_process"));
    }, {_process: 67}],
    52: [function(e, t, n) {
      (function(t) {
        function o(e, t, n) {
          for (var r = t; r < n; r++)
            e[r] = 0;
        }
        function s(e, t, n) {
          t.writeUInt32BE(r((e.getTime() + y) / 1e3), n);
        }
        function a(e, t, n) {
          t.writeUInt16BE(r(e) % 65536, n), t.writeUInt16BE(r(256 * (256 * e)) % 65536, n + 2);
        }
        function i(e, t, n) {
          t[n] = r(e) % 256, t[n + 1] = r(256 * e) % 256;
        }
        function c(e, t, n) {
          e || (e = [0, 0, 0, 0, 0, 0, 0, 0, 0]);
          for (var r = 0; r < e.length; r++)
            a(e[r], t, n + 4 * r);
        }
        function l(e, n, r) {
          var o = new t(e, "utf8");
          o.copy(n, r), n[r + o.length] = 0;
        }
        function p(e) {
          for (var t = Array(e.length / 4),
              n = 0; n < t.length; n++)
            t[n] = f(e, 4 * n);
          return t;
        }
        function u(e, t) {
          return new Date(1e3 * e.readUInt32BE(t) - y);
        }
        function f(e, t) {
          return e.readUInt16BE(t) + e.readUInt16BE(t + 2) / 65536;
        }
        function h(e, t) {
          return e[t] + e[t + 1] / 256;
        }
        function m(e, t, n) {
          var r;
          for (r = 0; r < n && !(0 === e[t + r]); r++)
            ;
          return e.toString("utf8", t, t + r);
        }
        var g = e("./index"),
            _ = e("./descriptor"),
            y = 2.0828448e12;
        n.fullBoxes = {};
        ["mvhd", "tkhd", "mdhd", "vmhd", "smhd", "stsd", "esds", "stsz", "stco", "stss", "stts", "ctts", "stsc", "dref", "elst", "hdlr", "mehd", "trex", "mfhd", "tfhd", "tfdt", "trun"].forEach(function(e) {
          n.fullBoxes[e] = !0;
        }), n.ftyp = {}, n.ftyp.encode = function(e, r, o) {
          r = r ? r.slice(o) : new t(n.ftyp.encodingLength(e));
          var s = e.compatibleBrands || [];
          r.write(e.brand, 0, 4, "ascii"), r.writeUInt32BE(e.brandVersion, 4);
          for (var d = 0; d < s.length; d++)
            r.write(s[d], 8 + 4 * d, 4, "ascii");
          return n.ftyp.encode.bytes = 8 + 4 * s.length, r;
        }, n.ftyp.decode = function(e, t) {
          e = e.slice(t);
          for (var n = e.toString("ascii", 0, 4),
              r = e.readUInt32BE(4),
              o = [],
              s = 8; s < e.length; s += 4)
            o.push(e.toString("ascii", s, s + 4));
          return {
            brand: n,
            brandVersion: r,
            compatibleBrands: o
          };
        }, n.ftyp.encodingLength = function(e) {
          return 8 + 4 * (e.compatibleBrands || []).length;
        }, n.mvhd = {}, n.mvhd.encode = function(e, r, d) {
          return r = r ? r.slice(d) : new t(96), s(e.ctime || new Date, r, 0), s(e.mtime || new Date, r, 4), r.writeUInt32BE(e.timeScale || 0, 8), r.writeUInt32BE(e.duration || 0, 12), a(e.preferredRate || 0, r, 16), i(e.preferredVolume || 0, r, 20), o(r, 22, 32), c(e.matrix, r, 32), r.writeUInt32BE(e.previewTime || 0, 68), r.writeUInt32BE(e.previewDuration || 0, 72), r.writeUInt32BE(e.posterTime || 0, 76), r.writeUInt32BE(e.selectionTime || 0, 80), r.writeUInt32BE(e.selectionDuration || 0, 84), r.writeUInt32BE(e.currentTime || 0, 88), r.writeUInt32BE(e.nextTrackId || 0, 92), n.mvhd.encode.bytes = 96, r;
        }, n.mvhd.decode = function(e, t) {
          return e = e.slice(t), {
            ctime: u(e, 0),
            mtime: u(e, 4),
            timeScale: e.readUInt32BE(8),
            duration: e.readUInt32BE(12),
            preferredRate: f(e, 16),
            preferredVolume: h(e, 20),
            matrix: p(e.slice(32, 68)),
            previewTime: e.readUInt32BE(68),
            previewDuration: e.readUInt32BE(72),
            posterTime: e.readUInt32BE(76),
            selectionTime: e.readUInt32BE(80),
            selectionDuration: e.readUInt32BE(84),
            currentTime: e.readUInt32BE(88),
            nextTrackId: e.readUInt32BE(92)
          };
        }, n.mvhd.encodingLength = function() {
          return 96;
        }, n.tkhd = {}, n.tkhd.encode = function(e, r, i) {
          return r = r ? r.slice(i) : new t(80), s(e.ctime || new Date, r, 0), s(e.mtime || new Date, r, 4), r.writeUInt32BE(e.trackId || 0, 8), o(r, 12, 16), r.writeUInt32BE(e.duration || 0, 16), o(r, 20, 28), r.writeUInt16BE(e.layer || 0, 28), r.writeUInt16BE(e.alternateGroup || 0, 30), r.writeUInt16BE(e.volume || 0, 32), c(e.matrix, r, 36), r.writeUInt32BE(e.trackWidth || 0, 72), r.writeUInt32BE(e.trackHeight || 0, 76), n.tkhd.encode.bytes = 80, r;
        }, n.tkhd.decode = function(e, t) {
          return e = e.slice(t), {
            ctime: u(e, 0),
            mtime: u(e, 4),
            trackId: e.readUInt32BE(8),
            duration: e.readUInt32BE(16),
            layer: e.readUInt16BE(28),
            alternateGroup: e.readUInt16BE(30),
            volume: e.readUInt16BE(32),
            matrix: p(e.slice(36, 72)),
            trackWidth: e.readUInt32BE(72),
            trackHeight: e.readUInt32BE(76)
          };
        }, n.tkhd.encodingLength = function() {
          return 80;
        }, n.mdhd = {}, n.mdhd.encode = function(e, r, o) {
          return r = r ? r.slice(o) : new t(20), s(e.ctime || new Date, r, 0), s(e.mtime || new Date, r, 4), r.writeUInt32BE(e.timeScale || 0, 8), r.writeUInt32BE(e.duration || 0, 12), r.writeUInt16BE(e.language || 0, 16), r.writeUInt16BE(e.quality || 0, 18), n.mdhd.encode.bytes = 20, r;
        }, n.mdhd.decode = function(e, t) {
          return e = e.slice(t), {
            ctime: u(e, 0),
            mtime: u(e, 4),
            timeScale: e.readUInt32BE(8),
            duration: e.readUInt32BE(12),
            language: e.readUInt16BE(16),
            quality: e.readUInt16BE(18)
          };
        }, n.mdhd.encodingLength = function() {
          return 20;
        }, n.vmhd = {}, n.vmhd.encode = function(e, r, o) {
          r = r ? r.slice(o) : new t(8), r.writeUInt16BE(e.graphicsMode || 0, 0);
          var s = e.opcolor || [0, 0, 0];
          return r.writeUInt16BE(s[0], 2), r.writeUInt16BE(s[1], 4), r.writeUInt16BE(s[2], 6), n.vmhd.encode.bytes = 8, r;
        }, n.vmhd.decode = function(e, t) {
          return e = e.slice(t), {
            graphicsMode: e.readUInt16BE(0),
            opcolor: [e.readUInt16BE(2), e.readUInt16BE(4), e.readUInt16BE(6)]
          };
        }, n.vmhd.encodingLength = function() {
          return 8;
        }, n.smhd = {}, n.smhd.encode = function(e, r, s) {
          return r = r ? r.slice(s) : new t(4), r.writeUInt16BE(e.balance || 0, 0), o(r, 2, 4), n.smhd.encode.bytes = 4, r;
        }, n.smhd.decode = function(e, t) {
          return e = e.slice(t), {balance: e.readUInt16BE(0)};
        }, n.smhd.encodingLength = function() {
          return 4;
        }, n.stsd = {}, n.stsd.encode = function(e, r, o) {
          r = r ? r.slice(o) : new t(n.stsd.encodingLength(e));
          var s = e.entries || [];
          r.writeUInt32BE(s.length, 0);
          for (var d = 4,
              a = 0,
              i; a < s.length; a++)
            i = s[a], g.encode(i, r, d), d += g.encode.bytes;
          return n.stsd.encode.bytes = d, r;
        }, n.stsd.decode = function(e, t, n) {
          e = e.slice(t);
          for (var r = e.readUInt32BE(0),
              o = Array(r),
              s = 4,
              d = 0,
              i; d < r; d++)
            i = g.decode(e, s, n), o[d] = i, s += i.length;
          return {entries: o};
        }, n.stsd.encodingLength = function(e) {
          var t = 4;
          if (!e.entries)
            return t;
          for (var n = 0; n < e.entries.length; n++)
            t += g.encodingLength(e.entries[n]);
          return t;
        }, n.avc1 = n.VisualSampleEntry = {}, n.VisualSampleEntry.encode = function(e, r, s) {
          r = r ? r.slice(s) : new t(n.VisualSampleEntry.encodingLength(e)), o(r, 0, 6), r.writeUInt16BE(e.dataReferenceIndex || 0, 6), o(r, 8, 24), r.writeUInt16BE(e.width || 0, 24), r.writeUInt16BE(e.height || 0, 26), r.writeUInt32BE(e.hResolution || 4718592, 28), r.writeUInt32BE(e.vResolution || 4718592, 32), o(r, 36, 40), r.writeUInt16BE(e.frameCount || 1, 40);
          var i = e.compressorName || "",
              a = d(i.length, 31);
          r.writeUInt8(a, 42), r.write(i, 43, a, "utf8"), r.writeUInt16BE(e.depth || 24, 74), r.writeInt16BE(-1, 76);
          var c = 78,
              l = e.children || [];
          l.forEach(function(e) {
            g.encode(e, r, c), c += g.encode.bytes;
          }), n.VisualSampleEntry.encode.bytes = c;
        }, n.VisualSampleEntry.decode = function(e, t, n) {
          e = e.slice(t);
          for (var r = n - t,
              o = d(e.readUInt8(42), 31),
              s = {
                dataReferenceIndex: e.readUInt16BE(6),
                width: e.readUInt16BE(24),
                height: e.readUInt16BE(26),
                hResolution: e.readUInt32BE(28),
                vResolution: e.readUInt32BE(32),
                frameCount: e.readUInt16BE(40),
                compressorName: e.toString("utf8", 43, 43 + o),
                depth: e.readUInt16BE(74),
                children: []
              },
              i = 78; 8 <= r - i; ) {
            var a = g.decode(e, i, r);
            s.children.push(a), s[a.type] = a, i += a.length;
          }
          return s;
        }, n.VisualSampleEntry.encodingLength = function(e) {
          var t = 78,
              n = e.children || [];
          return n.forEach(function(e) {
            t += g.encodingLength(e);
          }), t;
        }, n.avcC = {}, n.avcC.encode = function(e, r, o) {
          r = r ? r.slice(o) : t(e.buffer.length), e.buffer.copy(r), n.avcC.encode.bytes = e.buffer.length;
        }, n.avcC.decode = function(e, n, r) {
          return e = e.slice(n, r), {
            mimeCodec: e.toString("hex", 1, 4),
            buffer: new t(e)
          };
        }, n.avcC.encodingLength = function(e) {
          return e.buffer.length;
        }, n.mp4a = n.AudioSampleEntry = {}, n.AudioSampleEntry.encode = function(e, r, s) {
          r = r ? r.slice(s) : new t(n.AudioSampleEntry.encodingLength(e)), o(r, 0, 6), r.writeUInt16BE(e.dataReferenceIndex || 0, 6), o(r, 8, 16), r.writeUInt16BE(e.channelCount || 2, 16), r.writeUInt16BE(e.sampleSize || 16, 18), o(r, 20, 24), r.writeUInt32BE(e.sampleRate || 0, 24);
          var i = 28,
              d = e.children || [];
          d.forEach(function(e) {
            g.encode(e, r, i), i += g.encode.bytes;
          }), n.AudioSampleEntry.encode.bytes = i;
        }, n.AudioSampleEntry.decode = function(e, t, n) {
          e = e.slice(t, n);
          for (var r = n - t,
              o = {
                dataReferenceIndex: e.readUInt16BE(6),
                channelCount: e.readUInt16BE(16),
                sampleSize: e.readUInt16BE(18),
                sampleRate: e.readUInt32BE(24),
                children: []
              },
              s = 28; 8 <= r - s; ) {
            var i = g.decode(e, s, r);
            o.children.push(i), o[i.type] = i, s += i.length;
          }
          return o;
        }, n.AudioSampleEntry.encodingLength = function(e) {
          var t = 28,
              n = e.children || [];
          return n.forEach(function(e) {
            t += g.encodingLength(e);
          }), t;
        }, n.esds = {}, n.esds.encode = function(e, r, o) {
          r = r ? r.slice(o) : t(e.buffer.length), e.buffer.copy(r, 0), n.esds.encode.bytes = e.buffer.length;
        }, n.esds.decode = function(e, n, r) {
          e = e.slice(n, r);
          var o = _.Descriptor.decode(e, 0, e.length),
              s = "ESDescriptor" === o.tagName ? o : {},
              i = s.DecoderConfigDescriptor || {},
              d = i.oti || 0,
              a = i.DecoderSpecificInfo,
              c = a ? (248 & a.buffer.readUInt8(0)) >> 3 : 0,
              l = null;
          return d && (l = d.toString(16), c && (l += "." + c)), {
            mimeCodec: l,
            buffer: new t(e.slice(0))
          };
        }, n.esds.encodingLength = function(e) {
          return e.buffer.length;
        }, n.stsz = {}, n.stsz.encode = function(e, r, o) {
          var s = e.entries || [];
          r = r ? r.slice(o) : t(n.stsz.encodingLength(e)), r.writeUInt32BE(0, 0), r.writeUInt32BE(s.length, 4);
          for (var d = 0; d < s.length; d++)
            r.writeUInt32BE(s[d], 4 * d + 8);
          return n.stsz.encode.bytes = 8 + 4 * s.length, r;
        }, n.stsz.decode = function(e, t) {
          e = e.slice(t);
          for (var n = e.readUInt32BE(0),
              r = e.readUInt32BE(4),
              o = Array(r),
              s = 0; s < r; s++)
            o[s] = 0 === n ? e.readUInt32BE(4 * s + 8) : n;
          return {entries: o};
        }, n.stsz.encodingLength = function(e) {
          return 8 + 4 * e.entries.length;
        }, n.stss = n.stco = {}, n.stco.encode = function(e, r, o) {
          var s = e.entries || [];
          r = r ? r.slice(o) : new t(n.stco.encodingLength(e)), r.writeUInt32BE(s.length, 0);
          for (var d = 0; d < s.length; d++)
            r.writeUInt32BE(s[d], 4 * d + 4);
          return n.stco.encode.bytes = 4 + 4 * s.length, r;
        }, n.stco.decode = function(e, t) {
          e = e.slice(t);
          for (var n = e.readUInt32BE(0),
              r = Array(n),
              o = 0; o < n; o++)
            r[o] = e.readUInt32BE(4 * o + 4);
          return {entries: r};
        }, n.stco.encodingLength = function(e) {
          return 4 + 4 * e.entries.length;
        }, n.stts = {}, n.stts.encode = function(e, r, o) {
          var s = e.entries || [];
          r = r ? r.slice(o) : new t(n.stts.encodingLength(e)), r.writeUInt32BE(s.length, 0);
          for (var d = 0,
              i; d < s.length; d++)
            i = 8 * d + 4, r.writeUInt32BE(s[d].count || 0, i), r.writeUInt32BE(s[d].duration || 0, i + 4);
          return n.stts.encode.bytes = 4 + 8 * e.entries.length, r;
        }, n.stts.decode = function(e, t) {
          e = e.slice(t);
          for (var n = e.readUInt32BE(0),
              r = Array(n),
              o = 0,
              s; o < n; o++)
            s = 8 * o + 4, r[o] = {
              count: e.readUInt32BE(s),
              duration: e.readUInt32BE(s + 4)
            };
          return {entries: r};
        }, n.stts.encodingLength = function(e) {
          return 4 + 8 * e.entries.length;
        }, n.ctts = {}, n.ctts.encode = function(e, r, o) {
          var s = e.entries || [];
          r = r ? r.slice(o) : new t(n.ctts.encodingLength(e)), r.writeUInt32BE(s.length, 0);
          for (var d = 0,
              i; d < s.length; d++)
            i = 8 * d + 4, r.writeUInt32BE(s[d].count || 0, i), r.writeUInt32BE(s[d].compositionOffset || 0, i + 4);
          return n.ctts.encode.bytes = 4 + 8 * s.length, r;
        }, n.ctts.decode = function(e, t) {
          e = e.slice(t);
          for (var n = e.readUInt32BE(0),
              r = Array(n),
              o = 0,
              s; o < n; o++)
            s = 8 * o + 4, r[o] = {
              count: e.readUInt32BE(s),
              compositionOffset: e.readInt32BE(s + 4)
            };
          return {entries: r};
        }, n.ctts.encodingLength = function(e) {
          return 4 + 8 * e.entries.length;
        }, n.stsc = {}, n.stsc.encode = function(e, r, o) {
          var s = e.entries || [];
          r = r ? r.slice(o) : new t(n.stsc.encodingLength(e)), r.writeUInt32BE(s.length, 0);
          for (var d = 0,
              i; d < s.length; d++)
            i = 12 * d + 4, r.writeUInt32BE(s[d].firstChunk || 0, i), r.writeUInt32BE(s[d].samplesPerChunk || 0, i + 4), r.writeUInt32BE(s[d].sampleDescriptionId || 0, i + 8);
          return n.stsc.encode.bytes = 4 + 12 * s.length, r;
        }, n.stsc.decode = function(e, t) {
          e = e.slice(t);
          for (var n = e.readUInt32BE(0),
              r = Array(n),
              o = 0,
              s; o < n; o++)
            s = 12 * o + 4, r[o] = {
              firstChunk: e.readUInt32BE(s),
              samplesPerChunk: e.readUInt32BE(s + 4),
              sampleDescriptionId: e.readUInt32BE(s + 8)
            };
          return {entries: r};
        }, n.stsc.encodingLength = function(e) {
          return 4 + 12 * e.entries.length;
        }, n.dref = {}, n.dref.encode = function(e, r, o) {
          r = r ? r.slice(o) : new t(n.dref.encodingLength(e));
          var s = e.entries || [];
          r.writeUInt32BE(s.length, 0);
          for (var d = 4,
              a = 0; a < s.length; a++) {
            var i = s[a],
                c = (i.buf ? i.buf.length : 0) + 4 + 4;
            r.writeUInt32BE(c, d), d += 4, r.write(i.type, d, 4, "ascii"), d += 4, i.buf && (i.buf.copy(r, d), d += i.buf.length);
          }
          return n.dref.encode.bytes = d, r;
        }, n.dref.decode = function(e, t) {
          e = e.slice(t);
          for (var n = e.readUInt32BE(0),
              r = Array(n),
              o = 4,
              s = 0; s < n; s++) {
            var i = e.readUInt32BE(o),
                d = e.toString("ascii", o + 4, o + 8),
                a = e.slice(o + 8, o + i);
            o += i, r[s] = {
              type: d,
              buf: a
            };
          }
          return {entries: r};
        }, n.dref.encodingLength = function(e) {
          var t = 4;
          if (!e.entries)
            return t;
          for (var n = 0,
              r; n < e.entries.length; n++)
            r = e.entries[n].buf, t += (r ? r.length : 0) + 4 + 4;
          return t;
        }, n.elst = {}, n.elst.encode = function(e, r, o) {
          var s = e.entries || [];
          r = r ? r.slice(o) : new t(n.elst.encodingLength(e)), r.writeUInt32BE(s.length, 0);
          for (var d = 0,
              i; d < s.length; d++)
            i = 12 * d + 4, r.writeUInt32BE(s[d].trackDuration || 0, i), r.writeUInt32BE(s[d].mediaTime || 0, i + 4), a(s[d].mediaRate || 0, r, i + 8);
          return n.elst.encode.bytes = 4 + 12 * s.length, r;
        }, n.elst.decode = function(e, t) {
          e = e.slice(t);
          for (var n = e.readUInt32BE(0),
              r = Array(n),
              o = 0,
              s; o < n; o++)
            s = 12 * o + 4, r[o] = {
              trackDuration: e.readUInt32BE(s),
              mediaTime: e.readInt32BE(s + 4),
              mediaRate: f(e, s + 8)
            };
          return {entries: r};
        }, n.elst.encodingLength = function(e) {
          return 4 + 12 * e.entries.length;
        }, n.hdlr = {}, n.hdlr.encode = function(e, r, o) {
          r = r ? r.slice(o) : new t(n.hdlr.encodingLength(e));
          var s = 21 + (e.name || "").length;
          return r.fill(0, 0, s), r.write(e.handlerType || "", 4, 4, "ascii"), l(e.name || "", r, 20), n.hdlr.encode.bytes = s, r;
        }, n.hdlr.decode = function(e, t, n) {
          return e = e.slice(t), {
            handlerType: e.toString("ascii", 4, 8),
            name: m(e, 20, n)
          };
        }, n.hdlr.encodingLength = function(e) {
          return 21 + (e.name || "").length;
        }, n.mehd = {}, n.mehd.encode = function(e, r, o) {
          return r = r ? r.slice(o) : new t(4), r.writeUInt32BE(e.fragmentDuration || 0, 0), n.mehd.encode.bytes = 4, r;
        }, n.mehd.decode = function(e, t) {
          return e = e.slice(t), {fragmentDuration: e.readUInt32BE(0)};
        }, n.mehd.encodingLength = function() {
          return 4;
        }, n.trex = {}, n.trex.encode = function(e, r, o) {
          return r = r ? r.slice(o) : new t(20), r.writeUInt32BE(e.trackId || 0, 0), r.writeUInt32BE(e.defaultSampleDescriptionIndex || 0, 4), r.writeUInt32BE(e.defaultSampleDuration || 0, 8), r.writeUInt32BE(e.defaultSampleSize || 0, 12), r.writeUInt32BE(e.defaultSampleFlags || 0, 16), n.trex.encode.bytes = 20, r;
        }, n.trex.decode = function(e, t) {
          return e = e.slice(t), {
            trackId: e.readUInt32BE(0),
            defaultSampleDescriptionIndex: e.readUInt32BE(4),
            defaultSampleDuration: e.readUInt32BE(8),
            defaultSampleSize: e.readUInt32BE(12),
            defaultSampleFlags: e.readUInt32BE(16)
          };
        }, n.trex.encodingLength = function() {
          return 20;
        }, n.mfhd = {}, n.mfhd.encode = function(e, r, o) {
          return r = r ? r.slice(o) : new t(4), r.writeUInt32BE(e.sequenceNumber || 0, 0), n.mfhd.encode.bytes = 4, r;
        }, n.mfhd.decode = function(e) {
          return {sequenceNumber: e.readUint32BE(0)};
        }, n.mfhd.encodingLength = function() {
          return 4;
        }, n.tfhd = {}, n.tfhd.encode = function(e, r, o) {
          return r = r ? r.slice(o) : new t(4), r.writeUInt32BE(e.trackId, 0), n.tfhd.encode.bytes = 4, r;
        }, n.tfhd.decode = function() {}, n.tfhd.encodingLength = function() {
          return 4;
        }, n.tfdt = {}, n.tfdt.encode = function(e, r, o) {
          return r = r ? r.slice(o) : new t(4), r.writeUInt32BE(e.baseMediaDecodeTime || 0, 0), n.tfdt.encode.bytes = 4, r;
        }, n.tfdt.decode = function() {}, n.tfdt.encodingLength = function() {
          return 4;
        }, n.trun = {}, n.trun.encode = function(e, r, o) {
          r = r ? r.slice(o) : new t(8 + 16 * e.entries.length), r.writeUInt32BE(e.entries.length, 0), r.writeInt32BE(e.dataOffset, 4);
          for (var s = 8,
              d = 0,
              i; d < e.entries.length; d++)
            i = e.entries[d], r.writeUInt32BE(i.sampleDuration, s), s += 4, r.writeUInt32BE(i.sampleSize, s), s += 4, r.writeUInt32BE(i.sampleFlags, s), s += 4, r.writeUInt32BE(i.sampleCompositionTimeOffset, s), s += 4;
          n.trun.encode.bytes = s;
        }, n.trun.decode = function() {}, n.trun.encodingLength = function(e) {
          return 8 + 16 * e.entries.length;
        }, n.mdat = {}, n.mdat.encode = function(e, t, r) {
          e.buffer ? (e.buffer.copy(t, r), n.mdat.encode.bytes = e.buffer.length) : n.mdat.encode.bytes = n.mdat.encodingLength(e);
        }, n.mdat.decode = function(e, n, r) {
          return {buffer: new t(e.slice(n, r))};
        }, n.mdat.encodingLength = function(e) {
          return e.buffer ? e.buffer.length : e.contentLength;
        };
      }).call(this, e("buffer").Buffer);
    }, {
      "./descriptor": 53,
      "./index": 54,
      buffer: 25
    }],
    53: [function(e, t, n) {
      (function(e) {
        var t = {
          3: "ESDescriptor",
          4: "DecoderConfigDescriptor",
          5: "DecoderSpecificInfo",
          6: "SLConfigDescriptor"
        };
        n.Descriptor = {}, n.Descriptor.decode = function(r, o, s) {
          var i = r.readUInt8(o),
              d = o + 1,
              a = 0,
              c;
          do
            c = r.readUInt8(d++), a = a << 7 | 127 & c;
 while (128 & c);
          var l = t[i],
              p;
          return p = n[l] ? n[l].decode(r, d, s) : {buffer: new e(r.slice(d, d + a))}, p.tag = i, p.tagName = l, p.length = d - o + a, p.contentsLen = a, p;
        }, n.DescriptorArray = {}, n.DescriptorArray.decode = function(e, r, o) {
          for (var s = r,
              i = {}; s + 2 <= o; ) {
            var d = n.Descriptor.decode(e, s, o);
            s += d.length;
            var a = t[d.tag] || "Descriptor" + d.tag;
            i[a] = d;
          }
          return i;
        }, n.ESDescriptor = {}, n.ESDescriptor.decode = function(e, t, r) {
          var o = e.readUInt8(t + 2),
              s = t + 3;
          if (128 & o && (s += 2), 64 & o) {
            var i = e.readUInt8(s);
            s += i + 1;
          }
          return 32 & o && (s += 2), n.DescriptorArray.decode(e, s, r);
        }, n.DecoderConfigDescriptor = {}, n.DecoderConfigDescriptor.decode = function(e, t, r) {
          var o = e.readUInt8(t),
              s = n.DescriptorArray.decode(e, t + 13, r);
          return s.oti = o, s;
        };
      }).call(this, e("buffer").Buffer);
    }, {buffer: 25}],
    54: [function(e, t, n) {
      (function(t) {
        var r = e("uint64be"),
            o = e("./boxes"),
            s = 4294967295,
            i = n,
            d = n.containers = {
              moov: ["mvhd", "meta", "traks", "mvex"],
              trak: ["tkhd", "tref", "trgr", "edts", "meta", "mdia", "udta"],
              edts: ["elst"],
              mdia: ["mdhd", "hdlr", "elng", "minf"],
              minf: ["vmhd", "smhd", "hmhd", "sthd", "nmhd", "dinf", "stbl"],
              dinf: ["dref"],
              stbl: ["stsd", "stts", "ctts", "cslg", "stsc", "stsz", "stz2", "stco", "co64", "stss", "stsh", "padb", "stdp", "sdtp", "sbgps", "sgpds", "subss", "saizs", "saios"],
              mvex: ["mehd", "trexs", "leva"],
              moof: ["mfhd", "meta", "trafs"],
              traf: ["tfhd", "trun", "sbgps", "sgpds", "subss", "saizs", "saios", "tfdt", "meta"]
            };
        i.encode = function(e, n, r) {
          return i.encodingLength(e), r = r || 0, n = n || new t(e.length), i._encode(e, n, r);
        }, i._encode = function(e, t, n) {
          var a = e.type,
              c = e.length;
          c > s && (c = 1), t.writeUInt32BE(c, n), t.write(e.type, n + 4, 4, "ascii");
          var l = n + 8;
          if (1 === c && (r.encode(e.length, t, l), l += 8), o.fullBoxes[a] && (t.writeUInt32BE(e.flags || 0, l), t.writeUInt8(e.version || 0, l), l += 4), d[a]) {
            var p = d[a];
            p.forEach(function(n) {
              if (5 === n.length) {
                var r = e[n] || [];
                n = n.substr(0, 4), r.forEach(function(e) {
                  i._encode(e, t, l), l += i.encode.bytes;
                });
              } else
                e[n] && (i._encode(e[n], t, l), l += i.encode.bytes);
            }), e.otherBoxes && e.otherBoxes.forEach(function(e) {
              i._encode(e, t, l), l += i.encode.bytes;
            });
          } else if (o[a]) {
            var u = o[a].encode;
            u(e, t, l), l += u.bytes;
          } else if (e.buffer) {
            var f = e.buffer;
            f.copy(t, l), l += e.buffer.length;
          } else
            throw new Error("Either `type` must be set to a known type (not'" + a + "') or `buffer` must be set");
          return i.encode.bytes = l - n, t;
        }, i.readHeaders = function(e, t, n) {
          if (t = t || 0, n = n || e.length, 8 > n - t)
            return 8;
          var s = e.readUInt32BE(t),
              i = e.toString("ascii", t + 4, t + 8),
              d = t + 8;
          if (1 === s) {
            if (16 > n - t)
              return 16;
            s = r.decode(e, d), d += 8;
          }
          var a,
              c;
          return o.fullBoxes[i] && (a = e.readUInt8(d), c = 16777215 & e.readUInt32BE(d), d += 4), {
            length: s,
            headersLen: d - t,
            contentLen: s - (d - t),
            type: i,
            version: a,
            flags: c
          };
        }, i.decode = function(e, t, n) {
          t = t || 0, n = n || e.length;
          var r = i.readHeaders(e, t, n);
          if (!r || r.length > n - t)
            throw new Error("Data too short");
          return i.decodeWithoutHeaders(r, e, t + r.headersLen, t + r.length);
        }, i.decodeWithoutHeaders = function(e, n, r, s) {
          r = r || 0, s = s || n.length;
          var a = e.type,
              c = {};
          if (d[a]) {
            c.otherBoxes = [];
            for (var l = d[a],
                p = r,
                u; 8 <= s - p; )
              if (u = i.decode(n, p, s), p += u.length, 0 <= l.indexOf(u.type))
                c[u.type] = u;
              else if (0 <= l.indexOf(u.type + "s")) {
                var f = u.type + "s",
                    h = c[f] = c[f] || [];
                h.push(u);
              } else
                c.otherBoxes.push(u);
          } else if (o[a]) {
            var m = o[a].decode;
            c = m(n, r, s);
          } else
            c.buffer = new t(n.slice(r, s));
          return c.length = e.length, c.contentLen = e.contentLen, c.type = e.type, c.version = e.version, c.flags = e.flags, c;
        }, i.encodingLength = function(e) {
          var t = e.type,
              n = 8;
          if (o.fullBoxes[t] && (n += 4), d[t]) {
            var r = d[t];
            r.forEach(function(t) {
              if (5 === t.length) {
                var r = e[t] || [];
                t = t.substr(0, 4), r.forEach(function(e) {
                  e.type = t, n += i.encodingLength(e);
                });
              } else if (e[t]) {
                var o = e[t];
                o.type = t, n += i.encodingLength(o);
              }
            }), e.otherBoxes && e.otherBoxes.forEach(function(e) {
              n += i.encodingLength(e);
            });
          } else if (o[t])
            n += o[t].encodingLength(e);
          else if (e.buffer)
            n += e.buffer.length;
          else
            throw new Error("Either `type` must be set to a known type (not'" + t + "') or `buffer` must be set");
          return n > s && (n += 8), e.length = n, n;
        };
      }).call(this, e("buffer").Buffer);
    }, {
      "./boxes": 52,
      buffer: 25,
      uint64be: 113
    }],
    55: [function(e, t) {
      (function(n) {
        function r() {
          return this instanceof r ? void(s.Writable.call(this), this.destroyed = !1, this._pending = 0, this._missing = 0, this._buf = null, this._str = null, this._cb = null, this._ondrain = null, this._writeBuffer = null, this._writeCb = null, this._ondrain = null, this._kick()) : new r;
        }
        function o(e) {
          this._parent = e, this.destroyed = !1, s.PassThrough.call(this);
        }
        var s = e("readable-stream"),
            i = e("inherits"),
            d = e("next-event"),
            a = e("mp4-box-encoding"),
            c = new n(0);
        t.exports = r, i(r, s.Writable), r.prototype.destroy = function(e) {
          this.destroyed || (this.destroyed = !0, e && this.emit("error", e), this.emit("close"));
        }, r.prototype._write = function(e, t, n) {
          if (!this.destroyed) {
            for (var r = !this._str || !this._str._writableState.needDrain; e.length && !this.destroyed; ) {
              if (!this._missing)
                return this._writeBuffer = e, void(this._writeCb = n);
              var o = e.length < this._missing ? e.length : this._missing;
              if (this._buf ? e.copy(this._buf, this._buf.length - this._missing) : this._str && (r = this._str.write(o === e.length ? e : e.slice(0, o))), this._missing -= o, !this._missing) {
                var s = this._buf,
                    i = this._cb,
                    d = this._str;
                this._buf = this._cb = this._str = this._ondrain = null, r = !0, d && d.end(), i && i(s);
              }
              e = o === e.length ? c : e.slice(o);
            }
            return this._pending && !this._missing ? (this._writeBuffer = e, void(this._writeCb = n)) : void(r ? n() : this._ondrain(n));
          }
        }, r.prototype._buffer = function(e, t) {
          this._missing = e, this._buf = new n(e), this._cb = t;
        }, r.prototype._stream = function(e, t) {
          var n = this;
          return this._missing = e, this._str = new o(this), this._ondrain = d(this._str, "drain"), this._pending++, this._str.on("end", function() {
            n._pending--, n._kick();
          }), this._cb = t, this._str;
        }, r.prototype._readBox = function() {
          function e(r, o) {
            t._buffer(r, function(r) {
              o = o ? n.concat([o, r]) : r;
              var s = a.readHeaders(o);
              "number" == typeof s ? e(s - o.length, o) : (t._pending++, t._headers = s, t.emit("box", s));
            });
          }
          var t = this;
          e(8);
        }, r.prototype.stream = function() {
          var e = this;
          if (!e._headers)
            throw new Error("this function can only be called once after 'box' is emitted");
          var t = e._headers;
          return e._headers = null, e._stream(t.contentLen, null);
        }, r.prototype.decode = function(e) {
          var t = this;
          if (!t._headers)
            throw new Error("this function can only be called once after 'box' is emitted");
          var n = t._headers;
          t._headers = null, t._buffer(n.contentLen, function(r) {
            var o = a.decodeWithoutHeaders(n, r);
            e(o), t._pending--, t._kick();
          });
        }, r.prototype.ignore = function() {
          var e = this;
          if (!e._headers)
            throw new Error("this function can only be called once after 'box' is emitted");
          var t = e._headers;
          e._headers = null, this._missing = t.contentLen, this._cb = function() {
            e._pending--, e._kick();
          };
        }, r.prototype._kick = function() {
          if (!this._pending && (this._buf || this._str || this._readBox(), this._writeBuffer)) {
            var e = this._writeCb,
                t = this._writeBuffer;
            this._writeBuffer = null, this._writeCb = null, this._write(t, null, e);
          }
        }, i(o, s.PassThrough), o.prototype.destroy = function(e) {
          this.destroyed || (this.destroyed = !0, this._parent.destroy(e), e && this.emit("error", e), this.emit("close"));
        };
      }).call(this, e("buffer").Buffer);
    }, {
      buffer: 25,
      inherits: 42,
      "mp4-box-encoding": 54,
      "next-event": 60,
      "readable-stream": 84
    }],
    56: [function(e, t) {
      (function(n, r) {
        function o() {}
        function s() {
          if (!(this instanceof s))
            return new s;
          d.Readable.call(this), this.destroyed = !1, this._reading = !1, this._stream = null, this._drain = null, this._want = !1, this._onreadable = function() {
            e._want && (e._want = !1, e._read());
          }, this._onend = function() {
            e._stream = null;
          };
          var e = this;
        }
        function i(e) {
          this._parent = e, this.destroyed = !1, d.PassThrough.call(this);
        }
        var d = e("readable-stream"),
            a = e("inherits"),
            c = e("mp4-box-encoding");
        t.exports = s, a(s, d.Readable), s.prototype.mediaData = s.prototype.mdat = function(e, t) {
          var n = new i(this);
          return this.box({
            type: "mdat",
            contentLength: e,
            encodeBufferLen: 8,
            stream: n
          }, t), n;
        }, s.prototype.box = function(e, t) {
          if (t || (t = o), this.destroyed)
            return t(new Error("Encoder is destroyed"));
          var s;
          if (e.encodeBufferLen && (s = new r(e.encodeBufferLen)), e.stream)
            e.buffer = null, s = c.encode(e, s), this.push(s), this._stream = e.stream, this._stream.on("readable", this._onreadable), this._stream.on("end", this._onend), this._stream.on("end", t), this._forward();
          else {
            s = c.encode(e, s);
            var i = this.push(s);
            if (i)
              return n.nextTick(t);
            this._drain = t;
          }
        }, s.prototype.destroy = function(e) {
          if (!this.destroyed) {
            if (this.destroyed = !0, this._stream && this._stream.destroy && this._stream.destroy(), this._stream = null, this._drain) {
              var t = this._drain;
              this._drain = null, t(e);
            }
            e && this.emit("error", e), this.emit("close");
          }
        }, s.prototype.finalize = function() {
          this.push(null);
        }, s.prototype._forward = function() {
          if (this._stream)
            for (; !this.destroyed; ) {
              var e = this._stream.read();
              if (!e)
                return void(this._want = !!this._stream);
              if (!this.push(e))
                return;
            }
        }, s.prototype._read = function() {
          if (!(this._reading || this.destroyed)) {
            if (this._reading = !0, this._stream && this._forward(), this._drain) {
              var e = this._drain;
              this._drain = null, e();
            }
            this._reading = !1;
          }
        }, a(i, d.PassThrough), i.prototype.destroy = function(e) {
          this.destroyed || (this.destroyed = !0, this._parent.destroy(e), e && this.emit("error", e), this.emit("close"));
        };
      }).call(this, e("_process"), e("buffer").Buffer);
    }, {
      _process: 67,
      buffer: 25,
      inherits: 42,
      "mp4-box-encoding": 54,
      "readable-stream": 84
    }],
    57: [function(e, t, n) {
      n.decode = e("./decode"), n.encode = e("./encode");
    }, {
      "./decode": 55,
      "./encode": 56
    }],
    58: [function(e, t) {
      function n(e) {
        if (e += "", !(100 < e.length)) {
          var t = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(e);
          if (t) {
            var r = parseFloat(t[1]),
                n = (t[2] || "ms").toLowerCase();
            return "years" === n || "year" === n || "yrs" === n || "yr" === n || "y" === n ? r * d : "days" === n || "day" === n || "d" === n ? r * u : "hours" === n || "hour" === n || "hrs" === n || "hr" === n || "h" === n ? r * p : "minutes" === n || "minute" === n || "mins" === n || "min" === n || "m" === n ? r * l : "seconds" === n || "second" === n || "secs" === n || "sec" === n || "s" === n ? r * c : "milliseconds" === n || "millisecond" === n || "msecs" === n || "msec" === n || "ms" === n ? r : void 0;
          }
        }
      }
      function o(e) {
        var t = Math.round;
        return e >= u ? t(e / u) + "d" : e >= p ? t(e / p) + "h" : e >= l ? t(e / l) + "m" : e >= c ? t(e / c) + "s" : e + "ms";
      }
      function i(e) {
        return a(e, u, "day") || a(e, p, "hour") || a(e, l, "minute") || a(e, c, "second") || e + " ms";
      }
      function a(e, t, n) {
        return e < t ? void 0 : e < 1.5 * t ? r(e / t) + " " + n : s(e / t) + " " + n + "s";
      }
      var c = 1e3,
          l = 60 * c,
          p = 60 * l,
          u = 24 * p,
          d = 365.25 * u;
      t.exports = function(e, t) {
        t = t || {};
        var r = typeof e;
        if ("string" == r && 0 < e.length)
          return n(e);
        if ("number" == r && !1 === isNaN(e))
          return t.long ? i(e) : o(e);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e));
      };
    }, {}],
    59: [function(e, t) {
      function n(e, t) {
        var o = this;
        return o instanceof n ? void(i.Readable.call(o, t), o.destroyed = !1, o._drained = !1, o._forwarding = !1, o._current = null, "function" == typeof e ? o._queue = e : (o._queue = e.map(r), o._queue.forEach(function(e) {
          "function" != typeof e && o._attachErrorListener(e);
        })), o._next()) : new n(e, t);
      }
      function r(e) {
        if (!e || "function" == typeof e || e._readableState)
          return e;
        var t = new i.Readable().wrap(e);
        return e.destroy && (t.destroy = e.destroy.bind(e)), t;
      }
      t.exports = n;
      var o = e("inherits"),
          i = e("readable-stream");
      o(n, i.Readable), n.obj = function(e) {
        return new n(e, {
          objectMode: !0,
          highWaterMark: 16
        });
      }, n.prototype._read = function() {
        this._drained = !0, this._forward();
      }, n.prototype._forward = function() {
        if (!this._forwarding && this._drained && this._current) {
          this._forwarding = !0;
          for (var e; null !== (e = this._current.read()); )
            this._drained = this.push(e);
          this._forwarding = !1;
        }
      }, n.prototype.destroy = function(e) {
        this.destroyed || (this.destroyed = !0, this._current && this._current.destroy && this._current.destroy(), "function" != typeof this._queue && this._queue.forEach(function(e) {
          e.destroy && e.destroy();
        }), e && this.emit("error", e), this.emit("close"));
      }, n.prototype._next = function() {
        var e = this;
        if (e._current = null, "function" == typeof e._queue)
          e._queue(function(t, n) {
            return t ? e.destroy(t) : void(n = r(n), e._attachErrorListener(n), e._gotNextStream(n));
          });
        else {
          var t = e._queue.shift();
          "function" == typeof t && (t = r(t()), e._attachErrorListener(t)), e._gotNextStream(t);
        }
      }, n.prototype._gotNextStream = function(e) {
        function t() {
          o._forward();
        }
        function n() {
          e._readableState.ended || o.destroy();
        }
        function r() {
          o._current = null, e.removeListener("readable", t), e.removeListener("end", r), e.removeListener("close", n), o._next();
        }
        var o = this;
        return e ? void(o._current = e, o._forward(), e.on("readable", t), e.once("end", r), e.once("close", n)) : (o.push(null), void o.destroy());
      }, n.prototype._attachErrorListener = function(e) {
        function t(r) {
          e.removeListener("error", t), n.destroy(r);
        }
        var n = this;
        e && e.once("error", t);
      };
    }, {
      inherits: 42,
      "readable-stream": 84
    }],
    60: [function(e, t) {
      t.exports = function(e, t) {
        var n = null;
        return e.on(t, function(e) {
          if (n) {
            var t = n;
            n = null, t(e);
          }
        }), function(e) {
          n = e;
        };
      };
    }, {}],
    61: [function(e, t) {
      function n(e) {
        var t = function() {
          return t.called ? t.value : (t.called = !0, t.value = e.apply(this, arguments));
        };
        return t.called = !1, t;
      }
      function r(e) {
        var t = function() {
          if (t.called)
            throw new Error(t.onceError);
          return t.called = !0, t.value = e.apply(this, arguments);
        },
            n = e.name || "Function wrapped with `once`";
        return t.onceError = n + " shouldn't be called more than once", t.called = !1, t;
      }
      var o = e("wrappy");
      t.exports = o(n), t.exports.strict = o(r), n.proto = n(function() {
        Object.defineProperty(Function.prototype, "once", {
          value: function() {
            return n(this);
          },
          configurable: !0
        }), Object.defineProperty(Function.prototype, "onceStrict", {
          value: function() {
            return r(this);
          },
          configurable: !0
        });
      });
    }, {wrappy: 125}],
    62: [function(e, t) {
      (function(n) {
        function r(e) {
          n.isBuffer(e) && (e = d.decode(e)), i(e.info, "info"), i(e.info["name.utf-8"] || e.info.name, "info.name"), i(e.info["piece length"], "info['piece length']"), i(e.info.pieces, "info.pieces"), e.info.files ? e.info.files.forEach(function(e) {
            i("number" == typeof e.length, "info.files[0].length"), i(e["path.utf-8"] || e.path, "info.files[0].path");
          }) : i("number" == typeof e.info.length, "info.length");
          var t = {};
          t.info = e.info, t.infoBuffer = d.encode(e.info), t.infoHash = c.sync(t.infoBuffer), t.infoHashBuffer = n.from(t.infoHash, "hex"), t.name = (e.info["name.utf-8"] || e.info.name).toString(), void 0 !== e.info.private && (t.private = !!e.info.private), e["creation date"] && (t.created = new Date(1e3 * e["creation date"])), e["created by"] && (t.createdBy = e["created by"].toString()), n.isBuffer(e.comment) && (t.comment = e.comment.toString()), t.announce = [], e["announce-list"] && e["announce-list"].length ? e["announce-list"].forEach(function(e) {
            e.forEach(function(e) {
              t.announce.push(e.toString());
            });
          }) : e.announce && t.announce.push(e.announce.toString()), n.isBuffer(e["url-list"]) && (e["url-list"] = 0 < e["url-list"].length ? [e["url-list"]] : []), t.urlList = (e["url-list"] || []).map(function(e) {
            return e.toString();
          }), l(t.announce), l(t.urlList);
          var r = e.info.files || [e.info];
          t.files = r.map(function(e, n) {
            var s = [].concat(t.name, e["path.utf-8"] || e.path || []).map(function(e) {
              return e.toString();
            });
            return {
              path: a.join.apply(null, [a.sep].concat(s)).slice(1),
              name: s[s.length - 1],
              length: e.length,
              offset: r.slice(0, n).reduce(o, 0)
            };
          }), t.length = r.reduce(o, 0);
          var p = t.files[t.files.length - 1];
          return t.pieceLength = e.info["piece length"], t.lastPieceLength = (p.offset + p.length) % t.pieceLength || t.pieceLength, t.pieces = s(e.info.pieces), t;
        }
        function o(e, t) {
          return e + t.length;
        }
        function s(e) {
          for (var t = [],
              n = 0; n < e.length; n += 20)
            t.push(e.slice(n, n + 20).toString("hex"));
          return t;
        }
        function i(e, t) {
          if (!e)
            throw new Error("Torrent is missing required field: " + t);
        }
        t.exports = r, t.exports.decode = r, t.exports.encode = function(e) {
          var t = {info: e.info};
          return t["announce-list"] = (e.announce || []).map(function(e) {
            return t.announce || (t.announce = e), e = n.from(e, "utf8"), [e];
          }), t["url-list"] = e.urlList || [], e.created && (t["creation date"] = 0 | e.created.getTime() / 1e3), e.createdBy && (t["created by"] = e.createdBy), e.comment && (t.comment = e.comment), d.encode(t);
        };
        var d = e("bencode"),
            a = e("path"),
            c = e("simple-sha1"),
            l = e("uniq");
      }).call(this, e("buffer").Buffer);
    }, {
      bencode: 11,
      buffer: 25,
      path: 64,
      "simple-sha1": 96,
      uniq: 114
    }],
    63: [function(e, t) {
      (function(n, r) {
        function o(e) {
          if ("string" == typeof e && /^(stream-)?magnet:/.test(e))
            return c(e);
          if ("string" == typeof e && (/^[a-f0-9]{40}$/i.test(e) || /^[a-z2-7]{32}$/i.test(e)))
            return c("magnet:?xt=urn:btih:" + e);
          if (r.isBuffer(e) && 20 === e.length)
            return c("magnet:?xt=urn:btih:" + e.toString("hex"));
          if (r.isBuffer(e))
            return l(e);
          if (e && e.infoHash)
            return e.announce || (e.announce = []), "string" == typeof e.announce && (e.announce = [e.announce]), e.urlList || (e.urlList = []), e;
          throw new Error("Invalid torrent identifier");
        }
        function s(e) {
          return "undefined" != typeof Blob && e instanceof Blob;
        }
        t.exports = o, t.exports.remote = function(e, t) {
          function r(e) {
            try {
              c = o(e);
            } catch (e) {
              return t(e);
            }
            c && c.infoHash ? t(null, c) : t(new Error("Invalid torrent identifier"));
          }
          var c;
          if ("function" != typeof t)
            throw new Error("second argument must be a Function");
          try {
            c = o(e);
          } catch (e) {}
          c && c.infoHash ? n.nextTick(function() {
            t(null, c);
          }) : s(e) ? i(e, function(e, n) {
            return e ? t(new Error("Error converting Blob: " + e.message)) : void r(n);
          }) : "function" == typeof a && /^https?:/.test(e) ? a.concat({
            url: e,
            timeout: 30000,
            headers: {"user-agent": "WebTorrent (http://webtorrent.io)"}
          }, function(e, n, o) {
            return e ? t(new Error("Error downloading torrent: " + e.message)) : void r(o);
          }) : "function" == typeof d.readFile && "string" == typeof e ? d.readFile(e, function(e, n) {
            return e ? t(new Error("Invalid torrent identifier")) : void r(n);
          }) : n.nextTick(function() {
            t(new Error("Invalid torrent identifier"));
          });
        };
        var i = e("blob-to-buffer"),
            d = e("fs"),
            a = e("simple-get"),
            c = e("magnet-uri"),
            l = e("parse-torrent-file");
        t.exports.toMagnetURI = c.encode, t.exports.toTorrentFile = l.encode;
        (function() {
          r.alloc(0);
        })();
      }).call(this, e("_process"), e("buffer").Buffer);
    }, {
      _process: 67,
      "blob-to-buffer": 21,
      buffer: 25,
      fs: 24,
      "magnet-uri": 49,
      "parse-torrent-file": 62,
      "simple-get": 94
    }],
    64: [function(e, t, n) {
      (function(e) {
        function t(e, t) {
          for (var n = 0,
              r = e.length - 1,
              o; 0 <= r; r--)
            o = e[r], "." === o ? e.splice(r, 1) : ".." === o ? (e.splice(r, 1), n++) : n && (e.splice(r, 1), n--);
          if (t)
            for (; n--; n)
              e.unshift("..");
          return e;
        }
        function r(e, t) {
          if (e.filter)
            return e.filter(t);
          for (var n = [],
              r = 0; r < e.length; r++)
            t(e[r], r, e) && n.push(e[r]);
          return n;
        }
        var o = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/,
            s = function(e) {
              return o.exec(e).slice(1);
            };
        n.resolve = function() {
          for (var n = "",
              o = !1,
              s = arguments.length - 1,
              i; -1 <= s && !o; s--) {
            if (i = 0 <= s ? arguments[s] : e.cwd(), "string" != typeof i)
              throw new TypeError("Arguments to path.resolve must be strings");
            else if (!i)
              continue;
            n = i + "/" + n, o = "/" === i.charAt(0);
          }
          return n = t(r(n.split("/"), function(e) {
            return !!e;
          }), !o).join("/"), (o ? "/" : "") + n || ".";
        }, n.normalize = function(e) {
          var o = n.isAbsolute(e),
              s = "/" === i(e, -1);
          return e = t(r(e.split("/"), function(e) {
            return !!e;
          }), !o).join("/"), e || o || (e = "."), e && s && (e += "/"), (o ? "/" : "") + e;
        }, n.isAbsolute = function(e) {
          return "/" === e.charAt(0);
        }, n.join = function() {
          var e = Array.prototype.slice.call(arguments, 0);
          return n.normalize(r(e, function(e) {
            if ("string" != typeof e)
              throw new TypeError("Arguments to path.join must be strings");
            return e;
          }).join("/"));
        }, n.relative = function(e, t) {
          function r(e) {
            for (var t = 0; t < e.length && "" === e[t]; t++)
              ;
            for (var n = e.length - 1; 0 <= n && "" === e[n]; n--)
              ;
            return t > n ? [] : e.slice(t, n - t + 1);
          }
          e = n.resolve(e).substr(1), t = n.resolve(t).substr(1);
          for (var o = r(e.split("/")),
              s = r(t.split("/")),
              a = d(o.length, s.length),
              c = a,
              l = 0; l < a; l++)
            if (o[l] !== s[l]) {
              c = l;
              break;
            }
          for (var i = [],
              l = c; l < o.length; l++)
            i.push("..");
          return i = i.concat(s.slice(c)), i.join("/");
        }, n.sep = "/", n.delimiter = ":", n.dirname = function(e) {
          var t = s(e),
              n = t[0],
              r = t[1];
          return n || r ? (r && (r = r.substr(0, r.length - 1)), n + r) : ".";
        }, n.basename = function(e, t) {
          var n = s(e)[2];
          return t && n.substr(-1 * t.length) === t && (n = n.substr(0, n.length - t.length)), n;
        }, n.extname = function(e) {
          return s(e)[3];
        };
        var i = function(e, t, n) {
          return e.substr(t, n);
        };
      }).call(this, e("_process"));
    }, {_process: 67}],
    65: [function(e, n) {
      for (var r = e("closest-to"),
          o = 1024,
          s = 13,
          i = []; 22 > s++; )
        i.push(t(2, s));
      n.exports = function(e) {
        return r(e / o, i);
      };
    }, {"closest-to": 28}],
    66: [function(e, t) {
      (function(e) {
        "use strict";
        t.exports = e.version && 0 !== e.version.indexOf("v0.") && (0 !== e.version.indexOf("v1.") || 0 === e.version.indexOf("v1.8.")) ? e : {nextTick: function(t, n, r, o) {
            if ("function" != typeof t)
              throw new TypeError("\"callback\" argument must be a function");
            var s = arguments.length,
                d,
                a;
            switch (s) {
              case 0:
              case 1:
                return e.nextTick(t);
              case 2:
                return e.nextTick(function() {
                  t.call(null, n);
                });
              case 3:
                return e.nextTick(function() {
                  t.call(null, n, r);
                });
              case 4:
                return e.nextTick(function() {
                  t.call(null, n, r, o);
                });
              default:
                for (d = Array(s - 1), a = 0; a < d.length; )
                  d[a++] = arguments[a];
                return e.nextTick(function() {
                  t.apply(null, d);
                });
            }
          }};
      }).call(this, e("_process"));
    }, {_process: 67}],
    67: [function(e, t) {
      function n() {
        throw new Error("setTimeout has not been defined");
      }
      function r() {
        throw new Error("clearTimeout has not been defined");
      }
      function o(e) {
        if (p === setTimeout)
          return setTimeout(e, 0);
        if ((p === n || !p) && setTimeout)
          return p = setTimeout, setTimeout(e, 0);
        try {
          return p(e, 0);
        } catch (t) {
          try {
            return p.call(null, e, 0);
          } catch (t) {
            return p.call(this, e, 0);
          }
        }
      }
      function s(e) {
        if (u === clearTimeout)
          return clearTimeout(e);
        if ((u === r || !u) && clearTimeout)
          return u = clearTimeout, clearTimeout(e);
        try {
          return u(e);
        } catch (t) {
          try {
            return u.call(null, e);
          } catch (t) {
            return u.call(this, e);
          }
        }
      }
      function i() {
        h && g && (h = !1, g.length ? f = g.concat(f) : m = -1, f.length && d());
      }
      function d() {
        if (!h) {
          var e = o(i);
          h = !0;
          for (var t = f.length; t; ) {
            for (g = f, f = []; ++m < t; )
              g && g[m].run();
            m = -1, t = f.length;
          }
          g = null, h = !1, s(e);
        }
      }
      function a(e, t) {
        this.fun = e, this.array = t;
      }
      function c() {}
      var l = t.exports = {},
          p,
          u;
      (function() {
        try {
          p = "function" == typeof setTimeout ? setTimeout : n;
        } catch (t) {
          p = n;
        }
        try {
          u = "function" == typeof clearTimeout ? clearTimeout : r;
        } catch (t) {
          u = r;
        }
      })();
      var f = [],
          h = !1,
          m = -1,
          g;
      l.nextTick = function(e) {
        var t = Array(arguments.length - 1);
        if (1 < arguments.length)
          for (var n = 1; n < arguments.length; n++)
            t[n - 1] = arguments[n];
        f.push(new a(e, t)), 1 !== f.length || h || o(d);
      }, a.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, l.title = "browser", l.browser = !0, l.env = {}, l.argv = [], l.version = "", l.versions = {}, l.on = c, l.addListener = c, l.once = c, l.off = c, l.removeListener = c, l.removeAllListeners = c, l.emit = c, l.prependListener = c, l.prependOnceListener = c, l.listeners = function() {
        return [];
      }, l.binding = function() {
        throw new Error("process.binding is not supported");
      }, l.cwd = function() {
        return "/";
      }, l.chdir = function() {
        throw new Error("process.chdir is not supported");
      }, l.umask = function() {
        return 0;
      };
    }, {}],
    68: [function(e, t) {
      (function(n) {
        var r = e("once"),
            o = e("end-of-stream"),
            s = e("fs"),
            i = function() {},
            d = /^v?\.0/.test(n.version),
            a = function(e) {
              return "function" == typeof e;
            },
            c = function(e) {
              return !!d && !!s && (e instanceof (s.ReadStream || i) || e instanceof (s.WriteStream || i)) && a(e.close);
            },
            l = function(e) {
              return e.setHeader && a(e.abort);
            },
            p = function(e, t, n, s) {
              s = r(s);
              var d = !1;
              e.on("close", function() {
                d = !0;
              }), o(e, {
                readable: t,
                writable: n
              }, function(e) {
                return e ? s(e) : void(d = !0, s());
              });
              var p = !1;
              return function(t) {
                if (!d)
                  return p ? void 0 : (p = !0, c(e) ? e.close(i) : l(e) ? e.abort() : a(e.destroy) ? e.destroy() : void s(t || new Error("stream was destroyed")));
              };
            },
            u = function(e) {
              e();
            },
            f = function(e, t) {
              return e.pipe(t);
            };
        t.exports = function() {
          var e = Array.prototype.slice.call(arguments),
              t = a(e[e.length - 1] || i) && e.pop() || i;
          if (Array.isArray(e[0]) && (e = e[0]), 2 > e.length)
            throw new Error("pump requires two streams per minimum");
          var n = e.map(function(o, s) {
            var i = s < e.length - 1;
            return p(o, i, 0 < s, function(e) {
              r || (r = e), e && n.forEach(u), i || (n.forEach(u), t(r));
            });
          }),
              r;
          return e.reduce(f);
        };
      }).call(this, e("_process"));
    }, {
      _process: 67,
      "end-of-stream": 34,
      fs: 23,
      once: 61
    }],
    69: [function(t, n, o) {
      (function(t) {
        (function(s) {
          function d(e) {
            throw new RangeError(U[e]);
          }
          function a(e, t) {
            for (var n = e.length,
                r = []; n--; )
              r[n] = t(e[n]);
            return r;
          }
          function c(e, t) {
            var n = e.split("@"),
                r = "";
            1 < n.length && (r = n[0] + "@", e = n[1]), e = e.replace(A, ".");
            var o = e.split("."),
                s = a(o, t).join(".");
            return r + s;
          }
          function l(e) {
            for (var t = [],
                n = 0,
                r = e.length,
                o,
                s; n < r; )
              o = e.charCodeAt(n++), 55296 <= o && 56319 >= o && n < r ? (s = e.charCodeAt(n++), 56320 == (64512 & s) ? t.push(((1023 & o) << 10) + (1023 & s) + 65536) : (t.push(o), n--)) : t.push(o);
            return t;
          }
          function p(e) {
            return a(e, function(e) {
              var t = "";
              return 65535 < e && (e -= 65536, t += O(55296 | 1023 & e >>> 10), e = 56320 | 1023 & e), t += O(e), t;
            }).join("");
          }
          function u(e) {
            return 10 > e - 48 ? e - 22 : 26 > e - 65 ? e - 65 : 26 > e - 97 ? e - 97 : v;
          }
          function f(e, t) {
            return e + 22 + 75 * (26 > e) - ((0 != t) << 5);
          }
          function h(e, t, n) {
            var r = 0;
            for (e = n ? P(e / E) : e >> 1, e += P(e / t); e > R * C >> 1; r += v)
              e = P(e / R);
            return P(r + (R + 1) * e / (e + w));
          }
          function m(e) {
            var r = [],
                o = e.length,
                s = 0,
                i = I,
                n = B,
                a,
                c,
                l,
                f,
                m,
                g,
                _,
                y,
                b,
                t;
            for (c = e.lastIndexOf(L), 0 > c && (c = 0), l = 0; l < c; ++l)
              128 <= e.charCodeAt(l) && d("not-basic"), r.push(e.charCodeAt(l));
            for (f = 0 < c ? c + 1 : 0; f < o; ) {
              for (m = s, g = 1, _ = v; ; _ += v) {
                if (f >= o && d("invalid-input"), y = u(e.charCodeAt(f++)), (y >= v || y > P((x - s) / g)) && d("overflow"), s += y * g, b = _ <= n ? S : _ >= n + C ? C : _ - n, y < b)
                  break;
                t = v - b, g > P(x / t) && d("overflow"), g *= t;
              }
              a = r.length + 1, n = h(s - m, a, 0 == m), P(s / a) > x - i && d("overflow"), i += P(s / a), s %= a, r.splice(s++, 0, i);
            }
            return p(r);
          }
          function g(e) {
            var r = [],
                o,
                n,
                s,
                i,
                a,
                c,
                p,
                u,
                m,
                g,
                t,
                _,
                y,
                b,
                w;
            for (e = l(e), _ = e.length, o = I, n = 0, a = B, c = 0; c < _; ++c)
              t = e[c], 128 > t && r.push(O(t));
            for (s = i = r.length, i && r.push(L); s < _; ) {
              for (p = x, c = 0; c < _; ++c)
                t = e[c], t >= o && t < p && (p = t);
              for (y = s + 1, p - o > P((x - n) / y) && d("overflow"), n += (p - o) * y, o = p, c = 0; c < _; ++c)
                if (t = e[c], t < o && ++n > x && d("overflow"), t == o) {
                  for (u = n, m = v; ; m += v) {
                    if (g = m <= a ? S : m >= a + C ? C : m - a, u < g)
                      break;
                    w = u - g, b = v - g, r.push(O(f(g + w % b, 0))), u = P(w / b);
                  }
                  r.push(O(f(u, 0))), a = h(n, y, s == i), n = 0, ++s;
                }
              ++n, ++o;
            }
            return r.join("");
          }
          var _ = "object" == typeof o && o && !o.nodeType && o,
              y = "object" == typeof n && n && !n.nodeType && n,
              b = "object" == typeof t && t;
          (b.global === b || b.window === b || b.self === b) && (s = b);
          var x = 2147483647,
              v = 36,
              S = 1,
              C = 26,
              w = 38,
              E = 700,
              B = 72,
              I = 128,
              L = "-",
              k = /^xn--/,
              T = /[^\x20-\x7E]/,
              A = /[\x2E\u3002\uFF0E\uFF61]/g,
              U = {
                overflow: "Overflow: input needs wider integers to process",
                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                "invalid-input": "Invalid input"
              },
              R = v - S,
              P = r,
              O = e,
              H,
              M;
          if (H = {
            version: "1.4.1",
            ucs2: {
              decode: l,
              encode: p
            },
            decode: m,
            encode: g,
            toASCII: function(e) {
              return c(e, function(e) {
                return T.test(e) ? "xn--" + g(e) : e;
              });
            },
            toUnicode: function(e) {
              return c(e, function(e) {
                return k.test(e) ? m(e.slice(4).toLowerCase()) : e;
              });
            }
          }, "function" == typeof i && "object" == typeof i.amd && i.amd)
            i("punycode", function() {
              return H;
            });
          else if (!(_ && y))
            s.punycode = H;
          else if (n.exports == _)
            y.exports = H;
          else
            for (M in H)
              H.hasOwnProperty(M) && (_[M] = H[M]);
        })(this);
      }).call(this, "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
    }, {}],
    70: [function(e, t) {
      "use strict";
      function n(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t);
      }
      t.exports = function(e, t, o, s) {
        t = t || "&", o = o || "=";
        var d = {};
        if ("string" != typeof e || 0 === e.length)
          return d;
        var a = /\+/g;
        e = e.split(t);
        var c = 1e3;
        s && "number" == typeof s.maxKeys && (c = s.maxKeys);
        var l = e.length;
        0 < c && l > c && (l = c);
        for (var p = 0; p < l; ++p) {
          var i = e[p].replace(a, "%20"),
              u = i.indexOf(o),
              f,
              h,
              m,
              g;
          0 <= u ? (f = i.substr(0, u), h = i.substr(u + 1)) : (f = i, h = ""), m = decodeURIComponent(f), g = decodeURIComponent(h), n(d, m) ? r(d[m]) ? d[m].push(g) : d[m] = [d[m], g] : d[m] = g;
        }
        return d;
      };
      var r = Array.isArray || function(e) {
        return "[object Array]" === Object.prototype.toString.call(e);
      };
    }, {}],
    71: [function(e, t) {
      "use strict";
      function n(e, t) {
        if (e.map)
          return e.map(t);
        for (var n = [],
            r = 0; r < e.length; r++)
          n.push(t(e[r], r));
        return n;
      }
      var r = function(e) {
        switch (typeof e) {
          case "string":
            return e;
          case "boolean":
            return e ? "true" : "false";
          case "number":
            return isFinite(e) ? e : "";
          default:
            return "";
        }
      };
      t.exports = function(e, t, i, d) {
        return t = t || "&", i = i || "=", null === e && (e = void 0), "object" == typeof e ? n(s(e), function(s) {
          var d = encodeURIComponent(r(s)) + i;
          return o(e[s]) ? n(e[s], function(e) {
            return d + encodeURIComponent(r(e));
          }).join(t) : d + encodeURIComponent(r(e[s]));
        }).join(t) : d ? encodeURIComponent(r(d)) + i + encodeURIComponent(r(e)) : "";
      };
      var o = Array.isArray || function(e) {
        return "[object Array]" === Object.prototype.toString.call(e);
      },
          s = Object.keys || function(e) {
            var t = [];
            for (var n in e)
              Object.prototype.hasOwnProperty.call(e, n) && t.push(n);
            return t;
          };
    }, {}],
    72: [function(e, t, n) {
      "use strict";
      n.decode = n.parse = e("./decode"), n.encode = n.stringify = e("./encode");
    }, {
      "./decode": 70,
      "./encode": 71
    }],
    73: [function(e, t) {
      t.exports = function(e) {
        var t = 0;
        return function() {
          if (t === e.length)
            return null;
          var n = e.length - t,
              r = 0 | Math.random() * n,
              o = e[t + r],
              s = e[t];
          return e[t] = o, e[t + r] = s, t++, o;
        };
      };
    }, {}],
    74: [function(e, t) {
      (function(n, r) {
        "use strict";
        var o = e("safe-buffer").Buffer,
            s = r.crypto || r.msCrypto;
        t.exports = s && s.getRandomValues ? function(e, t) {
          if (65536 < e)
            throw new Error("requested too many random bytes");
          var i = new r.Uint8Array(e);
          0 < e && s.getRandomValues(i);
          var d = o.from(i.buffer);
          return "function" == typeof t ? n.nextTick(function() {
            t(null, d);
          }) : d;
        } : function() {
          throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
        };
      }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
    }, {
      _process: 67,
      "safe-buffer": 92
    }],
    75: [function(e, t) {
      function r(e, t) {
        var n = this;
        return n instanceof r ? void(s.Writable.call(n, t), n.destroyed = !1, n._queue = [], n._position = e || 0, n._cb = null, n._buffer = null, n._out = null) : new r(e);
      }
      var o = e("inherits"),
          s = e("readable-stream");
      t.exports = r, o(r, s.Writable), r.prototype._write = function(e, t, r) {
        for (var o = this,
            s = !0; ; ) {
          if (o.destroyed)
            return;
          if (0 === o._queue.length)
            return o._buffer = e, void(o._cb = r);
          o._buffer = null;
          var i = o._queue[0],
              d = n(i.start - o._position, 0),
              a = i.end - o._position;
          if (d >= e.length)
            return o._position += e.length, r(null);
          var c;
          if (a > e.length) {
            o._position += e.length, c = 0 === d ? e : e.slice(d), s = i.stream.write(c) && s;
            break;
          }
          o._position += a, c = 0 === d && a === e.length ? e : e.slice(d, a), s = i.stream.write(c) && s, i.last && i.stream.end(), e = e.slice(a), o._queue.shift();
        }
        s ? r(null) : i.stream.once("drain", r.bind(null, null));
      }, r.prototype.slice = function(e) {
        var t = this;
        if (t.destroyed)
          return null;
        e instanceof Array || (e = [e]);
        var n = new s.PassThrough;
        return e.forEach(function(r, o) {
          t._queue.push({
            start: r.start,
            end: r.end,
            stream: n,
            last: o === e.length - 1
          });
        }), t._buffer && t._write(t._buffer, null, t._cb), n;
      }, r.prototype.destroy = function(e) {
        var t = this;
        t.destroyed || (t.destroyed = !0, e && t.emit("error", e));
      };
    }, {
      inherits: 42,
      "readable-stream": 84
    }],
    76: [function(e, t) {
      "use strict";
      function n(e) {
        return this instanceof n ? void(a.call(this, e), c.call(this, e), e && !1 === e.readable && (this.readable = !1), e && !1 === e.writable && (this.writable = !1), this.allowHalfOpen = !0, e && !1 === e.allowHalfOpen && (this.allowHalfOpen = !1), this.once("end", r)) : new n(e);
      }
      function r() {
        this.allowHalfOpen || this._writableState.ended || s(o, this);
      }
      function o(e) {
        e.end();
      }
      var s = e("process-nextick-args").nextTick,
          i = Object.keys || function(e) {
            var t = [];
            for (var n in e)
              t.push(n);
            return t;
          };
      t.exports = n;
      var d = e("core-util-is");
      d.inherits = e("inherits");
      var a = e("./_stream_readable"),
          c = e("./_stream_writable");
      d.inherits(n, a);
      for (var l = i(c.prototype),
          p = 0,
          u; p < l.length; p++)
        u = l[p], n.prototype[u] || (n.prototype[u] = c.prototype[u]);
      Object.defineProperty(n.prototype, "destroyed", {
        get: function() {
          return void 0 === this._readableState || void 0 === this._writableState ? !1 : this._readableState.destroyed && this._writableState.destroyed;
        },
        set: function(e) {
          void 0 === this._readableState || void 0 === this._writableState || (this._readableState.destroyed = e, this._writableState.destroyed = e);
        }
      }), n.prototype._destroy = function(e, t) {
        this.push(null), this.end(), s(t, e);
      };
    }, {
      "./_stream_readable": 78,
      "./_stream_writable": 80,
      "core-util-is": 29,
      inherits: 42,
      "process-nextick-args": 66
    }],
    77: [function(e, t) {
      "use strict";
      function n(e) {
        return this instanceof n ? void r.call(this, e) : new n(e);
      }
      t.exports = n;
      var r = e("./_stream_transform"),
          o = e("core-util-is");
      o.inherits = e("inherits"), o.inherits(n, r), n.prototype._transform = function(e, t, n) {
        n(null, e);
      };
    }, {
      "./_stream_transform": 79,
      "core-util-is": 29,
      inherits: 42
    }],
    78: [function(e, t) {
      (function(n, o) {
        "use strict";
        function s(e) {
          return j.from(e);
        }
        function i(e) {
          return j.isBuffer(e) || e instanceof F;
        }
        function d(e, t, n) {
          return "function" == typeof e.prependListener ? e.prependListener(t, n) : void(e._events && e._events[t] ? P(e._events[t]) ? e._events[t].unshift(n) : e._events[t] = [n, e._events[t]] : e.on(t, n));
        }
        function a(t, n) {
          O = O || e("./_stream_duplex"), t = t || {};
          var o = n instanceof O;
          this.objectMode = !!t.objectMode, o && (this.objectMode = this.objectMode || !!t.readableObjectMode);
          var s = t.highWaterMark,
              i = t.readableHighWaterMark,
              d = this.objectMode ? 16 : 16384;
          this.highWaterMark = s || 0 === s ? s : o && (i || 0 === i) ? i : d, this.highWaterMark = r(this.highWaterMark), this.buffer = new z, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, t.encoding && (!G && (G = e("string_decoder/").StringDecoder), this.decoder = new G(t.encoding), this.encoding = t.encoding);
        }
        function c(t) {
          return O = O || e("./_stream_duplex"), this instanceof c ? void(this._readableState = new a(t, this), this.readable = !0, t && ("function" == typeof t.read && (this._read = t.read), "function" == typeof t.destroy && (this._destroy = t.destroy)), q.call(this)) : new c(t);
        }
        function l(e, t, n, r, o) {
          var i = e._readableState;
          if (null === t)
            i.reading = !1, g(e, i);
          else {
            var d;
            o || (d = u(i, t)), d ? e.emit("error", d) : i.objectMode || t && 0 < t.length ? ("string" != typeof t && !i.objectMode && Object.getPrototypeOf(t) !== j.prototype && (t = s(t)), r ? i.endEmitted ? e.emit("error", new Error("stream.unshift() after end event")) : p(e, i, t, !0) : i.ended ? e.emit("error", new Error("stream.push() after EOF")) : (i.reading = !1, i.decoder && !n ? (t = i.decoder.write(t), i.objectMode || 0 !== t.length ? p(e, i, t, !1) : b(e, i)) : p(e, i, t, !1))) : !r && (i.reading = !1);
          }
          return f(i);
        }
        function p(e, t, n, r) {
          t.flowing && 0 === t.length && !t.sync ? (e.emit("data", n), e.read(0)) : (t.length += t.objectMode ? 1 : n.length, r ? t.buffer.unshift(n) : t.buffer.push(n), t.needReadable && _(e)), b(e, t);
        }
        function u(e, t) {
          var n;
          return i(t) || "string" == typeof t || void 0 === t || e.objectMode || (n = new TypeError("Invalid non-string/buffer chunk")), n;
        }
        function f(e) {
          return !e.ended && (e.needReadable || e.length < e.highWaterMark || 0 === e.length);
        }
        function h(e) {
          return e >= X ? e = X : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
        }
        function m(e, t) {
          return 0 >= e || 0 === t.length && t.ended ? 0 : t.objectMode ? 1 : e === e ? (e > t.highWaterMark && (t.highWaterMark = h(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0)) : t.flowing && t.length ? t.buffer.head.data.length : t.length;
        }
        function g(e, t) {
          if (!t.ended) {
            if (t.decoder) {
              var n = t.decoder.end();
              n && n.length && (t.buffer.push(n), t.length += t.objectMode ? 1 : n.length);
            }
            t.ended = !0, _(e);
          }
        }
        function _(e) {
          var t = e._readableState;
          t.needReadable = !1, t.emittedReadable || (W("emitReadable", t.flowing), t.emittedReadable = !0, t.sync ? R(y, e) : y(e));
        }
        function y(e) {
          W("emit readable"), e.emit("readable"), C(e);
        }
        function b(e, t) {
          t.readingMore || (t.readingMore = !0, R(w, e, t));
        }
        function w(e, t) {
          for (var n = t.length; !t.reading && !t.flowing && !t.ended && t.length < t.highWaterMark && (W("maybeReadMore read 0"), e.read(0), n !== t.length); )
            n = t.length;
          t.readingMore = !1;
        }
        function k(e) {
          return function() {
            var t = e._readableState;
            W("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, 0 === t.awaitDrain && M(e, "data") && (t.flowing = !0, C(e));
          };
        }
        function x(e) {
          W("readable nexttick read 0"), e.read(0);
        }
        function v(e, t) {
          t.resumeScheduled || (t.resumeScheduled = !0, R(S, e, t));
        }
        function S(e, t) {
          t.reading || (W("resume read 0"), e.read(0)), t.resumeScheduled = !1, t.awaitDrain = 0, e.emit("resume"), C(e), t.flowing && !t.reading && e.read(0);
        }
        function C(e) {
          var t = e._readableState;
          for (W("flow", t.flowing); t.flowing && null !== e.read(); )
            ;
        }
        function E(e, t) {
          if (0 === t.length)
            return null;
          var r;
          return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (r = t.decoder ? t.buffer.join("") : 1 === t.buffer.length ? t.buffer.head.data : t.buffer.concat(t.length), t.buffer.clear()) : r = B(e, t.buffer, t.decoder), r;
        }
        function B(e, t, n) {
          var r;
          return e < t.head.data.length ? (r = t.head.data.slice(0, e), t.head.data = t.head.data.slice(e)) : e === t.head.data.length ? r = t.shift() : r = n ? I(e, t) : L(e, t), r;
        }
        function I(e, t) {
          var n = t.head,
              r = 1,
              o = n.data;
          for (e -= o.length; n = n.next; ) {
            var s = n.data,
                i = e > s.length ? s.length : e;
            if (o += i === s.length ? s : s.slice(0, e), e -= i, 0 === e) {
              i === s.length ? (++r, t.head = n.next ? n.next : t.tail = null) : (t.head = n, n.data = s.slice(i));
              break;
            }
            ++r;
          }
          return t.length -= r, o;
        }
        function L(e, t) {
          var n = j.allocUnsafe(e),
              r = t.head,
              o = 1;
          for (r.data.copy(n), e -= r.data.length; r = r.next; ) {
            var s = r.data,
                i = e > s.length ? s.length : e;
            if (s.copy(n, n.length - e, 0, i), e -= i, 0 === e) {
              i === s.length ? (++o, t.head = r.next ? r.next : t.tail = null) : (t.head = r, r.data = s.slice(i));
              break;
            }
            ++o;
          }
          return t.length -= o, n;
        }
        function T(e) {
          var t = e._readableState;
          if (0 < t.length)
            throw new Error("\"endReadable()\" called on non-empty stream");
          t.endEmitted || (t.ended = !0, R(A, t, e));
        }
        function A(e, t) {
          e.endEmitted || 0 !== e.length || (e.endEmitted = !0, t.readable = !1, t.emit("end"));
        }
        function U(e, t) {
          for (var n = 0,
              r = e.length; n < r; n++)
            if (e[n] === t)
              return n;
          return -1;
        }
        var R = e("process-nextick-args").nextTick;
        t.exports = c;
        var P = e("isarray"),
            O;
        c.ReadableState = a;
        var H = e("events").EventEmitter,
            M = function(e, t) {
              return e.listeners(t).length;
            },
            q = e("./internal/streams/stream"),
            j = e("safe-buffer").Buffer,
            F = o.Uint8Array || function() {},
            N = e("core-util-is");
        N.inherits = e("inherits");
        var D = e("util"),
            W;
        W = D && D.debuglog ? D.debuglog("stream") : function() {};
        var z = e("./internal/streams/BufferList"),
            V = e("./internal/streams/destroy"),
            G;
        N.inherits(c, q);
        var K = ["error", "close", "destroy", "pause", "resume"];
        Object.defineProperty(c.prototype, "destroyed", {
          get: function() {
            return void 0 !== this._readableState && this._readableState.destroyed;
          },
          set: function(e) {
            this._readableState && (this._readableState.destroyed = e);
          }
        }), c.prototype.destroy = V.destroy, c.prototype._undestroy = V.undestroy, c.prototype._destroy = function(e, t) {
          this.push(null), t(e);
        }, c.prototype.push = function(e, t) {
          var n = this._readableState,
              r;
          return n.objectMode ? r = !0 : "string" == typeof e && (t = t || n.defaultEncoding, t !== n.encoding && (e = j.from(e, t), t = ""), r = !0), l(this, e, t, !1, r);
        }, c.prototype.unshift = function(e) {
          return l(this, e, null, !0, !1);
        }, c.prototype.isPaused = function() {
          return !1 === this._readableState.flowing;
        }, c.prototype.setEncoding = function(t) {
          return G || (G = e("string_decoder/").StringDecoder), this._readableState.decoder = new G(t), this._readableState.encoding = t, this;
        };
        var X = 8388608;
        c.prototype.read = function(e) {
          W("read", e), e = parseInt(e, 10);
          var t = this._readableState,
              n = e;
          if (0 !== e && (t.emittedReadable = !1), 0 === e && t.needReadable && (t.length >= t.highWaterMark || t.ended))
            return W("read: emitReadable", t.length, t.ended), 0 === t.length && t.ended ? T(this) : _(this), null;
          if (e = m(e, t), 0 === e && t.ended)
            return 0 === t.length && T(this), null;
          var r = t.needReadable;
          W("need readable", r), (0 === t.length || t.length - e < t.highWaterMark) && (r = !0, W("length less than watermark", r)), t.ended || t.reading ? (r = !1, W("reading or ended", r)) : r && (W("do read"), t.reading = !0, t.sync = !0, 0 === t.length && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, !t.reading && (e = m(n, t)));
          var o;
          return o = 0 < e ? E(e, t) : null, null === o ? (t.needReadable = !0, e = 0) : t.length -= e, 0 === t.length && (!t.ended && (t.needReadable = !0), n !== e && t.ended && T(this)), null !== o && this.emit("data", o), o;
        }, c.prototype._read = function() {
          this.emit("error", new Error("_read() is not implemented"));
        }, c.prototype.pipe = function(e, t) {
          function r(e, t) {
            W("onunpipe"), e === u && t && !1 === t.hasUnpiped && (t.hasUnpiped = !0, s());
          }
          function o() {
            W("onend"), e.end();
          }
          function s() {
            W("cleanup"), e.removeListener("close", c), e.removeListener("finish", l), e.removeListener("drain", g), e.removeListener("error", a), e.removeListener("unpipe", r), u.removeListener("end", o), u.removeListener("end", p), u.removeListener("data", i), _ = !0, f.awaitDrain && (!e._writableState || e._writableState.needDrain) && g();
          }
          function i(t) {
            W("ondata"), y = !1;
            var n = e.write(t);
            !1 !== n || y || ((1 === f.pipesCount && f.pipes === e || 1 < f.pipesCount && -1 !== U(f.pipes, e)) && !_ && (W("false write response, pause", u._readableState.awaitDrain), u._readableState.awaitDrain++, y = !0), u.pause());
          }
          function a(t) {
            W("onerror", t), p(), e.removeListener("error", a), 0 === M(e, "error") && e.emit("error", t);
          }
          function c() {
            e.removeListener("finish", l), p();
          }
          function l() {
            W("onfinish"), e.removeListener("close", c), p();
          }
          function p() {
            W("unpipe"), u.unpipe(e);
          }
          var u = this,
              f = this._readableState;
          switch (f.pipesCount) {
            case 0:
              f.pipes = e;
              break;
            case 1:
              f.pipes = [f.pipes, e];
              break;
            default:
              f.pipes.push(e);
          }
          f.pipesCount += 1, W("pipe count=%d opts=%j", f.pipesCount, t);
          var h = (!t || !1 !== t.end) && e !== n.stdout && e !== n.stderr,
              m = h ? o : p;
          f.endEmitted ? R(m) : u.once("end", m), e.on("unpipe", r);
          var g = k(u);
          e.on("drain", g);
          var _ = !1,
              y = !1;
          return u.on("data", i), d(e, "error", a), e.once("close", c), e.once("finish", l), e.emit("pipe", u), f.flowing || (W("pipe resume"), u.resume()), e;
        }, c.prototype.unpipe = function(e) {
          var t = this._readableState,
              n = {hasUnpiped: !1};
          if (0 === t.pipesCount)
            return this;
          if (1 === t.pipesCount)
            return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, n), this);
          if (!e) {
            var r = t.pipes,
                o = t.pipesCount;
            t.pipes = null, t.pipesCount = 0, t.flowing = !1;
            for (var s = 0; s < o; s++)
              r[s].emit("unpipe", this, n);
            return this;
          }
          var i = U(t.pipes, e);
          return -1 === i ? this : (t.pipes.splice(i, 1), t.pipesCount -= 1, 1 === t.pipesCount && (t.pipes = t.pipes[0]), e.emit("unpipe", this, n), this);
        }, c.prototype.on = function(e, t) {
          var n = q.prototype.on.call(this, e, t);
          if ("data" === e)
            !1 !== this._readableState.flowing && this.resume();
          else if ("readable" === e) {
            var r = this._readableState;
            r.endEmitted || r.readableListening || (r.readableListening = r.needReadable = !0, r.emittedReadable = !1, r.reading ? r.length && _(this) : R(x, this));
          }
          return n;
        }, c.prototype.addListener = c.prototype.on, c.prototype.resume = function() {
          var e = this._readableState;
          return e.flowing || (W("resume"), e.flowing = !0, v(this, e)), this;
        }, c.prototype.pause = function() {
          return W("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (W("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
        }, c.prototype.wrap = function(e) {
          var t = this,
              r = this._readableState,
              o = !1;
          for (var s in e.on("end", function() {
            if (W("wrapped end"), r.decoder && !r.ended) {
              var e = r.decoder.end();
              e && e.length && t.push(e);
            }
            t.push(null);
          }), e.on("data", function(n) {
            if ((W("wrapped data"), r.decoder && (n = r.decoder.write(n)), !(r.objectMode && (null === n || void 0 === n))) && (r.objectMode || n && n.length)) {
              var s = t.push(n);
              s || (o = !0, e.pause());
            }
          }), e)
            void 0 === this[s] && "function" == typeof e[s] && (this[s] = function(t) {
              return function() {
                return e[t].apply(e, arguments);
              };
            }(s));
          for (var i = 0; i < K.length; i++)
            e.on(K[i], this.emit.bind(this, K[i]));
          return this._read = function(t) {
            W("wrapped _read", t), o && (o = !1, e.resume());
          }, this;
        }, c._fromList = E;
      }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
    }, {
      "./_stream_duplex": 76,
      "./internal/streams/BufferList": 81,
      "./internal/streams/destroy": 82,
      "./internal/streams/stream": 83,
      _process: 67,
      "core-util-is": 29,
      events: 35,
      inherits: 42,
      isarray: 47,
      "process-nextick-args": 66,
      "safe-buffer": 92,
      "string_decoder/": 106,
      util: 23
    }],
    79: [function(e, t) {
      "use strict";
      function n(e, t) {
        var n = this._transformState;
        n.transforming = !1;
        var r = n.writecb;
        if (!r)
          return this.emit("error", new Error("write callback called multiple times"));
        n.writechunk = null, n.writecb = null, null != t && this.push(t), r(e);
        var o = this._readableState;
        o.reading = !1, (o.needReadable || o.length < o.highWaterMark) && this._read(o.highWaterMark);
      }
      function r(e) {
        return this instanceof r ? void(i.call(this, e), this._transformState = {
          afterTransform: n.bind(this),
          needTransform: !1,
          transforming: !1,
          writecb: null,
          writechunk: null,
          writeencoding: null
        }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && ("function" == typeof e.transform && (this._transform = e.transform), "function" == typeof e.flush && (this._flush = e.flush)), this.on("prefinish", o)) : new r(e);
      }
      function o() {
        var e = this;
        "function" == typeof this._flush ? this._flush(function(t, n) {
          s(e, t, n);
        }) : s(this, null, null);
      }
      function s(e, t, n) {
        if (t)
          return e.emit("error", t);
        if (null != n && e.push(n), e._writableState.length)
          throw new Error("Calling transform done when ws.length != 0");
        if (e._transformState.transforming)
          throw new Error("Calling transform done when still transforming");
        return e.push(null);
      }
      t.exports = r;
      var i = e("./_stream_duplex"),
          d = e("core-util-is");
      d.inherits = e("inherits"), d.inherits(r, i), r.prototype.push = function(e, t) {
        return this._transformState.needTransform = !1, i.prototype.push.call(this, e, t);
      }, r.prototype._transform = function() {
        throw new Error("_transform() is not implemented");
      }, r.prototype._write = function(e, t, n) {
        var r = this._transformState;
        if (r.writecb = n, r.writechunk = e, r.writeencoding = t, !r.transforming) {
          var o = this._readableState;
          (r.needTransform || o.needReadable || o.length < o.highWaterMark) && this._read(o.highWaterMark);
        }
      }, r.prototype._read = function() {
        var e = this._transformState;
        null !== e.writechunk && e.writecb && !e.transforming ? (e.transforming = !0, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = !0;
      }, r.prototype._destroy = function(e, t) {
        var n = this;
        i.prototype._destroy.call(this, e, function(e) {
          t(e), n.emit("close");
        });
      };
    }, {
      "./_stream_duplex": 76,
      "core-util-is": 29,
      inherits: 42
    }],
    80: [function(e, t) {
      (function(n, o) {
        "use strict";
        function s(e) {
          var t = this;
          this.next = null, this.entry = null, this.finish = function() {
            B(t, e);
          };
        }
        function i(e) {
          return P.from(e);
        }
        function d(e) {
          return P.isBuffer(e) || e instanceof O;
        }
        function a() {}
        function c(t, n) {
          T = T || e("./_stream_duplex"), t = t || {};
          var o = n instanceof T;
          this.objectMode = !!t.objectMode, o && (this.objectMode = this.objectMode || !!t.writableObjectMode);
          var i = t.highWaterMark,
              d = t.writableHighWaterMark,
              a = this.objectMode ? 16 : 16384;
          this.highWaterMark = i || 0 === i ? i : o && (d || 0 === d) ? d : a, this.highWaterMark = r(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
          var c = !1 === t.decodeStrings;
          this.decodeStrings = !c, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(e) {
            y(n, e);
          }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new s(this);
        }
        function l(t) {
          return T = T || e("./_stream_duplex"), M.call(l, this) || this instanceof T ? void(this._writableState = new c(t, this), this.writable = !0, t && ("function" == typeof t.write && (this._write = t.write), "function" == typeof t.writev && (this._writev = t.writev), "function" == typeof t.destroy && (this._destroy = t.destroy), "function" == typeof t.final && (this._final = t.final)), R.call(this)) : new l(t);
        }
        function p(e, t) {
          var n = new Error("write after end");
          e.emit("error", n), I(t, n);
        }
        function u(e, t, n, r) {
          var o = !0,
              s = !1;
          return null === n ? s = new TypeError("May not write null values to stream") : "string" != typeof n && void 0 !== n && !t.objectMode && (s = new TypeError("Invalid non-string/buffer chunk")), s && (e.emit("error", s), I(r, s), o = !1), o;
        }
        function f(e, t, n) {
          return e.objectMode || !1 === e.decodeStrings || "string" != typeof t || (t = P.from(t, n)), t;
        }
        function h(e, t, n, r, o, s) {
          if (!n) {
            var i = f(t, r, o);
            r !== i && (n = !0, o = "buffer", r = i);
          }
          var d = t.objectMode ? 1 : r.length;
          t.length += d;
          var a = t.length < t.highWaterMark;
          if (a || (t.needDrain = !0), t.writing || t.corked) {
            var c = t.lastBufferedRequest;
            t.lastBufferedRequest = {
              chunk: r,
              encoding: o,
              isBuf: n,
              callback: s,
              next: null
            }, c ? c.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
          } else
            m(e, t, !1, d, r, o, s);
          return a;
        }
        function m(e, t, n, r, o, s, i) {
          t.writelen = r, t.writecb = i, t.writing = !0, t.sync = !0, n ? e._writev(o, t.onwrite) : e._write(o, s, t.onwrite), t.sync = !1;
        }
        function g(e, t, n, r, o) {
          --t.pendingcb, n ? (I(o, r), I(C, e, t), e._writableState.errorEmitted = !0, e.emit("error", r)) : (o(r), e._writableState.errorEmitted = !0, e.emit("error", r), C(e, t));
        }
        function _(e) {
          e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
        }
        function y(e, t) {
          var n = e._writableState,
              r = n.sync,
              o = n.writecb;
          if (_(n), t)
            g(e, n, r, t, o);
          else {
            var s = x(n);
            s || n.corked || n.bufferProcessing || !n.bufferedRequest || k(e, n), r ? L(b, e, n, s, o) : b(e, n, s, o);
          }
        }
        function b(e, t, n, r) {
          n || w(e, t), t.pendingcb--, r(), C(e, t);
        }
        function w(e, t) {
          0 === t.length && t.needDrain && (t.needDrain = !1, e.emit("drain"));
        }
        function k(e, t) {
          t.bufferProcessing = !0;
          var n = t.bufferedRequest;
          if (e._writev && n && n.next) {
            var r = t.bufferedRequestCount,
                o = Array(r),
                i = t.corkedRequestsFree;
            i.entry = n;
            for (var d = 0,
                a = !0; n; )
              o[d] = n, n.isBuf || (a = !1), n = n.next, d += 1;
            o.allBuffers = a, m(e, t, !0, t.length, o, "", i.finish), t.pendingcb++, t.lastBufferedRequest = null, i.next ? (t.corkedRequestsFree = i.next, i.next = null) : t.corkedRequestsFree = new s(t), t.bufferedRequestCount = 0;
          } else {
            for (; n; ) {
              var c = n.chunk,
                  l = n.encoding,
                  p = n.callback,
                  u = t.objectMode ? 1 : c.length;
              if (m(e, t, !1, u, c, l, p), n = n.next, t.bufferedRequestCount--, t.writing)
                break;
            }
            null === n && (t.lastBufferedRequest = null);
          }
          t.bufferedRequest = n, t.bufferProcessing = !1;
        }
        function x(e) {
          return e.ending && 0 === e.length && null === e.bufferedRequest && !e.finished && !e.writing;
        }
        function v(e, t) {
          e._final(function(n) {
            t.pendingcb--, n && e.emit("error", n), t.prefinished = !0, e.emit("prefinish"), C(e, t);
          });
        }
        function S(e, t) {
          t.prefinished || t.finalCalled || ("function" == typeof e._final ? (t.pendingcb++, t.finalCalled = !0, I(v, e, t)) : (t.prefinished = !0, e.emit("prefinish")));
        }
        function C(e, t) {
          var n = x(t);
          return n && (S(e, t), 0 === t.pendingcb && (t.finished = !0, e.emit("finish"))), n;
        }
        function E(e, t, n) {
          t.ending = !0, C(e, t), n && (t.finished ? I(n) : e.once("finish", n)), t.ended = !0, e.writable = !1;
        }
        function B(e, t, n) {
          var r = e.entry;
          for (e.entry = null; r; ) {
            var o = r.callback;
            t.pendingcb--, o(n), r = r.next;
          }
          t.corkedRequestsFree ? t.corkedRequestsFree.next = e : t.corkedRequestsFree = e;
        }
        var I = e("process-nextick-args").nextTick;
        t.exports = l;
        var L = !n.browser && -1 < ["v0.10", "v0.9."].indexOf(n.version.slice(0, 5)) ? setImmediate : I,
            T;
        l.WritableState = c;
        var A = e("core-util-is");
        A.inherits = e("inherits");
        var U = {deprecate: e("util-deprecate")},
            R = e("./internal/streams/stream"),
            P = e("safe-buffer").Buffer,
            O = o.Uint8Array || function() {},
            H = e("./internal/streams/destroy");
        A.inherits(l, R), c.prototype.getBuffer = function() {
          for (var e = this.bufferedRequest,
              t = []; e; )
            t.push(e), e = e.next;
          return t;
        }, function() {
          try {
            Object.defineProperty(c.prototype, "buffer", {get: U.deprecate(function() {
                return this.getBuffer();
              }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")});
          } catch (e) {}
        }();
        var M;
        "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (M = Function.prototype[Symbol.hasInstance], Object.defineProperty(l, Symbol.hasInstance, {value: function(e) {
            return !!M.call(this, e) || !(this !== l) && e && e._writableState instanceof c;
          }})) : M = function(e) {
          return e instanceof this;
        }, l.prototype.pipe = function() {
          this.emit("error", new Error("Cannot pipe, not readable"));
        }, l.prototype.write = function(e, t, n) {
          var r = this._writableState,
              o = !1,
              s = !r.objectMode && d(e);
          return s && !P.isBuffer(e) && (e = i(e)), "function" == typeof t && (n = t, t = null), s ? t = "buffer" : !t && (t = r.defaultEncoding), "function" != typeof n && (n = a), r.ended ? p(this, n) : (s || u(this, r, e, n)) && (r.pendingcb++, o = h(this, r, s, e, t, n)), o;
        }, l.prototype.cork = function() {
          var e = this._writableState;
          e.corked++;
        }, l.prototype.uncork = function() {
          var e = this._writableState;
          e.corked && (e.corked--, !e.writing && !e.corked && !e.finished && !e.bufferProcessing && e.bufferedRequest && k(this, e));
        }, l.prototype.setDefaultEncoding = function(e) {
          if ("string" == typeof e && (e = e.toLowerCase()), !(-1 < ["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase())))
            throw new TypeError("Unknown encoding: " + e);
          return this._writableState.defaultEncoding = e, this;
        }, l.prototype._write = function(e, t, n) {
          n(new Error("_write() is not implemented"));
        }, l.prototype._writev = null, l.prototype.end = function(e, t, n) {
          var r = this._writableState;
          "function" == typeof e ? (n = e, e = null, t = null) : "function" == typeof t && (n = t, t = null), null !== e && e !== void 0 && this.write(e, t), r.corked && (r.corked = 1, this.uncork()), r.ending || r.finished || E(this, r, n);
        }, Object.defineProperty(l.prototype, "destroyed", {
          get: function() {
            return void 0 !== this._writableState && this._writableState.destroyed;
          },
          set: function(e) {
            this._writableState && (this._writableState.destroyed = e);
          }
        }), l.prototype.destroy = H.destroy, l.prototype._undestroy = H.undestroy, l.prototype._destroy = function(e, t) {
          this.end(), t(e);
        };
      }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
    }, {
      "./_stream_duplex": 76,
      "./internal/streams/destroy": 82,
      "./internal/streams/stream": 83,
      _process: 67,
      "core-util-is": 29,
      inherits: 42,
      "process-nextick-args": 66,
      "safe-buffer": 92,
      "util-deprecate": 121
    }],
    81: [function(e, t) {
      "use strict";
      function n(e, t) {
        if (!(e instanceof t))
          throw new TypeError("Cannot call a class as a function");
      }
      function r(e, t, n) {
        e.copy(t, n);
      }
      var o = e("safe-buffer").Buffer,
          s = e("util");
      t.exports = function() {
        function e() {
          n(this, e), this.head = null, this.tail = null, this.length = 0;
        }
        return e.prototype.push = function(e) {
          var t = {
            data: e,
            next: null
          };
          0 < this.length ? this.tail.next = t : this.head = t, this.tail = t, ++this.length;
        }, e.prototype.unshift = function(e) {
          var t = {
            data: e,
            next: this.head
          };
          0 === this.length && (this.tail = t), this.head = t, ++this.length;
        }, e.prototype.shift = function() {
          if (0 !== this.length) {
            var e = this.head.data;
            return this.head = 1 === this.length ? this.tail = null : this.head.next, --this.length, e;
          }
        }, e.prototype.clear = function() {
          this.head = this.tail = null, this.length = 0;
        }, e.prototype.join = function(e) {
          if (0 === this.length)
            return "";
          for (var t = this.head,
              n = "" + t.data; t = t.next; )
            n += e + t.data;
          return n;
        }, e.prototype.concat = function(e) {
          if (0 === this.length)
            return o.alloc(0);
          if (1 === this.length)
            return this.head.data;
          for (var t = o.allocUnsafe(e >>> 0),
              n = this.head,
              s = 0; n; )
            r(n.data, t, s), s += n.data.length, n = n.next;
          return t;
        }, e;
      }(), s && s.inspect && s.inspect.custom && (t.exports.prototype[s.inspect.custom] = function() {
        var e = s.inspect({length: this.length});
        return this.constructor.name + " " + e;
      });
    }, {
      "safe-buffer": 92,
      util: 23
    }],
    82: [function(e, t) {
      "use strict";
      function n(e, t) {
        e.emit("error", t);
      }
      var r = e("process-nextick-args").nextTick;
      t.exports = {
        destroy: function(e, t) {
          var o = this,
              s = this._readableState && this._readableState.destroyed,
              i = this._writableState && this._writableState.destroyed;
          return s || i ? (t ? t(e) : e && (!this._writableState || !this._writableState.errorEmitted) && r(n, this, e), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(e) {
            !t && e ? (r(n, o, e), o._writableState && (o._writableState.errorEmitted = !0)) : t && t(e);
          }), this);
        },
        undestroy: function() {
          this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
        }
      };
    }, {"process-nextick-args": 66}],
    83: [function(e, t) {
      t.exports = e("events").EventEmitter;
    }, {events: 35}],
    84: [function(e, t, n) {
      n = t.exports = e("./lib/_stream_readable.js"), n.Stream = n, n.Readable = n, n.Writable = e("./lib/_stream_writable.js"), n.Duplex = e("./lib/_stream_duplex.js"), n.Transform = e("./lib/_stream_transform.js"), n.PassThrough = e("./lib/_stream_passthrough.js");
    }, {
      "./lib/_stream_duplex.js": 76,
      "./lib/_stream_passthrough.js": 77,
      "./lib/_stream_readable.js": 78,
      "./lib/_stream_transform.js": 79,
      "./lib/_stream_writable.js": 80
    }],
    85: [function(e, t, n) {
      function r(e, t, n, r) {
        function s() {
          S.removeEventListener("loadstart", s), n.autoplay && S.play();
        }
        function d() {
          S.removeEventListener("canplay", d), r(null, S);
        }
        function u() {
          S = t("iframe"), o(e, function(e, t) {
            return e ? w(e) : void(S.src = t, ".pdf" !== x && (S.sandbox = "allow-forms allow-scripts"), r(null, S));
          });
        }
        function w(t) {
          t.message = "Error rendering file \"" + e.name + "\": " + t.message, a(t.message), r(t);
        }
        var x = p.extname(e.name).toLowerCase(),
            v = 0,
            S;
        0 <= g.indexOf(x) ? function() {
          function r() {
            a("Use MediaSource API for " + e.name), g(), S.addEventListener("error", u), S.addEventListener("loadstart", s), S.addEventListener("canplay", d);
            var t = new l(S),
                n = t.createWriteStream(i(e.name));
            e.createReadStream().pipe(n), v && (S.currentTime = v);
          }
          function c() {
            a("Use Blob URL for " + e.name), g(), S.addEventListener("error", w), S.addEventListener("loadstart", s), S.addEventListener("canplay", d), o(e, function(e, t) {
              return e ? w(e) : void(S.src = t, v && (S.currentTime = v));
            });
          }
          function p(e) {
            a("videostream error: fallback to MediaSource API: %o", e.message || e), S.removeEventListener("error", p), S.removeEventListener("canplay", d), r();
          }
          function u(t) {
            return a("MediaSource API error: fallback to Blob URL: %o", t.message || t), "number" == typeof e.length && e.length > n.maxBlobLength ? (a("File length too large for Blob URL approach: %d (max: %d)", e.length, n.maxBlobLength), w(new Error("File length too large for Blob URL approach: " + e.length + " (max: " + n.maxBlobLength + ")"))) : void(S.removeEventListener("error", u), S.removeEventListener("canplay", d), c());
          }
          function g() {
            S || (S = t(_), S.addEventListener("progress", function() {
              v = S.currentTime;
            }));
          }
          var _ = 0 <= m.indexOf(x) ? "video" : "audio";
          k ? 0 <= h.indexOf(x) ? function() {
            a("Use `videostream` package for " + e.name), g(), S.addEventListener("error", p), S.addEventListener("loadstart", s), S.addEventListener("canplay", d), f(e, S);
          }() : r() : c();
        }() : 0 <= _.indexOf(x) ? function() {
          S = t("audio"), o(e, function(e, t) {
            return e ? w(e) : void(S.addEventListener("error", w), S.addEventListener("loadstart", s), S.addEventListener("canplay", d), S.src = t);
          });
        }() : 0 <= y.indexOf(x) ? function() {
          S = t("img"), o(e, function(t, n) {
            return t ? w(t) : void(S.src = n, S.alt = e.name, r(null, S));
          });
        }() : 0 <= b.indexOf(x) ? u() : function() {
          a("Unknown file extension \"%s\" - will attempt to render into iframe", x);
          var t = "";
          e.createReadStream({
            start: 0,
            end: 1e3
          }).setEncoding("utf8").on("data", function(e) {
            t += e;
          }).on("end", function() {
            c(t) ? (a("File extension \"%s\" appears ascii, so will render.", x), u()) : (a("File extension \"%s\" appears non-ascii, will not render.", x), r(new Error("Unsupported file type \"" + x + "\": Cannot append to DOM")));
          }).on("error", r);
        }();
      }
      function o(e, t) {
        var r = p.extname(e.name).toLowerCase();
        u(e.createReadStream(), n.mime[r], t);
      }
      function s(e) {
        if (null == e)
          throw new Error("file cannot be null or undefined");
        if ("string" != typeof e.name)
          throw new Error("missing or invalid file.name property");
        if ("function" != typeof e.createReadStream)
          throw new Error("missing or invalid file.createReadStream property");
      }
      function i(e) {
        var t = p.extname(e).toLowerCase();
        return {
          ".m4a": "audio/mp4; codecs=\"mp4a.40.5\"",
          ".m4v": "video/mp4; codecs=\"avc1.640029, mp4a.40.5\"",
          ".mkv": "video/webm; codecs=\"avc1.640029, mp4a.40.5\"",
          ".mp3": "audio/mpeg",
          ".mp4": "video/mp4; codecs=\"avc1.640029, mp4a.40.5\"",
          ".webm": "video/webm; codecs=\"vorbis, vp8\""
        }[t];
      }
      function d(e) {
        null == e.autoplay && (e.autoplay = !0), null == e.controls && (e.controls = !0), null == e.maxBlobLength && (e.maxBlobLength = w);
      }
      n.render = function(e, t, n, o) {
        "function" == typeof n && (o = n, n = {}), n || (n = {}), o || (o = function() {}), s(e), d(n), "string" == typeof t && (t = document.querySelector(t)), r(e, function(n) {
          if (t.nodeName !== n.toUpperCase()) {
            var r = p.extname(e.name).toLowerCase();
            throw new Error("Cannot render \"" + r + "\" inside a \"" + t.nodeName.toLowerCase() + "\" element, expected \"" + n + "\"");
          }
          return t;
        }, n, o);
      }, n.append = function(e, t, n, o) {
        function i(e) {
          var r = a(e);
          return n.controls && (r.controls = !0), n.autoplay && (r.autoplay = !0), t.appendChild(r), r;
        }
        function a(e) {
          var n = document.createElement(e);
          return t.appendChild(n), n;
        }
        if ("function" == typeof n && (o = n, n = {}), n || (n = {}), o || (o = function() {}), s(e), d(n), "string" == typeof t && (t = document.querySelector(t)), t && ("VIDEO" === t.nodeName || "AUDIO" === t.nodeName))
          throw new Error("Invalid video/audio node argument. Argument must be root element that video/audio tag will be appended to.");
        r(e, function(e) {
          return "video" === e || "audio" === e ? i(e) : a(e);
        }, n, function(e, t) {
          e && t && t.remove(), o(e, t);
        });
      }, n.mime = e("./lib/mime.json");
      var a = e("debug")("render-media"),
          c = e("is-ascii"),
          l = e("mediasource"),
          p = e("path"),
          u = e("stream-to-blob-url"),
          f = e("videostream"),
          h = [".m4a", ".m4v", ".mp4"],
          m = [".m4v", ".mkv", ".mp4", ".webm"],
          g = [].concat(m, [".m4a", ".mp3"]),
          _ = [".aac", ".oga", ".ogg", ".wav"],
          y = [".bmp", ".gif", ".jpeg", ".jpg", ".png", ".svg"],
          b = [".css", ".html", ".js", ".md", ".pdf", ".txt"],
          w = 200000000,
          k = "undefined" != typeof window && window.MediaSource;
    }, {
      "./lib/mime.json": 86,
      debug: 87,
      "is-ascii": 43,
      mediasource: 50,
      path: 64,
      "stream-to-blob-url": 103,
      videostream: 124
    }],
    86: [function(e, t) {
      t.exports = {
        ".3gp": "video/3gpp",
        ".aac": "audio/aac",
        ".aif": "audio/x-aiff",
        ".aiff": "audio/x-aiff",
        ".atom": "application/atom+xml",
        ".avi": "video/x-msvideo",
        ".bmp": "image/bmp",
        ".bz2": "application/x-bzip2",
        ".conf": "text/plain",
        ".css": "text/css",
        ".csv": "text/plain",
        ".diff": "text/x-diff",
        ".doc": "application/msword",
        ".flv": "video/x-flv",
        ".gif": "image/gif",
        ".gz": "application/x-gzip",
        ".htm": "text/html",
        ".html": "text/html",
        ".ico": "image/vnd.microsoft.icon",
        ".ics": "text/calendar",
        ".iso": "application/octet-stream",
        ".jar": "application/java-archive",
        ".jpeg": "image/jpeg",
        ".jpg": "image/jpeg",
        ".js": "application/javascript",
        ".json": "application/json",
        ".less": "text/css",
        ".log": "text/plain",
        ".m3u": "audio/x-mpegurl",
        ".m4a": "audio/mp4",
        ".m4v": "video/mp4",
        ".manifest": "text/cache-manifest",
        ".markdown": "text/x-markdown",
        ".mathml": "application/mathml+xml",
        ".md": "text/x-markdown",
        ".mid": "audio/midi",
        ".midi": "audio/midi",
        ".mov": "video/quicktime",
        ".mp3": "audio/mpeg",
        ".mp4": "video/mp4",
        ".mp4v": "video/mp4",
        ".mpeg": "video/mpeg",
        ".mpg": "video/mpeg",
        ".odp": "application/vnd.oasis.opendocument.presentation",
        ".ods": "application/vnd.oasis.opendocument.spreadsheet",
        ".odt": "application/vnd.oasis.opendocument.text",
        ".oga": "audio/ogg",
        ".ogg": "application/ogg",
        ".pdf": "application/pdf",
        ".png": "image/png",
        ".pps": "application/vnd.ms-powerpoint",
        ".ppt": "application/vnd.ms-powerpoint",
        ".ps": "application/postscript",
        ".psd": "image/vnd.adobe.photoshop",
        ".qt": "video/quicktime",
        ".rar": "application/x-rar-compressed",
        ".rdf": "application/rdf+xml",
        ".rss": "application/rss+xml",
        ".rtf": "application/rtf",
        ".svg": "image/svg+xml",
        ".svgz": "image/svg+xml",
        ".swf": "application/x-shockwave-flash",
        ".tar": "application/x-tar",
        ".tbz": "application/x-bzip-compressed-tar",
        ".text": "text/plain",
        ".tif": "image/tiff",
        ".tiff": "image/tiff",
        ".torrent": "application/x-bittorrent",
        ".ttf": "application/x-font-ttf",
        ".txt": "text/plain",
        ".wav": "audio/wav",
        ".webm": "video/webm",
        ".wma": "audio/x-ms-wma",
        ".wmv": "video/x-ms-wmv",
        ".xls": "application/vnd.ms-excel",
        ".xml": "application/xml",
        ".yaml": "text/yaml",
        ".yml": "text/yaml",
        ".zip": "application/zip"
      };
    }, {}],
    87: [function(e, t, n) {
      arguments[4][15][0].apply(n, arguments);
    }, {
      "./debug": 88,
      _process: 67,
      dup: 15
    }],
    88: [function(e, t, n) {
      arguments[4][16][0].apply(n, arguments);
    }, {
      dup: 16,
      ms: 58
    }],
    89: [function(e, t) {
      (function(e) {
        t.exports = function(t, n, r) {
          function o(t) {
            function n() {
              r && r(t, d), r = null;
            }
            i ? e.nextTick(n) : n();
          }
          function s(e, n, r) {
            if (d[e] = r, n && (p = !0), 0 == --c || n)
              o(n);
            else if (!p && u < a) {
              var i;
              l ? (i = l[u], u += 1, t[i](function(e, t) {
                s(i, e, t);
              })) : (i = u, u += 1, t[i](function(e, t) {
                s(i, e, t);
              }));
            }
          }
          if ("number" != typeof n)
            throw new Error("second argument must be a Number");
          var i = !0,
              d,
              a,
              c,
              l,
              p;
          Array.isArray(t) ? (d = [], c = a = t.length) : (l = Object.keys(t), d = {}, c = a = l.length);
          var u = n;
          c ? l ? l.some(function(e, r) {
            if (t[e](function(t, n) {
              s(e, t, n);
            }), r === n - 1)
              return !0;
          }) : t.some(function(e, t) {
            if (e(function(e, n) {
              s(t, e, n);
            }), t === n - 1)
              return !0;
          }) : o(null), i = !1;
        };
      }).call(this, e("_process"));
    }, {_process: 67}],
    90: [function(e, t) {
      (function(e) {
        t.exports = function(t, n) {
          function r(t) {
            function r() {
              n && n(t, d), n = null;
            }
            s ? e.nextTick(r) : r();
          }
          function o(e, t, n) {
            d[e] = n, (0 == --a || t) && r(t);
          }
          var s = !0,
              d,
              a,
              i;
          Array.isArray(t) ? (d = [], a = t.length) : (i = Object.keys(t), d = {}, a = i.length), a ? i ? i.forEach(function(e) {
            t[e](function(t, n) {
              o(e, t, n);
            });
          }) : t.forEach(function(e, t) {
            e(function(e, n) {
              o(t, e, n);
            });
          }) : r(null), s = !1;
        };
      }).call(this, e("_process"));
    }, {_process: 67}],
    91: [function(e, t, n) {
      (function(o) {
        (function(e) {
          if ("object" == typeof n && "undefined" != typeof t)
            t.exports = e();
          else if ("function" == typeof i && i.amd)
            i([], e);
          else {
            var r;
            r = "undefined" == typeof window ? "undefined" == typeof o ? "undefined" == typeof self ? this : self : o : window, r.Rusha = e();
          }
        })(function() {
          return function d(c, t, n) {
            function r(i, o) {
              if (!t[i]) {
                if (!c[i]) {
                  var p = "function" == typeof e && e;
                  if (!o && p)
                    return p(i, !0);
                  if (s)
                    return s(i, !0);
                  var a = new Error("Cannot find module '" + i + "'");
                  throw a.code = "MODULE_NOT_FOUND", a;
                }
                var f = t[i] = {exports: {}};
                c[i][0].call(f.exports, function(t) {
                  var e = c[i][1][t];
                  return r(e ? e : t);
                }, f, f.exports, d, c, t, n);
              }
              return t[i].exports;
            }
            for (var s = "function" == typeof e && e,
                i = 0; i < n.length; i++)
              r(n[i]);
            return r;
          }({
            1: [function(e, t) {
              var n = arguments[3],
                  o = arguments[4],
                  s = arguments[5],
                  d = JSON.stringify;
              t.exports = function(e, t) {
                function a(e) {
                  for (var t in _[e] = !0, o[e][1]) {
                    var n = o[e][1][t];
                    _[n] || a(n);
                  }
                }
                for (var c = Object.keys(s),
                    p = 0,
                    i = c.length,
                    l; p < i; p++) {
                  var u = c[p],
                      f = s[u].exports;
                  if (f === e || f && f.default === e) {
                    l = u;
                    break;
                  }
                }
                if (!l) {
                  l = r(4294967296 * Math.random()).toString(16);
                  for (var h = {},
                      p = 0,
                      i = c.length,
                      u; p < i; p++)
                    u = c[p], h[u] = u;
                  o[l] = ["function(require,module,exports){" + e + "(self); }", h];
                }
                var m = r(4294967296 * Math.random()).toString(16),
                    g = {};
                g[l] = l, o[m] = ["function(require,module,exports){var f = require(" + d(l) + ");(f.default ? f.default : f)(self);}", g];
                var _ = {};
                a(m);
                var y = "(" + n + ")({" + Object.keys(_).map(function(e) {
                  return d(e) + ":[" + o[e][0] + "," + d(o[e][1]) + "]";
                }).join(",") + "},{},[" + d(m) + "])",
                    b = window.URL || window.webkitURL || window.mozURL || window.msURL,
                    w = new Blob([y], {type: "text/javascript"});
                if (t && t.bare)
                  return w;
                var k = b.createObjectURL(w),
                    x = new Worker(k);
                return x.objectURL = k, x;
              };
            }, {}],
            2: [function(e, t) {
              (function(e) {
                "use strict";
                var n;
                "undefined" != typeof self && "undefined" != typeof self.FileReaderSync && (n = new self.FileReaderSync);
                var r = function(e, t, n, r, o, s) {
                  var d = s % 4,
                      a = (o + d) % 4,
                      c = o - a,
                      l;
                  switch (d) {
                    case 0:
                      t[s] = e.charCodeAt(r + 3);
                    case 1:
                      t[0 | s + 1 - (d << 1)] = e.charCodeAt(r + 2);
                    case 2:
                      t[0 | s + 2 - (d << 1)] = e.charCodeAt(r + 1);
                    case 3:
                      t[0 | s + 3 - (d << 1)] = e.charCodeAt(r);
                  }
                  if (!(o < a + (4 - d))) {
                    for (l = 4 - d; l < c; l = 0 | l + 4)
                      n[s + l >> 2] = e.charCodeAt(r + l) << 24 | e.charCodeAt(r + l + 1) << 16 | e.charCodeAt(r + l + 2) << 8 | e.charCodeAt(r + l + 3);
                    switch (a) {
                      case 3:
                        t[0 | s + c + 1] = e.charCodeAt(r + c + 2);
                      case 2:
                        t[0 | s + c + 2] = e.charCodeAt(r + c + 1);
                      case 1:
                        t[0 | s + c + 3] = e.charCodeAt(r + c);
                    }
                  }
                },
                    o = function(e, t, n, r, o, s) {
                      var d = s % 4,
                          a = (o + d) % 4,
                          c = o - a,
                          l;
                      switch (d) {
                        case 0:
                          t[s] = e[r + 3];
                        case 1:
                          t[0 | s + 1 - (d << 1)] = e[r + 2];
                        case 2:
                          t[0 | s + 2 - (d << 1)] = e[r + 1];
                        case 3:
                          t[0 | s + 3 - (d << 1)] = e[r];
                      }
                      if (!(o < a + (4 - d))) {
                        for (l = 4 - d; l < c; l = 0 | l + 4)
                          n[0 | s + l >> 2] = e[r + l] << 24 | e[r + l + 1] << 16 | e[r + l + 2] << 8 | e[r + l + 3];
                        switch (a) {
                          case 3:
                            t[0 | s + c + 1] = e[r + c + 2];
                          case 2:
                            t[0 | s + c + 2] = e[r + c + 1];
                          case 1:
                            t[0 | s + c + 3] = e[r + c];
                        }
                      }
                    },
                    s = function(e, t, r, o, s, d) {
                      var a = d % 4,
                          c = (s + a) % 4,
                          l = s - c,
                          p = new Uint8Array(n.readAsArrayBuffer(e.slice(o, o + s))),
                          u;
                      switch (a) {
                        case 0:
                          t[d] = p[3];
                        case 1:
                          t[0 | d + 1 - (a << 1)] = p[2];
                        case 2:
                          t[0 | d + 2 - (a << 1)] = p[1];
                        case 3:
                          t[0 | d + 3 - (a << 1)] = p[0];
                      }
                      if (!(s < c + (4 - a))) {
                        for (u = 4 - a; u < l; u = 0 | u + 4)
                          r[0 | d + u >> 2] = p[u] << 24 | p[u + 1] << 16 | p[u + 2] << 8 | p[u + 3];
                        switch (c) {
                          case 3:
                            t[0 | d + l + 1] = p[l + 2];
                          case 2:
                            t[0 | d + l + 2] = p[l + 1];
                          case 1:
                            t[0 | d + l + 3] = p[l];
                        }
                      }
                    };
                t.exports = function(t, n, i, d, a, c) {
                  if ("string" == typeof t)
                    return r(t, n, i, d, a, c);
                  if (t instanceof Array)
                    return o(t, n, i, d, a, c);
                  if (e.Buffer && e.Buffer.isBuffer(t))
                    return o(t, n, i, d, a, c);
                  if (t instanceof ArrayBuffer)
                    return o(new Uint8Array(t), n, i, d, a, c);
                  if (t.buffer instanceof ArrayBuffer)
                    return o(new Uint8Array(t.buffer, t.byteOffset, t.byteLength), n, i, d, a, c);
                  if (t instanceof Blob)
                    return s(t, n, i, d, a, c);
                  throw new Error("Unsupported data type.");
                };
              }).call(this, "undefined" == typeof o ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : o);
            }, {}],
            3: [function(e, t) {
              "use strict";
              t.exports = function(e, t, n) {
                "use asm";
                var r = new e.Int32Array(n);
                return {hash: function(e, t) {
                    e |= 0, t |= 0;
                    var n = 0,
                        o = 0,
                        s = 0,
                        i = 0,
                        d = 0,
                        a = 0,
                        c = 0,
                        l = 0,
                        p = 0,
                        u = 0,
                        f = 0,
                        h = 0,
                        m = 0,
                        g = 0;
                    for (s = 0 | r[t + 320 >> 2], d = 0 | r[t + 324 >> 2], c = 0 | r[t + 328 >> 2], p = 0 | r[t + 332 >> 2], f = 0 | r[t + 336 >> 2], n = 0; (0 | n) < (0 | e); n = 0 | n + 64) {
                      for (i = s, a = d, l = c, u = p, h = f, o = 0; 64 > (0 | o); o = 0 | o + 4)
                        g = 0 | r[n + o >> 2], m = 0 | (0 | (s << 5 | s >>> 27) + (d & c | ~d & p)) + (0 | (0 | g + f) + 1518500249), f = p, p = c, c = d << 30 | d >>> 2, d = s, s = m, r[e + o >> 2] = g;
                      for (o = 0 | e + 64; (0 | o) < (0 | e + 80); o = 0 | o + 4)
                        g = (r[o - 12 >> 2] ^ r[o - 32 >> 2] ^ r[o - 56 >> 2] ^ r[o - 64 >> 2]) << 1 | (r[o - 12 >> 2] ^ r[o - 32 >> 2] ^ r[o - 56 >> 2] ^ r[o - 64 >> 2]) >>> 31, m = 0 | (0 | (s << 5 | s >>> 27) + (d & c | ~d & p)) + (0 | (0 | g + f) + 1518500249), f = p, p = c, c = d << 30 | d >>> 2, d = s, s = m, r[o >> 2] = g;
                      for (o = 0 | e + 80; (0 | o) < (0 | e + 160); o = 0 | o + 4)
                        g = (r[o - 12 >> 2] ^ r[o - 32 >> 2] ^ r[o - 56 >> 2] ^ r[o - 64 >> 2]) << 1 | (r[o - 12 >> 2] ^ r[o - 32 >> 2] ^ r[o - 56 >> 2] ^ r[o - 64 >> 2]) >>> 31, m = 0 | (0 | (s << 5 | s >>> 27) + (d ^ c ^ p)) + (0 | (0 | g + f) + 1859775393), f = p, p = c, c = d << 30 | d >>> 2, d = s, s = m, r[o >> 2] = g;
                      for (o = 0 | e + 160; (0 | o) < (0 | e + 240); o = 0 | o + 4)
                        g = (r[o - 12 >> 2] ^ r[o - 32 >> 2] ^ r[o - 56 >> 2] ^ r[o - 64 >> 2]) << 1 | (r[o - 12 >> 2] ^ r[o - 32 >> 2] ^ r[o - 56 >> 2] ^ r[o - 64 >> 2]) >>> 31, m = 0 | (0 | (s << 5 | s >>> 27) + (d & c | d & p | c & p)) + (0 | (0 | g + f) - 1894007588), f = p, p = c, c = d << 30 | d >>> 2, d = s, s = m, r[o >> 2] = g;
                      for (o = 0 | e + 240; (0 | o) < (0 | e + 320); o = 0 | o + 4)
                        g = (r[o - 12 >> 2] ^ r[o - 32 >> 2] ^ r[o - 56 >> 2] ^ r[o - 64 >> 2]) << 1 | (r[o - 12 >> 2] ^ r[o - 32 >> 2] ^ r[o - 56 >> 2] ^ r[o - 64 >> 2]) >>> 31, m = 0 | (0 | (s << 5 | s >>> 27) + (d ^ c ^ p)) + (0 | (0 | g + f) - 899497514), f = p, p = c, c = d << 30 | d >>> 2, d = s, s = m, r[o >> 2] = g;
                      s = 0 | s + i, d = 0 | d + a, c = 0 | c + l, p = 0 | p + u, f = 0 | f + h;
                    }
                    r[t + 320 >> 2] = s, r[t + 324 >> 2] = d, r[t + 328 >> 2] = c, r[t + 332 >> 2] = p, r[t + 336 >> 2] = f;
                  }};
              };
            }, {}],
            4: [function(e, t) {
              "use strict";
              function n(e, t) {
                if (!(e instanceof t))
                  throw new TypeError("Cannot call a class as a function");
              }
              var r = e("./rusha"),
                  o = e("./utils"),
                  s = o.toHex,
                  i = function() {
                    function e() {
                      n(this, e), this._rusha = new r, this._rusha.resetState();
                    }
                    return e.prototype.update = function(e) {
                      return this._rusha.append(e), this;
                    }, e.prototype.digest = function(e) {
                      var t = this._rusha.rawEnd().buffer;
                      if (!e)
                        return t;
                      if ("hex" === e)
                        return s(t);
                      throw new Error("unsupported digest encoding");
                    }, e;
                  }();
              t.exports = function() {
                return new i;
              };
            }, {
              "./rusha": 6,
              "./utils": 7
            }],
            5: [function(e, t) {
              "use strict";
              var n = e("webworkify"),
                  r = e("./rusha"),
                  o = e("./hash"),
                  s = e("./worker"),
                  i = e("./utils"),
                  d = i.isDedicatedWorkerScope,
                  a = "undefined" != typeof self && d(self);
              r.disableWorkerBehaviour = a ? s() : function() {}, r.createWorker = function() {
                var t = n(e("./worker")),
                    r = t.terminate;
                return t.terminate = function() {
                  URL.revokeObjectURL(t.objectURL), r.call(t);
                }, t;
              }, r.createHash = o, t.exports = r;
            }, {
              "./hash": 4,
              "./rusha": 6,
              "./utils": 7,
              "./worker": 8,
              webworkify: 1
            }],
            6: [function(e, t) {
              "use strict";
              function n(e, t) {
                if (!(e instanceof t))
                  throw new TypeError("Cannot call a class as a function");
              }
              var r = e("./core.sjs"),
                  o = e("./utils"),
                  s = o.toHex,
                  i = o.ceilHeapSize,
                  a = e("./conv"),
                  c = function(e) {
                    for (e += 9; 0 < e % 64; e += 1)
                      ;
                    return e;
                  },
                  l = function(e, t) {
                    var n = new Uint8Array(e.buffer),
                        r = t % 4,
                        o = t - r;
                    switch (r) {
                      case 0:
                        n[o + 3] = 0;
                      case 1:
                        n[o + 2] = 0;
                      case 2:
                        n[o + 1] = 0;
                      case 3:
                        n[o + 0] = 0;
                    }
                    for (var s = (t >> 2) + 1; s < e.length; s++)
                      e[s] = 0;
                  },
                  p = function(e, t, n) {
                    e[t >> 2] |= 128 << 24 - (t % 4 << 3), e[(-16 & (t >> 2) + 2) + 14] = 0 | n / 536870912, e[(-16 & (t >> 2) + 2) + 15] = n << 3;
                  },
                  u = function(e, t) {
                    var n = new Int32Array(e, t + 320, 5),
                        r = new Int32Array(5),
                        o = new DataView(r.buffer);
                    return o.setInt32(0, n[0], !1), o.setInt32(4, n[1], !1), o.setInt32(8, n[2], !1), o.setInt32(12, n[3], !1), o.setInt32(16, n[4], !1), r;
                  },
                  f = function() {
                    function e(t) {
                      if (n(this, e), t = t || 65536, 0 < t % 64)
                        throw new Error("Chunk size must be a multiple of 128 bit");
                      this._offset = 0, this._maxChunkLen = t, this._padMaxChunkLen = c(t), this._heap = new ArrayBuffer(i(this._padMaxChunkLen + 320 + 20)), this._h32 = new Int32Array(this._heap), this._h8 = new Int8Array(this._heap), this._core = new r({Int32Array: Int32Array}, {}, this._heap);
                    }
                    return e.prototype._initState = function(e, t) {
                      this._offset = 0;
                      var n = new Int32Array(e, t + 320, 5);
                      n[0] = 1732584193, n[1] = -271733879, n[2] = -1732584194, n[3] = 271733878, n[4] = -1009589776;
                    }, e.prototype._padChunk = function(e, t) {
                      var n = c(e),
                          r = new Int32Array(this._heap, 0, n >> 2);
                      return l(r, e), p(r, e, t), n;
                    }, e.prototype._write = function(e, t, n, r) {
                      a(e, this._h8, this._h32, t, n, r || 0);
                    }, e.prototype._coreCall = function(e, t, n, r, o) {
                      var s = n;
                      this._write(e, t, n), o && (s = this._padChunk(n, r)), this._core.hash(s, this._padMaxChunkLen);
                    }, e.prototype.rawDigest = function(e) {
                      var t = e.byteLength || e.length || e.size || 0;
                      this._initState(this._heap, this._padMaxChunkLen);
                      var n = 0,
                          r = this._maxChunkLen;
                      for (n = 0; t > n + r; n += r)
                        this._coreCall(e, n, r, t, !1);
                      return this._coreCall(e, n, t - n, t, !0), u(this._heap, this._padMaxChunkLen);
                    }, e.prototype.digest = function(e) {
                      return s(this.rawDigest(e).buffer);
                    }, e.prototype.digestFromString = function(e) {
                      return this.digest(e);
                    }, e.prototype.digestFromBuffer = function(e) {
                      return this.digest(e);
                    }, e.prototype.digestFromArrayBuffer = function(e) {
                      return this.digest(e);
                    }, e.prototype.resetState = function() {
                      return this._initState(this._heap, this._padMaxChunkLen), this;
                    }, e.prototype.append = function(e) {
                      var t = 0,
                          n = e.byteLength || e.length || e.size || 0,
                          r = this._offset % this._maxChunkLen,
                          o;
                      for (this._offset += n; t < n; )
                        o = d(n - t, this._maxChunkLen - r), this._write(e, t, o, r), r += o, t += o, r === this._maxChunkLen && (this._core.hash(this._maxChunkLen, this._padMaxChunkLen), r = 0);
                      return this;
                    }, e.prototype.getState = function() {
                      var e = this._offset % this._maxChunkLen,
                          t;
                      if (!e) {
                        var n = new Int32Array(this._heap, this._padMaxChunkLen + 320, 5);
                        t = n.buffer.slice(n.byteOffset, n.byteOffset + n.byteLength);
                      } else
                        t = this._heap.slice(0);
                      return {
                        offset: this._offset,
                        heap: t
                      };
                    }, e.prototype.setState = function(e) {
                      if (this._offset = e.offset, 20 === e.heap.byteLength) {
                        var t = new Int32Array(this._heap, this._padMaxChunkLen + 320, 5);
                        t.set(new Int32Array(e.heap));
                      } else
                        this._h32.set(new Int32Array(e.heap));
                      return this;
                    }, e.prototype.rawEnd = function() {
                      var e = this._offset,
                          t = e % this._maxChunkLen,
                          n = this._padChunk(t, e);
                      this._core.hash(n, this._padMaxChunkLen);
                      var r = u(this._heap, this._padMaxChunkLen);
                      return this._initState(this._heap, this._padMaxChunkLen), r;
                    }, e.prototype.end = function() {
                      return s(this.rawEnd().buffer);
                    }, e;
                  }();
              t.exports = f, t.exports._core = r;
            }, {
              "./conv": 2,
              "./core.sjs": 3,
              "./utils": 7
            }],
            7: [function(e, t) {
              "use strict";
              for (var n = Array(256),
                  r = 0; 256 > r; r++)
                n[r] = (16 > r ? "0" : "") + r.toString(16);
              t.exports.toHex = function(e) {
                for (var t = new Uint8Array(e),
                    r = Array(e.byteLength),
                    o = 0; o < r.length; o++)
                  r[o] = n[t[o]];
                return r.join("");
              }, t.exports.ceilHeapSize = function(e) {
                var t = 0;
                if (65536 >= e)
                  return 65536;
                if (16777216 > e)
                  for (t = 1; t < e; t <<= 1)
                    ;
                else
                  for (t = 16777216; t < e; t += 16777216)
                    ;
                return t;
              }, t.exports.isDedicatedWorkerScope = function(e) {
                var t = "WorkerGlobalScope" in e && e instanceof e.WorkerGlobalScope,
                    n = "SharedWorkerGlobalScope" in e && e instanceof e.SharedWorkerGlobalScope,
                    r = "ServiceWorkerGlobalScope" in e && e instanceof e.ServiceWorkerGlobalScope;
                return t && !n && !r;
              };
            }, {}],
            8: [function(e, t) {
              "use strict";
              t.exports = function() {
                var t = e("./rusha"),
                    n = function(e, t, n) {
                      try {
                        return n(null, e.digest(t));
                      } catch (t) {
                        return n(t);
                      }
                    },
                    r = function(e, t, n, o, s) {
                      var i = new self.FileReader;
                      i.onloadend = function() {
                        if (i.error)
                          return s(i.error);
                        var d = i.result;
                        t += i.result.byteLength;
                        try {
                          e.append(d);
                        } catch (t) {
                          return void s(t);
                        }
                        t < o.size ? r(e, t, n, o, s) : s(null, e.end());
                      }, i.readAsArrayBuffer(o.slice(t, t + n));
                    },
                    o = !0;
                return self.onmessage = function(e) {
                  if (o) {
                    var s = e.data.data,
                        i = e.data.file,
                        d = e.data.id;
                    if ("undefined" != typeof d && (i || s)) {
                      var a = e.data.blockSize || 4194304,
                          c = new t(a);
                      c.resetState();
                      var l = function(e, t) {
                        e ? self.postMessage({
                          id: d,
                          error: e.name
                        }) : self.postMessage({
                          id: d,
                          hash: t
                        });
                      };
                      s && n(c, s, l), i && r(c, 0, a, i, l);
                    }
                  }
                }, function() {
                  o = !1;
                };
              };
            }, {"./rusha": 6}]
          }, {}, [5])(5);
        });
      }).call(this, "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
    }, {}],
    92: [function(e, t, n) {
      function r(e, t) {
        for (var n in e)
          t[n] = e[n];
      }
      function o(e, t, n) {
        return i(e, t, n);
      }
      var s = e("buffer"),
          i = s.Buffer;
      i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? t.exports = s : (r(s, n), n.Buffer = o), r(i, o), o.from = function(e, t, n) {
        if ("number" == typeof e)
          throw new TypeError("Argument must not be a number");
        return i(e, t, n);
      }, o.alloc = function(e, t, n) {
        if ("number" != typeof e)
          throw new TypeError("Argument must be a number");
        var r = i(e);
        return void 0 === t ? r.fill(0) : "string" == typeof n ? r.fill(t, n) : r.fill(t), r;
      }, o.allocUnsafe = function(e) {
        if ("number" != typeof e)
          throw new TypeError("Argument must be a number");
        return i(e);
      }, o.allocUnsafeSlow = function(e) {
        if ("number" != typeof e)
          throw new TypeError("Argument must be a number");
        return s.SlowBuffer(e);
      };
    }, {buffer: 25}],
    93: [function(e, t) {
      (function(e) {
        t.exports = function(t, n) {
          var r = [];
          t.on("data", function(e) {
            r.push(e);
          }), t.once("end", function() {
            n && n(null, e.concat(r)), n = null;
          }), t.once("error", function(e) {
            n && n(e), n = null;
          });
        };
      }).call(this, e("buffer").Buffer);
    }, {buffer: 25}],
    94: [function(e, t) {
      (function(n) {
        function r(e, t) {
          e = "string" == typeof e ? {url: e} : Object.assign({}, e), e.headers = Object.assign({}, e.headers), t = c(t), e.url && o(e), null == e.maxRedirects && (e.maxRedirects = 10);
          var i;
          e.form && (i = "string" == typeof e.form ? e.form : l.stringify(e.form)), e.body && (i = e.json && !s(e.body) ? JSON.stringify(e.body) : e.body), e.json && (e.headers.accept = "application/json"), e.json && i && (e.headers["content-type"] = "application/json"), e.form && (e.headers["content-type"] = "application/x-www-form-urlencoded"), i && !s(i) && (e.headers["content-length"] = n.byteLength(i)), delete e.body, delete e.form, i && !e.method && (e.method = "POST"), e.method && (e.method = e.method.toUpperCase());
          var u = Object.keys(e.headers).some(function(e) {
            return "accept-encoding" === e.toLowerCase();
          });
          u || (e.headers["accept-encoding"] = "gzip, deflate");
          var f = "https:" === e.protocol ? a : d,
              h = f.request(e, function(n) {
                if (300 <= n.statusCode && 400 > n.statusCode && "location" in n.headers)
                  return e.url = n.headers.location, n.resume(), void(0 < e.maxRedirects ? (e.maxRedirects -= 1, r(e, t)) : t(new Error("too many redirects")));
                var o = "function" == typeof p && "HEAD" !== e.method;
                t(null, o ? p(n) : n);
              });
          return h.on("timeout", function() {
            h.abort(), t(new Error("Request timed out"));
          }), h.on("error", t), i && s(i) ? i.on("error", t).pipe(h) : h.end(i), h;
        }
        function o(e) {
          var t = u.parse(e.url);
          t.hostname && (e.hostname = t.hostname), t.port && (e.port = t.port), t.protocol && (e.protocol = t.protocol), t.auth && (e.auth = t.auth), e.path = t.path, delete e.url;
        }
        function s(e) {
          return "function" == typeof e.pipe;
        }
        t.exports = r;
        var i = e("simple-concat"),
            d = e("http"),
            a = e("https"),
            c = e("once"),
            l = e("querystring"),
            p = e("decompress-response"),
            u = e("url");
        r.concat = function(e, t) {
          return r(e, function(n, r) {
            return n ? t(n) : void i(r, function(n, o) {
              if (n)
                return t(n);
              if (e.json)
                try {
                  o = JSON.parse(o.toString());
                } catch (e) {
                  return t(e, r, o);
                }
              t(null, r, o);
            });
          });
        }, ["get", "post", "put", "patch", "head", "delete"].forEach(function(e) {
          r[e] = function(t, n) {
            return "string" == typeof t && (t = {url: t}), t.method = e.toUpperCase(), r(t, n);
          };
        });
      }).call(this, e("buffer").Buffer);
    }, {
      buffer: 25,
      "decompress-response": 23,
      http: 99,
      https: 39,
      once: 61,
      querystring: 72,
      "simple-concat": 93,
      url: 116
    }],
    95: [function(e, t) {
      (function(n) {
        function r(e) {
          var t = this;
          if (!(t instanceof r))
            return new r(e);
          if (t._id = a(4).toString("hex").slice(0, 7), t._debug("new peer %o", e), e = Object.assign({allowHalfOpen: !1}, e), c.Duplex.call(t, e), t.channelName = e.initiator ? e.channelName || a(20).toString("hex") : null, t._isChromium = "undefined" != typeof window && !!window.webkitRTCPeerConnection, t.initiator = e.initiator || !1, t.channelConfig = e.channelConfig || r.channelConfig, t.config = e.config || r.config, t.constraints = t._transformConstraints(e.constraints || r.constraints), t.offerConstraints = t._transformConstraints(e.offerConstraints || {}), t.answerConstraints = t._transformConstraints(e.answerConstraints || {}), t.reconnectTimer = e.reconnectTimer || !1, t.sdpTransform = e.sdpTransform || function(e) {
            return e;
          }, t.stream = e.stream || !1, t.trickle = void 0 === e.trickle || e.trickle, t.destroyed = !1, t.connected = !1, t.remoteAddress = void 0, t.remoteFamily = void 0, t.remotePort = void 0, t.localAddress = void 0, t.localPort = void 0, t._wrtc = e.wrtc && "object" == typeof e.wrtc ? e.wrtc : i(), !t._wrtc)
            if ("undefined" == typeof window)
              throw new Error("No WebRTC support: Specify `opts.wrtc` option in this environment");
            else
              throw new Error("No WebRTC support: Not a supported browser");
          if (t._pcReady = !1, t._channelReady = !1, t._iceComplete = !1, t._channel = null, t._pendingCandidates = [], t._previousStreams = [], t._chunk = null, t._cb = null, t._interval = null, t._reconnectTimeout = null, t._pc = new t._wrtc.RTCPeerConnection(t.config, t.constraints), t._isWrtc = Array.isArray(t._pc.RTCIceConnectionStates), t._isReactNativeWebrtc = "number" == typeof t._pc._peerConnectionId, t._pc.oniceconnectionstatechange = function() {
            t._onIceStateChange();
          }, t._pc.onicegatheringstatechange = function() {
            t._onIceStateChange();
          }, t._pc.onsignalingstatechange = function() {
            t._onSignalingStateChange();
          }, t._pc.onicecandidate = function(e) {
            t._onIceCandidate(e);
          }, t.initiator) {
            var n = !1;
            t._pc.onnegotiationneeded = function() {
              n || t._createOffer(), n = !0;
            }, t._setupData({channel: t._pc.createDataChannel(t.channelName, t.channelConfig)});
          } else
            t._pc.ondatachannel = function(e) {
              t._setupData(e);
            };
          "addTrack" in t._pc ? (t.stream && t.stream.getTracks().forEach(function(e) {
            t._pc.addTrack(e, t.stream);
          }), t._pc.ontrack = function(e) {
            t._onTrack(e);
          }) : (t.stream && t._pc.addStream(t.stream), t._pc.onaddstream = function(e) {
            t._onAddStream(e);
          }), t.initiator && t._isWrtc && t._pc.onnegotiationneeded(), t._onFinishBound = function() {
            t._onFinish();
          }, t.once("finish", t._onFinishBound);
        }
        function o() {}
        t.exports = r;
        var s = e("debug")("simple-peer"),
            i = e("get-browser-rtc"),
            d = e("inherits"),
            a = e("randombytes"),
            c = e("readable-stream"),
            l = 65536;
        d(r, c.Duplex), r.WEBRTC_SUPPORT = !!i(), r.config = {iceServers: [{urls: "stun:stun.l.google.com:19302"}, {urls: "stun:global.stun.twilio.com:3478?transport=udp"}]}, r.constraints = {}, r.channelConfig = {}, Object.defineProperty(r.prototype, "bufferSize", {get: function() {
            var e = this;
            return e._channel && e._channel.bufferedAmount || 0;
          }}), r.prototype.address = function() {
          var e = this;
          return {
            port: e.localPort,
            family: "IPv4",
            address: e.localAddress
          };
        }, r.prototype.signal = function(e) {
          var t = this;
          if (t.destroyed)
            throw new Error("cannot signal after peer is destroyed");
          if ("string" == typeof e)
            try {
              e = JSON.parse(e);
            } catch (t) {
              e = {};
            }
          t._debug("signal()"), e.candidate && (t._pc.remoteDescription && t._pc.remoteDescription.type ? t._addIceCandidate(e.candidate) : t._pendingCandidates.push(e.candidate)), e.sdp && t._pc.setRemoteDescription(new t._wrtc.RTCSessionDescription(e), function() {
            t.destroyed || (t._pendingCandidates.forEach(function(e) {
              t._addIceCandidate(e);
            }), t._pendingCandidates = [], "offer" === t._pc.remoteDescription.type && t._createAnswer());
          }, function(e) {
            t._destroy(e);
          }), e.sdp || e.candidate || t._destroy(new Error("signal() called with invalid signal data"));
        }, r.prototype._addIceCandidate = function(e) {
          var t = this;
          try {
            t._pc.addIceCandidate(new t._wrtc.RTCIceCandidate(e), o, function(e) {
              t._destroy(e);
            });
          } catch (e) {
            t._destroy(new Error("error adding candidate: " + e.message));
          }
        }, r.prototype.send = function(e) {
          var t = this;
          t._channel.send(e);
        }, r.prototype.destroy = function(e) {
          var t = this;
          t._destroy(null, e);
        }, r.prototype._destroy = function(e, t) {
          var n = this;
          if (!n.destroyed) {
            if (t && n.once("close", t), n._debug("destroy (error: %s)", e && (e.message || e)), n.readable = n.writable = !1, n._readableState.ended || n.push(null), n._writableState.finished || n.end(), n.destroyed = !0, n.connected = !1, n._pcReady = !1, n._channelReady = !1, n._previousStreams = null, clearInterval(n._interval), clearTimeout(n._reconnectTimeout), n._interval = null, n._reconnectTimeout = null, n._chunk = null, n._cb = null, n._onFinishBound && n.removeListener("finish", n._onFinishBound), n._onFinishBound = null, n._pc) {
              try {
                n._pc.close();
              } catch (e) {}
              n._pc.oniceconnectionstatechange = null, n._pc.onicegatheringstatechange = null, n._pc.onsignalingstatechange = null, n._pc.onicecandidate = null, "addTrack" in n._pc ? n._pc.ontrack = null : n._pc.onaddstream = null, n._pc.onnegotiationneeded = null, n._pc.ondatachannel = null;
            }
            if (n._channel) {
              try {
                n._channel.close();
              } catch (e) {}
              n._channel.onmessage = null, n._channel.onopen = null, n._channel.onclose = null, n._channel.onerror = null;
            }
            n._pc = null, n._channel = null, e && n.emit("error", e), n.emit("close");
          }
        }, r.prototype._setupData = function(e) {
          var t = this;
          return e.channel ? void(t._channel = e.channel, t._channel.binaryType = "arraybuffer", "number" == typeof t._channel.bufferedAmountLowThreshold && (t._channel.bufferedAmountLowThreshold = l), t.channelName = t._channel.label, t._channel.onmessage = function(e) {
            t._onChannelMessage(e);
          }, t._channel.onbufferedamountlow = function() {
            t._onChannelBufferedAmountLow();
          }, t._channel.onopen = function() {
            t._onChannelOpen();
          }, t._channel.onclose = function() {
            t._onChannelClose();
          }, t._channel.onerror = function(e) {
            t._destroy(e);
          }) : t._destroy(new Error("Data channel event is missing `channel` property"));
        }, r.prototype._read = function() {}, r.prototype._write = function(e, t, n) {
          var r = this;
          if (r.destroyed)
            return n(new Error("cannot write after peer is destroyed"));
          if (r.connected) {
            try {
              r.send(e);
            } catch (e) {
              return r._destroy(e);
            }
            r._channel.bufferedAmount > l ? (r._debug("start backpressure: bufferedAmount %d", r._channel.bufferedAmount), r._cb = n) : n(null);
          } else
            r._debug("write before connect"), r._chunk = e, r._cb = n;
        }, r.prototype._onFinish = function() {
          function e() {
            setTimeout(function() {
              t._destroy();
            }, 1e3);
          }
          var t = this;
          t.destroyed || (t.connected ? e() : t.once("connect", e));
        }, r.prototype._createOffer = function() {
          var e = this;
          e.destroyed || e._pc.createOffer(function(t) {
            function n() {
              var n = e._pc.localDescription || t;
              e._debug("signal"), e.emit("signal", {
                type: n.type,
                sdp: n.sdp
              });
            }
            e.destroyed || (t.sdp = e.sdpTransform(t.sdp), e._pc.setLocalDescription(t, function() {
              e.destroyed || (e.trickle || e._iceComplete ? n() : e.once("_iceComplete", n));
            }, function(t) {
              e._destroy(t);
            }));
          }, function(t) {
            e._destroy(t);
          }, e.offerConstraints);
        }, r.prototype._createAnswer = function() {
          var e = this;
          e.destroyed || e._pc.createAnswer(function(t) {
            function n() {
              var n = e._pc.localDescription || t;
              e._debug("signal"), e.emit("signal", {
                type: n.type,
                sdp: n.sdp
              });
            }
            e.destroyed || (t.sdp = e.sdpTransform(t.sdp), e._pc.setLocalDescription(t, function() {
              e.destroyed || (e.trickle || e._iceComplete ? n() : e.once("_iceComplete", n));
            }, function(t) {
              e._destroy(t);
            }));
          }, function(t) {
            e._destroy(t);
          }, e.answerConstraints);
        }, r.prototype._onIceStateChange = function() {
          var e = this;
          if (!e.destroyed) {
            var t = e._pc.iceConnectionState,
                n = e._pc.iceGatheringState;
            e._debug("iceStateChange (connection: %s) (gathering: %s)", t, n), e.emit("iceStateChange", t, n), ("connected" === t || "completed" === t) && (clearTimeout(e._reconnectTimeout), e._pcReady = !0, e._maybeReady()), "disconnected" === t && (e.reconnectTimer ? (clearTimeout(e._reconnectTimeout), e._reconnectTimeout = setTimeout(function() {
              e._destroy();
            }, e.reconnectTimer)) : e._destroy()), "failed" === t && e._destroy(new Error("Ice connection failed.")), "closed" === t && e._destroy();
          }
        }, r.prototype.getStats = function(e) {
          var t = this;
          0 === t._pc.getStats.length ? t._pc.getStats().then(function(t) {
            var n = [];
            t.forEach(function(e) {
              n.push(e);
            }), e(null, n);
          }, function(t) {
            e(t);
          }) : t._isReactNativeWebrtc ? t._pc.getStats(null, function(t) {
            var n = [];
            t.forEach(function(e) {
              n.push(e);
            }), e(null, n);
          }, function(t) {
            e(t);
          }) : 0 < t._pc.getStats.length ? t._pc.getStats(function(n) {
            if (!t.destroyed) {
              var r = [];
              n.result().forEach(function(e) {
                var t = {};
                e.names().forEach(function(n) {
                  t[n] = e.stat(n);
                }), t.id = e.id, t.type = e.type, t.timestamp = e.timestamp, r.push(t);
              }), e(null, r);
            }
          }, function(t) {
            e(t);
          }) : e(null, []);
        }, r.prototype._maybeReady = function() {
          function e() {
            t.destroyed || t.getStats(function(n, r) {
              function o(e) {
                a = !0;
                var n = i[e.localCandidateId];
                n && n.ip ? (t.localAddress = n.ip, t.localPort = +n.port) : n && n.ipAddress ? (t.localAddress = n.ipAddress, t.localPort = +n.portNumber) : "string" == typeof e.googLocalAddress && (n = e.googLocalAddress.split(":"), t.localAddress = n[0], t.localPort = +n[1]);
                var r = s[e.remoteCandidateId];
                r && r.ip ? (t.remoteAddress = r.ip, t.remotePort = +r.port) : r && r.ipAddress ? (t.remoteAddress = r.ipAddress, t.remotePort = +r.portNumber) : "string" == typeof e.googRemoteAddress && (r = e.googRemoteAddress.split(":"), t.remoteAddress = r[0], t.remotePort = +r[1]), t.remoteFamily = "IPv4", t._debug("connect local: %s:%s remote: %s:%s", t.localAddress, t.localPort, t.remoteAddress, t.remotePort);
              }
              if (!t.destroyed) {
                n && (r = []);
                var s = {},
                    i = {},
                    d = {},
                    a = !1;
                if (r.forEach(function(e) {
                  ("remotecandidate" === e.type || "remote-candidate" === e.type) && (s[e.id] = e), ("localcandidate" === e.type || "local-candidate" === e.type) && (i[e.id] = e), ("candidatepair" === e.type || "candidate-pair" === e.type) && (d[e.id] = e);
                }), r.forEach(function(e) {
                  "transport" === e.type && o(d[e.selectedCandidatePairId]), ("googCandidatePair" === e.type && "true" === e.googActiveConnection || ("candidatepair" === e.type || "candidate-pair" === e.type) && e.selected) && o(e);
                }), !a && (!Object.keys(d).length || Object.keys(i).length))
                  return void setTimeout(e, 100);
                if (t._connecting = !1, t.connected = !0, t._chunk) {
                  try {
                    t.send(t._chunk);
                  } catch (e) {
                    return t._destroy(e);
                  }
                  t._chunk = null, t._debug("sent chunk from \"write before connect\"");
                  var c = t._cb;
                  t._cb = null, c(null);
                }
                "number" != typeof t._channel.bufferedAmountLowThreshold && (t._interval = setInterval(function() {
                  t._onInterval();
                }, 150), t._interval.unref && t._interval.unref()), t._debug("connect"), t.emit("connect");
              }
            });
          }
          var t = this;
          t._debug("maybeReady pc %s channel %s", t._pcReady, t._channelReady);
          t.connected || t._connecting || !t._pcReady || !t._channelReady || (t._connecting = !0, e());
        }, r.prototype._onInterval = function() {
          this._cb && this._channel && !(this._channel.bufferedAmount > l) && this._onChannelBufferedAmountLow();
        }, r.prototype._onSignalingStateChange = function() {
          var e = this;
          e.destroyed || (e._debug("signalingStateChange %s", e._pc.signalingState), e.emit("signalingStateChange", e._pc.signalingState));
        }, r.prototype._onIceCandidate = function(e) {
          var t = this;
          t.destroyed || (e.candidate && t.trickle ? t.emit("signal", {candidate: {
              candidate: e.candidate.candidate,
              sdpMLineIndex: e.candidate.sdpMLineIndex,
              sdpMid: e.candidate.sdpMid
            }}) : !e.candidate && (t._iceComplete = !0, t.emit("_iceComplete")));
        }, r.prototype._onChannelMessage = function(e) {
          var t = this;
          if (!t.destroyed) {
            var r = e.data;
            r instanceof ArrayBuffer && (r = n.from(r)), t.push(r);
          }
        }, r.prototype._onChannelBufferedAmountLow = function() {
          var e = this;
          if (!e.destroyed && e._cb) {
            e._debug("ending backpressure: bufferedAmount %d", e._channel.bufferedAmount);
            var t = e._cb;
            e._cb = null, t(null);
          }
        }, r.prototype._onChannelOpen = function() {
          var e = this;
          e.connected || e.destroyed || (e._debug("on channel open"), e._channelReady = !0, e._maybeReady());
        }, r.prototype._onChannelClose = function() {
          var e = this;
          e.destroyed || (e._debug("on channel close"), e._destroy());
        }, r.prototype._onAddStream = function(e) {
          var t = this;
          t.destroyed || (t._debug("on add stream"), t.emit("stream", e.stream));
        }, r.prototype._onTrack = function(e) {
          var t = this;
          if (!t.destroyed) {
            t._debug("on track");
            var n = e.streams[0].id;
            -1 !== t._previousStreams.indexOf(n) || (t._previousStreams.push(n), t.emit("stream", e.streams[0]));
          }
        }, r.prototype._debug = function() {
          var e = this,
              t = [].slice.call(arguments);
          t[0] = "[" + e._id + "] " + t[0], s.apply(null, t);
        }, r.prototype._transformConstraints = function(e) {
          var t = this;
          if (0 === Object.keys(e).length)
            return e;
          if ((e.mandatory || e.optional) && !t._isChromium) {
            var n = Object.assign({}, e.optional, e.mandatory);
            return void 0 !== n.OfferToReceiveVideo && (n.offerToReceiveVideo = n.OfferToReceiveVideo, delete n.OfferToReceiveVideo), void 0 !== n.OfferToReceiveAudio && (n.offerToReceiveAudio = n.OfferToReceiveAudio, delete n.OfferToReceiveAudio), n;
          }
          return e.mandatory || e.optional || !t._isChromium ? e : (void 0 !== e.offerToReceiveVideo && (e.OfferToReceiveVideo = e.offerToReceiveVideo, delete e.offerToReceiveVideo), void 0 !== e.offerToReceiveAudio && (e.OfferToReceiveAudio = e.offerToReceiveAudio, delete e.offerToReceiveAudio), {mandatory: e});
        };
      }).call(this, e("buffer").Buffer);
    }, {
      buffer: 25,
      debug: 31,
      "get-browser-rtc": 38,
      inherits: 42,
      randombytes: 74,
      "readable-stream": 84
    }],
    96: [function(e, t) {
      function n(e) {
        return i.digest(e);
      }
      function r(e) {
        for (var t = e.length,
            n = new Uint8Array(t),
            r = 0; r < t; r++)
          n[r] = e.charCodeAt(r);
        return n;
      }
      function o(e) {
        for (var t = e.length,
            n = [],
            r = 0,
            o; r < t; r++)
          o = e[r], n.push((o >>> 4).toString(16)), n.push((15 & o).toString(16));
        return n.join("");
      }
      var s = e("rusha"),
          i = new s,
          d = "undefined" == typeof window ? self : window,
          a = d.crypto || d.msCrypto || {},
          c = a.subtle || a.webkitSubtle;
      try {
        c.digest({name: "sha-1"}, new Uint8Array).catch(function() {
          c = !1;
        });
      } catch (e) {
        c = !1;
      }
      t.exports = function(e, t) {
        return c ? void("string" == typeof e && (e = r(e)), c.digest({name: "sha-1"}, e).then(function(e) {
          t(o(new Uint8Array(e)));
        }, function() {
          t(n(e));
        })) : void setTimeout(t, 0, n(e));
      }, t.exports.sync = n;
    }, {rusha: 91}],
    97: [function(e, t) {
      (function(n) {
        function r(e) {
          var t = this;
          if (!(t instanceof r))
            return new r(e);
          if (e || (e = {}), "string" == typeof e && (e = {url: e}), null == e.url && null == e.socket)
            throw new Error("Missing required `url` or `socket` option");
          if (null != e.url && null != e.socket)
            throw new Error("Must specify either `url` or `socket` option, not both");
          if (t._id = d(4).toString("hex").slice(0, 7), t._debug("new websocket: %o", e), e = Object.assign({allowHalfOpen: !1}, e), a.Duplex.call(t, e), t.connected = !1, t.destroyed = !1, t._chunk = null, t._cb = null, t._interval = null, e.socket)
            t.url = e.socket.url, t._ws = e.socket;
          else {
            t.url = e.url;
            try {
              t._ws = "function" == typeof c ? new l(e.url, e) : new l(e.url);
            } catch (e) {
              return void n.nextTick(function() {
                t._destroy(e);
              });
            }
          }
          t._ws.binaryType = "arraybuffer", t._ws.onopen = function() {
            t._onOpen();
          }, t._ws.onmessage = function(e) {
            t._onMessage(e);
          }, t._ws.onclose = function() {
            t._onClose();
          }, t._ws.onerror = function() {
            t.destroy(new Error("connection error to " + t.url));
          }, t._onFinishBound = function() {
            t._onFinish();
          }, t.once("finish", t._onFinishBound);
        }
        t.exports = r;
        var o = e("safe-buffer").Buffer,
            s = e("debug")("simple-websocket"),
            i = e("inherits"),
            d = e("randombytes"),
            a = e("readable-stream"),
            c = e("ws"),
            l = "function" == typeof c ? c : WebSocket,
            p = 65536;
        i(r, a.Duplex), r.WEBSOCKET_SUPPORT = !!l, r.prototype.send = function(e) {
          this._ws.send(e);
        }, r.prototype.destroy = function(e) {
          this._destroy(e, function() {});
        }, r.prototype._destroy = function(e, t) {
          var n = this;
          if (!n.destroyed) {
            if (n._debug("destroy (error: %s)", e && (e.message || e)), n.readable = n.writable = !1, n._readableState.ended || n.push(null), n._writableState.finished || n.end(), n.connected = !1, n.destroyed = !0, clearInterval(n._interval), n._interval = null, n._chunk = null, n._cb = null, n._onFinishBound && n.removeListener("finish", n._onFinishBound), n._onFinishBound = null, n._ws) {
              var r = n._ws,
                  o = function() {
                    r.onclose = null;
                  };
              if (r.readyState === l.CLOSED)
                o();
              else
                try {
                  r.onclose = o, r.close();
                } catch (e) {
                  o();
                }
              r.onopen = null, r.onmessage = null, r.onerror = function() {};
            }
            if (n._ws = null, e) {
              if ("undefined" != typeof DOMException && e instanceof DOMException) {
                var s = e.code;
                e = new Error(e.message), e.code = s;
              }
              n.emit("error", e);
            }
            n.emit("close"), t();
          }
        }, r.prototype._read = function() {}, r.prototype._write = function(e, t, n) {
          if (this.destroyed)
            return n(new Error("cannot write after socket is destroyed"));
          if (this.connected) {
            try {
              this.send(e);
            } catch (e) {
              return this.destroy(e);
            }
            "function" != typeof c && this._ws.bufferedAmount > p ? (this._debug("start backpressure: bufferedAmount %d", this._ws.bufferedAmount), this._cb = n) : n(null);
          } else
            this._debug("write before connect"), this._chunk = e, this._cb = n;
        }, r.prototype._onFinish = function() {
          function e() {
            setTimeout(function() {
              t.destroy();
            }, 1e3);
          }
          var t = this;
          t.destroyed || (t.connected ? e() : t.once("connect", e));
        }, r.prototype._onMessage = function(e) {
          if (!this.destroyed) {
            var t = e.data;
            t instanceof ArrayBuffer && (t = o.from(t)), this.push(t);
          }
        }, r.prototype._onOpen = function() {
          var e = this;
          if (!(e.connected || e.destroyed)) {
            if (e.connected = !0, e._chunk) {
              try {
                e.send(e._chunk);
              } catch (t) {
                return e.destroy(t);
              }
              e._chunk = null, e._debug("sent chunk from \"write before connect\"");
              var t = e._cb;
              e._cb = null, t(null);
            }
            "function" != typeof c && (e._interval = setInterval(function() {
              e._onInterval();
            }, 150), e._interval.unref && e._interval.unref()), e._debug("connect"), e.emit("connect");
          }
        }, r.prototype._onInterval = function() {
          if (this._cb && this._ws && !(this._ws.bufferedAmount > p)) {
            this._debug("ending backpressure: bufferedAmount %d", this._ws.bufferedAmount);
            var e = this._cb;
            this._cb = null, e(null);
          }
        }, r.prototype._onClose = function() {
          this.destroyed || (this._debug("on close"), this.destroy());
        }, r.prototype._debug = function() {
          var e = [].slice.call(arguments);
          e[0] = "[" + this._id + "] " + e[0], s.apply(null, e);
        };
      }).call(this, e("_process"));
    }, {
      _process: 67,
      debug: 31,
      inherits: 42,
      randombytes: 74,
      "readable-stream": 84,
      "safe-buffer": 92,
      ws: 23
    }],
    98: [function(e, t) {
      var n = 1,
          r = 65535,
          o = 4,
          s = setInterval(function() {
            n = n + 1 & r;
          }, 0 | 1e3 / o);
      s.unref && s.unref(), t.exports = function(e) {
        var t = o * (e || 5),
            s = [0],
            i = 1,
            d = n - 1 & r;
        return function(e) {
          var a = n - d & r;
          for (a > t && (a = t), d = n; a--; )
            i == t && (i = 0), s[i] = s[0 == i ? t - 1 : i - 1], i++;
          e && (s[i - 1] += e);
          var c = s[i - 1],
              l = s.length < t ? 0 : s[i == t ? 0 : i];
          return s.length < o ? c : (c - l) * o / s.length;
        };
      };
    }, {}],
    99: [function(e, t, n) {
      (function(t) {
        var r = e("./lib/request"),
            o = e("./lib/response"),
            s = e("xtend"),
            i = e("builtin-status-codes"),
            d = e("url"),
            a = n;
        a.request = function(e, n) {
          e = "string" == typeof e ? d.parse(e) : s(e);
          var o = -1 === t.location.protocol.search(/^https?:$/) ? "http:" : "",
              i = e.protocol || o,
              a = e.hostname || e.host,
              c = e.port,
              l = e.path || "/";
          a && -1 !== a.indexOf(":") && (a = "[" + a + "]"), e.url = (a ? i + "//" + a : "") + (c ? ":" + c : "") + l, e.method = (e.method || "GET").toUpperCase(), e.headers = e.headers || {};
          var p = new r(e);
          return n && p.on("response", n), p;
        }, a.get = function(e, t) {
          var n = a.request(e, t);
          return n.end(), n;
        }, a.ClientRequest = r, a.IncomingMessage = o, a.Agent = function() {}, a.Agent.defaultMaxSockets = 4, a.STATUS_CODES = i, a.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"];
      }).call(this, "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
    }, {
      "./lib/request": 101,
      "./lib/response": 102,
      "builtin-status-codes": 26,
      url: 116,
      xtend: 126
    }],
    100: [function(e, t, n) {
      (function(e) {
        function t() {
          if (d != void 0)
            return d;
          if (e.XMLHttpRequest) {
            d = new e.XMLHttpRequest;
            try {
              d.open("GET", e.XDomainRequest ? "/" : "https://example.com");
            } catch (t) {
              d = null;
            }
          } else
            d = null;
          return d;
        }
        function r(e) {
          var n = t();
          if (!n)
            return !1;
          try {
            return n.responseType = e, n.responseType === e;
          } catch (t) {}
          return !1;
        }
        function o(e) {
          return "function" == typeof e;
        }
        n.fetch = o(e.fetch) && o(e.ReadableStream), n.writableStream = o(e.WritableStream), n.abortController = o(e.AbortController), n.blobConstructor = !1;
        try {
          new Blob([new ArrayBuffer(1)]), n.blobConstructor = !0;
        } catch (t) {}
        var s = "undefined" != typeof e.ArrayBuffer,
            i = s && o(e.ArrayBuffer.prototype.slice),
            d;
        n.arraybuffer = n.fetch || s && r("arraybuffer"), n.msstream = !n.fetch && i && r("ms-stream"), n.mozchunkedarraybuffer = !n.fetch && s && r("moz-chunked-arraybuffer"), n.overrideMimeType = n.fetch || !!t() && o(t().overrideMimeType), n.vbArray = o(e.VBArray), d = null;
      }).call(this, "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
    }, {}],
    101: [function(e, t) {
      (function(n, r, o) {
        function s(e, t) {
          return d.fetch && t ? "fetch" : d.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : d.msstream ? "ms-stream" : d.arraybuffer && e ? "arraybuffer" : d.vbArray && e ? "text:vbarray" : "text";
        }
        function i(e) {
          try {
            var t = e.status;
            return null !== t && 0 !== t;
          } catch (t) {
            return !1;
          }
        }
        var d = e("./capability"),
            a = e("inherits"),
            c = e("./response"),
            l = e("readable-stream"),
            p = e("to-arraybuffer"),
            u = c.IncomingMessage,
            f = c.readyStates,
            h = t.exports = function(e) {
              var t = this;
              l.Writable.call(t), t._opts = e, t._body = [], t._headers = {}, e.auth && t.setHeader("Authorization", "Basic " + new o(e.auth).toString("base64")), Object.keys(e.headers).forEach(function(n) {
                t.setHeader(n, e.headers[n]);
              });
              var n = !0,
                  r;
              if ("disable-fetch" === e.mode || "requestTimeout" in e && !d.abortController)
                n = !1, r = !0;
              else if ("prefer-streaming" === e.mode)
                r = !1;
              else if ("allow-wrong-content-type" === e.mode)
                r = !d.overrideMimeType;
              else if (!e.mode || "default" === e.mode || "prefer-fast" === e.mode)
                r = !0;
              else
                throw new Error("Invalid value for opts.mode");
              t._mode = s(r, n), t.on("finish", function() {
                t._onFinish();
              });
            };
        a(h, l.Writable), h.prototype.setHeader = function(e, t) {
          var n = this,
              r = e.toLowerCase();
          -1 !== m.indexOf(r) || (n._headers[r] = {
            name: e,
            value: t
          });
        }, h.prototype.getHeader = function(e) {
          var t = this._headers[e.toLowerCase()];
          return t ? t.value : null;
        }, h.prototype.removeHeader = function(e) {
          var t = this;
          delete t._headers[e.toLowerCase()];
        }, h.prototype._onFinish = function() {
          var e = this;
          if (!e._destroyed) {
            var t = e._opts,
                s = e._headers,
                i = null;
            "GET" !== t.method && "HEAD" !== t.method && (d.arraybuffer ? i = p(o.concat(e._body)) : d.blobConstructor ? i = new r.Blob(e._body.map(function(e) {
              return p(e);
            }), {type: (s["content-type"] || {}).value || ""}) : i = o.concat(e._body).toString());
            var a = [];
            if (Object.keys(s).forEach(function(e) {
              var t = s[e].name,
                  n = s[e].value;
              Array.isArray(n) ? n.forEach(function(e) {
                a.push([t, e]);
              }) : a.push([t, n]);
            }), "fetch" === e._mode) {
              var c = null;
              if (d.abortController) {
                var l = new AbortController;
                c = l.signal, e._fetchAbortController = l, "requestTimeout" in t && 0 !== t.requestTimeout && r.setTimeout(function() {
                  e.emit("requestTimeout"), e._fetchAbortController && e._fetchAbortController.abort();
                }, t.requestTimeout);
              }
              r.fetch(e._opts.url, {
                method: e._opts.method,
                headers: a,
                body: i || void 0,
                mode: "cors",
                credentials: t.withCredentials ? "include" : "same-origin",
                signal: c
              }).then(function(t) {
                e._fetchResponse = t, e._connect();
              }, function(t) {
                e.emit("error", t);
              });
            } else {
              var u = e._xhr = new r.XMLHttpRequest;
              try {
                u.open(e._opts.method, e._opts.url, !0);
              } catch (t) {
                return void n.nextTick(function() {
                  e.emit("error", t);
                });
              }
              "responseType" in u && (u.responseType = e._mode.split(":")[0]), "withCredentials" in u && (u.withCredentials = !!t.withCredentials), "text" === e._mode && "overrideMimeType" in u && u.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in t && (u.timeout = t.requestTimeout, u.ontimeout = function() {
                e.emit("requestTimeout");
              }), a.forEach(function(e) {
                u.setRequestHeader(e[0], e[1]);
              }), e._response = null, u.onreadystatechange = function() {
                switch (u.readyState) {
                  case f.LOADING:
                  case f.DONE:
                    e._onXHRProgress();
                }
              }, "moz-chunked-arraybuffer" === e._mode && (u.onprogress = function() {
                e._onXHRProgress();
              }), u.onerror = function() {
                e._destroyed || e.emit("error", new Error("XHR error"));
              };
              try {
                u.send(i);
              } catch (t) {
                return void n.nextTick(function() {
                  e.emit("error", t);
                });
              }
            }
          }
        }, h.prototype._onXHRProgress = function() {
          var e = this;
          !i(e._xhr) || e._destroyed || (!e._response && e._connect(), e._response._onXHRProgress());
        }, h.prototype._connect = function() {
          var e = this;
          e._destroyed || (e._response = new u(e._xhr, e._fetchResponse, e._mode), e._response.on("error", function(t) {
            e.emit("error", t);
          }), e.emit("response", e._response));
        }, h.prototype._write = function(e, t, n) {
          var r = this;
          r._body.push(e), n();
        }, h.prototype.abort = h.prototype.destroy = function() {
          var e = this;
          e._destroyed = !0, e._response && (e._response._destroyed = !0), e._xhr ? e._xhr.abort() : e._fetchAbortController && e._fetchAbortController.abort();
        }, h.prototype.end = function(e, t, n) {
          var r = this;
          "function" == typeof e && (n = e, e = void 0), l.Writable.prototype.end.call(r, e, t, n);
        }, h.prototype.flushHeaders = function() {}, h.prototype.setTimeout = function() {}, h.prototype.setNoDelay = function() {}, h.prototype.setSocketKeepAlive = function() {};
        var m = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "user-agent", "via"];
      }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global, e("buffer").Buffer);
    }, {
      "./capability": 100,
      "./response": 102,
      _process: 67,
      buffer: 25,
      inherits: 42,
      "readable-stream": 84,
      "to-arraybuffer": 109
    }],
    102: [function(e, t, n) {
      (function(t, r, o) {
        var s = e("./capability"),
            i = e("inherits"),
            d = e("readable-stream"),
            a = n.readyStates = {
              UNSENT: 0,
              OPENED: 1,
              HEADERS_RECEIVED: 2,
              LOADING: 3,
              DONE: 4
            },
            c = n.IncomingMessage = function(e, n, r) {
              var i = this;
              if (d.Readable.call(i), i._mode = r, i.headers = {}, i.rawHeaders = [], i.trailers = {}, i.rawTrailers = [], i.on("end", function() {
                t.nextTick(function() {
                  i.emit("close");
                });
              }), "fetch" === r) {
                function e() {
                  c.read().then(function(t) {
                    return i._destroyed ? void 0 : t.done ? void i.push(null) : void(i.push(new o(t.value)), e());
                  }).catch(function(e) {
                    i._destroyed || i.emit("error", e);
                  });
                }
                if (i._fetchResponse = n, i.url = n.url, i.statusCode = n.status, i.statusMessage = n.statusText, n.headers.forEach(function(e, t) {
                  i.headers[t.toLowerCase()] = e, i.rawHeaders.push(t, e);
                }), s.writableStream) {
                  var a = new WritableStream({
                    write: function(e) {
                      return new Promise(function(t) {
                        i._destroyed || (i.push(new o(e)) ? t() : i._resumeFetch = t);
                      });
                    },
                    close: function() {
                      i._destroyed || i.push(null);
                    },
                    abort: function(e) {
                      i._destroyed || i.emit("error", e);
                    }
                  });
                  try {
                    return void n.body.pipeTo(a);
                  } catch (t) {}
                }
                var c = n.body.getReader();
                e();
              } else {
                i._xhr = e, i._pos = 0, i.url = e.responseURL, i.statusCode = e.status, i.statusMessage = e.statusText;
                var l = e.getAllResponseHeaders().split(/\r?\n/);
                if (l.forEach(function(e) {
                  var t = e.match(/^([^:]+):\s*(.*)/);
                  if (t) {
                    var n = t[1].toLowerCase();
                    "set-cookie" === n ? (void 0 === i.headers[n] && (i.headers[n] = []), i.headers[n].push(t[2])) : void 0 === i.headers[n] ? i.headers[n] = t[2] : i.headers[n] += ", " + t[2], i.rawHeaders.push(t[1], t[2]);
                  }
                }), i._charset = "x-user-defined", !s.overrideMimeType) {
                  var p = i.rawHeaders["mime-type"];
                  if (p) {
                    var u = p.match(/;\s*charset=([^;])(;|$)/);
                    u && (i._charset = u[1].toLowerCase());
                  }
                  i._charset || (i._charset = "utf-8");
                }
              }
            };
        i(c, d.Readable), c.prototype._read = function() {
          var e = this,
              t = e._resumeFetch;
          t && (e._resumeFetch = null, t());
        }, c.prototype._onXHRProgress = function() {
          var e = this,
              t = e._xhr,
              n = null;
          switch (e._mode) {
            case "text:vbarray":
              if (t.readyState !== a.DONE)
                break;
              try {
                n = new r.VBArray(t.responseBody).toArray();
              } catch (t) {}
              if (null !== n) {
                e.push(new o(n));
                break;
              }
            case "text":
              try {
                n = t.responseText;
              } catch (t) {
                e._mode = "text:vbarray";
                break;
              }
              if (n.length > e._pos) {
                var s = n.substr(e._pos);
                if ("x-user-defined" === e._charset) {
                  for (var d = new o(s.length),
                      c = 0; c < s.length; c++)
                    d[c] = 255 & s.charCodeAt(c);
                  e.push(d);
                } else
                  e.push(s, e._charset);
                e._pos = n.length;
              }
              break;
            case "arraybuffer":
              if (t.readyState !== a.DONE || !t.response)
                break;
              n = t.response, e.push(new o(new Uint8Array(n)));
              break;
            case "moz-chunked-arraybuffer":
              if (n = t.response, t.readyState !== a.LOADING || !n)
                break;
              e.push(new o(new Uint8Array(n)));
              break;
            case "ms-stream":
              if (n = t.response, t.readyState !== a.LOADING)
                break;
              var i = new r.MSStreamReader;
              i.onprogress = function() {
                i.result.byteLength > e._pos && (e.push(new o(new Uint8Array(i.result.slice(e._pos)))), e._pos = i.result.byteLength);
              }, i.onload = function() {
                e.push(null);
              }, i.readAsArrayBuffer(n);
          }
          e._xhr.readyState === a.DONE && "ms-stream" !== e._mode && e.push(null);
        };
      }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global, e("buffer").Buffer);
    }, {
      "./capability": 100,
      _process: 67,
      buffer: 25,
      inherits: 42,
      "readable-stream": 84
    }],
    103: [function(e, t) {
      var n = e("stream-to-blob");
      t.exports = function e(t, r, o) {
        return "function" == typeof r ? e(t, null, r) : void n(t, r, function(e, t) {
          if (e)
            return o(e);
          var n = URL.createObjectURL(t);
          o(null, n);
        });
      };
    }, {"stream-to-blob": 104}],
    104: [function(e, t) {
      var n = e("once");
      t.exports = function e(t, r, o) {
        if ("function" == typeof r)
          return e(t, null, r);
        o = n(o);
        var s = [];
        t.on("data", function(e) {
          s.push(e);
        }).on("end", function() {
          var e = r ? new Blob(s, {type: r}) : new Blob(s);
          o(null, e);
        }).on("error", o);
      };
    }, {once: 61}],
    105: [function(e, t) {
      (function(n) {
        var r = e("once");
        t.exports = function(e, t, o) {
          o = r(o);
          var s = new n(t),
              i = 0;
          e.on("data", function(e) {
            e.copy(s, i), i += e.length;
          }).on("end", function() {
            o(null, s);
          }).on("error", o);
        };
      }).call(this, e("buffer").Buffer);
    }, {
      buffer: 25,
      once: 61
    }],
    106: [function(e, t, n) {
      "use strict";
      function r(e) {
        if (!e)
          return "utf8";
        for (var t; ; )
          switch (e) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return e;
            default:
              if (t)
                return;
              e = ("" + e).toLowerCase(), t = !0;
          }
      }
      function o(e) {
        var t = r(e);
        if ("string" != typeof t && (g.isEncoding === _ || !_(e)))
          throw new Error("Unknown encoding: " + e);
        return t || e;
      }
      function s(e) {
        this.encoding = o(e);
        var t;
        switch (this.encoding) {
          case "utf16le":
            this.text = l, this.end = p, t = 4;
            break;
          case "utf8":
            this.fillLast = c, t = 4;
            break;
          case "base64":
            this.text = u, this.end = f, t = 3;
            break;
          default:
            return this.write = h, void(this.end = m);
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = g.allocUnsafe(t);
      }
      function d(e) {
        if (127 >= e)
          return 0;
        return 6 == e >> 5 ? 2 : 14 == e >> 4 ? 3 : 30 == e >> 3 ? 4 : -1;
      }
      function a(e, t, n) {
        var r = t.length - 1;
        if (r < n)
          return 0;
        var o = d(t[r]);
        return 0 <= o ? (0 < o && (e.lastNeed = o - 1), o) : --r < n ? 0 : (o = d(t[r]), 0 <= o) ? (0 < o && (e.lastNeed = o - 2), o) : --r < n ? 0 : (o = d(t[r]), 0 <= o ? (0 < o && (2 === o ? o = 0 : e.lastNeed = o - 3), o) : 0);
      }
      function i(e, t, n) {
        if (128 != (192 & t[0]))
          return e.lastNeed = 0, "\uFFFD".repeat(n);
        if (1 < e.lastNeed && 1 < t.length) {
          if (128 != (192 & t[1]))
            return e.lastNeed = 1, "\uFFFD".repeat(n + 1);
          if (2 < e.lastNeed && 2 < t.length && 128 != (192 & t[2]))
            return e.lastNeed = 2, "\uFFFD".repeat(n + 2);
        }
      }
      function c(e) {
        var t = this.lastTotal - this.lastNeed,
            n = i(this, e, t);
        return void 0 === n ? this.lastNeed <= e.length ? (e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : void(e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length) : n;
      }
      function l(e, t) {
        if (0 == (e.length - t) % 2) {
          var n = e.toString("utf16le", t);
          if (n) {
            var r = n.charCodeAt(n.length - 1);
            if (55296 <= r && 56319 >= r)
              return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], n.slice(0, -1);
          }
          return n;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
      }
      function p(e) {
        var t = e && e.length ? this.write(e) : "";
        if (this.lastNeed) {
          var n = this.lastTotal - this.lastNeed;
          return t + this.lastChar.toString("utf16le", 0, n);
        }
        return t;
      }
      function u(e, t) {
        var r = (e.length - t) % 3;
        return 0 == r ? e.toString("base64", t) : (this.lastNeed = 3 - r, this.lastTotal = 3, 1 == r ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - r));
      }
      function f(e) {
        var t = e && e.length ? this.write(e) : "";
        return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
      }
      function h(e) {
        return e.toString(this.encoding);
      }
      function m(e) {
        return e && e.length ? this.write(e) : "";
      }
      var g = e("safe-buffer").Buffer,
          _ = g.isEncoding || function(e) {
            switch (e = "" + e, e && e.toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
              case "raw":
                return !0;
              default:
                return !1;
            }
          };
      n.StringDecoder = s, s.prototype.write = function(e) {
        if (0 === e.length)
          return "";
        var t,
            n;
        if (this.lastNeed) {
          if (t = this.fillLast(e), void 0 === t)
            return "";
          n = this.lastNeed, this.lastNeed = 0;
        } else
          n = 0;
        return n < e.length ? t ? t + this.text(e, n) : this.text(e, n) : t || "";
      }, s.prototype.end = function(e) {
        var t = e && e.length ? this.write(e) : "";
        return this.lastNeed ? t + "\uFFFD".repeat(this.lastTotal - this.lastNeed) : t;
      }, s.prototype.text = function(e, t) {
        var n = a(this, e, t);
        if (!this.lastNeed)
          return e.toString("utf8", t);
        this.lastTotal = n;
        var r = e.length - (n - this.lastNeed);
        return e.copy(this.lastChar, 0, r), e.toString("utf8", t, r);
      }, s.prototype.fillLast = function(e) {
        return this.lastNeed <= e.length ? (e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : void(e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length);
      };
    }, {"safe-buffer": 92}],
    107: [function(e, t, n) {
      var r = e("./thirty-two");
      n.encode = r.encode, n.decode = r.decode;
    }, {"./thirty-two": 108}],
    108: [function(e, t, n) {
      (function(e) {
        "use strict";
        function t(e) {
          var t = r(e.length / 5);
          return 0 == e.length % 5 ? t : t + 1;
        }
        var o = [255, 255, 26, 27, 28, 29, 30, 31, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255];
        n.encode = function(n) {
          e.isBuffer(n) || (n = new e(n));
          for (var r = 0,
              o = 0,
              s = 0,
              i = 0,
              d = new e(8 * t(n)); r < n.length; ) {
            var a = n[r];
            3 < s ? (i = a & 255 >> s, s = (s + 5) % 8, i = i << s | (r + 1 < n.length ? n[r + 1] : 0) >> 8 - s, r++) : (i = 31 & a >> 8 - (s + 5), s = (s + 5) % 8, 0 == s && r++), d[o] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".charCodeAt(i), o++;
          }
          for (r = o; r < d.length; r++)
            d[r] = 61;
          return d;
        }, n.decode = function(t) {
          var n = 0,
              r = 0,
              d = 0,
              a;
          e.isBuffer(t) || (t = new e(t));
          for (var c = new e(s(5 * t.length / 8)),
              l = 0; l < t.length && !(61 === t[l]); l++) {
            var i = t[l] - 48;
            if (i < o.length)
              r = o[i], 3 >= n ? (n = (n + 5) % 8, 0 == n ? (a |= r, c[d] = a, d++, a = 0) : a |= 255 & r << 8 - n) : (n = (n + 5) % 8, a |= 255 & r >>> n, c[d] = a, d++, a = 255 & r << 8 - n);
            else
              throw new Error("Invalid input - it is not base32 encoded string");
          }
          return c.slice(0, d);
        };
      }).call(this, e("buffer").Buffer);
    }, {buffer: 25}],
    109: [function(e, t) {
      var n = e("buffer").Buffer;
      t.exports = function(e) {
        if (e instanceof Uint8Array) {
          if (0 === e.byteOffset && e.byteLength === e.buffer.byteLength)
            return e.buffer;
          if ("function" == typeof e.buffer.slice)
            return e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);
        }
        if (n.isBuffer(e)) {
          for (var t = new Uint8Array(e.length),
              r = e.length,
              o = 0; o < r; o++)
            t[o] = e[o];
          return t.buffer;
        }
        throw new Error("Argument must be a Buffer");
      };
    }, {buffer: 25}],
    110: [function(e, t) {
      (function(n) {
        function o(e) {
          function t(e, t) {
            var n = new i(t);
            return n.on("warning", r._onWarning), n.on("error", r._onError), n.listen(e), r._internalDHT = !0, n;
          }
          var r = this;
          if (!(r instanceof o))
            return new o(e);
          if (d.call(r), !e.peerId)
            throw new Error("Option `peerId` is required");
          if (!e.infoHash)
            throw new Error("Option `infoHash` is required");
          if (!n.browser && !e.port)
            throw new Error("Option `port` is required");
          r.peerId = "string" == typeof e.peerId ? e.peerId : e.peerId.toString("hex"), r.infoHash = "string" == typeof e.infoHash ? e.infoHash : e.infoHash.toString("hex"), r._port = e.port, r._userAgent = e.userAgent, r.destroyed = !1, r._announce = e.announce || [], r._intervalMs = e.intervalMs || 900000, r._trackerOpts = null, r._dhtAnnouncing = !1, r._dhtTimeout = !1, r._internalDHT = !1, r._onWarning = function(e) {
            r.emit("warning", e);
          }, r._onError = function(e) {
            r.emit("error", e);
          }, r._onDHTPeer = function(e, t) {
            t.toString("hex") !== r.infoHash || r.emit("peer", e.host + ":" + e.port, "dht");
          }, r._onTrackerPeer = function(e) {
            r.emit("peer", e, "tracker");
          }, r._onTrackerAnnounce = function() {
            r.emit("trackerAnnounce");
          }, !1 === e.tracker ? r.tracker = null : e.tracker && "object" == typeof e.tracker ? (r._trackerOpts = a(e.tracker), r.tracker = r._createTracker()) : r.tracker = r._createTracker(), r.dht = !1 === e.dht || "function" != typeof i ? null : e.dht && "function" == typeof e.dht.addNode ? e.dht : e.dht && "object" == typeof e.dht ? t(e.dhtPort, e.dht) : t(e.dhtPort), r.dht && (r.dht.on("peer", r._onDHTPeer), r._dhtAnnounce());
        }
        t.exports = o;
        var s = e("debug")("torrent-discovery"),
            i = e("bittorrent-dht/client"),
            d = e("events").EventEmitter,
            a = e("xtend"),
            c = e("inherits"),
            l = e("run-parallel"),
            p = e("bittorrent-tracker/client");
        c(o, d), o.prototype.updatePort = function(e) {
          var t = this;
          e === t._port || (t._port = e, t.dht && t._dhtAnnounce(), t.tracker && (t.tracker.stop(), t.tracker.destroy(function() {
            t.tracker = t._createTracker();
          })));
        }, o.prototype.complete = function(e) {
          this.tracker && this.tracker.complete(e);
        }, o.prototype.destroy = function(e) {
          var t = this;
          if (!t.destroyed) {
            t.destroyed = !0, clearTimeout(t._dhtTimeout);
            var n = [];
            t.tracker && (t.tracker.stop(), t.tracker.removeListener("warning", t._onWarning), t.tracker.removeListener("error", t._onError), t.tracker.removeListener("peer", t._onTrackerPeer), t.tracker.removeListener("update", t._onTrackerAnnounce), n.push(function(e) {
              t.tracker.destroy(e);
            })), t.dht && t.dht.removeListener("peer", t._onDHTPeer), t._internalDHT && (t.dht.removeListener("warning", t._onWarning), t.dht.removeListener("error", t._onError), n.push(function(e) {
              t.dht.destroy(e);
            })), l(n, e), t.dht = null, t.tracker = null, t._announce = null;
          }
        }, o.prototype._createTracker = function() {
          var e = a(this._trackerOpts, {
            infoHash: this.infoHash,
            announce: this._announce,
            peerId: this.peerId,
            port: this._port,
            userAgent: this._userAgent
          }),
              t = new p(e);
          return t.on("warning", this._onWarning), t.on("error", this._onError), t.on("peer", this._onTrackerPeer), t.on("update", this._onTrackerAnnounce), t.setInterval(this._intervalMs), t.start(), t;
        }, o.prototype._dhtAnnounce = function() {
          function e() {
            return t._intervalMs + r(Math.random() * t._intervalMs / 5);
          }
          var t = this;
          t._dhtAnnouncing || (s("dht announce"), t._dhtAnnouncing = !0, clearTimeout(t._dhtTimeout), t.dht.announce(t.infoHash, t._port, function(n) {
            t._dhtAnnouncing = !1, s("dht announce complete"), n && t.emit("warning", n), t.emit("dhtAnnounce"), t.destroyed || (t._dhtTimeout = setTimeout(function() {
              t._dhtAnnounce();
            }, e()), t._dhtTimeout.unref && t._dhtTimeout.unref());
          }));
        };
      }).call(this, e("_process"));
    }, {
      _process: 67,
      "bittorrent-dht/client": 23,
      "bittorrent-tracker/client": 17,
      debug: 31,
      events: 35,
      inherits: 42,
      "run-parallel": 90,
      xtend: 126
    }],
    111: [function(e, t) {
      (function(e) {
        function n(e) {
          return this instanceof n ? void(this.length = e, this.missing = e, this.sources = null, this._chunks = s(e / r), this._remainder = e % r || r, this._buffered = 0, this._buffer = null, this._cancellations = null, this._reservations = 0, this._flushed = !1) : new n(e);
        }
        t.exports = n;
        var r = 16384;
        n.BLOCK_LENGTH = r, n.prototype.chunkLength = function(e) {
          return e === this._chunks - 1 ? this._remainder : r;
        }, n.prototype.chunkLengthRemaining = function(e) {
          return this.length - e * r;
        }, n.prototype.chunkOffset = function(e) {
          return e * r;
        }, n.prototype.reserve = function() {
          return this.init() ? this._cancellations.length ? this._cancellations.pop() : this._reservations < this._chunks ? this._reservations++ : -1 : -1;
        }, n.prototype.reserveRemaining = function() {
          if (!this.init())
            return -1;
          if (this._reservations < this._chunks) {
            var e = this._reservations;
            return this._reservations = this._chunks, e;
          }
          return -1;
        }, n.prototype.cancel = function(e) {
          this.init() && this._cancellations.push(e);
        }, n.prototype.cancelRemaining = function(e) {
          this.init() && (this._reservations = e);
        }, n.prototype.get = function(e) {
          return this.init() ? this._buffer[e] : null;
        }, n.prototype.set = function(e, t, n) {
          if (!this.init())
            return !1;
          for (var o = t.length,
              i = s(o / r),
              d = 0; d < i; d++)
            if (!this._buffer[e + d]) {
              var a = d * r,
                  c = t.slice(a, a + r);
              this._buffered++, this._buffer[e + d] = c, this.missing -= c.length, -1 === this.sources.indexOf(n) && this.sources.push(n);
            }
          return this._buffered === this._chunks;
        }, n.prototype.flush = function() {
          if (!this._buffer || this._chunks !== this._buffered)
            return null;
          var t = e.concat(this._buffer, this.length);
          return this._buffer = null, this._cancellations = null, this.sources = null, this._flushed = !0, t;
        }, n.prototype.init = function() {
          return !this._flushed && (!!this._buffer || (this._buffer = Array(this._chunks), this._cancellations = [], this.sources = [], !0));
        };
      }).call(this, e("buffer").Buffer);
    }, {buffer: 25}],
    112: [function(e, t) {
      (function(n) {
        var r = e("is-typedarray").strict;
        t.exports = function(e) {
          if (r(e)) {
            var t = new n(e.buffer);
            return e.byteLength !== e.buffer.byteLength && (t = t.slice(e.byteOffset, e.byteOffset + e.byteLength)), t;
          }
          return new n(e);
        };
      }).call(this, e("buffer").Buffer);
    }, {
      buffer: 25,
      "is-typedarray": 46
    }],
    113: [function(e, t, n) {
      (function(e) {
        var t = 4294967295;
        n.encodingLength = function() {
          return 8;
        }, n.encode = function(n, o, s) {
          o || (o = new e(8)), s || (s = 0);
          var i = r(n / t);
          return o.writeUInt32BE(i, s), o.writeUInt32BE(n - i * t, s + 4), o;
        }, n.decode = function(n, r) {
          r || (r = 0), n || (n = new e(4)), r || (r = 0);
          var o = n.readUInt32BE(r),
              s = n.readUInt32BE(r + 4);
          return o * t + s;
        }, n.encode.bytes = 8, n.decode.bytes = 8;
      }).call(this, e("buffer").Buffer);
    }, {buffer: 25}],
    114: [function(e, t) {
      "use strict";
      function n(e, t) {
        for (var n = 1,
            r = e.length,
            o = e[0],
            s = e[0],
            d = 1; d < r; ++d)
          if (s = o, o = e[d], t(o, s)) {
            if (d === n) {
              n++;
              continue;
            }
            e[n++] = o;
          }
        return e.length = n, e;
      }
      function r(e) {
        for (var t = 1,
            n = e.length,
            r = e[0],
            o = e[0],
            s = 1; s < n; ++s, o = r)
          if (o = r, r = e[s], r !== o) {
            if (s === t) {
              t++;
              continue;
            }
            e[t++] = r;
          }
        return e.length = t, e;
      }
      t.exports = function(e, t, o) {
        return 0 === e.length ? e : t ? (o || e.sort(t), n(e, t)) : (o || e.sort(), r(e));
      };
    }, {}],
    115: [function(e, t) {
      t.exports = function(e, t) {
        if (!(t >= e.length || 0 > t)) {
          var n = e.pop();
          if (t < e.length) {
            var r = e[t];
            return e[t] = n, r;
          }
          return n;
        }
      };
    }, {}],
    116: [function(e, t, n) {
      "use strict";
      function r() {
        this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
      }
      function o(e, t, n) {
        if (e && d.isObject(e) && e instanceof r)
          return e;
        var o = new r;
        return o.parse(e, t, n), o;
      }
      var s = e("punycode"),
          d = e("./util");
      n.parse = o, n.resolve = function(e, t) {
        return o(e, !1, !0).resolve(t);
      }, n.resolveObject = function(e, t) {
        return e ? o(e, !1, !0).resolveObject(t) : t;
      }, n.format = function(e) {
        return d.isString(e) && (e = o(e)), e instanceof r ? e.format() : r.prototype.format.call(e);
      }, n.Url = r;
      var a = /^([a-z0-9.+-]+:)/i,
          i = /:[0-9]*$/,
          c = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
          l = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", "\"", "`", " ", "\r", "\n", "\t"]),
          p = ["'"].concat(l),
          u = ["%", "/", "?", ";", "#"].concat(p),
          f = ["/", "?", "#"],
          h = /^[+a-z0-9A-Z_-]{0,63}$/,
          m = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
          g = {
            javascript: !0,
            "javascript:": !0
          },
          _ = {
            javascript: !0,
            "javascript:": !0
          },
          y = {
            http: !0,
            https: !0,
            ftp: !0,
            gopher: !0,
            file: !0,
            "http:": !0,
            "https:": !0,
            "ftp:": !0,
            "gopher:": !0,
            "file:": !0
          },
          b = e("querystring");
      r.prototype.parse = function(e, t, n) {
        if (!d.isString(e))
          throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
        var r = e.indexOf("?"),
            o = -1 !== r && r < e.indexOf("#") ? "?" : "#",
            w = e.split(o),
            x = /\\/g;
        w[0] = w[0].replace(x, "/"), e = w.join(o);
        var v = e;
        if (v = v.trim(), !n && 1 === e.split("#").length) {
          var S = c.exec(v);
          if (S)
            return this.path = v, this.href = v, this.pathname = S[1], S[2] ? (this.search = S[2], this.query = t ? b.parse(this.search.substr(1)) : this.search.substr(1)) : t && (this.search = "", this.query = {}), this;
        }
        var C = a.exec(v);
        if (C) {
          C = C[0];
          var E = C.toLowerCase();
          this.protocol = E, v = v.substr(C.length);
        }
        if (n || C || v.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          var B = "//" === v.substr(0, 2);
          B && !(C && _[C]) && (v = v.substr(2), this.slashes = !0);
        }
        if (!_[C] && (B || C && !y[C])) {
          for (var I = -1,
              L = 0,
              i; L < f.length; L++)
            i = v.indexOf(f[L]), -1 !== i && (-1 == I || i < I) && (I = i);
          var T,
              A;
          A = -1 === I ? v.lastIndexOf("@") : v.lastIndexOf("@", I), -1 !== A && (T = v.slice(0, A), v = v.slice(A + 1), this.auth = decodeURIComponent(T)), I = -1;
          for (var L = 0,
              i; L < u.length; L++)
            i = v.indexOf(u[L]), -1 !== i && (-1 === I || i < I) && (I = i);
          -1 === I && (I = v.length), this.host = v.slice(0, I), v = v.slice(I), this.parseHost(), this.hostname = this.hostname || "";
          var U = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
          if (!U)
            for (var R = this.hostname.split(/\./),
                L = 0,
                P = R.length,
                l; L < P; L++)
              if (l = R[L], l && !l.match(h)) {
                for (var O = "",
                    H = 0,
                    M = l.length; H < M; H++)
                  O += 127 < l.charCodeAt(H) ? "x" : l[H];
                if (!O.match(h)) {
                  var k = R.slice(0, L),
                      q = R.slice(L + 1),
                      j = l.match(m);
                  j && (k.push(j[1]), q.unshift(j[2])), q.length && (v = "/" + q.join(".") + v), this.hostname = k.join(".");
                  break;
                }
              }
          this.hostname = this.hostname.length > 255 ? "" : this.hostname.toLowerCase(), U || (this.hostname = s.toASCII(this.hostname));
          var F = this.port ? ":" + this.port : "",
              N = this.hostname || "";
          this.host = N + F, this.href += this.host, U && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== v[0] && (v = "/" + v));
        }
        if (!g[E])
          for (var L = 0,
              P = p.length,
              D; L < P; L++)
            if (D = p[L], -1 !== v.indexOf(D)) {
              var W = encodeURIComponent(D);
              W === D && (W = escape(D)), v = v.split(D).join(W);
            }
        var z = v.indexOf("#");
        -1 !== z && (this.hash = v.substr(z), v = v.slice(0, z));
        var V = v.indexOf("?");
        if (-1 === V ? t && (this.search = "", this.query = {}) : (this.search = v.substr(V), this.query = v.substr(V + 1), t && (this.query = b.parse(this.query)), v = v.slice(0, V)), v && (this.pathname = v), y[E] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
          var F = this.pathname || "",
              G = this.search || "";
          this.path = F + G;
        }
        return this.href = this.format(), this;
      }, r.prototype.format = function() {
        var e = this.auth || "";
        e && (e = encodeURIComponent(e), e = e.replace(/%3A/i, ":"), e += "@");
        var t = this.protocol || "",
            n = this.pathname || "",
            r = this.hash || "",
            o = !1,
            s = "";
        this.host ? o = e + this.host : this.hostname && (o = e + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (o += ":" + this.port)), this.query && d.isObject(this.query) && Object.keys(this.query).length && (s = b.stringify(this.query));
        var i = this.search || s && "?" + s || "";
        return t && ":" !== t.substr(-1) && (t += ":"), this.slashes || (!t || y[t]) && !1 !== o ? (o = "//" + (o || ""), n && "/" !== n.charAt(0) && (n = "/" + n)) : !o && (o = ""), r && "#" !== r.charAt(0) && (r = "#" + r), i && "?" !== i.charAt(0) && (i = "?" + i), n = n.replace(/[?#]/g, function(e) {
          return encodeURIComponent(e);
        }), i = i.replace("#", "%23"), t + o + n + i + r;
      }, r.prototype.resolve = function(e) {
        return this.resolveObject(o(e, !1, !0)).format();
      }, r.prototype.resolveObject = function(e) {
        if (d.isString(e)) {
          var t = new r;
          t.parse(e, !1, !0), e = t;
        }
        for (var n = new r,
            o = Object.keys(this),
            a = 0,
            c; a < o.length; a++)
          c = o[a], n[c] = this[c];
        if (n.hash = e.hash, "" === e.href)
          return n.href = n.format(), n;
        if (e.slashes && !e.protocol) {
          for (var l = Object.keys(e),
              u = 0,
              f; u < l.length; u++)
            f = l[u], "protocol" !== f && (n[f] = e[f]);
          return y[n.protocol] && n.hostname && !n.pathname && (n.path = n.pathname = "/"), n.href = n.format(), n;
        }
        if (e.protocol && e.protocol !== n.protocol) {
          if (!y[e.protocol]) {
            for (var h = Object.keys(e),
                m = 0,
                g; m < h.length; m++)
              g = h[m], n[g] = e[g];
            return n.href = n.format(), n;
          }
          if (n.protocol = e.protocol, !e.host && !_[e.protocol]) {
            for (var b = (e.pathname || "").split("/"); b.length && !(e.host = b.shift()); )
              ;
            e.host || (e.host = ""), e.hostname || (e.hostname = ""), "" !== b[0] && b.unshift(""), 2 > b.length && b.unshift(""), n.pathname = b.join("/");
          } else
            n.pathname = e.pathname;
          if (n.search = e.search, n.query = e.query, n.host = e.host || "", n.auth = e.auth, n.hostname = e.hostname || e.host, n.port = e.port, n.pathname || n.search) {
            var w = n.pathname || "",
                p = n.search || "";
            n.path = w + p;
          }
          return n.slashes = n.slashes || e.slashes, n.href = n.format(), n;
        }
        var s = n.pathname && "/" === n.pathname.charAt(0),
            k = e.host || e.pathname && "/" === e.pathname.charAt(0),
            x = k || s || n.host && e.pathname,
            v = x,
            S = n.pathname && n.pathname.split("/") || [],
            b = e.pathname && e.pathname.split("/") || [],
            C = n.protocol && !y[n.protocol];
        if (C && (n.hostname = "", n.port = null, n.host && ("" === S[0] ? S[0] = n.host : S.unshift(n.host)), n.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && ("" === b[0] ? b[0] = e.host : b.unshift(e.host)), e.host = null), x = x && ("" === b[0] || "" === S[0])), k)
          n.host = e.host || "" === e.host ? e.host : n.host, n.hostname = e.hostname || "" === e.hostname ? e.hostname : n.hostname, n.search = e.search, n.query = e.query, S = b;
        else if (b.length)
          S || (S = []), S.pop(), S = S.concat(b), n.search = e.search, n.query = e.query;
        else if (!d.isNullOrUndefined(e.search)) {
          if (C) {
            n.hostname = n.host = S.shift();
            var E = n.host && 0 < n.host.indexOf("@") && n.host.split("@");
            E && (n.auth = E.shift(), n.host = n.hostname = E.shift());
          }
          return n.search = e.search, n.query = e.query, d.isNull(n.pathname) && d.isNull(n.search) || (n.path = (n.pathname ? n.pathname : "") + (n.search ? n.search : "")), n.href = n.format(), n;
        }
        if (!S.length)
          return n.pathname = null, n.path = n.search ? "/" + n.search : null, n.href = n.format(), n;
        for (var B = S.slice(-1)[0],
            I = (n.host || e.host || 1 < S.length) && ("." === B || ".." === B) || "" === B,
            L = 0,
            T = S.length; 0 <= T; T--)
          B = S[T], "." === B ? S.splice(T, 1) : ".." === B ? (S.splice(T, 1), L++) : L && (S.splice(T, 1), L--);
        if (!x && !v)
          for (; L--; L)
            S.unshift("..");
        x && "" !== S[0] && (!S[0] || "/" !== S[0].charAt(0)) && S.unshift(""), I && "/" !== S.join("/").substr(-1) && S.push("");
        var i = "" === S[0] || S[0] && "/" === S[0].charAt(0);
        if (C) {
          n.hostname = n.host = i ? "" : S.length ? S.shift() : "";
          var E = n.host && 0 < n.host.indexOf("@") && n.host.split("@");
          E && (n.auth = E.shift(), n.host = n.hostname = E.shift());
        }
        return x = x || n.host && S.length, x && !i && S.unshift(""), S.length ? n.pathname = S.join("/") : (n.pathname = null, n.path = null), d.isNull(n.pathname) && d.isNull(n.search) || (n.path = (n.pathname ? n.pathname : "") + (n.search ? n.search : "")), n.auth = e.auth || n.auth, n.slashes = n.slashes || e.slashes, n.href = n.format(), n;
      }, r.prototype.parseHost = function() {
        var e = this.host,
            t = i.exec(e);
        t && (t = t[0], ":" !== t && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e);
      };
    }, {
      "./util": 117,
      punycode: 69,
      querystring: 72
    }],
    117: [function(e, t) {
      "use strict";
      t.exports = {
        isString: function(e) {
          return "string" == typeof e;
        },
        isObject: function(e) {
          return "object" == typeof e && null !== e;
        },
        isNull: function(e) {
          return null === e;
        },
        isNullOrUndefined: function(e) {
          return null == e;
        }
      };
    }, {}],
    118: [function(e, t) {
      var n = e("bencode"),
          r = e("bitfield"),
          o = e("safe-buffer").Buffer,
          i = e("debug")("ut_metadata"),
          d = e("events").EventEmitter,
          a = e("inherits"),
          c = e("simple-sha1"),
          l = 1e3,
          p = 16384;
      t.exports = function(e) {
        function t(t) {
          d.call(this), this._wire = t, this._metadataComplete = !1, this._metadataSize = null, this._remainingRejects = null, this._fetching = !1, this._bitfield = new r(0, {grow: l}), o.isBuffer(e) && this.setMetadata(e);
        }
        return a(t, d), t.prototype.name = "ut_metadata", t.prototype.onHandshake = function(e) {
          this._infoHash = e;
        }, t.prototype.onExtendedHandshake = function(e) {
          return e.m && e.m.ut_metadata ? e.metadata_size ? "number" != typeof e.metadata_size || 1e7 < e.metadata_size || 0 >= e.metadata_size ? this.emit("warning", new Error("Peer gave invalid metadata size")) : void(this._metadataSize = e.metadata_size, this._numPieces = s(this._metadataSize / p), this._remainingRejects = 2 * this._numPieces, this._fetching && this._requestPieces()) : this.emit("warning", new Error("Peer does not have metadata")) : this.emit("warning", new Error("Peer does not support ut_metadata"));
        }, t.prototype.onMessage = function(e) {
          var t,
              r;
          try {
            var o = e.toString(),
                s = o.indexOf("ee") + 2;
            t = n.decode(o.substring(0, s)), r = e.slice(s);
          } catch (e) {
            return;
          }
          switch (t.msg_type) {
            case 0:
              this._onRequest(t.piece);
              break;
            case 1:
              this._onData(t.piece, r, t.total_size);
              break;
            case 2:
              this._onReject(t.piece);
          }
        }, t.prototype.fetch = function() {
          this._metadataComplete || (this._fetching = !0, this._metadataSize && this._requestPieces());
        }, t.prototype.cancel = function() {
          this._fetching = !1;
        }, t.prototype.setMetadata = function(e) {
          if (this._metadataComplete)
            return !0;
          i("set metadata");
          try {
            var t = n.decode(e).info;
            t && (e = n.encode(t));
          } catch (e) {}
          return this._infoHash && this._infoHash !== c.sync(e) ? !1 : (this.cancel(), this.metadata = e, this._metadataComplete = !0, this._metadataSize = this.metadata.length, this._wire.extendedHandshake.metadata_size = this._metadataSize, this.emit("metadata", n.encode({info: n.decode(this.metadata)})), !0);
        }, t.prototype._send = function(e, t) {
          var r = n.encode(e);
          o.isBuffer(t) && (r = o.concat([r, t])), this._wire.extended("ut_metadata", r);
        }, t.prototype._request = function(e) {
          this._send({
            msg_type: 0,
            piece: e
          });
        }, t.prototype._data = function(e, t, n) {
          var r = {
            msg_type: 1,
            piece: e
          };
          "number" == typeof n && (r.total_size = n), this._send(r, t);
        }, t.prototype._reject = function(e) {
          this._send({
            msg_type: 2,
            piece: e
          });
        }, t.prototype._onRequest = function(e) {
          if (!this._metadataComplete)
            return void this._reject(e);
          var t = e * p,
              n = t + p;
          n > this._metadataSize && (n = this._metadataSize);
          var r = this.metadata.slice(t, n);
          this._data(e, r, this._metadataSize);
        }, t.prototype._onData = function(e, t) {
          t.length > p || (t.copy(this.metadata, e * p), this._bitfield.set(e), this._checkDone());
        }, t.prototype._onReject = function(e) {
          0 < this._remainingRejects && this._fetching ? (this._request(e), this._remainingRejects -= 1) : this.emit("warning", new Error("Peer sent \"reject\" too much"));
        }, t.prototype._requestPieces = function() {
          this.metadata = o.alloc(this._metadataSize);
          for (var e = 0; e < this._numPieces; e++)
            this._request(e);
        }, t.prototype._checkDone = function() {
          for (var e = !0,
              t = 0; t < this._numPieces; t++)
            if (!this._bitfield.get(t)) {
              e = !1;
              break;
            }
          if (e) {
            var n = this.setMetadata(this.metadata);
            n || this._failedMetadata();
          }
        }, t.prototype._failedMetadata = function() {
          this._bitfield = new r(0, {grow: l}), this._remainingRejects -= this._numPieces, 0 < this._remainingRejects ? this._requestPieces() : this.emit("warning", new Error("Peer sent invalid metadata"));
        }, t;
      };
    }, {
      bencode: 11,
      bitfield: 13,
      debug: 119,
      events: 35,
      inherits: 42,
      "safe-buffer": 92,
      "simple-sha1": 96
    }],
    119: [function(e, t, n) {
      arguments[4][15][0].apply(n, arguments);
    }, {
      "./debug": 120,
      _process: 67,
      dup: 15
    }],
    120: [function(e, t, n) {
      arguments[4][16][0].apply(n, arguments);
    }, {
      dup: 16,
      ms: 58
    }],
    121: [function(e, t) {
      (function(e) {
        function n(t) {
          try {
            if (!e.localStorage)
              return !1;
          } catch (e) {
            return !1;
          }
          var n = e.localStorage[t];
          return null != n && "true" === (n + "").toLowerCase();
        }
        t.exports = function(e, t) {
          if (n("noDeprecation"))
            return e;
          var r = !1;
          return function() {
            if (!r) {
              if (n("throwDeprecation"))
                throw new Error(t);
              else
                n("traceDeprecation") ? console.trace(t) : console.warn(t);
              r = !0;
            }
            return e.apply(this, arguments);
          };
        };
      }).call(this, "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
    }, {}],
    122: [function(e, t) {
      (function(n) {
        function o(e) {
          var t = this;
          a.call(t), t._tracks = [], t._fragmentSequence = 1, t._file = e, t._decoder = null, t._findMoov(0);
        }
        function s(e, t) {
          var n = this;
          n._entries = e, n._countName = t || "count", n._index = 0, n._offset = 0, n.value = n._entries[0];
        }
        function d() {
          return {
            version: 0,
            flags: 0,
            entries: []
          };
        }
        var i = e("binary-search"),
            a = e("events").EventEmitter,
            c = e("inherits"),
            l = e("mp4-stream"),
            p = e("mp4-box-encoding"),
            u = e("range-slice-stream");
        t.exports = o, c(o, a), o.prototype._findMoov = function(e) {
          var t = this;
          t._decoder && t._decoder.destroy(), t._decoder = l.decode();
          var n = t._file.createReadStream({start: e});
          n.pipe(t._decoder), t._decoder.once("box", function(r) {
            "moov" === r.type ? t._decoder.decode(function(e) {
              n.destroy();
              try {
                t._processMoov(e);
              } catch (e) {
                e.message = "Cannot parse mp4 file: " + e.message, t.emit("error", e);
              }
            }) : (n.destroy(), t._findMoov(e + r.length));
          });
        }, s.prototype.inc = function() {
          var e = this;
          e._offset++, e._offset >= e._entries[e._index][e._countName] && (e._index++, e._offset = 0), e.value = e._entries[e._index];
        }, o.prototype._processMoov = function(e) {
          var t = this,
              r = e.traks;
          t._tracks = [], t._hasVideo = !1, t._hasAudio = !1;
          for (var o = 0; o < r.length; o++) {
            var i = r[o],
                a = i.mdia.minf.stbl,
                c = a.stsd.entries[0],
                l = i.mdia.hdlr.handlerType,
                u,
                f;
            if ("vide" === l && "avc1" === c.type) {
              if (t._hasVideo)
                continue;
              t._hasVideo = !0, u = "avc1", c.avcC && (u += "." + c.avcC.mimeCodec), f = "video/mp4; codecs=\"" + u + "\"";
            } else if ("soun" === l && "mp4a" === c.type) {
              if (t._hasAudio)
                continue;
              t._hasAudio = !0, u = "mp4a", c.esds && c.esds.mimeCodec && (u += "." + c.esds.mimeCodec), f = "audio/mp4; codecs=\"" + u + "\"";
            } else
              continue;
            var h = [],
                m = 0,
                g = 0,
                _ = 0,
                y = 0,
                b = 0,
                w = 0,
                k = new s(a.stts.entries),
                x = null;
            a.ctts && (x = new s(a.ctts.entries));
            for (var v = 0; ; ) {
              var S = a.stsc.entries[b],
                  C = a.stsz.entries[m],
                  E = k.value.duration,
                  B = x ? x.value.compositionOffset : 0,
                  I = !0;
              if (a.stss && (I = a.stss.entries[v] === m + 1), h.push({
                size: C,
                duration: E,
                dts: w,
                presentationOffset: B,
                sync: I,
                offset: y + a.stco.entries[_]
              }), m++, m >= a.stsz.entries.length)
                break;
              if (g++, y += C, g >= S.samplesPerChunk) {
                g = 0, y = 0, _++;
                var L = a.stsc.entries[b + 1];
                L && _ + 1 >= L.firstChunk && b++;
              }
              w += E, k.inc(), x && x.inc(), I && v++;
            }
            i.mdia.mdhd.duration = 0, i.tkhd.duration = 0;
            var T = S.sampleDescriptionId,
                A = {
                  type: "moov",
                  mvhd: e.mvhd,
                  traks: [{
                    tkhd: i.tkhd,
                    mdia: {
                      mdhd: i.mdia.mdhd,
                      hdlr: i.mdia.hdlr,
                      elng: i.mdia.elng,
                      minf: {
                        vmhd: i.mdia.minf.vmhd,
                        smhd: i.mdia.minf.smhd,
                        dinf: i.mdia.minf.dinf,
                        stbl: {
                          stsd: a.stsd,
                          stts: d(),
                          ctts: d(),
                          stsc: d(),
                          stsz: d(),
                          stco: d(),
                          stss: d()
                        }
                      }
                    }
                  }],
                  mvex: {
                    mehd: {fragmentDuration: e.mvhd.duration},
                    trexs: [{
                      trackId: i.tkhd.trackId,
                      defaultSampleDescriptionIndex: T,
                      defaultSampleDuration: 0,
                      defaultSampleSize: 0,
                      defaultSampleFlags: 0
                    }]
                  }
                };
            t._tracks.push({
              trackId: i.tkhd.trackId,
              timeScale: i.mdia.mdhd.timeScale,
              samples: h,
              currSample: null,
              currTime: null,
              moov: A,
              mime: f
            });
          }
          if (0 === t._tracks.length)
            return void t.emit("error", new Error("no playable tracks"));
          e.mvhd.duration = 0, t._ftyp = {
            type: "ftyp",
            brand: "iso5",
            brandVersion: 0,
            compatibleBrands: ["iso5"]
          };
          var U = p.encode(t._ftyp),
              R = t._tracks.map(function(e) {
                var t = p.encode(e.moov);
                return {
                  mime: e.mime,
                  init: n.concat([U, t])
                };
              });
          t.emit("ready", R);
        }, o.prototype.seek = function(e) {
          var t = this;
          if (!t._tracks)
            throw new Error("Not ready yet; wait for 'ready' event");
          t._fileStream && (t._fileStream.destroy(), t._fileStream = null);
          var n = -1;
          if (t._tracks.map(function(r, o) {
            function s(e) {
              i.destroyed || i.box(e.moof, function(n) {
                if (n)
                  return t.emit("error", n);
                if (!i.destroyed) {
                  var d = r.inStream.slice(e.ranges);
                  d.pipe(i.mediaData(e.length, function(e) {
                    if (e)
                      return t.emit("error", e);
                    if (!i.destroyed) {
                      var n = t._generateFragment(o);
                      return n ? void s(n) : i.finalize();
                    }
                  }));
                }
              });
            }
            r.outStream && r.outStream.destroy(), r.inStream && (r.inStream.destroy(), r.inStream = null);
            var i = r.outStream = l.encode(),
                d = t._generateFragment(o, e);
            return d ? void((-1 == n || d.ranges[0].start < n) && (n = d.ranges[0].start), s(d)) : i.finalize();
          }), 0 <= n) {
            var r = t._fileStream = t._file.createReadStream({start: n});
            t._tracks.forEach(function(e) {
              e.inStream = new u(n, {highWaterMark: 1e7}), r.pipe(e.inStream);
            });
          }
          return t._tracks.map(function(e) {
            return e.outStream;
          });
        }, o.prototype._findSampleBefore = function(e, t) {
          var n = this,
              o = n._tracks[e],
              s = r(o.timeScale * t),
              d = i(o.samples, s, function(e, n) {
                var t = e.dts + e.presentationOffset;
                return t - n;
              });
          for (-1 === d ? d = 0 : 0 > d && (d = -d - 2); !o.samples[d].sync; )
            d--;
          return d;
        };
        o.prototype._generateFragment = function(e, t) {
          var n = this,
              r = n._tracks[e],
              o;
          if (o = void 0 === t ? r.currSample : n._findSampleBefore(e, t), o >= r.samples.length)
            return null;
          for (var s = r.samples[o].dts,
              i = 0,
              d = [],
              a = o,
              c; a < r.samples.length && (c = r.samples[a], !(c.sync && c.dts - s >= r.timeScale * 1)); a++) {
            i += c.size;
            var l = d.length - 1;
            0 > l || d[l].end !== c.offset ? d.push({
              start: c.offset,
              end: c.offset + c.size
            }) : d[l].end += c.size;
          }
          return r.currSample = a, {
            moof: n._generateMoof(e, o, a),
            ranges: d,
            length: i
          };
        }, o.prototype._generateMoof = function(e, t, n) {
          for (var r = this,
              o = r._tracks[e],
              s = [],
              i = t,
              d; i < n; i++)
            d = o.samples[i], s.push({
              sampleDuration: d.duration,
              sampleSize: d.size,
              sampleFlags: d.sync ? 33554432 : 16842752,
              sampleCompositionTimeOffset: d.presentationOffset
            });
          var a = {
            type: "moof",
            mfhd: {sequenceNumber: r._fragmentSequence++},
            trafs: [{
              tfhd: {
                flags: 131072,
                trackId: o.trackId
              },
              tfdt: {baseMediaDecodeTime: o.samples[t].dts},
              trun: {
                flags: 3841,
                dataOffset: 8,
                entries: s
              }
            }]
          };
          return a.trafs[0].trun.dataOffset += p.encodingLength(a), a;
        };
      }).call(this, e("buffer").Buffer);
    }, {
      "binary-search": 12,
      buffer: 25,
      events: 35,
      inherits: 42,
      "mp4-box-encoding": 54,
      "mp4-stream": 57,
      "range-slice-stream": 75
    }],
    123: [function(e, t) {
      var n = e("once"),
          r = e("end-of-stream"),
          o = e("fs"),
          s = function() {},
          i = function(e) {
            return "function" == typeof e;
          },
          d = function(e) {
            return !!o && (e instanceof (o.ReadStream || s) || e instanceof (o.WriteStream || s)) && i(e.close);
          },
          a = function(e) {
            return e.setHeader && i(e.abort);
          },
          c = function(e, t, o, c) {
            c = n(c);
            var l = !1;
            e.on("close", function() {
              l = !0;
            }), r(e, {
              readable: t,
              writable: o
            }, function(e) {
              return e ? c(e) : void(l = !0, c());
            });
            var p = !1;
            return function(t) {
              if (!l)
                return p ? void 0 : (p = !0, d(e) ? e.close(s) : a(e) ? e.abort() : i(e.destroy) ? e.destroy() : void c(t || new Error("stream was destroyed")));
            };
          },
          l = function(e) {
            e();
          },
          p = function(e, t) {
            return e.pipe(t);
          };
      t.exports = function() {
        var e = Array.prototype.slice.call(arguments),
            t = i(e[e.length - 1] || s) && e.pop() || s;
        if (Array.isArray(e[0]) && (e = e[0]), 2 > e.length)
          throw new Error("pump requires two streams per minimum");
        var n = e.map(function(o, s) {
          var i = s < e.length - 1;
          return c(o, i, 0 < s, function(e) {
            r || (r = e), e && n.forEach(l), i || (n.forEach(l), t(r));
          });
        }),
            r;
        return e.reduce(p);
      };
    }, {
      "end-of-stream": 34,
      fs: 23,
      once: 61
    }],
    124: [function(e, t) {
      function n(e, t, o) {
        var s = this;
        return this instanceof n ? void(o = o || {}, s.detailedError = null, s._elem = t, s._elemWrapper = new r(t), s._waitingFired = !1, s._trackMeta = null, s._file = e, s._tracks = null, "none" !== s._elem.preload && s._createMuxer(), s._onError = function() {
          s.detailedError = s._elemWrapper.detailedError, s.destroy();
        }, s._onWaiting = function() {
          s._waitingFired = !0, s._muxer ? s._tracks && s._pump() : s._createMuxer();
        }, s._elem.addEventListener("waiting", s._onWaiting), s._elem.addEventListener("error", s._onError)) : new n(e, t, o);
      }
      var r = e("mediasource"),
          o = e("pump"),
          s = e("./mp4-remuxer");
      t.exports = n, n.prototype._createMuxer = function() {
        var e = this;
        e._muxer = new s(e._file), e._muxer.on("ready", function(t) {
          e._tracks = t.map(function(t) {
            var n = e._elemWrapper.createWriteStream(t.mime);
            n.on("error", function(t) {
              e._elemWrapper.error(t);
            });
            var r = {
              muxed: null,
              mediaSource: n,
              initFlushed: !1,
              onInitFlushed: null
            };
            return n.write(t.init, function(e) {
              r.initFlushed = !0, r.onInitFlushed && r.onInitFlushed(e);
            }), r;
          }), (e._waitingFired || "auto" === e._elem.preload) && e._pump();
        }), e._muxer.on("error", function(t) {
          e._elemWrapper.error(t);
        });
      }, n.prototype._pump = function() {
        var e = this,
            t = e._muxer.seek(e._elem.currentTime, !e._tracks);
        e._tracks.forEach(function(n, r) {
          var s = function() {
            n.muxed && (n.muxed.destroy(), n.mediaSource = e._elemWrapper.createWriteStream(n.mediaSource), n.mediaSource.on("error", function(t) {
              e._elemWrapper.error(t);
            })), n.muxed = t[r], o(n.muxed, n.mediaSource);
          };
          n.initFlushed ? s() : n.onInitFlushed = function(t) {
            return t ? void e._elemWrapper.error(t) : void s();
          };
        });
      }, n.prototype.destroy = function() {
        var e = this;
        e.destroyed || (e.destroyed = !0, e._elem.removeEventListener("waiting", e._onWaiting), e._elem.removeEventListener("error", e._onError), e._tracks && e._tracks.forEach(function(e) {
          e.muxed.destroy();
        }), e._elem.src = "");
      };
    }, {
      "./mp4-remuxer": 122,
      mediasource: 50,
      pump: 123
    }],
    125: [function(e, t) {
      function n(e, t) {
        function r() {
          for (var t = Array(arguments.length),
              n = 0; n < t.length; n++)
            t[n] = arguments[n];
          var r = e.apply(this, t),
              o = t[t.length - 1];
          return "function" == typeof r && r !== o && Object.keys(o).forEach(function(e) {
            r[e] = o[e];
          }), r;
        }
        if (e && t)
          return n(e)(t);
        if ("function" != typeof e)
          throw new TypeError("need wrapper function");
        return Object.keys(e).forEach(function(t) {
          r[t] = e[t];
        }), r;
      }
      t.exports = n;
    }, {}],
    126: [function(e, t) {
      t.exports = function() {
        for (var e = {},
            t = 0,
            r; t < arguments.length; t++)
          for (var o in r = arguments[t], r)
            n.call(r, o) && (e[o] = r[o]);
        return e;
      };
      var n = Object.prototype.hasOwnProperty;
    }, {}],
    127: [function(e, t) {
      t.exports = function(e) {
        for (var t = 1,
            r; t < arguments.length; t++)
          for (var o in r = arguments[t], r)
            n.call(r, o) && (e[o] = r[o]);
        return e;
      };
      var n = Object.prototype.hasOwnProperty;
    }, {}],
    128: [function(e, t) {
      t.exports = function e(t, n, r) {
        return void 0 === n ? function(n, r) {
          return e(t, n, r);
        } : (void 0 === r && (r = "0"), t -= n.toString().length, 0 < t ? Array(t + (/\./.test(n) ? 2 : 1)).join(r) + n : n + "");
      };
    }, {}],
    129: [function(e, t) {
      t.exports = {version: "0.98.22"};
    }, {}],
    130: [function(e, t) {
      (function(n, r) {
        function o(e) {
          function t() {
            s.destroyed || (s.ready = !0, s.emit("ready"));
          }
          var s = this;
          return s instanceof o ? void(u.call(s), !e && (e = {}), s.peerId = "string" == typeof e.peerId ? e.peerId : d.isBuffer(e.peerId) ? e.peerId.toString("hex") : d.from(B + w(9).toString("base64")).toString("hex"), s.peerIdBuffer = d.from(s.peerId, "hex"), s.nodeId = "string" == typeof e.nodeId ? e.nodeId : d.isBuffer(e.nodeId) ? e.nodeId.toString("hex") : w(20).toString("hex"), s.nodeIdBuffer = d.from(s.nodeId, "hex"), s._debugId = s.peerId.toString("hex").substring(0, 7), s.destroyed = !1, s.listening = !1, s.torrentPort = e.torrentPort || 0, s.dhtPort = e.dhtPort || 0, s.tracker = e.tracker === void 0 ? {} : e.tracker, s.torrents = [], s.maxConns = +e.maxConns || 55, s._debug("new webtorrent (peerId %s, nodeId %s, port %s)", s.peerId, s.nodeId, s.torrentPort), s.tracker && ("object" != typeof s.tracker && (s.tracker = {}), e.rtcConfig && (console.warn("WebTorrent: opts.rtcConfig is deprecated. Use opts.tracker.rtcConfig instead"), s.tracker.rtcConfig = e.rtcConfig), e.wrtc && (console.warn("WebTorrent: opts.wrtc is deprecated. Use opts.tracker.wrtc instead"), s.tracker.wrtc = e.wrtc), r.WRTC && !s.tracker.wrtc && (s.tracker.wrtc = r.WRTC)), "function" == typeof v ? s._tcpPool = new v(s) : n.nextTick(function() {
            s._onListening();
          }), s._downloadSpeed = k(), s._uploadSpeed = k(), !1 !== e.dht && "function" == typeof p ? (s.dht = new p(f({nodeId: s.nodeId}, e.dht)), s.dht.once("error", function(e) {
            s._destroy(e);
          }), s.dht.once("listening", function() {
            var e = s.dht.address();
            e && (s.dhtPort = e.port);
          }), s.dht.setMaxListeners(0), s.dht.listen(s.dhtPort)) : s.dht = !1, s.enableWebSeeds = !1 !== e.webSeeds, "function" == typeof m && null != e.blocklist ? m(e.blocklist, {headers: {"user-agent": "WebTorrent/" + C + " (https://webtorrent.io)"}}, function(e, n) {
            return e ? s.error("Failed to load blocklist: " + e.message) : void(s.blocked = n, t());
          }) : n.nextTick(t)) : new o(e);
        }
        function s(e) {
          return "object" == typeof e && null != e && "function" == typeof e.pipe;
        }
        function i(e) {
          return "undefined" != typeof FileList && e instanceof FileList;
        }
        t.exports = o;
        var d = e("safe-buffer").Buffer,
            a = e("simple-concat"),
            c = e("create-torrent"),
            l = e("debug")("webtorrent"),
            p = e("bittorrent-dht/client"),
            u = e("events").EventEmitter,
            f = e("xtend"),
            h = e("inherits"),
            m = e("load-ip-set"),
            g = e("run-parallel"),
            _ = e("parse-torrent"),
            y = e("path"),
            b = e("simple-peer"),
            w = e("randombytes"),
            k = e("speedometer"),
            x = e("zero-fill"),
            v = e("./lib/tcp-pool"),
            S = e("./lib/torrent"),
            C = e("./package.json").version,
            E = C.match(/([0-9]+)/g).slice(0, 2).map(function(e) {
              return x(2, e);
            }).join(""),
            B = "-WW" + E + "-";
        h(o, u), o.WEBRTC_SUPPORT = b.WEBRTC_SUPPORT, Object.defineProperty(o.prototype, "downloadSpeed", {get: function() {
            return this._downloadSpeed();
          }}), Object.defineProperty(o.prototype, "uploadSpeed", {get: function() {
            return this._uploadSpeed();
          }}), Object.defineProperty(o.prototype, "progress", {get: function() {
            var e = this.torrents.filter(function(e) {
              return 1 !== e.progress;
            }),
                t = e.reduce(function(e, t) {
                  return e + t.downloaded;
                }, 0),
                n = e.reduce(function(e, t) {
                  return e + (t.length || 0);
                }, 0) || 1;
            return t / n;
          }}), Object.defineProperty(o.prototype, "ratio", {get: function() {
            var e = this.torrents.reduce(function(e, t) {
              return e + t.uploaded;
            }, 0),
                t = this.torrents.reduce(function(e, t) {
                  return e + t.received;
                }, 0) || 1;
            return e / t;
          }}), o.prototype.get = function(e) {
          var t = this,
              n = t.torrents.length,
              r,
              o;
          if (e instanceof S) {
            for (r = 0; r < n; r++)
              if (o = t.torrents[r], o === e)
                return o;
          } else {
            var s;
            try {
              s = _(e);
            } catch (e) {}
            if (!s)
              return null;
            if (!s.infoHash)
              throw new Error("Invalid torrent identifier");
            for (r = 0; r < n; r++)
              if (o = t.torrents[r], o.infoHash === s.infoHash)
                return o;
          }
          return null;
        }, o.prototype.download = function(e, t, n) {
          return console.warn("WebTorrent: client.download() is deprecated. Use client.add() instead"), this.add(e, t, n);
        }, o.prototype.add = function(e, t, n) {
          function r() {
            if (!d.destroyed)
              for (var e = 0,
                  n = d.torrents.length,
                  r; e < n; e++)
                if (r = d.torrents[e], r.infoHash === a.infoHash && r !== a)
                  return void a._destroy(new Error("Cannot add duplicate torrent " + a.infoHash));
          }
          function o() {
            d.destroyed || ("function" == typeof n && n(a), d.emit("torrent", a));
          }
          function s() {
            a.removeListener("_infoHash", r), a.removeListener("ready", o), a.removeListener("close", s);
          }
          var d = this;
          if (d.destroyed)
            throw new Error("client is destroyed");
          if ("function" == typeof t)
            return d.add(e, null, t);
          d._debug("add"), t = t ? f(t) : {};
          var a = new S(e, d, t);
          return d.torrents.push(a), a.once("_infoHash", r), a.once("ready", o), a.once("close", s), a;
        }, o.prototype.seed = function(e, t, n) {
          function r(e) {
            o._debug("on seed"), "function" == typeof n && n(e), e.emit("seed"), o.emit("seed", e);
          }
          var o = this;
          if (o.destroyed)
            throw new Error("client is destroyed");
          if ("function" == typeof t)
            return o.seed(e, null, t);
          o._debug("seed"), t = t ? f(t) : {}, "string" == typeof e && (t.path = y.dirname(e)), t.createdBy || (t.createdBy = "WebTorrent/" + E);
          var d = o.add(null, t, function(e) {
            var t = [function(t) {
              e.load(l, t);
            }];
            o.dht && t.push(function(t) {
              e.once("dhtAnnounce", t);
            }), g(t, function(t) {
              return o.destroyed ? void 0 : t ? e._destroy(t) : void r(e);
            });
          }),
              l;
          return i(e) && (e = Array.prototype.slice.call(e)), Array.isArray(e) || (e = [e]), g(e.map(function(e) {
            return function(t) {
              s(e) ? a(e, t) : t(null, e);
            };
          }), function(e, n) {
            return o.destroyed ? void 0 : e ? d._destroy(e) : void c.parseInput(n, t, function(e, r) {
              return o.destroyed ? void 0 : e ? d._destroy(e) : void(l = r.map(function(e) {
                return e.getStream;
              }), c(n, t, function(e, t) {
                if (!o.destroyed) {
                  if (e)
                    return d._destroy(e);
                  var n = o.get(t);
                  n ? d._destroy(new Error("Cannot add duplicate torrent " + n.infoHash)) : d._onTorrentId(t);
                }
              }));
            });
          }), d;
        }, o.prototype.remove = function(e, t) {
          this._debug("remove");
          var n = this.get(e);
          if (!n)
            throw new Error("No torrent with id " + e);
          this._remove(e, t);
        }, o.prototype._remove = function(e, t) {
          var n = this.get(e);
          n && (this.torrents.splice(this.torrents.indexOf(n), 1), n.destroy(t));
        }, o.prototype.address = function() {
          return this.listening ? this._tcpPool ? this._tcpPool.server.address() : {
            address: "0.0.0.0",
            family: "IPv4",
            port: 0
          } : null;
        }, o.prototype.destroy = function(e) {
          if (this.destroyed)
            throw new Error("client already destroyed");
          this._destroy(null, e);
        }, o.prototype._destroy = function(e, t) {
          var n = this;
          n._debug("client destroy"), n.destroyed = !0;
          var r = n.torrents.map(function(e) {
            return function(t) {
              e.destroy(t);
            };
          });
          n._tcpPool && r.push(function(e) {
            n._tcpPool.destroy(e);
          }), n.dht && r.push(function(e) {
            n.dht.destroy(e);
          }), g(r, t), e && n.emit("error", e), n.torrents = [], n._tcpPool = null, n.dht = null;
        }, o.prototype._onListening = function() {
          if (this._debug("listening"), this.listening = !0, this._tcpPool) {
            var e = this._tcpPool.server.address();
            e && (this.torrentPort = e.port);
          }
          this.emit("listening");
        }, o.prototype._debug = function() {
          var e = [].slice.call(arguments);
          e[0] = "[" + this._debugId + "] " + e[0], l.apply(null, e);
        };
      }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
    }, {
      "./lib/tcp-pool": 23,
      "./lib/torrent": 5,
      "./package.json": 129,
      _process: 67,
      "bittorrent-dht/client": 23,
      "create-torrent": 30,
      debug: 31,
      events: 35,
      inherits: 42,
      "load-ip-set": 23,
      "parse-torrent": 63,
      path: 64,
      randombytes: 74,
      "run-parallel": 90,
      "safe-buffer": 92,
      "simple-concat": 93,
      "simple-peer": 95,
      speedometer: 98,
      xtend: 126,
      "zero-fill": 128
    }]
  }, {}, [130])(130);
});

})();
(function() {
var define = $__System.amdDefine;
(function(t) {
  if (typeof exports === "object" && typeof module !== "undefined") {
    module.exports = t();
  } else if (typeof define === "function" && define.amd) {
    define("5b", [], t);
  } else {
    var e;
    if (typeof window !== "undefined") {
      e = window;
    } else if (typeof global !== "undefined") {
      e = global;
    } else if (typeof self !== "undefined") {
      e = self;
    } else {
      e = this;
    }
    e.IdbChunkStore = t();
  }
})(function() {
  var t,
      e,
      r;
  return function t(e, r, n) {
    function i(s, u) {
      if (!r[s]) {
        if (!e[s]) {
          var f = typeof require == "function" && require;
          if (!u && f)
            return f(s, !0);
          if (o)
            return o(s, !0);
          var a = new Error("Cannot find module '" + s + "'");
          throw a.code = "MODULE_NOT_FOUND", a;
        }
        var h = r[s] = {exports: {}};
        e[s][0].call(h.exports, function(t) {
          var r = e[s][1][t];
          return i(r ? r : t);
        }, h, h.exports, t, e, r, n);
      }
      return r[s].exports;
    }
    var o = typeof require == "function" && require;
    for (var s = 0; s < n.length; s++)
      i(n[s]);
    return i;
  }({
    1: [function(t, e, r) {
      "use strict";
      r.byteLength = h;
      r.toByteArray = l;
      r.fromByteArray = v;
      var n = [];
      var i = [];
      var o = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (var u = 0,
          f = s.length; u < f; ++u) {
        n[u] = s[u];
        i[s.charCodeAt(u)] = u;
      }
      i["-".charCodeAt(0)] = 62;
      i["_".charCodeAt(0)] = 63;
      function a(t) {
        var e = t.length;
        if (e % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        return t[e - 2] === "=" ? 2 : t[e - 1] === "=" ? 1 : 0;
      }
      function h(t) {
        return t.length * 3 / 4 - a(t);
      }
      function l(t) {
        var e,
            r,
            n,
            s,
            u,
            f;
        var h = t.length;
        u = a(t);
        f = new o(h * 3 / 4 - u);
        n = u > 0 ? h - 4 : h;
        var l = 0;
        for (e = 0, r = 0; e < n; e += 4, r += 3) {
          s = i[t.charCodeAt(e)] << 18 | i[t.charCodeAt(e + 1)] << 12 | i[t.charCodeAt(e + 2)] << 6 | i[t.charCodeAt(e + 3)];
          f[l++] = s >> 16 & 255;
          f[l++] = s >> 8 & 255;
          f[l++] = s & 255;
        }
        if (u === 2) {
          s = i[t.charCodeAt(e)] << 2 | i[t.charCodeAt(e + 1)] >> 4;
          f[l++] = s & 255;
        } else if (u === 1) {
          s = i[t.charCodeAt(e)] << 10 | i[t.charCodeAt(e + 1)] << 4 | i[t.charCodeAt(e + 2)] >> 2;
          f[l++] = s >> 8 & 255;
          f[l++] = s & 255;
        }
        return f;
      }
      function c(t) {
        return n[t >> 18 & 63] + n[t >> 12 & 63] + n[t >> 6 & 63] + n[t & 63];
      }
      function p(t, e, r) {
        var n;
        var i = [];
        for (var o = e; o < r; o += 3) {
          n = (t[o] << 16) + (t[o + 1] << 8) + t[o + 2];
          i.push(c(n));
        }
        return i.join("");
      }
      function v(t) {
        var e;
        var r = t.length;
        var i = r % 3;
        var o = "";
        var s = [];
        var u = 16383;
        for (var f = 0,
            a = r - i; f < a; f += u) {
          s.push(p(t, f, f + u > a ? a : f + u));
        }
        if (i === 1) {
          e = t[r - 1];
          o += n[e >> 2];
          o += n[e << 4 & 63];
          o += "==";
        } else if (i === 2) {
          e = (t[r - 2] << 8) + t[r - 1];
          o += n[e >> 10];
          o += n[e >> 4 & 63];
          o += n[e << 2 & 63];
          o += "=";
        }
        s.push(o);
        return s.join("");
      }
    }, {}],
    2: [function(t, e, r) {
      "use strict";
      var n = t("base64-js");
      var i = t("ieee754");
      r.Buffer = f;
      r.SlowBuffer = w;
      r.INSPECT_MAX_BYTES = 50;
      var o = 2147483647;
      r.kMaxLength = o;
      f.TYPED_ARRAY_SUPPORT = s();
      if (!f.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error("This browser lacks typed array (Uint8Array) support which is required by " + "`buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
      }
      function s() {
        try {
          var t = new Uint8Array(1);
          t.__proto__ = {
            __proto__: Uint8Array.prototype,
            foo: function() {
              return 42;
            }
          };
          return t.foo() === 42;
        } catch (t) {
          return false;
        }
      }
      function u(t) {
        if (t > o) {
          throw new RangeError("Invalid typed array length");
        }
        var e = new Uint8Array(t);
        e.__proto__ = f.prototype;
        return e;
      }
      function f(t, e, r) {
        if (typeof t === "number") {
          if (typeof e === "string") {
            throw new Error("If encoding is specified then the first argument must be a string");
          }
          return c(t);
        }
        return a(t, e, r);
      }
      if (typeof Symbol !== "undefined" && Symbol.species && f[Symbol.species] === f) {
        Object.defineProperty(f, Symbol.species, {
          value: null,
          configurable: true,
          enumerable: false,
          writable: false
        });
      }
      f.poolSize = 8192;
      function a(t, e, r) {
        if (typeof t === "number") {
          throw new TypeError('"value" argument must not be a number');
        }
        if (t instanceof ArrayBuffer) {
          return d(t, e, r);
        }
        if (typeof t === "string") {
          return p(t, e);
        }
        return g(t);
      }
      f.from = function(t, e, r) {
        return a(t, e, r);
      };
      f.prototype.__proto__ = Uint8Array.prototype;
      f.__proto__ = Uint8Array;
      function h(t) {
        if (typeof t !== "number") {
          throw new TypeError('"size" argument must be a number');
        } else if (t < 0) {
          throw new RangeError('"size" argument must not be negative');
        }
      }
      function l(t, e, r) {
        h(t);
        if (t <= 0) {
          return u(t);
        }
        if (e !== undefined) {
          return typeof r === "string" ? u(t).fill(e, r) : u(t).fill(e);
        }
        return u(t);
      }
      f.alloc = function(t, e, r) {
        return l(t, e, r);
      };
      function c(t) {
        h(t);
        return u(t < 0 ? 0 : y(t) | 0);
      }
      f.allocUnsafe = function(t) {
        return c(t);
      };
      f.allocUnsafeSlow = function(t) {
        return c(t);
      };
      function p(t, e) {
        if (typeof e !== "string" || e === "") {
          e = "utf8";
        }
        if (!f.isEncoding(e)) {
          throw new TypeError('"encoding" must be a valid string encoding');
        }
        var r = _(t, e) | 0;
        var n = u(r);
        var i = n.write(t, e);
        if (i !== r) {
          n = n.slice(0, i);
        }
        return n;
      }
      function v(t) {
        var e = t.length < 0 ? 0 : y(t.length) | 0;
        var r = u(e);
        for (var n = 0; n < e; n += 1) {
          r[n] = t[n] & 255;
        }
        return r;
      }
      function d(t, e, r) {
        if (e < 0 || t.byteLength < e) {
          throw new RangeError("'offset' is out of bounds");
        }
        if (t.byteLength < e + (r || 0)) {
          throw new RangeError("'length' is out of bounds");
        }
        var n;
        if (e === undefined && r === undefined) {
          n = new Uint8Array(t);
        } else if (r === undefined) {
          n = new Uint8Array(t, e);
        } else {
          n = new Uint8Array(t, e, r);
        }
        n.__proto__ = f.prototype;
        return n;
      }
      function g(t) {
        if (f.isBuffer(t)) {
          var e = y(t.length) | 0;
          var r = u(e);
          if (r.length === 0) {
            return r;
          }
          t.copy(r, 0, 0, e);
          return r;
        }
        if (t) {
          if (Q(t) || "length" in t) {
            if (typeof t.length !== "number" || W(t.length)) {
              return u(0);
            }
            return v(t);
          }
          if (t.type === "Buffer" && Array.isArray(t.data)) {
            return v(t.data);
          }
        }
        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
      }
      function y(t) {
        if (t >= o) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + o.toString(16) + " bytes");
        }
        return t | 0;
      }
      function w(t) {
        if (+t != t) {
          t = 0;
        }
        return f.alloc(+t);
      }
      f.isBuffer = function t(e) {
        return e != null && e._isBuffer === true;
      };
      f.compare = function t(e, r) {
        if (!f.isBuffer(e) || !f.isBuffer(r)) {
          throw new TypeError("Arguments must be Buffers");
        }
        if (e === r)
          return 0;
        var n = e.length;
        var i = r.length;
        for (var o = 0,
            s = Math.min(n, i); o < s; ++o) {
          if (e[o] !== r[o]) {
            n = e[o];
            i = r[o];
            break;
          }
        }
        if (n < i)
          return -1;
        if (i < n)
          return 1;
        return 0;
      };
      f.isEncoding = function t(e) {
        switch (String(e).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      f.concat = function t(e, r) {
        if (!Array.isArray(e)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (e.length === 0) {
          return f.alloc(0);
        }
        var n;
        if (r === undefined) {
          r = 0;
          for (n = 0; n < e.length; ++n) {
            r += e[n].length;
          }
        }
        var i = f.allocUnsafe(r);
        var o = 0;
        for (n = 0; n < e.length; ++n) {
          var s = e[n];
          if (!f.isBuffer(s)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }
          s.copy(i, o);
          o += s.length;
        }
        return i;
      };
      function _(t, e) {
        if (f.isBuffer(t)) {
          return t.length;
        }
        if (Q(t) || t instanceof ArrayBuffer) {
          return t.byteLength;
        }
        if (typeof t !== "string") {
          t = "" + t;
        }
        var r = t.length;
        if (r === 0)
          return 0;
        var n = false;
        for (; ; ) {
          switch (e) {
            case "ascii":
            case "latin1":
            case "binary":
              return r;
            case "utf8":
            case "utf-8":
            case undefined:
              return H(t).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return r * 2;
            case "hex":
              return r >>> 1;
            case "base64":
              return Z(t).length;
            default:
              if (n)
                return H(t).length;
              e = ("" + e).toLowerCase();
              n = true;
          }
        }
      }
      f.byteLength = _;
      function m(t, e, r) {
        var n = false;
        if (e === undefined || e < 0) {
          e = 0;
        }
        if (e > this.length) {
          return "";
        }
        if (r === undefined || r > this.length) {
          r = this.length;
        }
        if (r <= 0) {
          return "";
        }
        r >>>= 0;
        e >>>= 0;
        if (r <= e) {
          return "";
        }
        if (!t)
          t = "utf8";
        while (true) {
          switch (t) {
            case "hex":
              return D(this, e, r);
            case "utf8":
            case "utf-8":
              return C(this, e, r);
            case "ascii":
              return M(this, e, r);
            case "latin1":
            case "binary":
              return j(this, e, r);
            case "base64":
              return I(this, e, r);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return R(this, e, r);
            default:
              if (n)
                throw new TypeError("Unknown encoding: " + t);
              t = (t + "").toLowerCase();
              n = true;
          }
        }
      }
      f.prototype._isBuffer = true;
      function b(t, e, r) {
        var n = t[e];
        t[e] = t[r];
        t[r] = n;
      }
      f.prototype.swap16 = function t() {
        var e = this.length;
        if (e % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (var r = 0; r < e; r += 2) {
          b(this, r, r + 1);
        }
        return this;
      };
      f.prototype.swap32 = function t() {
        var e = this.length;
        if (e % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (var r = 0; r < e; r += 4) {
          b(this, r, r + 3);
          b(this, r + 1, r + 2);
        }
        return this;
      };
      f.prototype.swap64 = function t() {
        var e = this.length;
        if (e % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (var r = 0; r < e; r += 8) {
          b(this, r, r + 7);
          b(this, r + 1, r + 6);
          b(this, r + 2, r + 5);
          b(this, r + 3, r + 4);
        }
        return this;
      };
      f.prototype.toString = function t() {
        var e = this.length;
        if (e === 0)
          return "";
        if (arguments.length === 0)
          return C(this, 0, e);
        return m.apply(this, arguments);
      };
      f.prototype.equals = function t(e) {
        if (!f.isBuffer(e))
          throw new TypeError("Argument must be a Buffer");
        if (this === e)
          return true;
        return f.compare(this, e) === 0;
      };
      f.prototype.inspect = function t() {
        var e = "";
        var n = r.INSPECT_MAX_BYTES;
        if (this.length > 0) {
          e = this.toString("hex", 0, n).match(/.{2}/g).join(" ");
          if (this.length > n)
            e += " ... ";
        }
        return "<Buffer " + e + ">";
      };
      f.prototype.compare = function t(e, r, n, i, o) {
        if (!f.isBuffer(e)) {
          throw new TypeError("Argument must be a Buffer");
        }
        if (r === undefined) {
          r = 0;
        }
        if (n === undefined) {
          n = e ? e.length : 0;
        }
        if (i === undefined) {
          i = 0;
        }
        if (o === undefined) {
          o = this.length;
        }
        if (r < 0 || n > e.length || i < 0 || o > this.length) {
          throw new RangeError("out of range index");
        }
        if (i >= o && r >= n) {
          return 0;
        }
        if (i >= o) {
          return -1;
        }
        if (r >= n) {
          return 1;
        }
        r >>>= 0;
        n >>>= 0;
        i >>>= 0;
        o >>>= 0;
        if (this === e)
          return 0;
        var s = o - i;
        var u = n - r;
        var a = Math.min(s, u);
        var h = this.slice(i, o);
        var l = e.slice(r, n);
        for (var c = 0; c < a; ++c) {
          if (h[c] !== l[c]) {
            s = h[c];
            u = l[c];
            break;
          }
        }
        if (s < u)
          return -1;
        if (u < s)
          return 1;
        return 0;
      };
      function E(t, e, r, n, i) {
        if (t.length === 0)
          return -1;
        if (typeof r === "string") {
          n = r;
          r = 0;
        } else if (r > 2147483647) {
          r = 2147483647;
        } else if (r < -2147483648) {
          r = -2147483648;
        }
        r = +r;
        if (W(r)) {
          r = i ? 0 : t.length - 1;
        }
        if (r < 0)
          r = t.length + r;
        if (r >= t.length) {
          if (i)
            return -1;
          else
            r = t.length - 1;
        } else if (r < 0) {
          if (i)
            r = 0;
          else
            return -1;
        }
        if (typeof e === "string") {
          e = f.from(e, n);
        }
        if (f.isBuffer(e)) {
          if (e.length === 0) {
            return -1;
          }
          return A(t, e, r, n, i);
        } else if (typeof e === "number") {
          e = e & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (i) {
              return Uint8Array.prototype.indexOf.call(t, e, r);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(t, e, r);
            }
          }
          return A(t, [e], r, n, i);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function A(t, e, r, n, i) {
        var o = 1;
        var s = t.length;
        var u = e.length;
        if (n !== undefined) {
          n = String(n).toLowerCase();
          if (n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le") {
            if (t.length < 2 || e.length < 2) {
              return -1;
            }
            o = 2;
            s /= 2;
            u /= 2;
            r /= 2;
          }
        }
        function f(t, e) {
          if (o === 1) {
            return t[e];
          } else {
            return t.readUInt16BE(e * o);
          }
        }
        var a;
        if (i) {
          var h = -1;
          for (a = r; a < s; a++) {
            if (f(t, a) === f(e, h === -1 ? 0 : a - h)) {
              if (h === -1)
                h = a;
              if (a - h + 1 === u)
                return h * o;
            } else {
              if (h !== -1)
                a -= a - h;
              h = -1;
            }
          }
        } else {
          if (r + u > s)
            r = s - u;
          for (a = r; a >= 0; a--) {
            var l = true;
            for (var c = 0; c < u; c++) {
              if (f(t, a + c) !== f(e, c)) {
                l = false;
                break;
              }
            }
            if (l)
              return a;
          }
        }
        return -1;
      }
      f.prototype.includes = function t(e, r, n) {
        return this.indexOf(e, r, n) !== -1;
      };
      f.prototype.indexOf = function t(e, r, n) {
        return E(this, e, r, n, true);
      };
      f.prototype.lastIndexOf = function t(e, r, n) {
        return E(this, e, r, n, false);
      };
      function k(t, e, r, n) {
        r = Number(r) || 0;
        var i = t.length - r;
        if (!n) {
          n = i;
        } else {
          n = Number(n);
          if (n > i) {
            n = i;
          }
        }
        var o = e.length;
        if (o % 2 !== 0)
          throw new TypeError("Invalid hex string");
        if (n > o / 2) {
          n = o / 2;
        }
        for (var s = 0; s < n; ++s) {
          var u = parseInt(e.substr(s * 2, 2), 16);
          if (W(u))
            return s;
          t[r + s] = u;
        }
        return s;
      }
      function B(t, e, r, n) {
        return K(H(e, t.length - r), t, r, n);
      }
      function L(t, e, r, n) {
        return K(V(e), t, r, n);
      }
      function T(t, e, r, n) {
        return L(t, e, r, n);
      }
      function S(t, e, r, n) {
        return K(Z(e), t, r, n);
      }
      function x(t, e, r, n) {
        return K(J(e, t.length - r), t, r, n);
      }
      f.prototype.write = function t(e, r, n, i) {
        if (r === undefined) {
          i = "utf8";
          n = this.length;
          r = 0;
        } else if (n === undefined && typeof r === "string") {
          i = r;
          n = this.length;
          r = 0;
        } else if (isFinite(r)) {
          r = r >>> 0;
          if (isFinite(n)) {
            n = n >>> 0;
            if (i === undefined)
              i = "utf8";
          } else {
            i = n;
            n = undefined;
          }
        } else {
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        }
        var o = this.length - r;
        if (n === undefined || n > o)
          n = o;
        if (e.length > 0 && (n < 0 || r < 0) || r > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!i)
          i = "utf8";
        var s = false;
        for (; ; ) {
          switch (i) {
            case "hex":
              return k(this, e, r, n);
            case "utf8":
            case "utf-8":
              return B(this, e, r, n);
            case "ascii":
              return L(this, e, r, n);
            case "latin1":
            case "binary":
              return T(this, e, r, n);
            case "base64":
              return S(this, e, r, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return x(this, e, r, n);
            default:
              if (s)
                throw new TypeError("Unknown encoding: " + i);
              i = ("" + i).toLowerCase();
              s = true;
          }
        }
      };
      f.prototype.toJSON = function t() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function I(t, e, r) {
        if (e === 0 && r === t.length) {
          return n.fromByteArray(t);
        } else {
          return n.fromByteArray(t.slice(e, r));
        }
      }
      function C(t, e, r) {
        r = Math.min(t.length, r);
        var n = [];
        var i = e;
        while (i < r) {
          var o = t[i];
          var s = null;
          var u = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
          if (i + u <= r) {
            var f,
                a,
                h,
                l;
            switch (u) {
              case 1:
                if (o < 128) {
                  s = o;
                }
                break;
              case 2:
                f = t[i + 1];
                if ((f & 192) === 128) {
                  l = (o & 31) << 6 | f & 63;
                  if (l > 127) {
                    s = l;
                  }
                }
                break;
              case 3:
                f = t[i + 1];
                a = t[i + 2];
                if ((f & 192) === 128 && (a & 192) === 128) {
                  l = (o & 15) << 12 | (f & 63) << 6 | a & 63;
                  if (l > 2047 && (l < 55296 || l > 57343)) {
                    s = l;
                  }
                }
                break;
              case 4:
                f = t[i + 1];
                a = t[i + 2];
                h = t[i + 3];
                if ((f & 192) === 128 && (a & 192) === 128 && (h & 192) === 128) {
                  l = (o & 15) << 18 | (f & 63) << 12 | (a & 63) << 6 | h & 63;
                  if (l > 65535 && l < 1114112) {
                    s = l;
                  }
                }
            }
          }
          if (s === null) {
            s = 65533;
            u = 1;
          } else if (s > 65535) {
            s -= 65536;
            n.push(s >>> 10 & 1023 | 55296);
            s = 56320 | s & 1023;
          }
          n.push(s);
          i += u;
        }
        return U(n);
      }
      var P = 4096;
      function U(t) {
        var e = t.length;
        if (e <= P) {
          return String.fromCharCode.apply(String, t);
        }
        var r = "";
        var n = 0;
        while (n < e) {
          r += String.fromCharCode.apply(String, t.slice(n, n += P));
        }
        return r;
      }
      function M(t, e, r) {
        var n = "";
        r = Math.min(t.length, r);
        for (var i = e; i < r; ++i) {
          n += String.fromCharCode(t[i] & 127);
        }
        return n;
      }
      function j(t, e, r) {
        var n = "";
        r = Math.min(t.length, r);
        for (var i = e; i < r; ++i) {
          n += String.fromCharCode(t[i]);
        }
        return n;
      }
      function D(t, e, r) {
        var n = t.length;
        if (!e || e < 0)
          e = 0;
        if (!r || r < 0 || r > n)
          r = n;
        var i = "";
        for (var o = e; o < r; ++o) {
          i += X(t[o]);
        }
        return i;
      }
      function R(t, e, r) {
        var n = t.slice(e, r);
        var i = "";
        for (var o = 0; o < n.length; o += 2) {
          i += String.fromCharCode(n[o] + n[o + 1] * 256);
        }
        return i;
      }
      f.prototype.slice = function t(e, r) {
        var n = this.length;
        e = ~~e;
        r = r === undefined ? n : ~~r;
        if (e < 0) {
          e += n;
          if (e < 0)
            e = 0;
        } else if (e > n) {
          e = n;
        }
        if (r < 0) {
          r += n;
          if (r < 0)
            r = 0;
        } else if (r > n) {
          r = n;
        }
        if (r < e)
          r = e;
        var i = this.subarray(e, r);
        i.__proto__ = f.prototype;
        return i;
      };
      function O(t, e, r) {
        if (t % 1 !== 0 || t < 0)
          throw new RangeError("offset is not uint");
        if (t + e > r)
          throw new RangeError("Trying to access beyond buffer length");
      }
      f.prototype.readUIntLE = function t(e, r, n) {
        e = e >>> 0;
        r = r >>> 0;
        if (!n)
          O(e, r, this.length);
        var i = this[e];
        var o = 1;
        var s = 0;
        while (++s < r && (o *= 256)) {
          i += this[e + s] * o;
        }
        return i;
      };
      f.prototype.readUIntBE = function t(e, r, n) {
        e = e >>> 0;
        r = r >>> 0;
        if (!n) {
          O(e, r, this.length);
        }
        var i = this[e + --r];
        var o = 1;
        while (r > 0 && (o *= 256)) {
          i += this[e + --r] * o;
        }
        return i;
      };
      f.prototype.readUInt8 = function t(e, r) {
        e = e >>> 0;
        if (!r)
          O(e, 1, this.length);
        return this[e];
      };
      f.prototype.readUInt16LE = function t(e, r) {
        e = e >>> 0;
        if (!r)
          O(e, 2, this.length);
        return this[e] | this[e + 1] << 8;
      };
      f.prototype.readUInt16BE = function t(e, r) {
        e = e >>> 0;
        if (!r)
          O(e, 2, this.length);
        return this[e] << 8 | this[e + 1];
      };
      f.prototype.readUInt32LE = function t(e, r) {
        e = e >>> 0;
        if (!r)
          O(e, 4, this.length);
        return (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
      };
      f.prototype.readUInt32BE = function t(e, r) {
        e = e >>> 0;
        if (!r)
          O(e, 4, this.length);
        return this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
      };
      f.prototype.readIntLE = function t(e, r, n) {
        e = e >>> 0;
        r = r >>> 0;
        if (!n)
          O(e, r, this.length);
        var i = this[e];
        var o = 1;
        var s = 0;
        while (++s < r && (o *= 256)) {
          i += this[e + s] * o;
        }
        o *= 128;
        if (i >= o)
          i -= Math.pow(2, 8 * r);
        return i;
      };
      f.prototype.readIntBE = function t(e, r, n) {
        e = e >>> 0;
        r = r >>> 0;
        if (!n)
          O(e, r, this.length);
        var i = r;
        var o = 1;
        var s = this[e + --i];
        while (i > 0 && (o *= 256)) {
          s += this[e + --i] * o;
        }
        o *= 128;
        if (s >= o)
          s -= Math.pow(2, 8 * r);
        return s;
      };
      f.prototype.readInt8 = function t(e, r) {
        e = e >>> 0;
        if (!r)
          O(e, 1, this.length);
        if (!(this[e] & 128))
          return this[e];
        return (255 - this[e] + 1) * -1;
      };
      f.prototype.readInt16LE = function t(e, r) {
        e = e >>> 0;
        if (!r)
          O(e, 2, this.length);
        var n = this[e] | this[e + 1] << 8;
        return n & 32768 ? n | 4294901760 : n;
      };
      f.prototype.readInt16BE = function t(e, r) {
        e = e >>> 0;
        if (!r)
          O(e, 2, this.length);
        var n = this[e + 1] | this[e] << 8;
        return n & 32768 ? n | 4294901760 : n;
      };
      f.prototype.readInt32LE = function t(e, r) {
        e = e >>> 0;
        if (!r)
          O(e, 4, this.length);
        return this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
      };
      f.prototype.readInt32BE = function t(e, r) {
        e = e >>> 0;
        if (!r)
          O(e, 4, this.length);
        return this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
      };
      f.prototype.readFloatLE = function t(e, r) {
        e = e >>> 0;
        if (!r)
          O(e, 4, this.length);
        return i.read(this, e, true, 23, 4);
      };
      f.prototype.readFloatBE = function t(e, r) {
        e = e >>> 0;
        if (!r)
          O(e, 4, this.length);
        return i.read(this, e, false, 23, 4);
      };
      f.prototype.readDoubleLE = function t(e, r) {
        e = e >>> 0;
        if (!r)
          O(e, 8, this.length);
        return i.read(this, e, true, 52, 8);
      };
      f.prototype.readDoubleBE = function t(e, r) {
        e = e >>> 0;
        if (!r)
          O(e, 8, this.length);
        return i.read(this, e, false, 52, 8);
      };
      function N(t, e, r, n, i, o) {
        if (!f.isBuffer(t))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (e > i || e < o)
          throw new RangeError('"value" argument is out of bounds');
        if (r + n > t.length)
          throw new RangeError("Index out of range");
      }
      f.prototype.writeUIntLE = function t(e, r, n, i) {
        e = +e;
        r = r >>> 0;
        n = n >>> 0;
        if (!i) {
          var o = Math.pow(2, 8 * n) - 1;
          N(this, e, r, n, o, 0);
        }
        var s = 1;
        var u = 0;
        this[r] = e & 255;
        while (++u < n && (s *= 256)) {
          this[r + u] = e / s & 255;
        }
        return r + n;
      };
      f.prototype.writeUIntBE = function t(e, r, n, i) {
        e = +e;
        r = r >>> 0;
        n = n >>> 0;
        if (!i) {
          var o = Math.pow(2, 8 * n) - 1;
          N(this, e, r, n, o, 0);
        }
        var s = n - 1;
        var u = 1;
        this[r + s] = e & 255;
        while (--s >= 0 && (u *= 256)) {
          this[r + s] = e / u & 255;
        }
        return r + n;
      };
      f.prototype.writeUInt8 = function t(e, r, n) {
        e = +e;
        r = r >>> 0;
        if (!n)
          N(this, e, r, 1, 255, 0);
        this[r] = e & 255;
        return r + 1;
      };
      f.prototype.writeUInt16LE = function t(e, r, n) {
        e = +e;
        r = r >>> 0;
        if (!n)
          N(this, e, r, 2, 65535, 0);
        this[r] = e & 255;
        this[r + 1] = e >>> 8;
        return r + 2;
      };
      f.prototype.writeUInt16BE = function t(e, r, n) {
        e = +e;
        r = r >>> 0;
        if (!n)
          N(this, e, r, 2, 65535, 0);
        this[r] = e >>> 8;
        this[r + 1] = e & 255;
        return r + 2;
      };
      f.prototype.writeUInt32LE = function t(e, r, n) {
        e = +e;
        r = r >>> 0;
        if (!n)
          N(this, e, r, 4, 4294967295, 0);
        this[r + 3] = e >>> 24;
        this[r + 2] = e >>> 16;
        this[r + 1] = e >>> 8;
        this[r] = e & 255;
        return r + 4;
      };
      f.prototype.writeUInt32BE = function t(e, r, n) {
        e = +e;
        r = r >>> 0;
        if (!n)
          N(this, e, r, 4, 4294967295, 0);
        this[r] = e >>> 24;
        this[r + 1] = e >>> 16;
        this[r + 2] = e >>> 8;
        this[r + 3] = e & 255;
        return r + 4;
      };
      f.prototype.writeIntLE = function t(e, r, n, i) {
        e = +e;
        r = r >>> 0;
        if (!i) {
          var o = Math.pow(2, 8 * n - 1);
          N(this, e, r, n, o - 1, -o);
        }
        var s = 0;
        var u = 1;
        var f = 0;
        this[r] = e & 255;
        while (++s < n && (u *= 256)) {
          if (e < 0 && f === 0 && this[r + s - 1] !== 0) {
            f = 1;
          }
          this[r + s] = (e / u >> 0) - f & 255;
        }
        return r + n;
      };
      f.prototype.writeIntBE = function t(e, r, n, i) {
        e = +e;
        r = r >>> 0;
        if (!i) {
          var o = Math.pow(2, 8 * n - 1);
          N(this, e, r, n, o - 1, -o);
        }
        var s = n - 1;
        var u = 1;
        var f = 0;
        this[r + s] = e & 255;
        while (--s >= 0 && (u *= 256)) {
          if (e < 0 && f === 0 && this[r + s + 1] !== 0) {
            f = 1;
          }
          this[r + s] = (e / u >> 0) - f & 255;
        }
        return r + n;
      };
      f.prototype.writeInt8 = function t(e, r, n) {
        e = +e;
        r = r >>> 0;
        if (!n)
          N(this, e, r, 1, 127, -128);
        if (e < 0)
          e = 255 + e + 1;
        this[r] = e & 255;
        return r + 1;
      };
      f.prototype.writeInt16LE = function t(e, r, n) {
        e = +e;
        r = r >>> 0;
        if (!n)
          N(this, e, r, 2, 32767, -32768);
        this[r] = e & 255;
        this[r + 1] = e >>> 8;
        return r + 2;
      };
      f.prototype.writeInt16BE = function t(e, r, n) {
        e = +e;
        r = r >>> 0;
        if (!n)
          N(this, e, r, 2, 32767, -32768);
        this[r] = e >>> 8;
        this[r + 1] = e & 255;
        return r + 2;
      };
      f.prototype.writeInt32LE = function t(e, r, n) {
        e = +e;
        r = r >>> 0;
        if (!n)
          N(this, e, r, 4, 2147483647, -2147483648);
        this[r] = e & 255;
        this[r + 1] = e >>> 8;
        this[r + 2] = e >>> 16;
        this[r + 3] = e >>> 24;
        return r + 4;
      };
      f.prototype.writeInt32BE = function t(e, r, n) {
        e = +e;
        r = r >>> 0;
        if (!n)
          N(this, e, r, 4, 2147483647, -2147483648);
        if (e < 0)
          e = 4294967295 + e + 1;
        this[r] = e >>> 24;
        this[r + 1] = e >>> 16;
        this[r + 2] = e >>> 8;
        this[r + 3] = e & 255;
        return r + 4;
      };
      function z(t, e, r, n, i, o) {
        if (r + n > t.length)
          throw new RangeError("Index out of range");
        if (r < 0)
          throw new RangeError("Index out of range");
      }
      function F(t, e, r, n, o) {
        e = +e;
        r = r >>> 0;
        if (!o) {
          z(t, e, r, 4, 3.4028234663852886e38, -3.4028234663852886e38);
        }
        i.write(t, e, r, n, 23, 4);
        return r + 4;
      }
      f.prototype.writeFloatLE = function t(e, r, n) {
        return F(this, e, r, true, n);
      };
      f.prototype.writeFloatBE = function t(e, r, n) {
        return F(this, e, r, false, n);
      };
      function q(t, e, r, n, o) {
        e = +e;
        r = r >>> 0;
        if (!o) {
          z(t, e, r, 8, 1.7976931348623157e308, -1.7976931348623157e308);
        }
        i.write(t, e, r, n, 52, 8);
        return r + 8;
      }
      f.prototype.writeDoubleLE = function t(e, r, n) {
        return q(this, e, r, true, n);
      };
      f.prototype.writeDoubleBE = function t(e, r, n) {
        return q(this, e, r, false, n);
      };
      f.prototype.copy = function t(e, r, n, i) {
        if (!n)
          n = 0;
        if (!i && i !== 0)
          i = this.length;
        if (r >= e.length)
          r = e.length;
        if (!r)
          r = 0;
        if (i > 0 && i < n)
          i = n;
        if (i === n)
          return 0;
        if (e.length === 0 || this.length === 0)
          return 0;
        if (r < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (n < 0 || n >= this.length)
          throw new RangeError("sourceStart out of bounds");
        if (i < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (i > this.length)
          i = this.length;
        if (e.length - r < i - n) {
          i = e.length - r + n;
        }
        var o = i - n;
        var s;
        if (this === e && n < r && r < i) {
          for (s = o - 1; s >= 0; --s) {
            e[s + r] = this[s + n];
          }
        } else if (o < 1e3) {
          for (s = 0; s < o; ++s) {
            e[s + r] = this[s + n];
          }
        } else {
          Uint8Array.prototype.set.call(e, this.subarray(n, n + o), r);
        }
        return o;
      };
      f.prototype.fill = function t(e, r, n, i) {
        if (typeof e === "string") {
          if (typeof r === "string") {
            i = r;
            r = 0;
            n = this.length;
          } else if (typeof n === "string") {
            i = n;
            n = this.length;
          }
          if (e.length === 1) {
            var o = e.charCodeAt(0);
            if (o < 256) {
              e = o;
            }
          }
          if (i !== undefined && typeof i !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof i === "string" && !f.isEncoding(i)) {
            throw new TypeError("Unknown encoding: " + i);
          }
        } else if (typeof e === "number") {
          e = e & 255;
        }
        if (r < 0 || this.length < r || this.length < n) {
          throw new RangeError("Out of range index");
        }
        if (n <= r) {
          return this;
        }
        r = r >>> 0;
        n = n === undefined ? this.length : n >>> 0;
        if (!e)
          e = 0;
        var s;
        if (typeof e === "number") {
          for (s = r; s < n; ++s) {
            this[s] = e;
          }
        } else {
          var u = f.isBuffer(e) ? e : new f(e, i);
          var a = u.length;
          for (s = 0; s < n - r; ++s) {
            this[s + r] = u[s % a];
          }
        }
        return this;
      };
      var Y = /[^+\/0-9A-Za-z-_]/g;
      function G(t) {
        t = t.trim().replace(Y, "");
        if (t.length < 2)
          return "";
        while (t.length % 4 !== 0) {
          t = t + "=";
        }
        return t;
      }
      function X(t) {
        if (t < 16)
          return "0" + t.toString(16);
        return t.toString(16);
      }
      function H(t, e) {
        e = e || Infinity;
        var r;
        var n = t.length;
        var i = null;
        var o = [];
        for (var s = 0; s < n; ++s) {
          r = t.charCodeAt(s);
          if (r > 55295 && r < 57344) {
            if (!i) {
              if (r > 56319) {
                if ((e -= 3) > -1)
                  o.push(239, 191, 189);
                continue;
              } else if (s + 1 === n) {
                if ((e -= 3) > -1)
                  o.push(239, 191, 189);
                continue;
              }
              i = r;
              continue;
            }
            if (r < 56320) {
              if ((e -= 3) > -1)
                o.push(239, 191, 189);
              i = r;
              continue;
            }
            r = (i - 55296 << 10 | r - 56320) + 65536;
          } else if (i) {
            if ((e -= 3) > -1)
              o.push(239, 191, 189);
          }
          i = null;
          if (r < 128) {
            if ((e -= 1) < 0)
              break;
            o.push(r);
          } else if (r < 2048) {
            if ((e -= 2) < 0)
              break;
            o.push(r >> 6 | 192, r & 63 | 128);
          } else if (r < 65536) {
            if ((e -= 3) < 0)
              break;
            o.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
          } else if (r < 1114112) {
            if ((e -= 4) < 0)
              break;
            o.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
          } else {
            throw new Error("Invalid code point");
          }
        }
        return o;
      }
      function V(t) {
        var e = [];
        for (var r = 0; r < t.length; ++r) {
          e.push(t.charCodeAt(r) & 255);
        }
        return e;
      }
      function J(t, e) {
        var r,
            n,
            i;
        var o = [];
        for (var s = 0; s < t.length; ++s) {
          if ((e -= 2) < 0)
            break;
          r = t.charCodeAt(s);
          n = r >> 8;
          i = r % 256;
          o.push(i);
          o.push(n);
        }
        return o;
      }
      function Z(t) {
        return n.toByteArray(G(t));
      }
      function K(t, e, r, n) {
        for (var i = 0; i < n; ++i) {
          if (i + r >= e.length || i >= t.length)
            break;
          e[i + r] = t[i];
        }
        return i;
      }
      function Q(t) {
        return typeof ArrayBuffer.isView === "function" && ArrayBuffer.isView(t);
      }
      function W(t) {
        return t !== t;
      }
    }, {
      "base64-js": 1,
      ieee754: 5
    }],
    3: [function(t, e, r) {
      function n() {
        this._events = this._events || {};
        this._maxListeners = this._maxListeners || undefined;
      }
      e.exports = n;
      n.EventEmitter = n;
      n.prototype._events = undefined;
      n.prototype._maxListeners = undefined;
      n.defaultMaxListeners = 10;
      n.prototype.setMaxListeners = function(t) {
        if (!o(t) || t < 0 || isNaN(t))
          throw TypeError("n must be a positive number");
        this._maxListeners = t;
        return this;
      };
      n.prototype.emit = function(t) {
        var e,
            r,
            n,
            o,
            f,
            a;
        if (!this._events)
          this._events = {};
        if (t === "error") {
          if (!this._events.error || s(this._events.error) && !this._events.error.length) {
            e = arguments[1];
            if (e instanceof Error) {
              throw e;
            } else {
              var h = new Error('Uncaught, unspecified "error" event. (' + e + ")");
              h.context = e;
              throw h;
            }
          }
        }
        r = this._events[t];
        if (u(r))
          return false;
        if (i(r)) {
          switch (arguments.length) {
            case 1:
              r.call(this);
              break;
            case 2:
              r.call(this, arguments[1]);
              break;
            case 3:
              r.call(this, arguments[1], arguments[2]);
              break;
            default:
              o = Array.prototype.slice.call(arguments, 1);
              r.apply(this, o);
          }
        } else if (s(r)) {
          o = Array.prototype.slice.call(arguments, 1);
          a = r.slice();
          n = a.length;
          for (f = 0; f < n; f++)
            a[f].apply(this, o);
        }
        return true;
      };
      n.prototype.addListener = function(t, e) {
        var r;
        if (!i(e))
          throw TypeError("listener must be a function");
        if (!this._events)
          this._events = {};
        if (this._events.newListener)
          this.emit("newListener", t, i(e.listener) ? e.listener : e);
        if (!this._events[t])
          this._events[t] = e;
        else if (s(this._events[t]))
          this._events[t].push(e);
        else
          this._events[t] = [this._events[t], e];
        if (s(this._events[t]) && !this._events[t].warned) {
          if (!u(this._maxListeners)) {
            r = this._maxListeners;
          } else {
            r = n.defaultMaxListeners;
          }
          if (r && r > 0 && this._events[t].length > r) {
            this._events[t].warned = true;
            console.error("(node) warning: possible EventEmitter memory " + "leak detected. %d listeners added. " + "Use emitter.setMaxListeners() to increase limit.", this._events[t].length);
            if (typeof console.trace === "function") {
              console.trace();
            }
          }
        }
        return this;
      };
      n.prototype.on = n.prototype.addListener;
      n.prototype.once = function(t, e) {
        if (!i(e))
          throw TypeError("listener must be a function");
        var r = false;
        function n() {
          this.removeListener(t, n);
          if (!r) {
            r = true;
            e.apply(this, arguments);
          }
        }
        n.listener = e;
        this.on(t, n);
        return this;
      };
      n.prototype.removeListener = function(t, e) {
        var r,
            n,
            o,
            u;
        if (!i(e))
          throw TypeError("listener must be a function");
        if (!this._events || !this._events[t])
          return this;
        r = this._events[t];
        o = r.length;
        n = -1;
        if (r === e || i(r.listener) && r.listener === e) {
          delete this._events[t];
          if (this._events.removeListener)
            this.emit("removeListener", t, e);
        } else if (s(r)) {
          for (u = o; u-- > 0; ) {
            if (r[u] === e || r[u].listener && r[u].listener === e) {
              n = u;
              break;
            }
          }
          if (n < 0)
            return this;
          if (r.length === 1) {
            r.length = 0;
            delete this._events[t];
          } else {
            r.splice(n, 1);
          }
          if (this._events.removeListener)
            this.emit("removeListener", t, e);
        }
        return this;
      };
      n.prototype.removeAllListeners = function(t) {
        var e,
            r;
        if (!this._events)
          return this;
        if (!this._events.removeListener) {
          if (arguments.length === 0)
            this._events = {};
          else if (this._events[t])
            delete this._events[t];
          return this;
        }
        if (arguments.length === 0) {
          for (e in this._events) {
            if (e === "removeListener")
              continue;
            this.removeAllListeners(e);
          }
          this.removeAllListeners("removeListener");
          this._events = {};
          return this;
        }
        r = this._events[t];
        if (i(r)) {
          this.removeListener(t, r);
        } else if (r) {
          while (r.length)
            this.removeListener(t, r[r.length - 1]);
        }
        delete this._events[t];
        return this;
      };
      n.prototype.listeners = function(t) {
        var e;
        if (!this._events || !this._events[t])
          e = [];
        else if (i(this._events[t]))
          e = [this._events[t]];
        else
          e = this._events[t].slice();
        return e;
      };
      n.prototype.listenerCount = function(t) {
        if (this._events) {
          var e = this._events[t];
          if (i(e))
            return 1;
          else if (e)
            return e.length;
        }
        return 0;
      };
      n.listenerCount = function(t, e) {
        return t.listenerCount(e);
      };
      function i(t) {
        return typeof t === "function";
      }
      function o(t) {
        return typeof t === "number";
      }
      function s(t) {
        return typeof t === "object" && t !== null;
      }
      function u(t) {
        return t === void 0;
      }
    }, {}],
    4: [function(t, e, r) {
      e.exports = f;
      var n = t("events").EventEmitter;
      var i = t("inherits");
      var o = t("promisize");
      var s = typeof window === "undefined" ? self : window;
      var u = s.indexedDB || s.mozIndexedDB || s.webkitIndexedDB || s.msIndexedDB;
      f.INDEXEDDB_SUPPORT = u != null;
      f.BROADCAST_SUPPORT = s.BroadcastChannel != null;
      i(f, n);
      function f(t, e, r) {
        var i = this;
        if (typeof t !== "string")
          throw new Error("A name must be supplied of type string");
        if (!u)
          throw new Error("IndexedDB not supported");
        if (typeof e === "function")
          return new f(t, null, e);
        if (!(i instanceof f))
          return new f(t, e, r);
        if (!e)
          e = {};
        n.call(i);
        i._db = null;
        i._closed = false;
        i._channel = null;
        i._waiters = [];
        var o = e.channel || s.BroadcastChannel;
        if (o) {
          i._channel = new o(t);
          i._channel.onmessage = y;
        }
        var a = u.open(t);
        a.onerror = l;
        a.onsuccess = p;
        a.onupgradeneeded = v;
        i.on("newListener", g);
        function l(t) {
          h(t);
          i._close(t.target.error);
          if (r)
            r(t.target.error);
        }
        function c(t) {
          h(t);
          i._close(t.target.error);
        }
        function p(t) {
          if (i._closed) {
            t.target.result.close();
          } else {
            i._db = t.target.result;
            i._db.onclose = d;
            i._db.onerror = c;
            for (var e in i._waiters)
              i._waiters[e]._init(null);
            i._waiters = null;
            if (r)
              r(null);
            i.emit("open");
          }
        }
        function v(t) {
          var e = t.target.result;
          e.createObjectStore("kv", {autoIncrement: true});
        }
        function d() {
          i._close();
        }
        function g(t) {
          if (t !== "add" && t !== "set" && t !== "remove")
            return;
          if (!i._channel)
            return i.emit("error", new Error("No BroadcastChannel support"));
        }
        function y(t) {
          if (t.data.method === "add")
            i.emit("add", t.data);
          else if (t.data.method === "set")
            i.emit("set", t.data);
          else if (t.data.method === "remove")
            i.emit("remove", t.data);
        }
      }
      f.prototype.get = function(t, e) {
        return this.transaction("readonly").get(t, e);
      };
      f.prototype.set = function(t, e, r) {
        return this.transaction("readwrite").set(t, e, r);
      };
      f.prototype.json = function(t, e) {
        return this.transaction("readonly").json(t, e);
      };
      f.prototype.keys = function(t, e) {
        return this.transaction("readonly").keys(t, e);
      };
      f.prototype.values = function(t, e) {
        return this.transaction("readonly").values(t, e);
      };
      f.prototype.remove = function(t, e) {
        return this.transaction("readwrite").remove(t, e);
      };
      f.prototype.clear = function(t) {
        return this.transaction("readwrite").clear(t);
      };
      f.prototype.count = function(t, e) {
        return this.transaction("readonly").count(t, e);
      };
      f.prototype.add = function(t, e, r) {
        return this.transaction("readwrite").add(t, e, r);
      };
      f.prototype.iterator = function(t, e) {
        return this.transaction("readonly").iterator(t, e);
      };
      f.prototype.transaction = function(t) {
        if (this._closed)
          throw new Error("Database is closed");
        var e = new a(this, t);
        if (this._db)
          e._init(null);
        else
          this._waiters.push(e);
        return e;
      };
      f.prototype.close = function() {
        this._close();
      };
      f.prototype._close = function(t) {
        if (this._closed)
          return;
        this._closed = true;
        if (this._db)
          this._db.close();
        if (this._channel)
          this._channel.close();
        this._db = null;
        this._channel = null;
        if (t)
          this.emit("error", t);
        this.emit("close");
        for (var e in this._waiters)
          this._waiters[e]._init(t || new Error("Database is closed"));
        this._waiters = null;
        this.removeAllListeners();
      };
      function a(t, e) {
        this._kvStore = t;
        this._mode = e || "readwrite";
        this._objectStore = null;
        this._waiters = null;
        this.finished = false;
        this.onfinish = null;
        if (this._mode !== "readonly" && this._mode !== "readwrite") {
          throw new Error('mode must be either "readonly" or "readwrite"');
        }
      }
      a.prototype._init = function(t) {
        var e = this;
        if (e.finished)
          return;
        if (t)
          return e._close(t);
        var r = e._kvStore._db.transaction("kv", e._mode);
        r.oncomplete = i;
        r.onerror = o;
        e._objectStore = r.objectStore("kv");
        for (var n in e._waiters)
          e._waiters[n](null, e._objectStore);
        e._waiters = null;
        function i() {
          e._close(null);
        }
        function o(t) {
          h(t);
          e._close(t.target.error);
        }
      };
      a.prototype._getObjectStore = function(t) {
        if (this.finished)
          throw new Error("Transaction is finished");
        if (this._objectStore)
          return t(null, this._objectStore);
        this._waiters = this._waiters || [];
        this._waiters.push(t);
      };
      a.prototype.set = function(t, e, r) {
        var n = this;
        if (t == null || e == null)
          throw new Error("A key and value must be given");
        r = o(r);
        n._getObjectStore(function(i, o) {
          if (i)
            return r(i);
          try {
            var s = o.put(e, t);
          } catch (t) {
            return r(t);
          }
          s.onerror = h.bind(this, r);
          s.onsuccess = function() {
            if (n._kvStore._channel) {
              n._kvStore._channel.postMessage({
                method: "set",
                key: t,
                value: e
              });
            }
            r(null);
          };
        });
        return r.promise;
      };
      a.prototype.add = function(t, e, r) {
        var n = this;
        if (e == null && t != null)
          return n.add(undefined, t, r);
        if (typeof e === "function" || e == null && r == null)
          return n.add(undefined, t, e);
        if (e == null)
          throw new Error("A value must be provided as an argument");
        r = o(r);
        n._getObjectStore(function(i, o) {
          if (i)
            return r(i);
          try {
            var s = t == null ? o.add(e) : o.add(e, t);
          } catch (t) {
            return r(t);
          }
          s.onerror = h.bind(this, r);
          s.onsuccess = function() {
            if (n._kvStore._channel) {
              n._kvStore._channel.postMessage({
                method: "add",
                key: t,
                value: e
              });
            }
            r(null);
          };
        });
        return r.promise;
      };
      a.prototype.get = function(t, e) {
        var r = this;
        if (t == null)
          throw new Error("A key must be given as an argument");
        e = o(e);
        r._getObjectStore(function(r, n) {
          if (r)
            return e(r);
          try {
            var i = n.get(t);
          } catch (t) {
            return e(t);
          }
          i.onerror = h.bind(this, e);
          i.onsuccess = function(t) {
            e(null, t.target.result);
          };
        });
        return e.promise;
      };
      a.prototype.json = function(t, e) {
        var r = this;
        if (typeof t === "function")
          return r.json(null, t);
        e = o(e);
        var n = {};
        r.iterator(t, function(t, r) {
          if (t)
            return e(t);
          if (r) {
            n[r.key] = r.value;
            r.continue();
          } else {
            e(null, n);
          }
        });
        return e.promise;
      };
      a.prototype.keys = function(t, e) {
        var r = this;
        if (typeof t === "function")
          return r.keys(null, t);
        e = o(e);
        var n = [];
        r.iterator(t, function(t, r) {
          if (t)
            return e(t);
          if (r) {
            n.push(r.key);
            r.continue();
          } else {
            e(null, n);
          }
        });
        return e.promise;
      };
      a.prototype.values = function(t, e) {
        var r = this;
        if (typeof t === "function")
          return r.values(null, t);
        e = o(e);
        var n = [];
        r.iterator(t, function(t, r) {
          if (t)
            return e(t);
          if (r) {
            n.push(r.value);
            r.continue();
          } else {
            e(null, n);
          }
        });
        return e.promise;
      };
      a.prototype.remove = function(t, e) {
        var r = this;
        if (t == null)
          throw new Error("A key must be given as an argument");
        e = o(e);
        r._getObjectStore(function(n, i) {
          if (n)
            return e(n);
          try {
            var o = i.delete(t);
          } catch (t) {
            return e(t);
          }
          o.onerror = h.bind(this, e);
          o.onsuccess = function() {
            if (r._kvStore._channel) {
              r._kvStore._channel.postMessage({
                method: "remove",
                key: t
              });
            }
            e(null);
          };
        });
        return e.promise;
      };
      a.prototype.clear = function(t) {
        var e = this;
        t = o(t);
        e._getObjectStore(function(e, r) {
          if (e)
            return t(e);
          try {
            var n = r.clear();
          } catch (e) {
            return t(e);
          }
          n.onerror = h.bind(this, t);
          n.onsuccess = function() {
            t(null);
          };
        });
        return t.promise;
      };
      a.prototype.count = function(t, e) {
        var r = this;
        if (typeof t === "function")
          return r.count(null, t);
        e = o(e);
        r._getObjectStore(function(r, n) {
          if (r)
            return e(r);
          try {
            var i = t == null ? n.count() : n.count(t);
          } catch (t) {
            return e(t);
          }
          i.onerror = h.bind(this, e);
          i.onsuccess = function(t) {
            e(null, t.target.result);
          };
        });
        return e.promise;
      };
      a.prototype.iterator = function(t, e) {
        var r = this;
        if (typeof t === "function")
          return r.iterator(null, t);
        if (typeof e !== "function")
          throw new Error("A function must be given");
        r._getObjectStore(function(r, n) {
          if (r)
            return e(r);
          try {
            var i = t == null ? n.openCursor() : n.openCursor(t);
          } catch (t) {
            return e(t);
          }
          i.onerror = h.bind(this, e);
          i.onsuccess = function(t) {
            var r = t.target.result;
            e(null, r);
          };
        });
      };
      a.prototype.abort = function() {
        if (this.finished)
          throw new Error("Transaction is finished");
        if (this._objectStore)
          this._objectStore.transaction.abort();
        this._close(new Error("Transaction aborted"));
      };
      a.prototype._close = function(t) {
        if (this.finished)
          return;
        this.finished = true;
        this._kvStore = null;
        this._objectStore = null;
        for (var e in this._waiters)
          this._waiters[e](t || new Error("Transaction is finished"));
        if (this.onfinish)
          this.onfinish(t);
        this.onfinish = null;
        this._waiters = null;
      };
      function h(t, e) {
        if (e == null)
          return h(null, t);
        e.preventDefault();
        e.stopPropagation();
        if (t)
          t(e.target.error);
      }
    }, {
      events: 3,
      inherits: 6,
      promisize: 8
    }],
    5: [function(t, e, r) {
      r.read = function(t, e, r, n, i) {
        var o,
            s;
        var u = i * 8 - n - 1;
        var f = (1 << u) - 1;
        var a = f >> 1;
        var h = -7;
        var l = r ? i - 1 : 0;
        var c = r ? -1 : 1;
        var p = t[e + l];
        l += c;
        o = p & (1 << -h) - 1;
        p >>= -h;
        h += u;
        for (; h > 0; o = o * 256 + t[e + l], l += c, h -= 8) {}
        s = o & (1 << -h) - 1;
        o >>= -h;
        h += n;
        for (; h > 0; s = s * 256 + t[e + l], l += c, h -= 8) {}
        if (o === 0) {
          o = 1 - a;
        } else if (o === f) {
          return s ? NaN : (p ? -1 : 1) * Infinity;
        } else {
          s = s + Math.pow(2, n);
          o = o - a;
        }
        return (p ? -1 : 1) * s * Math.pow(2, o - n);
      };
      r.write = function(t, e, r, n, i, o) {
        var s,
            u,
            f;
        var a = o * 8 - i - 1;
        var h = (1 << a) - 1;
        var l = h >> 1;
        var c = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var p = n ? 0 : o - 1;
        var v = n ? 1 : -1;
        var d = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
        e = Math.abs(e);
        if (isNaN(e) || e === Infinity) {
          u = isNaN(e) ? 1 : 0;
          s = h;
        } else {
          s = Math.floor(Math.log(e) / Math.LN2);
          if (e * (f = Math.pow(2, -s)) < 1) {
            s--;
            f *= 2;
          }
          if (s + l >= 1) {
            e += c / f;
          } else {
            e += c * Math.pow(2, 1 - l);
          }
          if (e * f >= 2) {
            s++;
            f /= 2;
          }
          if (s + l >= h) {
            u = 0;
            s = h;
          } else if (s + l >= 1) {
            u = (e * f - 1) * Math.pow(2, i);
            s = s + l;
          } else {
            u = e * Math.pow(2, l - 1) * Math.pow(2, i);
            s = 0;
          }
        }
        for (; i >= 8; t[r + p] = u & 255, p += v, u /= 256, i -= 8) {}
        s = s << i | u;
        a += i;
        for (; a > 0; t[r + p] = s & 255, p += v, s /= 256, a -= 8) {}
        t[r + p - v] |= d * 128;
      };
    }, {}],
    6: [function(t, e, r) {
      if (typeof Object.create === "function") {
        e.exports = function t(e, r) {
          e.super_ = r;
          e.prototype = Object.create(r.prototype, {constructor: {
              value: e,
              enumerable: false,
              writable: true,
              configurable: true
            }});
        };
      } else {
        e.exports = function t(e, r) {
          e.super_ = r;
          var n = function() {};
          n.prototype = r.prototype;
          e.prototype = new n;
          e.prototype.constructor = e;
        };
      }
    }, {}],
    7: [function(t, e, r) {
      var n = e.exports = {};
      var i;
      var o;
      function s() {
        throw new Error("setTimeout has not been defined");
      }
      function u() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            i = setTimeout;
          } else {
            i = s;
          }
        } catch (t) {
          i = s;
        }
        try {
          if (typeof clearTimeout === "function") {
            o = clearTimeout;
          } else {
            o = u;
          }
        } catch (t) {
          o = u;
        }
      })();
      function f(t) {
        if (i === setTimeout) {
          return setTimeout(t, 0);
        }
        if ((i === s || !i) && setTimeout) {
          i = setTimeout;
          return setTimeout(t, 0);
        }
        try {
          return i(t, 0);
        } catch (e) {
          try {
            return i.call(null, t, 0);
          } catch (e) {
            return i.call(this, t, 0);
          }
        }
      }
      function a(t) {
        if (o === clearTimeout) {
          return clearTimeout(t);
        }
        if ((o === u || !o) && clearTimeout) {
          o = clearTimeout;
          return clearTimeout(t);
        }
        try {
          return o(t);
        } catch (e) {
          try {
            return o.call(null, t);
          } catch (e) {
            return o.call(this, t);
          }
        }
      }
      var h = [];
      var l = false;
      var c;
      var p = -1;
      function v() {
        if (!l || !c) {
          return;
        }
        l = false;
        if (c.length) {
          h = c.concat(h);
        } else {
          p = -1;
        }
        if (h.length) {
          d();
        }
      }
      function d() {
        if (l) {
          return;
        }
        var t = f(v);
        l = true;
        var e = h.length;
        while (e) {
          c = h;
          h = [];
          while (++p < e) {
            if (c) {
              c[p].run();
            }
          }
          p = -1;
          e = h.length;
        }
        c = null;
        l = false;
        a(t);
      }
      n.nextTick = function(t) {
        var e = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var r = 1; r < arguments.length; r++) {
            e[r - 1] = arguments[r];
          }
        }
        h.push(new g(t, e));
        if (h.length === 1 && !l) {
          f(d);
        }
      };
      function g(t, e) {
        this.fun = t;
        this.array = e;
      }
      g.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      n.title = "browser";
      n.browser = true;
      n.env = {};
      n.argv = [];
      n.version = "";
      n.versions = {};
      function y() {}
      n.on = y;
      n.addListener = y;
      n.once = y;
      n.off = y;
      n.removeListener = y;
      n.removeAllListeners = y;
      n.emit = y;
      n.binding = function(t) {
        throw new Error("process.binding is not supported");
      };
      n.cwd = function() {
        return "/";
      };
      n.chdir = function(t) {
        throw new Error("process.chdir is not supported");
      };
      n.umask = function() {
        return 0;
      };
    }, {}],
    8: [function(t, e, r) {
      e.exports = n;
      function n(t) {
        var e;
        var r;
        var n;
        if (t != null && typeof t !== "function")
          throw new Error("cb must be a function");
        if (t == null && typeof Promise !== "undefined") {
          e = new Promise(function(t, e) {
            r = t;
            n = e;
          });
        }
        function i(i, o) {
          if (e) {
            if (i)
              n(i);
            else
              r(o);
          } else {
            if (t)
              t(i, o);
            else if (i)
              throw i;
          }
        }
        i.promise = e;
        return i;
      }
    }, {}],
    "/": [function(t, e, r) {
      (function(r, n) {
        e.exports = o;
        var i = t("idb-kv-store");
        function o(t, e, r) {
          var n = this;
          if (typeof t !== "number")
            throw new Error("chunkLength must be a number");
          if (typeof e === "function")
            return o(t, null, e);
          if (!(n instanceof o))
            return new o(t, e, r);
          if (!e)
            e = {};
          n.chunkLength = t;
          n.length = Number(e.length) || Infinity;
          n.closed = false;
          n._groupPutDelay = e.groupPutDelay || 10;
          n._groupPutCallbacks = [];
          n._groupPutData = {};
          n._groupPutTimeout = null;
          n._lastGroupPut = 0;
          if (n.length !== Infinity) {
            this.lastChunkLength = this.length % this.chunkLength || this.chunkLength;
            n.lastChunkIndex = Math.ceil(n.length / n.chunkLength) - 1;
          }
          var s = e.name || "" + Math.round(9e16 * Math.random());
          if (e.torrent && e.torrent.infoHash)
            s = e.torrent.infoHash;
          n._store = new i(s, r);
          n._store.on("close", u);
          n._store.on("error", f);
          function u() {
            n._close(new Error("IndexedDB database unexpectedly closed"));
          }
          function f(t) {
            n._close(t);
          }
        }
        o.prototype.put = function(t, e, r) {
          var i = this;
          if (i.closed)
            throw new Error("Store is closed");
          if (typeof t !== "number")
            throw new Error("index must be a number");
          if (!n.isBuffer(e))
            e = n.from(e);
          var o = t === i.lastChunkIndex;
          var u = o && e.length !== i.lastChunkLength || !o && e.length !== i.chunkLength;
          if (u)
            return s(r, new Error("Invalid buffer length"));
          i._groupPutData[t] = e;
          if (r)
            i._groupPutCallbacks.push(r);
          if (i._lastGroupPut + i._groupPutDelay < Date.now()) {
            i._groupPut();
          } else if (i._groupPutTimeout == null) {
            i._groupPutTimeout = setTimeout(i._groupPut.bind(i), i._groupPutDelay);
          }
        };
        o.prototype._groupPut = function() {
          var t = this;
          if (t.closed)
            return;
          var e = t._groupPutCallbacks;
          var r = t._groupPutData;
          t._groupPutCallbacks = [];
          t._groupPutData = {};
          t._lastGroupPut = Date.now();
          if (t._groupPutTimeout != null)
            clearTimeout(t._groupPutTimeout);
          t._groupPutTimeout = null;
          var n = t._store.transaction("readwrite");
          for (var i in r)
            n.set(Number(i), r[i], u);
          n.onfinish = function(t) {
            for (var r in e) {
              e[r](t);
            }
          };
        };
        o.prototype.get = function(t, e, r) {
          var i = this;
          if (typeof e === "function")
            return i.get(t, null, e);
          if (typeof r !== "function")
            throw new Error("cb must be a function");
          if (i.closed)
            throw new Error("Store is closed");
          if (typeof t !== "number")
            throw new Error("index must be a number");
          if (!e)
            e = {};
          i._store.get(t, function(t, i) {
            if (t)
              return r(t);
            if (typeof i === "undefined") {
              var o = new Error("Chunk does not exist");
              o.name = "MissingChunkError";
              return r(o);
            }
            var s = "offset" in e ? e.offset : 0;
            var u = "length" in e ? e.length : i.length - s;
            r(null, n.from(i).slice(s, s + u));
          });
        };
        o.prototype.close = function(t) {
          this._close();
          s(t, null);
        };
        o.prototype._close = function(t) {
          if (this.closed)
            return;
          this.closed = true;
          this._store.close();
          this._store = null;
          this._groupPutData = null;
          clearTimeout(this._groupPutTimeout);
          t = t || new Error("Store is closed");
          for (var e in this._groupPutCallbacks)
            this._groupPutCallbacks[e](t);
          this._groupPutCallbacks = null;
        };
        o.prototype.destroy = function(t) {
          var e = this;
          if (e.closed)
            throw new Error("Store is closed");
          e._store.clear(u);
          e.close(t);
        };
        function s() {
          if (arguments[0] != null) {
            r.nextTick.apply(this, arguments);
          }
        }
        function u() {}
      }).call(this, t("_process"), t("buffer").Buffer);
    }, {
      _process: 7,
      buffer: 2,
      "idb-kv-store": 4
    }]
  }, {}, [])("/");
});

})();
$__System.register('2b', ['7', '10', '57', '59', 'a', '2c', '5d', '5c', '5a', '5b'], function (_export) {
	var _classCallCheck, _Map, _Promise, OptionRegex, _createClass, _Object$assign, _getIterator, Helper, WebTorrent, IndexeddbChunkStore, MasterWebTorrent;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			_Map = _2['default'];
		}, function (_3) {
			_Promise = _3['default'];
		}, function (_4) {
			OptionRegex = _4.OptionRegex;
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_c) {
			_Object$assign = _c['default'];
		}, function (_d) {
			_getIterator = _d['default'];
		}, function (_c2) {
			Helper = _c2.Helper;
		}, function (_a2) {
			WebTorrent = _a2['default'];
		}, function (_b) {
			IndexeddbChunkStore = _b['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			//import parseTorrent from 'parse-torrent/index.js'; // doesn't work in karma

			'use strict';

			MasterWebTorrent = (function () {
				function MasterWebTorrent() {
					var container = arguments.length <= 0 || arguments[0] === undefined ? document.body : arguments[0];

					_classCallCheck(this, MasterWebTorrent);

					this.container = container;
					this.Helper = new Helper();
					this.client = new WebTorrent();
					this.client.on('error', function (err) {
						console.error('ERROR: ' + err.message);
					});
					this.addByTextReturn = new _Map(); // takes function, scope and attributes [] to trigger on this._resultAddByText
					this.OptionRegex = new OptionRegex(this, this.client, undefined, this.addByTextReturn);
					this.OptionRegex.returnMap.set('init', [this.OptionRegex.getMagnetURL, this.OptionRegex]);
					this.OptionRegex.returnMap.set('getMagnetURL', [this.OptionRegex.mapFoundMagnetURL, this.OptionRegex]);
					this.OptionRegex.returnMap.set('mapFoundMagnetURL', [this.OptionRegex.replaceBlobURL, this.OptionRegex]);
					this.OptionRegex.returnMap.set('replaceBlobURL', [this.OptionRegex.addProgressBar, this.OptionRegex]);
					this.OptionRegex.returnMap.set('addProgressBar', [this.OptionRegex.addTorrent, this.OptionRegex]);
					this.OptionRegex.returnMap.set('addTorrent', [this._resultAddByText, this]);
					this.torrents = new _Map(); // is used to map between client.torrents [] and nodes. using sst_id when created to quickly access
					this.nodes = []; // nodes in the dom on which torrents got appendedTo
					this.addOpts = {
						/*
      announce: [String],        // Torrent trackers to use (added to list in .torrent or magnet uri)
      getAnnounceOpts: Function, // Custom callback to allow sending extra parameters to the tracker
      maxWebConns: Number,       // Max number of simultaneous connections per web seed [default=4]
      path: String,              // Folder to download files to (default=`/tmp/webtorrent/`)
      store: Function            // Custom chunk store (must follow [abstract-chunk-store](https://www.npmjs.com/package/abstract-chunk-store) API)
      */
						store: IndexeddbChunkStore
					};
					this.seedOpts = {
						/*
      name: String,            // name of the torrent (default = basename of `path`, or 1st file's name)
      comment: String,         // free-form textual comments of the author
      createdBy: String,       // name and version of program used to create torrent
      creationDate: Date       // creation time in UNIX epoch format (default = now)
      private: Boolean,        // is this a private .torrent? (default = false)
      pieceLength: Number      // force a custom piece length (number of bytes)
      announceList: [[String]] // custom trackers (array of arrays of strings) (see [bep12](http://www.bittorrent.org/beps/bep_0012.html))
      urlList: [String]        // web seed urls (see [bep19](http://www.bittorrent.org/beps/bep_0019.html))
      */
						comment: 'sst_WebRTC',
						store: IndexeddbChunkStore
					};
					this.appendToOpts = {
						/*
      !!! IMPORTANT !!! when autoplay off it doesn't work in Firefox and Chrome
      autoplay: Boolean, // Autoplay video/audio files (default: true)
      controls: Boolean, // Show video/audio player controls (default: true)
      maxBlobLength: Number, // Files above this size will skip the "blob" strategy and fail (default: 200 * 1000 * 1000 bytes)
      */
						maxBlobLength: 2 * 1000 * 1000 * 1000 /*2GB*/
					};
					// !!! Important !!! set the attributes in the same order as in the array below
					this.attributes = ['data-id', 'data-magnetURL', 'data-blobs', 'onerror', 'data-linktxt'];
					this.classes = ['webTorrent', 'blobLoading', 'torrentLoading'];
					this.timeoutCont = null; // used for onerror
					this.onerrorCont = [];

					// hooks
					this.api = {
						/**
       * remove - check whole body if node, to which the torrent got appended, is still existent => not delete entry in node and torrent and client.torrents
       * 
       * @param {HtmlNode} [container=this.container] 
       * @returns 
       * @memberof MasterWebTorrent
       */
						removeDeletedNodes: this.removeDeletedNodes.bind(this),
						/**
       * creates id's from files
       * 
       * @param {FileList} files 
       * @returns 
       * @memberof Helper
       */
						createFilesId: this.Helper.createFilesId.bind(this.Helper),
						/**
       * Map
       * 
       * @param {[[id: number, torrent: Object]]}
       * @memberof MasterWebTorrent
       */
						torrents: this.torrents,
						/**
       * HtmlNode
       * 
       * @param {HtmlNode}
       * @memberof MasterWebTorrent
       */
						container: this.container
					};
				}

				// add (download)

				_createClass(MasterWebTorrent, [{
					key: 'add',
					value: function add(magnetURL, id, node, addOpts, appendToOpts, addCallback, appendToCallback) {
						if (addOpts === undefined) addOpts = _Object$assign({}, this.addOpts);

						var _this = this;

						if (addCallback === undefined) addCallback = function (torrent) {
							return _this.appendTo(undefined, appendToOpts, appendToCallback, torrent);
						};
						return (function () {
							id = Number(id);
							// don't add dublicated torrents (files) but simply use existing torrent
							var _iteratorNormalCompletion = true;
							var _didIteratorError = false;
							var _iteratorError = undefined;

							try {
								for (var _iterator = _getIterator(this.client.torrents), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
									var _torrent = _step.value;

									// in case of matching files.length check deeper for size and name
									if (id === _torrent.sst_id) {
										if (node) this.setNodes(_torrent, node, _torrent.sst_id);
										if (_torrent.done) addCallback(_torrent);
										return false;
									}
								}
								// -----------------------------------------------------------------------
								// none dublicated torrents
								// below gets executed before appendTo callback
							} catch (err) {
								_didIteratorError = true;
								_iteratorError = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion && _iterator['return']) {
										_iterator['return']();
									}
								} finally {
									if (_didIteratorError) {
										throw _iteratorError;
									}
								}
							}

							var torrent = this.client.add(magnetURL, addOpts, addCallback);
							this.addParseTorrent(torrent);
							torrent.sst_id = id;
							this.torrents.set(torrent.sst_id, torrent);
							// sst_id to identify (if node gets deleted before torrent finished seeding)
							if (node) this.setNodes(torrent, node, torrent.sst_id);
							return torrent;
						}).apply(this, arguments);
					}

					/**
      * Searching text for torrents to add (api hook)
      * 
      * @param {string} txt 
      * @param {Map([['function', Function], ['scope', Object], ['attributes', []])} arrayReturnMap
      * @param {Object} addOpts 
      * @param {Object} appendToOpts 
      * @param {Function} addCallback 
      * @param {Function} appendToCallback 
      * @memberof MasterWebTorrent
      */
				}, {
					key: 'addByText',
					value: function addByText(txt, arrayReturnMap, addOpts, appendToOpts, addCallback, appendToCallback) {
						// arrayReturnMap requires Map with function, scope, attributes
						var workerID = this.Helper.getRandomString();
						// [addOpts, appendToOpts, addCallback, appendToCallback] are applied to OptionRegex->addTorrent->this.WebTorrent.add
						this.addByTextReturn.set(workerID, [arrayReturnMap, [addOpts, appendToOpts, addCallback, appendToCallback]]);
						this.OptionRegex.init(txt, [this.attributes, this.classes], workerID);
					}

					// don't call this directly, it will be called by OptionRegex timeline triggered when worker finishes
				}, {
					key: '_resultAddByText',
					value: function _resultAddByText(data) {
						var txt = data[0][0],
						    workerID = data[0][2] /*, magnetURLs = data[1]*/;
						// trigger the linked function for this workerID
						var arrayReturnMap = this.addByTextReturn.get(workerID)[0];
						if (arrayReturnMap) {
							arrayReturnMap.forEach(function (returnMap) {
								// trigger: this.Dom.setData(container, oldMessage, dataPack.message);
								returnMap.get('attributes').push(txt);
								returnMap.get('function').apply(returnMap.get('scope'), returnMap.get('attributes'));
							});
							this.addByTextReturn['delete'](workerID);
						}
						return txt;
					}

					/**
      * seed (upload) (api hook)
      * 
      * @param {File | FileList} files 
      * @param {string} text 
      * @param {HtmlNode} node 
      * @param {Object} [seedOpts=this.seedOpts] 
      * @param {Object} appendToOpts 
      * @param {Function} [seedCallback=(torrent) => {return this.appendTo(text, appendToOpts, appendToCallback, torrent);}] 
      * @param {Function} appendToCallback 
      * @returns 
      * @memberof MasterWebTorrent
      */
				}, {
					key: 'seed',
					value: function seed(files, text, node, seedOpts, appendToOpts, seedCallback, appendToCallback) {
						if (seedOpts === undefined) seedOpts = _Object$assign({}, this.seedOpts);

						var _this2 = this;

						if (seedCallback === undefined) seedCallback = function (torrent) {
							return _this2.appendTo(text, appendToOpts, appendToCallback, torrent);
						};
						return (function () {
							if (node) {
								node.classList.add(this.classes[0], this.classes[1]);
								node.contentEditable = false;
							}
							var id = this.Helper.createFilesId(files);
							// don't seed dublicated torrents (files) but simply use existing torrent
							var _iteratorNormalCompletion2 = true;
							var _didIteratorError2 = false;
							var _iteratorError2 = undefined;

							try {
								for (var _iterator2 = _getIterator(this.client.torrents), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
									var _torrent2 = _step2.value;

									// in case of matching files.length check deeper for size and name
									if (id === _torrent2.sst_id) {
										// sst_id to identify (if node gets deleted before torrent finished seeding)
										if (node) this.setNodes(_torrent2, node, _torrent2.sst_id);
										if (_torrent2.done) seedCallback(_torrent2);
										return false;
									}
								}
								// -----------------------------------------------------------------------
								// none dublicated torrents
								// below gets executed before appendTo callback
							} catch (err) {
								_didIteratorError2 = true;
								_iteratorError2 = err;
							} finally {
								try {
									if (!_iteratorNormalCompletion2 && _iterator2['return']) {
										_iterator2['return']();
									}
								} finally {
									if (_didIteratorError2) {
										throw _iteratorError2;
									}
								}
							}

							var torrent = this.client.seed(files, seedOpts, seedCallback);
							this.addParseTorrent(torrent);
							torrent.sst_id = id;
							this.torrents.set(torrent.sst_id, torrent);
							// sst_id to identify (if node gets deleted before torrent finished seeding)
							if (node) this.setNodes(torrent, node, torrent.sst_id);
							return torrent;
						}).apply(this, arguments);
					}
				}, {
					key: 'appendTo',
					value: function appendTo(text, appendToOpts, appendToCallback, torrent) {
						if (appendToOpts === undefined) appendToOpts = this.appendToOpts;
						if (appendToCallback === undefined) appendToCallback = function (torrent) {
							console.info('torrent: ' + torrent.name + ' appended!');
						};
						return (function () {
							var _this3 = this;

							if (torrent.sst_nodes && torrent.sst_nodes.length > 0) {
								// use content of previously set torrent.sst_nodes
								if (torrent.sst_nodeCont) {
									this.appended(torrent, appendToCallback, text);
								} else if (!torrent.sst_appending) {
									(function () {
										// stop other files to be appended during this process
										torrent.sst_appending = true;
										// grab first node and use it as append role model
										var node = torrent.sst_nodes[0];
										// only appendTo empty nodes
										node.innerHTML = '';
										torrent.files.forEach(function (file, i) {
											file.appendTo(node, appendToOpts, function (err, elem) {
												// callback for last file, when finishing
												var callback = i === torrent.files.length - 1 ? function (elem) {
													setTimeout(function () {
														torrent.sst_appending = false;
														// workaround bug which possibly appends to wrong node... nodes in the dom can get mixed up during this process, make sure and if needed reset
														if (Number(torrent.sst_id) === Number(node.getAttribute(_this3.attributes[0]))) {
															// this only gets triggered on WebTorrentReceiver
															if (_this3.ProgressBar) _this3.ProgressBar.removeAll(torrent);
															// set node content to torrent
															torrent.sst_nodeCont = node.innerHTML;
															torrent.sst_containsVideo = torrent.sst_nodeCont.indexOf('video') !== -1;
															_this3.appended(torrent, appendToCallback, text);
														} else {
															// reset nodes and start over
															node.removeChild(elem);
															torrent.sst_nodes = [];
															_this3.appendTo(text, appendToOpts, appendToCallback, torrent);
														}
													}, 50); // waitForBlob
												} : function () {};
												// when not supported for appendTo eg. zip add download link
												if (!elem) {
													if (file.done) {
														_this3.appendToUnsupportedFileAsLink(text, torrent, file, node, callback);
													} else {
														torrent.on('done', function () {
															_this3.appendToUnsupportedFileAsLink(text, torrent, file, node, callback);
														});
													}
													//clear error
													err = undefined;
												} else {
													callback(elem);
												}
												if (err) {
													node.remove();
													_this3.removeDeletedNodes();
												}
												return err ? console.warn(err) : true;
											});
										});
									})();
								}
							} else {
								console.info('no nodes found in dom for:');
								console.info(torrent);
							}
						}).apply(this, arguments);
					}
				}, {
					key: 'appendToUnsupportedFileAsLink',
					value: function appendToUnsupportedFileAsLink(text, torrent, file, node, callback) {
						var _this4 = this;

						file.getBlobURL(function (err, url) {
							if (err) return console.warn(err);
							var name = file.name;
							text = text ? text : node.getAttribute(_this4.attributes[4]);
							if (text) {
								name = torrent.files.length > 1 ? text + '_' + torrent.files.indexOf(file) : text;
							}
							var a = document.createElement('a');
							a.target = '_blank';
							a.download = name;
							a.href = url;
							a.textContent = name;
							if (node.lastChild && node.lastChild.tagName === 'A') {
								a.textContent = ', ' + name;
							}
							node.appendChild(a);
							callback(a);
						});
					}
				}, {
					key: 'appended',
					value: function appended(torrent) {
						var _this5 = this;

						var appendToCallback = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
						var text = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

						var invalidNodes = []; // saving can invalidate nodes, grap those and pass it to removeInvalidNodes
						torrent.sst_nodes.forEach(function (node, i) {
							if (node && typeof node.getAttribute === 'function') {
								// set same content to all nodes
								if (node.innerHTML !== torrent.sst_nodeCont) node.innerHTML = torrent.sst_nodeCont;
								// set magnetURI
								if (!node.getAttribute(_this5.attributes[1])) node.setAttribute(_this5.attributes[1], torrent.magnetURI);
								// set linktxt
								if (text && !node.getAttribute(_this5.attributes[4])) node.setAttribute(_this5.attributes[4], text);
								// loading finished remove classes
								if (node.classList.contains(_this5.classes[1])) node.classList.remove(_this5.classes[1]);
								if (node.classList.contains(_this5.classes[2])) node.classList.remove(_this5.classes[2]);
								// prepare blob array for the first node
								if (i === 0) torrent.sst_localBlobs = [];
								node.childNodes.forEach(function (child) {
									// grab blobs
									if (i === 0) {
										var blob = child.getAttribute('src') ? child.getAttribute('src') : child.getAttribute('href');
										if (blob) torrent.sst_localBlobs.push(blob);
									}
									// error handling if blobs have to be renewed => this.blobsRefresh (set globally at WebTorrentSeeder / WebTorrentReceiver)
									child.setAttribute(_this5.attributes[3], _this5.appended_onerror + '(' + torrent.sst_id + ');');
									torrent.sst_onerror = _this5.appended_onerror + '(' + torrent.sst_id + ');'; // needs to be set on Regex replaceBlobURL
								});
								// set data-blobs
								node.setAttribute(_this5.attributes[2], torrent.sst_localBlobs.join(','));
							} else {
								invalidNodes.push(node);
							}
						});
						this.removeInvalidNodes(invalidNodes, torrent.sst_id);
						if (appendToCallback) appendToCallback(torrent);
					}

					// blobs refresh called by onerror attribute
				}, {
					key: 'blobsRefresh',
					value: function blobsRefresh() {
						var _this6 = this;

						var torrentId = arguments.length <= 0 || arguments[0] === undefined ? this.onerrorCont : arguments[0];

						// bundle all errors and do all at once
						if (Array.isArray(torrentId)) {
							torrentId.forEach(function (id) {
								var torrent = _this6.torrents.get(id);
								if (torrent) {
									torrent.files.forEach(function (file, i) {
										file.getBlobURL(function (err, url) {
											if (err) return console.warn(err);
											if (url !== torrent.sst_localBlobs[i]) {
												torrent.sst_nodeCont = torrent.sst_nodeCont.replace(torrent.sst_localBlobs[i], url);
												URL.revokeObjectURL(torrent.sst_localBlobs[i]);
											}
											// last file
											if (i === torrent.files.length - 1) {
												_this6.findAllNodes(torrent);
												_this6.appended(torrent);
											}
										});
									});
								}
							});
							this.onerrorCont = [];
						} else {
							if (this.onerrorCont.indexOf(torrentId) === -1) {
								this.onerrorCont.push(torrentId);
								/**
         * !!! Not needed, because loading class wouldn't be kept on next webrtc text received !!!
        // add blobLoading
        let torrent = this.torrents.get(torrentId);
        if(torrent){
        	// this only gets triggered on WebTorrentReceiver
        	if (this.findAllNodes) this.findAllNodes(torrent);
        	torrent.sst_nodes.forEach((node) => {
        		node.classList.add(this.classes[1]);
        	});
        }
        */

								/** 
         * videoObject.currentTime NOT POSSIBLE!!! RETURNS NULL AFTER ERROR!!!
         * https://www.w3schools.com/jsref/tryit.asp?filename=tryjsref_video_currenttime
        // get video currentTime to be set after fix blob, only triggered when appended receives it from this onerror and treats each nodes each children video
        */
							}
							clearTimeout(this.timeoutCont);
							this.timeoutCont = setTimeout(function () {
								_this6.blobsRefresh();
							}, 1000);
						}
					}

					// nodes
				}, {
					key: 'setNodes',
					value: function setNodes(torrent, node, id) {
						if (node) {
							// find node (node within the dom)
							if (!torrent.sst_nodes) torrent.sst_nodes = [];
							if (torrent.sst_nodes.indexOf(node) === -1) {
								torrent.sst_nodes.push(node);
								// find torrent in this.torrents by id
								if (!node.getAttribute(this.attributes[0])) node.setAttribute(this.attributes[0], id);
								if (this.nodes.indexOf(node) === -1) this.nodes.push(node);
								return true;
							}
						}
						return false;
					}
				}, {
					key: 'findAllNodes',
					value: function findAllNodes(torrent) {
						var _this7 = this;

						// find all nodes (node within the dom)
						var nodes = this.container.querySelectorAll('[' + this.attributes[0] + '="' + torrent.sst_id + '"]');
						nodes.forEach(function (node) {
							_this7.setNodes(torrent, node, torrent.sst_id);
						});
						return nodes;
					}

					/**
      * remove - check whole body if node, to which the torrent got appended, is still existent => not delete entry in node and torrent and client.torrents (api hook)
      * 
      * @param {HtmlNode} [container=this.container] 
      * @returns 
      * @memberof MasterWebTorrent
      */
				}, {
					key: 'removeDeletedNodes',
					value: function removeDeletedNodes() {
						var _this8 = this;

						var container = arguments.length <= 0 || arguments[0] === undefined ? this.container : arguments[0];

						var removedNodes = [];
						this.nodes.forEach(function (node) {
							if (!container.contains(node)) {
								if (_this8.remove(node)) {
									removedNodes.push(node);
								}
							}
						});
						if (removedNodes.length > 0) {
							this.nodes = this.nodes.filter(function (e) {
								return removedNodes.indexOf(e) === -1;
							});
						}
						return removedNodes;
					}
				}, {
					key: 'removeInvalidNodes',
					value: function removeInvalidNodes(nodes, id) {
						var _this9 = this;

						var removedNodes = [];
						nodes.forEach(function (node) {
							if (_this9.remove(node, undefined, id)) {
								removedNodes.push(node);
							}
						});
						if (removedNodes.length > 0) {
							this.nodes = this.nodes.filter(function (e) {
								return removedNodes.indexOf(e) === -1;
							});
						}
						return removedNodes;
					}
				}, {
					key: 'remove',
					value: function remove() {
						var node = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
						var callback = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
						var id = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

						id = id ? id : Number(node.getAttribute(this.attributes[0]));
						var torrent = this.torrents.get(id);
						if (torrent) {
							var index = torrent.sst_nodes.indexOf(node);
							if (index !== -1) torrent.sst_nodes.splice(index, 1);
							// if no ui element holds the torrent (has to find all nodes, since the node may change when edited in code mode just before the node)
							if (torrent.sst_nodes.length === 0 && this.findAllNodes(torrent).length === 0) {
								// this only gets triggered on WebTorrentReceiver
								if (this.ProgressBar) {
									this.ProgressBar.removeAll(torrent);
								}
								if (torrent.sst_localBlobs) {
									torrent.sst_localBlobs.forEach(function (blob) {
										URL.revokeObjectURL(blob);
									});
								}
								if (callback) {
									// Alias for client.remove(torrent)
									torrent.destroy(callback);
								} else {
									this.client.remove(torrent);
								}
								this.torrents['delete'](id);
								return true;
							}
							return torrent;
						}
						return false;
					}

					// loading
				}, {
					key: 'areTorrentsLoading',
					value: function areTorrentsLoading() {
						return this.client.torrents.some(function (torrent) {
							return !torrent.done || torrent.sst_appending;
						});
					}

					// saving
				}, {
					key: 'addParseTorrent',
					value: function addParseTorrent(torrent) {
						/*if(parseTorrent){
      	Object.defineProperty(torrent, 'sst_parsedTorrent', {
      		get: function () { return parseTorrent(this.torrentFile); }
      	});
      }*/
					}
				}, {
					key: 'getBlobByFileName',
					value: function getBlobByFileName(name) {
						var _this10 = this;

						return new _Promise(function (resolve, reject) {
							var getBlob = function getBlob(file) {
								file.getBlob(function (err, blob) {
									if (err) return reject(console.warn(err));
									resolve(blob);
								});
							};
							if (!_this10.client.torrents.some(function (torrent) {
								var file = undefined;
								if (torrent.done && (file = torrent.files.find(function (file) {
									return file.name === name;
								}))) {
									getBlob(file);
									return true;
								} else if (torrent.magnetURI.includes(name)) {
									// !!!waiting for on.done, only works with torrents which have a single file!!!
									torrent.on('done', function () {
										getBlob(torrent.files[0]);
									});
									return true;
								}
								return false;
							})) {
								reject('not found!');
							}
						});
					}
				}]);

				return MasterWebTorrent;
			})();

			_export('MasterWebTorrent', MasterWebTorrent);
		}
	};
});
$__System.registerDynamic('52', ['3a'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var ITERATOR = $__require('3a')('iterator'),
      SAFE_CLOSING = false;
  try {
    var riter = [7][ITERATOR]();
    riter['return'] = function () {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function () {
      throw 2;
    });
  } catch (e) {}
  module.exports = function (exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING) return false;
    var safe = false;
    try {
      var arr = [7],
          iter = arr[ITERATOR]();
      iter.next = function () {
        return { done: safe = true };
      };
      arr[ITERATOR] = function () {
        return iter;
      };
      exec(arr);
    } catch (e) {}
    return safe;
  };
});
$__System.registerDynamic('5e', ['41', '33', '2f', '5f', '60', '61', '62', '52'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var ctx = $__require('41'),
      $export = $__require('33'),
      toObject = $__require('2f'),
      call = $__require('5f'),
      isArrayIter = $__require('60'),
      toLength = $__require('61'),
      getIterFn = $__require('62');
  $export($export.S + $export.F * !$__require('52')(function (iter) {
    Array.from(iter);
  }), 'Array', { from: function from(arrayLike) {
      var O = toObject(arrayLike),
          C = typeof this == 'function' ? this : Array,
          $$ = arguments,
          $$len = $$.length,
          mapfn = $$len > 1 ? $$[1] : undefined,
          mapping = mapfn !== undefined,
          index = 0,
          iterFn = getIterFn(O),
          length,
          result,
          step,
          iterator;
      if (mapping) mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2);
      if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
          result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
        }
      } else {
        length = toLength(O.length);
        for (result = new C(length); length > index; index++) {
          result[index] = mapping ? mapfn(O[index], index) : O[index];
        }
      }
      result.length = index;
      return result;
    } });
});
$__System.registerDynamic('63', ['55', '5e', '35'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('55');
  $__require('5e');
  module.exports = $__require('35').Array.from;
});
$__System.registerDynamic("64", ["63"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("63"), __esModule: true };
});
$__System.registerDynamic("1c", ["64"], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var _Array$from = $__require("64")["default"];
  exports["default"] = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
      return arr2;
    } else {
      return _Array$from(arr);
    }
  };
  exports.__esModule = true;
});
$__System.registerDynamic("54", [], true, function ($__require, exports, module) {
  /* */
  "format cjs";

  var global = this || self,
      GLOBAL = global;
});
$__System.registerDynamic('51', ['35', '2e', '4e', '3a'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var core = $__require('35'),
      $ = $__require('2e'),
      DESCRIPTORS = $__require('4e'),
      SPECIES = $__require('3a')('species');
  module.exports = function (KEY) {
    var C = core[KEY];
    if (DESCRIPTORS && C && !C[SPECIES]) $.setDesc(C, SPECIES, {
      configurable: true,
      get: function () {
        return this;
      }
    });
  };
});
$__System.registerDynamic('65', ['2e', '66', '4f', '41', '4b', '67', '4c', '68', '69', '6a', '6b', '3f', '51', '4e'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $ = $__require('2e'),
      hide = $__require('66'),
      redefineAll = $__require('4f'),
      ctx = $__require('41'),
      strictNew = $__require('4b'),
      defined = $__require('67'),
      forOf = $__require('4c'),
      $iterDefine = $__require('68'),
      step = $__require('69'),
      ID = $__require('6a')('id'),
      $has = $__require('6b'),
      isObject = $__require('3f'),
      setSpecies = $__require('51'),
      DESCRIPTORS = $__require('4e'),
      isExtensible = Object.isExtensible || isObject,
      SIZE = DESCRIPTORS ? '_s' : 'size',
      id = 0;
  var fastKey = function (it, create) {
    if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!$has(it, ID)) {
      if (!isExtensible(it)) return 'F';
      if (!create) return 'E';
      hide(it, ID, ++id);
    }
    return 'O' + it[ID];
  };
  var getEntry = function (that, key) {
    var index = fastKey(key),
        entry;
    if (index !== 'F') return that._i[index];
    for (entry = that._f; entry; entry = entry.n) {
      if (entry.k == key) return entry;
    }
  };
  module.exports = {
    getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function (that, iterable) {
        strictNew(that, C, NAME);
        that._i = $.create(null);
        that._f = undefined;
        that._l = undefined;
        that[SIZE] = 0;
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
      });
      redefineAll(C.prototype, {
        clear: function clear() {
          for (var that = this, data = that._i, entry = that._f; entry; entry = entry.n) {
            entry.r = true;
            if (entry.p) entry.p = entry.p.n = undefined;
            delete data[entry.i];
          }
          that._f = that._l = undefined;
          that[SIZE] = 0;
        },
        'delete': function (key) {
          var that = this,
              entry = getEntry(that, key);
          if (entry) {
            var next = entry.n,
                prev = entry.p;
            delete that._i[entry.i];
            entry.r = true;
            if (prev) prev.n = next;
            if (next) next.p = prev;
            if (that._f == entry) that._f = next;
            if (that._l == entry) that._l = prev;
            that[SIZE]--;
          }
          return !!entry;
        },
        forEach: function forEach(callbackfn) {
          var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3),
              entry;
          while (entry = entry ? entry.n : this._f) {
            f(entry.v, entry.k, this);
            while (entry && entry.r) entry = entry.p;
          }
        },
        has: function has(key) {
          return !!getEntry(this, key);
        }
      });
      if (DESCRIPTORS) $.setDesc(C.prototype, 'size', { get: function () {
          return defined(this[SIZE]);
        } });
      return C;
    },
    def: function (that, key, value) {
      var entry = getEntry(that, key),
          prev,
          index;
      if (entry) {
        entry.v = value;
      } else {
        that._l = entry = {
          i: index = fastKey(key, true),
          k: key,
          v: value,
          p: prev = that._l,
          n: undefined,
          r: false
        };
        if (!that._f) that._f = entry;
        if (prev) prev.n = entry;
        that[SIZE]++;
        if (index !== 'F') that._i[index] = entry;
      }
      return that;
    },
    getEntry: getEntry,
    setStrong: function (C, NAME, IS_MAP) {
      $iterDefine(C, NAME, function (iterated, kind) {
        this._t = iterated;
        this._k = kind;
        this._l = undefined;
      }, function () {
        var that = this,
            kind = that._k,
            entry = that._l;
        while (entry && entry.r) entry = entry.p;
        if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
          that._t = undefined;
          return step(1);
        }
        if (kind == 'keys') return step(0, entry.k);
        if (kind == 'values') return step(0, entry.v);
        return step(0, [entry.k, entry.v]);
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
      setSpecies(NAME);
    }
  };
});
$__System.registerDynamic('4f', ['6c'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var redefine = $__require('6c');
  module.exports = function (target, src) {
    for (var key in src) redefine(target, key, src[key]);
    return target;
  };
});
$__System.registerDynamic("4b", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (it, Constructor, name) {
    if (!(it instanceof Constructor)) throw TypeError(name + ": use the 'new' operator!");
    return it;
  };
});
$__System.registerDynamic('6d', ['2e', '3d', '33', '31', '66', '4f', '4c', '4b', '3f', '50', '4e'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $ = $__require('2e'),
      global = $__require('3d'),
      $export = $__require('33'),
      fails = $__require('31'),
      hide = $__require('66'),
      redefineAll = $__require('4f'),
      forOf = $__require('4c'),
      strictNew = $__require('4b'),
      isObject = $__require('3f'),
      setToStringTag = $__require('50'),
      DESCRIPTORS = $__require('4e');
  module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = global[NAME],
        C = Base,
        ADDER = IS_MAP ? 'set' : 'add',
        proto = C && C.prototype,
        O = {};
    if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
      new C().entries().next();
    }))) {
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      redefineAll(C.prototype, methods);
    } else {
      C = wrapper(function (target, iterable) {
        strictNew(target, C, NAME);
        target._c = new Base();
        if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
      });
      $.each.call('add,clear,delete,forEach,get,has,set,keys,values,entries'.split(','), function (KEY) {
        var IS_ADDER = KEY == 'add' || KEY == 'set';
        if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
          if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
          var result = this._c[KEY](a === 0 ? 0 : a, b);
          return IS_ADDER ? this : result;
        });
      });
      if ('size' in proto) $.setDesc(C.prototype, 'size', { get: function () {
          return this._c.size;
        } });
    }
    setToStringTag(C, NAME);
    O[NAME] = C;
    $export($export.G + $export.W + $export.F, O);
    if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
    return C;
  };
});
$__System.registerDynamic('6e', ['65', '6d'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var strong = $__require('65');
  $__require('6d')('Map', function (get) {
    return function Map() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {
    get: function get(key) {
      var entry = strong.getEntry(this, key);
      return entry && entry.v;
    },
    set: function set(key, value) {
      return strong.def(this, key === 0 ? 0 : key, value);
    }
  }, strong, true);
});
$__System.registerDynamic('5f', ['38'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var anObject = $__require('38');
  module.exports = function (iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined) anObject(ret.call(iterator));
      throw e;
    }
  };
});
$__System.registerDynamic('60', ['6f', '3a'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var Iterators = $__require('6f'),
        ITERATOR = $__require('3a')('iterator'),
        ArrayProto = Array.prototype;
    module.exports = function (it) {
        return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
    };
});
$__System.registerDynamic('61', ['70'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toInteger = $__require('70'),
      min = Math.min;
  module.exports = function (it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
  };
});
$__System.registerDynamic('4c', ['41', '5f', '60', '38', '61', '62'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var ctx = $__require('41'),
      call = $__require('5f'),
      isArrayIter = $__require('60'),
      anObject = $__require('38'),
      toLength = $__require('61'),
      getIterFn = $__require('62');
  module.exports = function (iterable, entries, fn, that) {
    var iterFn = getIterFn(iterable),
        f = ctx(fn, that, entries ? 2 : 1),
        index = 0,
        length,
        step,
        iterator;
    if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
    if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
      entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
      call(iterator, f, step.value, entries);
    }
  };
});
$__System.registerDynamic('71', ['4c', '4a'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var forOf = $__require('4c'),
      classof = $__require('4a');
  module.exports = function (NAME) {
    return function toJSON() {
      if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
      var arr = [];
      forOf(this, false, arr.push, arr);
      return arr;
    };
  };
});
$__System.registerDynamic('72', ['33', '71'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('33');
  $export($export.P, 'Map', { toJSON: $__require('71')('Map') });
});
$__System.registerDynamic('73', ['54', '55', '56', '6e', '72', '35'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('54');
  $__require('55');
  $__require('56');
  $__require('6e');
  $__require('72');
  module.exports = $__require('35').Map;
});
$__System.registerDynamic("10", ["73"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("73"), __esModule: true };
});
$__System.register('74', ['7', '10', 'a', '1c', '5d'], function (_export) {
	var _classCallCheck, _Map, _createClass, _toConsumableArray, _getIterator, ProgressBar;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			_Map = _2['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_c) {
			_toConsumableArray = _c['default'];
		}, function (_d) {
			_getIterator = _d['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			ProgressBar = (function () {
				function ProgressBar(torrents, addTorrent, removeTorrentNode) {
					var interval = arguments.length <= 3 || arguments[3] === undefined ? 1000 : arguments[3];
					var animationClass = arguments.length <= 4 || arguments[4] === undefined ? 'torrentLoading' : arguments[4];

					_classCallCheck(this, ProgressBar);

					this.torrents = torrents;
					this.addTorrent = addTorrent;
					this.removeTorrentNode = removeTorrentNode;
					this.interval = interval;

					this.resetInterval = this.interval * 5;
					this.intervalCont = undefined;
					this.tags = ['span'];
					this.classes = ['torrentInfo', animationClass, 'torrentProgress', 'torrentControls'];
				}

				_createClass(ProgressBar, [{
					key: 'start',
					value: function start() {
						var _this = this;

						if (!this.intervalCont) this.intervalCont = setInterval(function () {
							_this.update();
						}, this.interval);
					}
				}, {
					key: 'end',
					value: function end() {
						this.intervalCont = clearInterval(this.intervalCont);
						var _iteratorNormalCompletion = true;
						var _didIteratorError = false;
						var _iteratorError = undefined;

						try {
							for (var _iterator = _getIterator(this.torrents.values()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
								var torrent = _step.value;

								this.removeAll(torrent);
							}
						} catch (err) {
							_didIteratorError = true;
							_iteratorError = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion && _iterator['return']) {
									_iterator['return']();
								}
							} finally {
								if (_didIteratorError) {
									throw _iteratorError;
								}
							}
						}
					}
				}, {
					key: 'update',
					value: function update() {
						var _this2 = this;

						var _iteratorNormalCompletion2 = true;
						var _didIteratorError2 = false;
						var _iteratorError2 = undefined;

						try {
							var _loop = function () {
								var torrent = _step2.value;

								if (!torrent.done && torrent.sst_nodes && !torrent.sst_containsVideo) {
									(function () {
										// don't add progressBar to videos, they stream anyways
										var progress = (100 * torrent.progress).toFixed(1);
										if (!torrent.sst_progressNodes) torrent.sst_progressNodes = new _Map();
										torrent.sst_nodes.forEach(function (node) {
											var parentNode = torrent.sst_progressNodes.get(node),
											    animationNode = undefined,
											    infoNode = undefined,
											    controlsNode = undefined;
											if (!parentNode || !node.contains(parentNode)) {
												parentNode = document.createElement('span');
												parentNode.classList.add(_this2.classes[0]);
												node.appendChild(parentNode);
												torrent.sst_progressNodes.set(node, parentNode);
												// child nodes of parentNode
												animationNode = document.createElement('span');
												animationNode.classList.add(_this2.classes[1]);
												parentNode.appendChild(animationNode);
												infoNode = document.createElement('span');
												infoNode.classList.add(_this2.classes[2]);
												parentNode.appendChild(infoNode);
												controlsNode = document.createElement('a');
												controlsNode.classList.add(_this2.classes[3]);
												controlsNode.innerText = 'Reset';
												controlsNode.onclick = function () {
													var magnetURI = torrent.magnetURI;
													var sst_id = torrent.sst_id;
													var nodes = [];
													torrent.sst_nodes.forEach(function (node) {
														nodes.push(node);
														_this2.removeTorrentNode(node, function () {
															setTimeout(function () {
																nodes.forEach(function (node) {
																	_this2.addTorrent(magnetURI, sst_id, node);
																});
															}, _this2.resetInterval);
														});
													});
												};
												parentNode.appendChild(controlsNode);
											} else {
												infoNode = parentNode.getElementsByClassName(_this2.classes[2])[0];
											}
											infoNode.innerHTML = '&nbsp;' + progress + '%&nbsp;';
										});
									})();
								}
							};

							for (var _iterator2 = _getIterator(this.torrents.values()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
								_loop();
							}
						} catch (err) {
							_didIteratorError2 = true;
							_iteratorError2 = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion2 && _iterator2['return']) {
									_iterator2['return']();
								}
							} finally {
								if (_didIteratorError2) {
									throw _iteratorError2;
								}
							}
						}
					}

					// removes the parentNode when MasterWebTorrent.appended
				}, {
					key: 'remove',
					value: function remove(torrent, node) {
						if (torrent.sst_progressNodes) {
							var parentNode = torrent.sst_progressNodes.get(node);
							if (parentNode && node.contains(parentNode)) {
								node.removeChild(parentNode);
								torrent.sst_progressNodes['delete'](node);
								if (!torrent.sst_progressNodes.size) delete torrent.sst_progressNodes;
							} else {
								// remove by class just in case virtual-dom mixed something up
								[].concat(_toConsumableArray(node.getElementsByClassName(this.classes[0]))).forEach(function (parentNode) {
									node.removeChild(parentNode);
								});
							}
						}
					}
				}, {
					key: 'removeAll',
					value: function removeAll(torrent) {
						var _this3 = this;

						if (torrent.sst_progressNodes) {
							torrent.sst_nodes.forEach(function (node) {
								_this3.remove(torrent, node);
							});
						}
					}
				}]);

				return ProgressBar;
			})();

			_export('ProgressBar', ProgressBar);
		}
	};
});
$__System.register('75', ['5', '6', '7', '74', 'a', '2c', '2b'], function (_export) {
	var _get, _inherits, _classCallCheck, ProgressBar, _createClass, _Object$assign, MasterWebTorrent, WebTorrentReceiver;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_4) {
			ProgressBar = _4.ProgressBar;
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_c) {
			_Object$assign = _c['default'];
		}, function (_b) {
			MasterWebTorrent = _b.MasterWebTorrent;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			WebTorrentReceiver = (function (_MasterWebTorrent) {
				_inherits(WebTorrentReceiver, _MasterWebTorrent);

				function WebTorrentReceiver(container) {
					_classCallCheck(this, WebTorrentReceiver);

					_get(Object.getPrototypeOf(WebTorrentReceiver.prototype), 'constructor', this).call(this, container);

					this.ProgressBar = new ProgressBar(this.torrents, this.add.bind(this), this.remove.bind(this));
					// onerror node error handling global
					this.appended_onerror = 'window.sst_WebTorrentReceiver_blobsRefresh';
					window.sst_WebTorrentReceiver_blobsRefresh = this.blobsRefresh.bind(this);

					// hooks
					this.api = _Object$assign(this.api, {
						/**
       * Searching text for torrents to add
       * 
       * @param {string} txt 
       * @param {Map([['function', Function], ['scope', Object], ['attributes', []])} arrayReturnMap
       * @param {Object} addOpts 
       * @param {Object} appendToOpts 
       * @param {Function} addCallback 
       * @param {Function} appendToCallback 
       * @memberof MasterWebTorrent
       */
						addByText: this.addByText.bind(this)
					});
				}

				// called only on new torrent INIT (once only)
				// 1) add find node which trigger this torrent to be added

				_createClass(WebTorrentReceiver, [{
					key: 'appendTo',
					value: function appendTo(text, appendToOpts, appendToCallback, torrent) {
						this.findAllNodes(torrent);
						_get(Object.getPrototypeOf(WebTorrentReceiver.prototype), 'appendTo', this).call(this, text, appendToOpts, appendToCallback, torrent);
					}

					// 2) after delay file.appendTo make sure to once more search for more nodes
				}, {
					key: 'appended',
					value: function appended(torrent, appendToCallback) {
						this.findAllNodes(torrent);
						_get(Object.getPrototypeOf(WebTorrentReceiver.prototype), 'appended', this).call(this, torrent, appendToCallback);
						if (!this.areTorrentsLoading()) this.ProgressBar.end();
					}

					// loading (progressbar) hooks
				}, {
					key: 'add',
					value: function add(magnetURL, id, node, addOpts, appendToOpts, addCallback, appendToCallback) {
						var torrent = _get(Object.getPrototypeOf(WebTorrentReceiver.prototype), 'add', this).call(this, magnetURL, id, node, addOpts, appendToOpts, addCallback, appendToCallback);
						this.findAllNodes(torrent); // to have nodes where the progressbar can attach to
						this.ProgressBar.start();
						return torrent;
					}
				}]);

				return WebTorrentReceiver;
			})(MasterWebTorrent);

			_export('WebTorrentReceiver', WebTorrentReceiver);
		}
	};
});
$__System.registerDynamic('2f', ['67'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var defined = $__require('67');
  module.exports = function (it) {
    return Object(defined(it));
  };
});
$__System.registerDynamic('76', ['2f', '77'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toObject = $__require('2f');
  $__require('77')('keys', function ($keys) {
    return function keys(it) {
      return $keys(toObject(it));
    };
  });
});
$__System.registerDynamic('78', ['76', '35'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('76');
  module.exports = $__require('35').Object.keys;
});
$__System.registerDynamic("79", ["78"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("78"), __esModule: true };
});
$__System.register('7a', ['7', '79', 'a'], function (_export) {
	var _classCallCheck, _Object$keys, _createClass, MasterEditor;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			_Object$keys = _2['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterEditor = (function () {
				function MasterEditor() {
					_classCallCheck(this, MasterEditor);
				}

				_createClass(MasterEditor, [{
					key: 'addEmojis',
					value: function addEmojis() {
						$.ajax({
							url: 'https://api.github.com/emojis'
						}).then(function (data) {
							window.emojis = _Object$keys(data);
							window.emojiUrls = data;
						});
					}
				}, {
					key: 'loadFile',
					value: function loadFile(files, text) {
						var _this = this;

						var container = arguments.length <= 2 || arguments[2] === undefined ? this.container : arguments[2];

						$.each(files, function (i, file) {
							var name = file.name;
							if (text) {
								name = files.length > 1 ? text + '_' + i : text;
							}
							var Reader = new FileReader();
							Reader.addEventListener('load', function () {
								var node = document.createElement('a');
								node.href = Reader.result;
								node.text = name;
								node.setAttribute('download', name);
								node.setAttribute('data-filename', name);
								if (i > 0) {
									_this.setData(container, ', ');
								}
								_this.setData(container, node, 'insertNode');
							}, false);
							Reader.readAsDataURL(file);
						});
					}
				}]);

				return MasterEditor;
			})();

			_export('MasterEditor', MasterEditor);
		}
	};
});
$__System.register('7b', ['5', '6', '7', '19'], function (_export) {
  var _get, _inherits, _classCallCheck, MasterHelper, Helper;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _classCallCheck = _3['default'];
    }, function (_4) {
      MasterHelper = _4.MasterHelper;
    }],
    execute: function () {
      /*jshint esnext: true */

      'use strict';

      Helper = (function (_MasterHelper) {
        _inherits(Helper, _MasterHelper);

        function Helper() {
          _classCallCheck(this, Helper);

          _get(Object.getPrototypeOf(Helper.prototype), 'constructor', this).apply(this, arguments);
        }

        return Helper;
      })(MasterHelper);

      _export('Helper', Helper);
    }
  };
});
$__System.registerDynamic("7c", ["28"], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "$", null);

  (function ($__global) {
    /* */
    "format global";
    "deps jquery";
    "exports $";
    /*!
     * Bootstrap v3.3.7 (http://getbootstrap.com)
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under the MIT license
     */

    if (typeof jQuery === 'undefined') {
      throw new Error('Bootstrap\'s JavaScript requires jQuery');
    }

    +function ($) {
      'use strict';

      var version = $.fn.jquery.split(' ')[0].split('.');
      if (version[0] < 2 && version[1] < 9 || version[0] == 1 && version[1] == 9 && version[2] < 1 || version[0] > 3) {
        throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4');
      }
    }(jQuery);

    /* ========================================================================
     * Bootstrap: transition.js v3.3.7
     * http://getbootstrap.com/javascript/#transitions
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
      // ============================================================

      function transitionEnd() {
        var el = document.createElement('bootstrap');

        var transEndEventNames = {
          WebkitTransition: 'webkitTransitionEnd',
          MozTransition: 'transitionend',
          OTransition: 'oTransitionEnd otransitionend',
          transition: 'transitionend'
        };

        for (var name in transEndEventNames) {
          if (el.style[name] !== undefined) {
            return { end: transEndEventNames[name] };
          }
        }

        return false; // explicit for ie8 (  ._.)
      }

      // http://blog.alexmaccaw.com/css-transitions
      $.fn.emulateTransitionEnd = function (duration) {
        var called = false;
        var $el = this;
        $(this).one('bsTransitionEnd', function () {
          called = true;
        });
        var callback = function () {
          if (!called) $($el).trigger($.support.transition.end);
        };
        setTimeout(callback, duration);
        return this;
      };

      $(function () {
        $.support.transition = transitionEnd();

        if (!$.support.transition) return;

        $.event.special.bsTransitionEnd = {
          bindType: $.support.transition.end,
          delegateType: $.support.transition.end,
          handle: function (e) {
            if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);
          }
        };
      });
    }(jQuery);

    /* ========================================================================
     * Bootstrap: alert.js v3.3.7
     * http://getbootstrap.com/javascript/#alerts
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // ALERT CLASS DEFINITION
      // ======================

      var dismiss = '[data-dismiss="alert"]';
      var Alert = function (el) {
        $(el).on('click', dismiss, this.close);
      };

      Alert.VERSION = '3.3.7';

      Alert.TRANSITION_DURATION = 150;

      Alert.prototype.close = function (e) {
        var $this = $(this);
        var selector = $this.attr('data-target');

        if (!selector) {
          selector = $this.attr('href');
          selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ''); // strip for ie7
        }

        var $parent = $(selector === '#' ? [] : selector);

        if (e) e.preventDefault();

        if (!$parent.length) {
          $parent = $this.closest('.alert');
        }

        $parent.trigger(e = $.Event('close.bs.alert'));

        if (e.isDefaultPrevented()) return;

        $parent.removeClass('in');

        function removeElement() {
          // detach from parent, fire event then clean up data
          $parent.detach().trigger('closed.bs.alert').remove();
        }

        $.support.transition && $parent.hasClass('fade') ? $parent.one('bsTransitionEnd', removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement();
      };

      // ALERT PLUGIN DEFINITION
      // =======================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.alert');

          if (!data) $this.data('bs.alert', data = new Alert(this));
          if (typeof option == 'string') data[option].call($this);
        });
      }

      var old = $.fn.alert;

      $.fn.alert = Plugin;
      $.fn.alert.Constructor = Alert;

      // ALERT NO CONFLICT
      // =================

      $.fn.alert.noConflict = function () {
        $.fn.alert = old;
        return this;
      };

      // ALERT DATA-API
      // ==============

      $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close);
    }(jQuery);

    /* ========================================================================
     * Bootstrap: button.js v3.3.7
     * http://getbootstrap.com/javascript/#buttons
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // BUTTON PUBLIC CLASS DEFINITION
      // ==============================

      var Button = function (element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Button.DEFAULTS, options);
        this.isLoading = false;
      };

      Button.VERSION = '3.3.7';

      Button.DEFAULTS = {
        loadingText: 'loading...'
      };

      Button.prototype.setState = function (state) {
        var d = 'disabled';
        var $el = this.$element;
        var val = $el.is('input') ? 'val' : 'html';
        var data = $el.data();

        state += 'Text';

        if (data.resetText == null) $el.data('resetText', $el[val]());

        // push to event loop to allow forms to submit
        setTimeout($.proxy(function () {
          $el[val](data[state] == null ? this.options[state] : data[state]);

          if (state == 'loadingText') {
            this.isLoading = true;
            $el.addClass(d).attr(d, d).prop(d, true);
          } else if (this.isLoading) {
            this.isLoading = false;
            $el.removeClass(d).removeAttr(d).prop(d, false);
          }
        }, this), 0);
      };

      Button.prototype.toggle = function () {
        var changed = true;
        var $parent = this.$element.closest('[data-toggle="buttons"]');

        if ($parent.length) {
          var $input = this.$element.find('input');
          if ($input.prop('type') == 'radio') {
            if ($input.prop('checked')) changed = false;
            $parent.find('.active').removeClass('active');
            this.$element.addClass('active');
          } else if ($input.prop('type') == 'checkbox') {
            if ($input.prop('checked') !== this.$element.hasClass('active')) changed = false;
            this.$element.toggleClass('active');
          }
          $input.prop('checked', this.$element.hasClass('active'));
          if (changed) $input.trigger('change');
        } else {
          this.$element.attr('aria-pressed', !this.$element.hasClass('active'));
          this.$element.toggleClass('active');
        }
      };

      // BUTTON PLUGIN DEFINITION
      // ========================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.button');
          var options = typeof option == 'object' && option;

          if (!data) $this.data('bs.button', data = new Button(this, options));

          if (option == 'toggle') data.toggle();else if (option) data.setState(option);
        });
      }

      var old = $.fn.button;

      $.fn.button = Plugin;
      $.fn.button.Constructor = Button;

      // BUTTON NO CONFLICT
      // ==================

      $.fn.button.noConflict = function () {
        $.fn.button = old;
        return this;
      };

      // BUTTON DATA-API
      // ===============

      $(document).on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
        var $btn = $(e.target).closest('.btn');
        Plugin.call($btn, 'toggle');
        if (!$(e.target).is('input[type="radio"], input[type="checkbox"]')) {
          // Prevent double click on radios, and the double selections (so cancellation) on checkboxes
          e.preventDefault();
          // The target component still receive the focus
          if ($btn.is('input,button')) $btn.trigger('focus');else $btn.find('input:visible,button:visible').first().trigger('focus');
        }
      }).on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
        $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type));
      });
    }(jQuery);

    /* ========================================================================
     * Bootstrap: carousel.js v3.3.7
     * http://getbootstrap.com/javascript/#carousel
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // CAROUSEL CLASS DEFINITION
      // =========================

      var Carousel = function (element, options) {
        this.$element = $(element);
        this.$indicators = this.$element.find('.carousel-indicators');
        this.options = options;
        this.paused = null;
        this.sliding = null;
        this.interval = null;
        this.$active = null;
        this.$items = null;

        this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this));

        this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element.on('mouseenter.bs.carousel', $.proxy(this.pause, this)).on('mouseleave.bs.carousel', $.proxy(this.cycle, this));
      };

      Carousel.VERSION = '3.3.7';

      Carousel.TRANSITION_DURATION = 600;

      Carousel.DEFAULTS = {
        interval: 5000,
        pause: 'hover',
        wrap: true,
        keyboard: true
      };

      Carousel.prototype.keydown = function (e) {
        if (/input|textarea/i.test(e.target.tagName)) return;
        switch (e.which) {
          case 37:
            this.prev();break;
          case 39:
            this.next();break;
          default:
            return;
        }

        e.preventDefault();
      };

      Carousel.prototype.cycle = function (e) {
        e || (this.paused = false);

        this.interval && clearInterval(this.interval);

        this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));

        return this;
      };

      Carousel.prototype.getItemIndex = function (item) {
        this.$items = item.parent().children('.item');
        return this.$items.index(item || this.$active);
      };

      Carousel.prototype.getItemForDirection = function (direction, active) {
        var activeIndex = this.getItemIndex(active);
        var willWrap = direction == 'prev' && activeIndex === 0 || direction == 'next' && activeIndex == this.$items.length - 1;
        if (willWrap && !this.options.wrap) return active;
        var delta = direction == 'prev' ? -1 : 1;
        var itemIndex = (activeIndex + delta) % this.$items.length;
        return this.$items.eq(itemIndex);
      };

      Carousel.prototype.to = function (pos) {
        var that = this;
        var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'));

        if (pos > this.$items.length - 1 || pos < 0) return;

        if (this.sliding) return this.$element.one('slid.bs.carousel', function () {
          that.to(pos);
        }); // yes, "slid"
        if (activeIndex == pos) return this.pause().cycle();

        return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos));
      };

      Carousel.prototype.pause = function (e) {
        e || (this.paused = true);

        if (this.$element.find('.next, .prev').length && $.support.transition) {
          this.$element.trigger($.support.transition.end);
          this.cycle(true);
        }

        this.interval = clearInterval(this.interval);

        return this;
      };

      Carousel.prototype.next = function () {
        if (this.sliding) return;
        return this.slide('next');
      };

      Carousel.prototype.prev = function () {
        if (this.sliding) return;
        return this.slide('prev');
      };

      Carousel.prototype.slide = function (type, next) {
        var $active = this.$element.find('.item.active');
        var $next = next || this.getItemForDirection(type, $active);
        var isCycling = this.interval;
        var direction = type == 'next' ? 'left' : 'right';
        var that = this;

        if ($next.hasClass('active')) return this.sliding = false;

        var relatedTarget = $next[0];
        var slideEvent = $.Event('slide.bs.carousel', {
          relatedTarget: relatedTarget,
          direction: direction
        });
        this.$element.trigger(slideEvent);
        if (slideEvent.isDefaultPrevented()) return;

        this.sliding = true;

        isCycling && this.pause();

        if (this.$indicators.length) {
          this.$indicators.find('.active').removeClass('active');
          var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]);
          $nextIndicator && $nextIndicator.addClass('active');
        }

        var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }); // yes, "slid"
        if ($.support.transition && this.$element.hasClass('slide')) {
          $next.addClass(type);
          $next[0].offsetWidth; // force reflow
          $active.addClass(direction);
          $next.addClass(direction);
          $active.one('bsTransitionEnd', function () {
            $next.removeClass([type, direction].join(' ')).addClass('active');
            $active.removeClass(['active', direction].join(' '));
            that.sliding = false;
            setTimeout(function () {
              that.$element.trigger(slidEvent);
            }, 0);
          }).emulateTransitionEnd(Carousel.TRANSITION_DURATION);
        } else {
          $active.removeClass('active');
          $next.addClass('active');
          this.sliding = false;
          this.$element.trigger(slidEvent);
        }

        isCycling && this.cycle();

        return this;
      };

      // CAROUSEL PLUGIN DEFINITION
      // ==========================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.carousel');
          var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option);
          var action = typeof option == 'string' ? option : options.slide;

          if (!data) $this.data('bs.carousel', data = new Carousel(this, options));
          if (typeof option == 'number') data.to(option);else if (action) data[action]();else if (options.interval) data.pause().cycle();
        });
      }

      var old = $.fn.carousel;

      $.fn.carousel = Plugin;
      $.fn.carousel.Constructor = Carousel;

      // CAROUSEL NO CONFLICT
      // ====================

      $.fn.carousel.noConflict = function () {
        $.fn.carousel = old;
        return this;
      };

      // CAROUSEL DATA-API
      // =================

      var clickHandler = function (e) {
        var href;
        var $this = $(this);
        var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')); // strip for ie7
        if (!$target.hasClass('carousel')) return;
        var options = $.extend({}, $target.data(), $this.data());
        var slideIndex = $this.attr('data-slide-to');
        if (slideIndex) options.interval = false;

        Plugin.call($target, options);

        if (slideIndex) {
          $target.data('bs.carousel').to(slideIndex);
        }

        e.preventDefault();
      };

      $(document).on('click.bs.carousel.data-api', '[data-slide]', clickHandler).on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler);

      $(window).on('load', function () {
        $('[data-ride="carousel"]').each(function () {
          var $carousel = $(this);
          Plugin.call($carousel, $carousel.data());
        });
      });
    }(jQuery);

    /* ========================================================================
     * Bootstrap: collapse.js v3.3.7
     * http://getbootstrap.com/javascript/#collapse
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    /* jshint latedef: false */

    +function ($) {
      'use strict';

      // COLLAPSE PUBLIC CLASS DEFINITION
      // ================================

      var Collapse = function (element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Collapse.DEFAULTS, options);
        this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],' + '[data-toggle="collapse"][data-target="#' + element.id + '"]');
        this.transitioning = null;

        if (this.options.parent) {
          this.$parent = this.getParent();
        } else {
          this.addAriaAndCollapsedClass(this.$element, this.$trigger);
        }

        if (this.options.toggle) this.toggle();
      };

      Collapse.VERSION = '3.3.7';

      Collapse.TRANSITION_DURATION = 350;

      Collapse.DEFAULTS = {
        toggle: true
      };

      Collapse.prototype.dimension = function () {
        var hasWidth = this.$element.hasClass('width');
        return hasWidth ? 'width' : 'height';
      };

      Collapse.prototype.show = function () {
        if (this.transitioning || this.$element.hasClass('in')) return;

        var activesData;
        var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing');

        if (actives && actives.length) {
          activesData = actives.data('bs.collapse');
          if (activesData && activesData.transitioning) return;
        }

        var startEvent = $.Event('show.bs.collapse');
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented()) return;

        if (actives && actives.length) {
          Plugin.call(actives, 'hide');
          activesData || actives.data('bs.collapse', null);
        }

        var dimension = this.dimension();

        this.$element.removeClass('collapse').addClass('collapsing')[dimension](0).attr('aria-expanded', true);

        this.$trigger.removeClass('collapsed').attr('aria-expanded', true);

        this.transitioning = 1;

        var complete = function () {
          this.$element.removeClass('collapsing').addClass('collapse in')[dimension]('');
          this.transitioning = 0;
          this.$element.trigger('shown.bs.collapse');
        };

        if (!$.support.transition) return complete.call(this);

        var scrollSize = $.camelCase(['scroll', dimension].join('-'));

        this.$element.one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]);
      };

      Collapse.prototype.hide = function () {
        if (this.transitioning || !this.$element.hasClass('in')) return;

        var startEvent = $.Event('hide.bs.collapse');
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented()) return;

        var dimension = this.dimension();

        this.$element[dimension](this.$element[dimension]())[0].offsetHeight;

        this.$element.addClass('collapsing').removeClass('collapse in').attr('aria-expanded', false);

        this.$trigger.addClass('collapsed').attr('aria-expanded', false);

        this.transitioning = 1;

        var complete = function () {
          this.transitioning = 0;
          this.$element.removeClass('collapsing').addClass('collapse').trigger('hidden.bs.collapse');
        };

        if (!$.support.transition) return complete.call(this);

        this.$element[dimension](0).one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION);
      };

      Collapse.prototype.toggle = function () {
        this[this.$element.hasClass('in') ? 'hide' : 'show']();
      };

      Collapse.prototype.getParent = function () {
        return $(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function (i, element) {
          var $element = $(element);
          this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element);
        }, this)).end();
      };

      Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
        var isOpen = $element.hasClass('in');

        $element.attr('aria-expanded', isOpen);
        $trigger.toggleClass('collapsed', !isOpen).attr('aria-expanded', isOpen);
      };

      function getTargetFromTrigger($trigger) {
        var href;
        var target = $trigger.attr('data-target') || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, ''); // strip for ie7

        return $(target);
      }

      // COLLAPSE PLUGIN DEFINITION
      // ==========================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.collapse');
          var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option);

          if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false;
          if (!data) $this.data('bs.collapse', data = new Collapse(this, options));
          if (typeof option == 'string') data[option]();
        });
      }

      var old = $.fn.collapse;

      $.fn.collapse = Plugin;
      $.fn.collapse.Constructor = Collapse;

      // COLLAPSE NO CONFLICT
      // ====================

      $.fn.collapse.noConflict = function () {
        $.fn.collapse = old;
        return this;
      };

      // COLLAPSE DATA-API
      // =================

      $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
        var $this = $(this);

        if (!$this.attr('data-target')) e.preventDefault();

        var $target = getTargetFromTrigger($this);
        var data = $target.data('bs.collapse');
        var option = data ? 'toggle' : $this.data();

        Plugin.call($target, option);
      });
    }(jQuery);

    /* ========================================================================
     * Bootstrap: dropdown.js v3.3.7
     * http://getbootstrap.com/javascript/#dropdowns
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // DROPDOWN CLASS DEFINITION
      // =========================

      var backdrop = '.dropdown-backdrop';
      var toggle = '[data-toggle="dropdown"]';
      var Dropdown = function (element) {
        $(element).on('click.bs.dropdown', this.toggle);
      };

      Dropdown.VERSION = '3.3.7';

      function getParent($this) {
        var selector = $this.attr('data-target');

        if (!selector) {
          selector = $this.attr('href');
          selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, ''); // strip for ie7
        }

        var $parent = selector && $(selector);

        return $parent && $parent.length ? $parent : $this.parent();
      }

      function clearMenus(e) {
        if (e && e.which === 3) return;
        $(backdrop).remove();
        $(toggle).each(function () {
          var $this = $(this);
          var $parent = getParent($this);
          var relatedTarget = { relatedTarget: this };

          if (!$parent.hasClass('open')) return;

          if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return;

          $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget));

          if (e.isDefaultPrevented()) return;

          $this.attr('aria-expanded', 'false');
          $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget));
        });
      }

      Dropdown.prototype.toggle = function (e) {
        var $this = $(this);

        if ($this.is('.disabled, :disabled')) return;

        var $parent = getParent($this);
        var isActive = $parent.hasClass('open');

        clearMenus();

        if (!isActive) {
          if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
            // if mobile we use a backdrop because click events don't delegate
            $(document.createElement('div')).addClass('dropdown-backdrop').insertAfter($(this)).on('click', clearMenus);
          }

          var relatedTarget = { relatedTarget: this };
          $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget));

          if (e.isDefaultPrevented()) return;

          $this.trigger('focus').attr('aria-expanded', 'true');

          $parent.toggleClass('open').trigger($.Event('shown.bs.dropdown', relatedTarget));
        }

        return false;
      };

      Dropdown.prototype.keydown = function (e) {
        if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return;

        var $this = $(this);

        e.preventDefault();
        e.stopPropagation();

        if ($this.is('.disabled, :disabled')) return;

        var $parent = getParent($this);
        var isActive = $parent.hasClass('open');

        if (!isActive && e.which != 27 || isActive && e.which == 27) {
          if (e.which == 27) $parent.find(toggle).trigger('focus');
          return $this.trigger('click');
        }

        var desc = ' li:not(.disabled):visible a';
        var $items = $parent.find('.dropdown-menu' + desc);

        if (!$items.length) return;

        var index = $items.index(e.target);

        if (e.which == 38 && index > 0) index--; // up
        if (e.which == 40 && index < $items.length - 1) index++; // down
        if (!~index) index = 0;

        $items.eq(index).trigger('focus');
      };

      // DROPDOWN PLUGIN DEFINITION
      // ==========================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.dropdown');

          if (!data) $this.data('bs.dropdown', data = new Dropdown(this));
          if (typeof option == 'string') data[option].call($this);
        });
      }

      var old = $.fn.dropdown;

      $.fn.dropdown = Plugin;
      $.fn.dropdown.Constructor = Dropdown;

      // DROPDOWN NO CONFLICT
      // ====================

      $.fn.dropdown.noConflict = function () {
        $.fn.dropdown = old;
        return this;
      };

      // APPLY TO STANDARD DROPDOWN ELEMENTS
      // ===================================

      $(document).on('click.bs.dropdown.data-api', clearMenus).on('click.bs.dropdown.data-api', '.dropdown form', function (e) {
        e.stopPropagation();
      }).on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle).on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown).on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown);
    }(jQuery);

    /* ========================================================================
     * Bootstrap: modal.js v3.3.7
     * http://getbootstrap.com/javascript/#modals
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // MODAL CLASS DEFINITION
      // ======================

      var Modal = function (element, options) {
        this.options = options;
        this.$body = $(document.body);
        this.$element = $(element);
        this.$dialog = this.$element.find('.modal-dialog');
        this.$backdrop = null;
        this.isShown = null;
        this.originalBodyPad = null;
        this.scrollbarWidth = 0;
        this.ignoreBackdropClick = false;

        if (this.options.remote) {
          this.$element.find('.modal-content').load(this.options.remote, $.proxy(function () {
            this.$element.trigger('loaded.bs.modal');
          }, this));
        }
      };

      Modal.VERSION = '3.3.7';

      Modal.TRANSITION_DURATION = 300;
      Modal.BACKDROP_TRANSITION_DURATION = 150;

      Modal.DEFAULTS = {
        backdrop: true,
        keyboard: true,
        show: true
      };

      Modal.prototype.toggle = function (_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget);
      };

      Modal.prototype.show = function (_relatedTarget) {
        var that = this;
        var e = $.Event('show.bs.modal', { relatedTarget: _relatedTarget });

        this.$element.trigger(e);

        if (this.isShown || e.isDefaultPrevented()) return;

        this.isShown = true;

        this.checkScrollbar();
        this.setScrollbar();
        this.$body.addClass('modal-open');

        this.escape();
        this.resize();

        this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this));

        this.$dialog.on('mousedown.dismiss.bs.modal', function () {
          that.$element.one('mouseup.dismiss.bs.modal', function (e) {
            if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true;
          });
        });

        this.backdrop(function () {
          var transition = $.support.transition && that.$element.hasClass('fade');

          if (!that.$element.parent().length) {
            that.$element.appendTo(that.$body); // don't move modals dom position
          }

          that.$element.show().scrollTop(0);

          that.adjustDialog();

          if (transition) {
            that.$element[0].offsetWidth; // force reflow
          }

          that.$element.addClass('in');

          that.enforceFocus();

          var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget });

          transition ? that.$dialog // wait for modal to slide in
          .one('bsTransitionEnd', function () {
            that.$element.trigger('focus').trigger(e);
          }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger('focus').trigger(e);
        });
      };

      Modal.prototype.hide = function (e) {
        if (e) e.preventDefault();

        e = $.Event('hide.bs.modal');

        this.$element.trigger(e);

        if (!this.isShown || e.isDefaultPrevented()) return;

        this.isShown = false;

        this.escape();
        this.resize();

        $(document).off('focusin.bs.modal');

        this.$element.removeClass('in').off('click.dismiss.bs.modal').off('mouseup.dismiss.bs.modal');

        this.$dialog.off('mousedown.dismiss.bs.modal');

        $.support.transition && this.$element.hasClass('fade') ? this.$element.one('bsTransitionEnd', $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal();
      };

      Modal.prototype.enforceFocus = function () {
        $(document).off('focusin.bs.modal') // guard against infinite focus loop
        .on('focusin.bs.modal', $.proxy(function (e) {
          if (document !== e.target && this.$element[0] !== e.target && !this.$element.has(e.target).length) {
            this.$element.trigger('focus');
          }
        }, this));
      };

      Modal.prototype.escape = function () {
        if (this.isShown && this.options.keyboard) {
          this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
            e.which == 27 && this.hide();
          }, this));
        } else if (!this.isShown) {
          this.$element.off('keydown.dismiss.bs.modal');
        }
      };

      Modal.prototype.resize = function () {
        if (this.isShown) {
          $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this));
        } else {
          $(window).off('resize.bs.modal');
        }
      };

      Modal.prototype.hideModal = function () {
        var that = this;
        this.$element.hide();
        this.backdrop(function () {
          that.$body.removeClass('modal-open');
          that.resetAdjustments();
          that.resetScrollbar();
          that.$element.trigger('hidden.bs.modal');
        });
      };

      Modal.prototype.removeBackdrop = function () {
        this.$backdrop && this.$backdrop.remove();
        this.$backdrop = null;
      };

      Modal.prototype.backdrop = function (callback) {
        var that = this;
        var animate = this.$element.hasClass('fade') ? 'fade' : '';

        if (this.isShown && this.options.backdrop) {
          var doAnimate = $.support.transition && animate;

          this.$backdrop = $(document.createElement('div')).addClass('modal-backdrop ' + animate).appendTo(this.$body);

          this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
            if (this.ignoreBackdropClick) {
              this.ignoreBackdropClick = false;
              return;
            }
            if (e.target !== e.currentTarget) return;
            this.options.backdrop == 'static' ? this.$element[0].focus() : this.hide();
          }, this));

          if (doAnimate) this.$backdrop[0].offsetWidth; // force reflow

          this.$backdrop.addClass('in');

          if (!callback) return;

          doAnimate ? this.$backdrop.one('bsTransitionEnd', callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback();
        } else if (!this.isShown && this.$backdrop) {
          this.$backdrop.removeClass('in');

          var callbackRemove = function () {
            that.removeBackdrop();
            callback && callback();
          };
          $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one('bsTransitionEnd', callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
        } else if (callback) {
          callback();
        }
      };

      // these following methods are used to handle overflowing modals

      Modal.prototype.handleUpdate = function () {
        this.adjustDialog();
      };

      Modal.prototype.adjustDialog = function () {
        var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;

        this.$element.css({
          paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
          paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
        });
      };

      Modal.prototype.resetAdjustments = function () {
        this.$element.css({
          paddingLeft: '',
          paddingRight: ''
        });
      };

      Modal.prototype.checkScrollbar = function () {
        var fullWindowWidth = window.innerWidth;
        if (!fullWindowWidth) {
          // workaround for missing window.innerWidth in IE8
          var documentElementRect = document.documentElement.getBoundingClientRect();
          fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
        }
        this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
        this.scrollbarWidth = this.measureScrollbar();
      };

      Modal.prototype.setScrollbar = function () {
        var bodyPad = parseInt(this.$body.css('padding-right') || 0, 10);
        this.originalBodyPad = document.body.style.paddingRight || '';
        if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth);
      };

      Modal.prototype.resetScrollbar = function () {
        this.$body.css('padding-right', this.originalBodyPad);
      };

      Modal.prototype.measureScrollbar = function () {
        // thx walsh
        var scrollDiv = document.createElement('div');
        scrollDiv.className = 'modal-scrollbar-measure';
        this.$body.append(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        this.$body[0].removeChild(scrollDiv);
        return scrollbarWidth;
      };

      // MODAL PLUGIN DEFINITION
      // =======================

      function Plugin(option, _relatedTarget) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.modal');
          var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option);

          if (!data) $this.data('bs.modal', data = new Modal(this, options));
          if (typeof option == 'string') data[option](_relatedTarget);else if (options.show) data.show(_relatedTarget);
        });
      }

      var old = $.fn.modal;

      $.fn.modal = Plugin;
      $.fn.modal.Constructor = Modal;

      // MODAL NO CONFLICT
      // =================

      $.fn.modal.noConflict = function () {
        $.fn.modal = old;
        return this;
      };

      // MODAL DATA-API
      // ==============

      $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
        var $this = $(this);
        var href = $this.attr('href');
        var $target = $($this.attr('data-target') || href && href.replace(/.*(?=#[^\s]+$)/, '')); // strip for ie7
        var option = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data());

        if ($this.is('a')) e.preventDefault();

        $target.one('show.bs.modal', function (showEvent) {
          if (showEvent.isDefaultPrevented()) return; // only register focus restorer if modal will actually get shown
          $target.one('hidden.bs.modal', function () {
            $this.is(':visible') && $this.trigger('focus');
          });
        });
        Plugin.call($target, option, this);
      });
    }(jQuery);

    /* ========================================================================
     * Bootstrap: tooltip.js v3.3.7
     * http://getbootstrap.com/javascript/#tooltip
     * Inspired by the original jQuery.tipsy by Jason Frame
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // TOOLTIP PUBLIC CLASS DEFINITION
      // ===============================

      var Tooltip = function (element, options) {
        this.type = null;
        this.options = null;
        this.enabled = null;
        this.timeout = null;
        this.hoverState = null;
        this.$element = null;
        this.inState = null;

        this.init('tooltip', element, options);
      };

      Tooltip.VERSION = '3.3.7';

      Tooltip.TRANSITION_DURATION = 150;

      Tooltip.DEFAULTS = {
        animation: true,
        placement: 'top',
        selector: false,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: 'hover focus',
        title: '',
        delay: 0,
        html: false,
        container: false,
        viewport: {
          selector: 'body',
          padding: 0
        }
      };

      Tooltip.prototype.init = function (type, element, options) {
        this.enabled = true;
        this.type = type;
        this.$element = $(element);
        this.options = this.getOptions(options);
        this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport);
        this.inState = { click: false, hover: false, focus: false };

        if (this.$element[0] instanceof document.constructor && !this.options.selector) {
          throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!');
        }

        var triggers = this.options.trigger.split(' ');

        for (var i = triggers.length; i--;) {
          var trigger = triggers[i];

          if (trigger == 'click') {
            this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this));
          } else if (trigger != 'manual') {
            var eventIn = trigger == 'hover' ? 'mouseenter' : 'focusin';
            var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout';

            this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this));
            this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this));
          }
        }

        this.options.selector ? this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' }) : this.fixTitle();
      };

      Tooltip.prototype.getDefaults = function () {
        return Tooltip.DEFAULTS;
      };

      Tooltip.prototype.getOptions = function (options) {
        options = $.extend({}, this.getDefaults(), this.$element.data(), options);

        if (options.delay && typeof options.delay == 'number') {
          options.delay = {
            show: options.delay,
            hide: options.delay
          };
        }

        return options;
      };

      Tooltip.prototype.getDelegateOptions = function () {
        var options = {};
        var defaults = this.getDefaults();

        this._options && $.each(this._options, function (key, value) {
          if (defaults[key] != value) options[key] = value;
        });

        return options;
      };

      Tooltip.prototype.enter = function (obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);

        if (!self) {
          self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
          $(obj.currentTarget).data('bs.' + this.type, self);
        }

        if (obj instanceof $.Event) {
          self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true;
        }

        if (self.tip().hasClass('in') || self.hoverState == 'in') {
          self.hoverState = 'in';
          return;
        }

        clearTimeout(self.timeout);

        self.hoverState = 'in';

        if (!self.options.delay || !self.options.delay.show) return self.show();

        self.timeout = setTimeout(function () {
          if (self.hoverState == 'in') self.show();
        }, self.options.delay.show);
      };

      Tooltip.prototype.isInStateTrue = function () {
        for (var key in this.inState) {
          if (this.inState[key]) return true;
        }

        return false;
      };

      Tooltip.prototype.leave = function (obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);

        if (!self) {
          self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
          $(obj.currentTarget).data('bs.' + this.type, self);
        }

        if (obj instanceof $.Event) {
          self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false;
        }

        if (self.isInStateTrue()) return;

        clearTimeout(self.timeout);

        self.hoverState = 'out';

        if (!self.options.delay || !self.options.delay.hide) return self.hide();

        self.timeout = setTimeout(function () {
          if (self.hoverState == 'out') self.hide();
        }, self.options.delay.hide);
      };

      Tooltip.prototype.show = function () {
        var e = $.Event('show.bs.' + this.type);

        if (this.hasContent() && this.enabled) {
          this.$element.trigger(e);

          var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
          if (e.isDefaultPrevented() || !inDom) return;
          var that = this;

          var $tip = this.tip();

          var tipId = this.getUID(this.type);

          this.setContent();
          $tip.attr('id', tipId);
          this.$element.attr('aria-describedby', tipId);

          if (this.options.animation) $tip.addClass('fade');

          var placement = typeof this.options.placement == 'function' ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;

          var autoToken = /\s?auto?\s?/i;
          var autoPlace = autoToken.test(placement);
          if (autoPlace) placement = placement.replace(autoToken, '') || 'top';

          $tip.detach().css({ top: 0, left: 0, display: 'block' }).addClass(placement).data('bs.' + this.type, this);

          this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);
          this.$element.trigger('inserted.bs.' + this.type);

          var pos = this.getPosition();
          var actualWidth = $tip[0].offsetWidth;
          var actualHeight = $tip[0].offsetHeight;

          if (autoPlace) {
            var orgPlacement = placement;
            var viewportDim = this.getPosition(this.$viewport);

            placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top' : placement == 'top' && pos.top - actualHeight < viewportDim.top ? 'bottom' : placement == 'right' && pos.right + actualWidth > viewportDim.width ? 'left' : placement == 'left' && pos.left - actualWidth < viewportDim.left ? 'right' : placement;

            $tip.removeClass(orgPlacement).addClass(placement);
          }

          var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);

          this.applyPlacement(calculatedOffset, placement);

          var complete = function () {
            var prevHoverState = that.hoverState;
            that.$element.trigger('shown.bs.' + that.type);
            that.hoverState = null;

            if (prevHoverState == 'out') that.leave(that);
          };

          $.support.transition && this.$tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        }
      };

      Tooltip.prototype.applyPlacement = function (offset, placement) {
        var $tip = this.tip();
        var width = $tip[0].offsetWidth;
        var height = $tip[0].offsetHeight;

        // manually read margins because getBoundingClientRect includes difference
        var marginTop = parseInt($tip.css('margin-top'), 10);
        var marginLeft = parseInt($tip.css('margin-left'), 10);

        // we must check for NaN for ie 8/9
        if (isNaN(marginTop)) marginTop = 0;
        if (isNaN(marginLeft)) marginLeft = 0;

        offset.top += marginTop;
        offset.left += marginLeft;

        // $.fn.offset doesn't round pixel values
        // so we use setOffset directly with our own function B-0
        $.offset.setOffset($tip[0], $.extend({
          using: function (props) {
            $tip.css({
              top: Math.round(props.top),
              left: Math.round(props.left)
            });
          }
        }, offset), 0);

        $tip.addClass('in');

        // check to see if placing tip in new offset caused the tip to resize itself
        var actualWidth = $tip[0].offsetWidth;
        var actualHeight = $tip[0].offsetHeight;

        if (placement == 'top' && actualHeight != height) {
          offset.top = offset.top + height - actualHeight;
        }

        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);

        if (delta.left) offset.left += delta.left;else offset.top += delta.top;

        var isVertical = /top|bottom/.test(placement);
        var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;
        var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';

        $tip.offset(offset);
        this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
      };

      Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
        this.arrow().css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%').css(isVertical ? 'top' : 'left', '');
      };

      Tooltip.prototype.setContent = function () {
        var $tip = this.tip();
        var title = this.getTitle();

        $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title);
        $tip.removeClass('fade in top bottom left right');
      };

      Tooltip.prototype.hide = function (callback) {
        var that = this;
        var $tip = $(this.$tip);
        var e = $.Event('hide.bs.' + this.type);

        function complete() {
          if (that.hoverState != 'in') $tip.detach();
          if (that.$element) {
            // TODO: Check whether guarding this code with this `if` is really necessary.
            that.$element.removeAttr('aria-describedby').trigger('hidden.bs.' + that.type);
          }
          callback && callback();
        }

        this.$element.trigger(e);

        if (e.isDefaultPrevented()) return;

        $tip.removeClass('in');

        $.support.transition && $tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();

        this.hoverState = null;

        return this;
      };

      Tooltip.prototype.fixTitle = function () {
        var $e = this.$element;
        if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
          $e.attr('data-original-title', $e.attr('title') || '').attr('title', '');
        }
      };

      Tooltip.prototype.hasContent = function () {
        return this.getTitle();
      };

      Tooltip.prototype.getPosition = function ($element) {
        $element = $element || this.$element;

        var el = $element[0];
        var isBody = el.tagName == 'BODY';

        var elRect = el.getBoundingClientRect();
        if (elRect.width == null) {
          // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
          elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top });
        }
        var isSvg = window.SVGElement && el instanceof window.SVGElement;
        // Avoid using $.offset() on SVGs since it gives incorrect results in jQuery 3.
        // See https://github.com/twbs/bootstrap/issues/20280
        var elOffset = isBody ? { top: 0, left: 0 } : isSvg ? null : $element.offset();
        var scroll = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() };
        var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null;

        return $.extend({}, elRect, scroll, outerDims, elOffset);
      };

      Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
        return placement == 'bottom' ? { top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2 } : placement == 'top' ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } : placement == 'left' ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
        /* placement == 'right' */{ top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width };
      };

      Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
        var delta = { top: 0, left: 0 };
        if (!this.$viewport) return delta;

        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0;
        var viewportDimensions = this.getPosition(this.$viewport);

        if (/right|left/.test(placement)) {
          var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll;
          var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;
          if (topEdgeOffset < viewportDimensions.top) {
            // top overflow
            delta.top = viewportDimensions.top - topEdgeOffset;
          } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
            // bottom overflow
            delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
          }
        } else {
          var leftEdgeOffset = pos.left - viewportPadding;
          var rightEdgeOffset = pos.left + viewportPadding + actualWidth;
          if (leftEdgeOffset < viewportDimensions.left) {
            // left overflow
            delta.left = viewportDimensions.left - leftEdgeOffset;
          } else if (rightEdgeOffset > viewportDimensions.right) {
            // right overflow
            delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
          }
        }

        return delta;
      };

      Tooltip.prototype.getTitle = function () {
        var title;
        var $e = this.$element;
        var o = this.options;

        title = $e.attr('data-original-title') || (typeof o.title == 'function' ? o.title.call($e[0]) : o.title);

        return title;
      };

      Tooltip.prototype.getUID = function (prefix) {
        do prefix += ~~(Math.random() * 1000000); while (document.getElementById(prefix));
        return prefix;
      };

      Tooltip.prototype.tip = function () {
        if (!this.$tip) {
          this.$tip = $(this.options.template);
          if (this.$tip.length != 1) {
            throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!');
          }
        }
        return this.$tip;
      };

      Tooltip.prototype.arrow = function () {
        return this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow');
      };

      Tooltip.prototype.enable = function () {
        this.enabled = true;
      };

      Tooltip.prototype.disable = function () {
        this.enabled = false;
      };

      Tooltip.prototype.toggleEnabled = function () {
        this.enabled = !this.enabled;
      };

      Tooltip.prototype.toggle = function (e) {
        var self = this;
        if (e) {
          self = $(e.currentTarget).data('bs.' + this.type);
          if (!self) {
            self = new this.constructor(e.currentTarget, this.getDelegateOptions());
            $(e.currentTarget).data('bs.' + this.type, self);
          }
        }

        if (e) {
          self.inState.click = !self.inState.click;
          if (self.isInStateTrue()) self.enter(self);else self.leave(self);
        } else {
          self.tip().hasClass('in') ? self.leave(self) : self.enter(self);
        }
      };

      Tooltip.prototype.destroy = function () {
        var that = this;
        clearTimeout(this.timeout);
        this.hide(function () {
          that.$element.off('.' + that.type).removeData('bs.' + that.type);
          if (that.$tip) {
            that.$tip.detach();
          }
          that.$tip = null;
          that.$arrow = null;
          that.$viewport = null;
          that.$element = null;
        });
      };

      // TOOLTIP PLUGIN DEFINITION
      // =========================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.tooltip');
          var options = typeof option == 'object' && option;

          if (!data && /destroy|hide/.test(option)) return;
          if (!data) $this.data('bs.tooltip', data = new Tooltip(this, options));
          if (typeof option == 'string') data[option]();
        });
      }

      var old = $.fn.tooltip;

      $.fn.tooltip = Plugin;
      $.fn.tooltip.Constructor = Tooltip;

      // TOOLTIP NO CONFLICT
      // ===================

      $.fn.tooltip.noConflict = function () {
        $.fn.tooltip = old;
        return this;
      };
    }(jQuery);

    /* ========================================================================
     * Bootstrap: popover.js v3.3.7
     * http://getbootstrap.com/javascript/#popovers
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // POPOVER PUBLIC CLASS DEFINITION
      // ===============================

      var Popover = function (element, options) {
        this.init('popover', element, options);
      };

      if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js');

      Popover.VERSION = '3.3.7';

      Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: 'right',
        trigger: 'click',
        content: '',
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
      });

      // NOTE: POPOVER EXTENDS tooltip.js
      // ================================

      Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);

      Popover.prototype.constructor = Popover;

      Popover.prototype.getDefaults = function () {
        return Popover.DEFAULTS;
      };

      Popover.prototype.setContent = function () {
        var $tip = this.tip();
        var title = this.getTitle();
        var content = this.getContent();

        $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title);
        $tip.find('.popover-content').children().detach().end()[// we use append for html objects to maintain js events
        this.options.html ? typeof content == 'string' ? 'html' : 'append' : 'text'](content);

        $tip.removeClass('fade top bottom left right in');

        // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
        // this manually by checking the contents.
        if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide();
      };

      Popover.prototype.hasContent = function () {
        return this.getTitle() || this.getContent();
      };

      Popover.prototype.getContent = function () {
        var $e = this.$element;
        var o = this.options;

        return $e.attr('data-content') || (typeof o.content == 'function' ? o.content.call($e[0]) : o.content);
      };

      Popover.prototype.arrow = function () {
        return this.$arrow = this.$arrow || this.tip().find('.arrow');
      };

      // POPOVER PLUGIN DEFINITION
      // =========================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.popover');
          var options = typeof option == 'object' && option;

          if (!data && /destroy|hide/.test(option)) return;
          if (!data) $this.data('bs.popover', data = new Popover(this, options));
          if (typeof option == 'string') data[option]();
        });
      }

      var old = $.fn.popover;

      $.fn.popover = Plugin;
      $.fn.popover.Constructor = Popover;

      // POPOVER NO CONFLICT
      // ===================

      $.fn.popover.noConflict = function () {
        $.fn.popover = old;
        return this;
      };
    }(jQuery);

    /* ========================================================================
     * Bootstrap: scrollspy.js v3.3.7
     * http://getbootstrap.com/javascript/#scrollspy
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // SCROLLSPY CLASS DEFINITION
      // ==========================

      function ScrollSpy(element, options) {
        this.$body = $(document.body);
        this.$scrollElement = $(element).is(document.body) ? $(window) : $(element);
        this.options = $.extend({}, ScrollSpy.DEFAULTS, options);
        this.selector = (this.options.target || '') + ' .nav li > a';
        this.offsets = [];
        this.targets = [];
        this.activeTarget = null;
        this.scrollHeight = 0;

        this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this));
        this.refresh();
        this.process();
      }

      ScrollSpy.VERSION = '3.3.7';

      ScrollSpy.DEFAULTS = {
        offset: 10
      };

      ScrollSpy.prototype.getScrollHeight = function () {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);
      };

      ScrollSpy.prototype.refresh = function () {
        var that = this;
        var offsetMethod = 'offset';
        var offsetBase = 0;

        this.offsets = [];
        this.targets = [];
        this.scrollHeight = this.getScrollHeight();

        if (!$.isWindow(this.$scrollElement[0])) {
          offsetMethod = 'position';
          offsetBase = this.$scrollElement.scrollTop();
        }

        this.$body.find(this.selector).map(function () {
          var $el = $(this);
          var href = $el.data('target') || $el.attr('href');
          var $href = /^#./.test(href) && $(href);

          return $href && $href.length && $href.is(':visible') && [[$href[offsetMethod]().top + offsetBase, href]] || null;
        }).sort(function (a, b) {
          return a[0] - b[0];
        }).each(function () {
          that.offsets.push(this[0]);
          that.targets.push(this[1]);
        });
      };

      ScrollSpy.prototype.process = function () {
        var scrollTop = this.$scrollElement.scrollTop() + this.options.offset;
        var scrollHeight = this.getScrollHeight();
        var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height();
        var offsets = this.offsets;
        var targets = this.targets;
        var activeTarget = this.activeTarget;
        var i;

        if (this.scrollHeight != scrollHeight) {
          this.refresh();
        }

        if (scrollTop >= maxScroll) {
          return activeTarget != (i = targets[targets.length - 1]) && this.activate(i);
        }

        if (activeTarget && scrollTop < offsets[0]) {
          this.activeTarget = null;
          return this.clear();
        }

        for (i = offsets.length; i--;) {
          activeTarget != targets[i] && scrollTop >= offsets[i] && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) && this.activate(targets[i]);
        }
      };

      ScrollSpy.prototype.activate = function (target) {
        this.activeTarget = target;

        this.clear();

        var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]';

        var active = $(selector).parents('li').addClass('active');

        if (active.parent('.dropdown-menu').length) {
          active = active.closest('li.dropdown').addClass('active');
        }

        active.trigger('activate.bs.scrollspy');
      };

      ScrollSpy.prototype.clear = function () {
        $(this.selector).parentsUntil(this.options.target, '.active').removeClass('active');
      };

      // SCROLLSPY PLUGIN DEFINITION
      // ===========================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.scrollspy');
          var options = typeof option == 'object' && option;

          if (!data) $this.data('bs.scrollspy', data = new ScrollSpy(this, options));
          if (typeof option == 'string') data[option]();
        });
      }

      var old = $.fn.scrollspy;

      $.fn.scrollspy = Plugin;
      $.fn.scrollspy.Constructor = ScrollSpy;

      // SCROLLSPY NO CONFLICT
      // =====================

      $.fn.scrollspy.noConflict = function () {
        $.fn.scrollspy = old;
        return this;
      };

      // SCROLLSPY DATA-API
      // ==================

      $(window).on('load.bs.scrollspy.data-api', function () {
        $('[data-spy="scroll"]').each(function () {
          var $spy = $(this);
          Plugin.call($spy, $spy.data());
        });
      });
    }(jQuery);

    /* ========================================================================
     * Bootstrap: tab.js v3.3.7
     * http://getbootstrap.com/javascript/#tabs
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // TAB CLASS DEFINITION
      // ====================

      var Tab = function (element) {
        // jscs:disable requireDollarBeforejQueryAssignment
        this.element = $(element);
        // jscs:enable requireDollarBeforejQueryAssignment
      };

      Tab.VERSION = '3.3.7';

      Tab.TRANSITION_DURATION = 150;

      Tab.prototype.show = function () {
        var $this = this.element;
        var $ul = $this.closest('ul:not(.dropdown-menu)');
        var selector = $this.data('target');

        if (!selector) {
          selector = $this.attr('href');
          selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ''); // strip for ie7
        }

        if ($this.parent('li').hasClass('active')) return;

        var $previous = $ul.find('.active:last a');
        var hideEvent = $.Event('hide.bs.tab', {
          relatedTarget: $this[0]
        });
        var showEvent = $.Event('show.bs.tab', {
          relatedTarget: $previous[0]
        });

        $previous.trigger(hideEvent);
        $this.trigger(showEvent);

        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return;

        var $target = $(selector);

        this.activate($this.closest('li'), $ul);
        this.activate($target, $target.parent(), function () {
          $previous.trigger({
            type: 'hidden.bs.tab',
            relatedTarget: $this[0]
          });
          $this.trigger({
            type: 'shown.bs.tab',
            relatedTarget: $previous[0]
          });
        });
      };

      Tab.prototype.activate = function (element, container, callback) {
        var $active = container.find('> .active');
        var transition = callback && $.support.transition && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length);

        function next() {
          $active.removeClass('active').find('> .dropdown-menu > .active').removeClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', false);

          element.addClass('active').find('[data-toggle="tab"]').attr('aria-expanded', true);

          if (transition) {
            element[0].offsetWidth; // reflow for transition
            element.addClass('in');
          } else {
            element.removeClass('fade');
          }

          if (element.parent('.dropdown-menu').length) {
            element.closest('li.dropdown').addClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', true);
          }

          callback && callback();
        }

        $active.length && transition ? $active.one('bsTransitionEnd', next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next();

        $active.removeClass('in');
      };

      // TAB PLUGIN DEFINITION
      // =====================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.tab');

          if (!data) $this.data('bs.tab', data = new Tab(this));
          if (typeof option == 'string') data[option]();
        });
      }

      var old = $.fn.tab;

      $.fn.tab = Plugin;
      $.fn.tab.Constructor = Tab;

      // TAB NO CONFLICT
      // ===============

      $.fn.tab.noConflict = function () {
        $.fn.tab = old;
        return this;
      };

      // TAB DATA-API
      // ============

      var clickHandler = function (e) {
        e.preventDefault();
        Plugin.call($(this), 'show');
      };

      $(document).on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler).on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler);
    }(jQuery);

    /* ========================================================================
     * Bootstrap: affix.js v3.3.7
     * http://getbootstrap.com/javascript/#affix
     * ========================================================================
     * Copyright 2011-2016 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      'use strict';

      // AFFIX CLASS DEFINITION
      // ======================

      var Affix = function (element, options) {
        this.options = $.extend({}, Affix.DEFAULTS, options);

        this.$target = $(this.options.target).on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this)).on('click.bs.affix.data-api', $.proxy(this.checkPositionWithEventLoop, this));

        this.$element = $(element);
        this.affixed = null;
        this.unpin = null;
        this.pinnedOffset = null;

        this.checkPosition();
      };

      Affix.VERSION = '3.3.7';

      Affix.RESET = 'affix affix-top affix-bottom';

      Affix.DEFAULTS = {
        offset: 0,
        target: window
      };

      Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        var targetHeight = this.$target.height();

        if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false;

        if (this.affixed == 'bottom') {
          if (offsetTop != null) return scrollTop + this.unpin <= position.top ? false : 'bottom';
          return scrollTop + targetHeight <= scrollHeight - offsetBottom ? false : 'bottom';
        }

        var initializing = this.affixed == null;
        var colliderTop = initializing ? scrollTop : position.top;
        var colliderHeight = initializing ? targetHeight : height;

        if (offsetTop != null && scrollTop <= offsetTop) return 'top';
        if (offsetBottom != null && colliderTop + colliderHeight >= scrollHeight - offsetBottom) return 'bottom';

        return false;
      };

      Affix.prototype.getPinnedOffset = function () {
        if (this.pinnedOffset) return this.pinnedOffset;
        this.$element.removeClass(Affix.RESET).addClass('affix');
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        return this.pinnedOffset = position.top - scrollTop;
      };

      Affix.prototype.checkPositionWithEventLoop = function () {
        setTimeout($.proxy(this.checkPosition, this), 1);
      };

      Affix.prototype.checkPosition = function () {
        if (!this.$element.is(':visible')) return;

        var height = this.$element.height();
        var offset = this.options.offset;
        var offsetTop = offset.top;
        var offsetBottom = offset.bottom;
        var scrollHeight = Math.max($(document).height(), $(document.body).height());

        if (typeof offset != 'object') offsetBottom = offsetTop = offset;
        if (typeof offsetTop == 'function') offsetTop = offset.top(this.$element);
        if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element);

        var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom);

        if (this.affixed != affix) {
          if (this.unpin != null) this.$element.css('top', '');

          var affixType = 'affix' + (affix ? '-' + affix : '');
          var e = $.Event(affixType + '.bs.affix');

          this.$element.trigger(e);

          if (e.isDefaultPrevented()) return;

          this.affixed = affix;
          this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null;

          this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace('affix', 'affixed') + '.bs.affix');
        }

        if (affix == 'bottom') {
          this.$element.offset({
            top: scrollHeight - height - offsetBottom
          });
        }
      };

      // AFFIX PLUGIN DEFINITION
      // =======================

      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.affix');
          var options = typeof option == 'object' && option;

          if (!data) $this.data('bs.affix', data = new Affix(this, options));
          if (typeof option == 'string') data[option]();
        });
      }

      var old = $.fn.affix;

      $.fn.affix = Plugin;
      $.fn.affix.Constructor = Affix;

      // AFFIX NO CONFLICT
      // =================

      $.fn.affix.noConflict = function () {
        $.fn.affix = old;
        return this;
      };

      // AFFIX DATA-API
      // ==============

      $(window).on('load', function () {
        $('[data-spy="affix"]').each(function () {
          var $spy = $(this);
          var data = $spy.data();

          data.offset = data.offset || {};

          if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom;
          if (data.offsetTop != null) data.offset.top = data.offsetTop;

          Plugin.call($spy, data);
        });
      });
    }(jQuery);
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("7d", ["7c"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  module.exports = $__require("7c");
});
$__System.registerDynamic('7e', [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    CodeMirror.defineMode("xml", function (config, parserConfig) {
      var indentUnit = config.indentUnit;
      var multilineTagIndentFactor = parserConfig.multilineTagIndentFactor || 1;
      var multilineTagIndentPastTag = parserConfig.multilineTagIndentPastTag || true;

      var Kludges = parserConfig.htmlMode ? {
        autoSelfClosers: { 'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
          'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
          'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
          'track': true, 'wbr': true },
        implicitlyClosed: { 'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
          'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
          'th': true, 'tr': true },
        contextGrabbers: {
          'dd': { 'dd': true, 'dt': true },
          'dt': { 'dd': true, 'dt': true },
          'li': { 'li': true },
          'option': { 'option': true, 'optgroup': true },
          'optgroup': { 'optgroup': true },
          'p': { 'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
            'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
            'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
            'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
            'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true },
          'rp': { 'rp': true, 'rt': true },
          'rt': { 'rp': true, 'rt': true },
          'tbody': { 'tbody': true, 'tfoot': true },
          'td': { 'td': true, 'th': true },
          'tfoot': { 'tbody': true },
          'th': { 'td': true, 'th': true },
          'thead': { 'tbody': true, 'tfoot': true },
          'tr': { 'tr': true }
        },
        doNotIndent: { "pre": true },
        allowUnquoted: true,
        allowMissing: true
      } : {
        autoSelfClosers: {},
        implicitlyClosed: {},
        contextGrabbers: {},
        doNotIndent: {},
        allowUnquoted: false,
        allowMissing: false
      };
      var alignCDATA = parserConfig.alignCDATA;

      // Return variables for tokenizers
      var tagName, type;

      function inText(stream, state) {
        function chain(parser) {
          state.tokenize = parser;
          return parser(stream, state);
        }

        var ch = stream.next();
        if (ch == "<") {
          if (stream.eat("!")) {
            if (stream.eat("[")) {
              if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));else return null;
            } else if (stream.match("--")) {
              return chain(inBlock("comment", "-->"));
            } else if (stream.match("DOCTYPE", true, true)) {
              stream.eatWhile(/[\w\._\-]/);
              return chain(doctype(1));
            } else {
              return null;
            }
          } else if (stream.eat("?")) {
            stream.eatWhile(/[\w\._\-]/);
            state.tokenize = inBlock("meta", "?>");
            return "meta";
          } else {
            var isClose = stream.eat("/");
            tagName = "";
            var c;
            while (c = stream.eat(/[^\s\u00a0=<>\"\'\/?]/)) tagName += c;
            if (!tagName) return "tag error";
            type = isClose ? "closeTag" : "openTag";
            state.tokenize = inTag;
            return "tag";
          }
        } else if (ch == "&") {
          var ok;
          if (stream.eat("#")) {
            if (stream.eat("x")) {
              ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
            } else {
              ok = stream.eatWhile(/[\d]/) && stream.eat(";");
            }
          } else {
            ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
          }
          return ok ? "atom" : "error";
        } else {
          stream.eatWhile(/[^&<]/);
          return null;
        }
      }

      function inTag(stream, state) {
        var ch = stream.next();
        if (ch == ">" || ch == "/" && stream.eat(">")) {
          state.tokenize = inText;
          type = ch == ">" ? "endTag" : "selfcloseTag";
          return "tag";
        } else if (ch == "=") {
          type = "equals";
          return null;
        } else if (ch == "<") {
          state.tokenize = inText;
          var next = state.tokenize(stream, state);
          return next ? next + " error" : "error";
        } else if (/[\'\"]/.test(ch)) {
          state.tokenize = inAttribute(ch);
          state.stringStartCol = stream.column();
          return state.tokenize(stream, state);
        } else {
          stream.eatWhile(/[^\s\u00a0=<>\"\']/);
          return "word";
        }
      }

      function inAttribute(quote) {
        var closure = function (stream, state) {
          while (!stream.eol()) {
            if (stream.next() == quote) {
              state.tokenize = inTag;
              break;
            }
          }
          return "string";
        };
        closure.isInAttribute = true;
        return closure;
      }

      function inBlock(style, terminator) {
        return function (stream, state) {
          while (!stream.eol()) {
            if (stream.match(terminator)) {
              state.tokenize = inText;
              break;
            }
            stream.next();
          }
          return style;
        };
      }
      function doctype(depth) {
        return function (stream, state) {
          var ch;
          while ((ch = stream.next()) != null) {
            if (ch == "<") {
              state.tokenize = doctype(depth + 1);
              return state.tokenize(stream, state);
            } else if (ch == ">") {
              if (depth == 1) {
                state.tokenize = inText;
                break;
              } else {
                state.tokenize = doctype(depth - 1);
                return state.tokenize(stream, state);
              }
            }
          }
          return "meta";
        };
      }

      var curState, curStream, setStyle;
      function pass() {
        for (var i = arguments.length - 1; i >= 0; i--) curState.cc.push(arguments[i]);
      }
      function cont() {
        pass.apply(null, arguments);
        return true;
      }

      function pushContext(tagName, startOfLine) {
        var noIndent = Kludges.doNotIndent.hasOwnProperty(tagName) || curState.context && curState.context.noIndent;
        curState.context = {
          prev: curState.context,
          tagName: tagName,
          indent: curState.indented,
          startOfLine: startOfLine,
          noIndent: noIndent
        };
      }
      function popContext() {
        if (curState.context) curState.context = curState.context.prev;
      }

      function element(type) {
        if (type == "openTag") {
          curState.tagName = tagName;
          curState.tagStart = curStream.column();
          return cont(attributes, endtag(curState.startOfLine));
        } else if (type == "closeTag") {
          var err = false;
          if (curState.context) {
            if (curState.context.tagName != tagName) {
              if (Kludges.implicitlyClosed.hasOwnProperty(curState.context.tagName.toLowerCase())) {
                popContext();
              }
              err = !curState.context || curState.context.tagName != tagName;
            }
          } else {
            err = true;
          }
          if (err) setStyle = "error";
          return cont(endclosetag(err));
        }
        return cont();
      }
      function endtag(startOfLine) {
        return function (type) {
          var tagName = curState.tagName;
          curState.tagName = curState.tagStart = null;
          if (type == "selfcloseTag" || type == "endTag" && Kludges.autoSelfClosers.hasOwnProperty(tagName.toLowerCase())) {
            maybePopContext(tagName.toLowerCase());
            return cont();
          }
          if (type == "endTag") {
            maybePopContext(tagName.toLowerCase());
            pushContext(tagName, startOfLine);
            return cont();
          }
          return cont();
        };
      }
      function endclosetag(err) {
        return function (type) {
          if (err) setStyle = "error";
          if (type == "endTag") {
            popContext();return cont();
          }
          setStyle = "error";
          return cont(arguments.callee);
        };
      }
      function maybePopContext(nextTagName) {
        var parentTagName;
        while (true) {
          if (!curState.context) {
            return;
          }
          parentTagName = curState.context.tagName.toLowerCase();
          if (!Kludges.contextGrabbers.hasOwnProperty(parentTagName) || !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
            return;
          }
          popContext();
        }
      }

      function attributes(type) {
        if (type == "word") {
          setStyle = "attribute";return cont(attribute, attributes);
        }
        if (type == "endTag" || type == "selfcloseTag") return pass();
        setStyle = "error";
        return cont(attributes);
      }
      function attribute(type) {
        if (type == "equals") return cont(attvalue, attributes);
        if (!Kludges.allowMissing) setStyle = "error";else if (type == "word") {
          setStyle = "attribute";return cont(attribute, attributes);
        }
        return type == "endTag" || type == "selfcloseTag" ? pass() : cont();
      }
      function attvalue(type) {
        if (type == "string") return cont(attvaluemaybe);
        if (type == "word" && Kludges.allowUnquoted) {
          setStyle = "string";return cont();
        }
        setStyle = "error";
        return type == "endTag" || type == "selfCloseTag" ? pass() : cont();
      }
      function attvaluemaybe(type) {
        if (type == "string") return cont(attvaluemaybe);else return pass();
      }

      return {
        startState: function () {
          return { tokenize: inText, cc: [], indented: 0, startOfLine: true, tagName: null, tagStart: null, context: null };
        },

        token: function (stream, state) {
          if (!state.tagName && stream.sol()) {
            state.startOfLine = true;
            state.indented = stream.indentation();
          }
          if (stream.eatSpace()) return null;

          setStyle = type = tagName = null;
          var style = state.tokenize(stream, state);
          state.type = type;
          if ((style || type) && style != "comment") {
            curState = state;curStream = stream;
            while (true) {
              var comb = state.cc.pop() || element;
              if (comb(type || style)) break;
            }
          }
          state.startOfLine = false;
          if (setStyle) style = setStyle == "error" ? style + " error" : setStyle;
          return style;
        },

        indent: function (state, textAfter, fullLine) {
          var context = state.context;
          // Indent multi-line strings (e.g. css).
          if (state.tokenize.isInAttribute) {
            return state.stringStartCol + 1;
          }
          if (state.tokenize != inTag && state.tokenize != inText || context && context.noIndent) return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
          // Indent the starts of attribute names.
          if (state.tagName) {
            if (multilineTagIndentPastTag) return state.tagStart + state.tagName.length + 2;else return state.tagStart + indentUnit * multilineTagIndentFactor;
          }
          if (alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
          if (context && /^<\//.test(textAfter)) context = context.prev;
          while (context && !context.startOfLine) context = context.prev;
          if (context) return context.indent + indentUnit;else return 0;
        },

        electricChars: "/",
        blockCommentStart: "<!--",
        blockCommentEnd: "-->",

        configuration: parserConfig.htmlMode ? "html" : "xml",
        helperType: parserConfig.htmlMode ? "html" : "xml"
      };
    });

    CodeMirror.defineMIME("text/xml", "xml");
    CodeMirror.defineMIME("application/xml", "xml");
    if (!CodeMirror.mimeModes.hasOwnProperty("text/html")) CodeMirror.defineMIME("text/html", { name: "xml", htmlMode: true });
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("7f", ["80"], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    // TODO actually recognize syntax of TypeScript constructs

    CodeMirror.defineMode("javascript", function (config, parserConfig) {
      var indentUnit = config.indentUnit;
      var statementIndent = parserConfig.statementIndent;
      var jsonMode = parserConfig.json;
      var isTS = parserConfig.typescript;

      // Tokenizer

      var keywords = function () {
        function kw(type) {
          return { type: type, style: "keyword" };
        }
        var A = kw("keyword a"),
            B = kw("keyword b"),
            C = kw("keyword c");
        var operator = kw("operator"),
            atom = { type: "atom", style: "atom" };

        var jsKeywords = {
          "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
          "return": C, "break": C, "continue": C, "new": C, "delete": C, "throw": C,
          "var": kw("var"), "const": kw("var"), "let": kw("var"),
          "function": kw("function"), "catch": kw("catch"),
          "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
          "in": operator, "typeof": operator, "instanceof": operator,
          "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
          "this": kw("this"), "module": kw("module"), "class": kw("class"), "super": kw("atom"),
          "yield": C, "export": kw("export"), "import": kw("import"), "extends": C
        };

        // Extend the 'normal' keywords with the TypeScript language extensions
        if (isTS) {
          var type = { type: "variable", style: "variable-3" };
          var tsKeywords = {
            // object-like things
            "interface": kw("interface"),
            "extends": kw("extends"),
            "constructor": kw("constructor"),

            // scope modifiers
            "public": kw("public"),
            "private": kw("private"),
            "protected": kw("protected"),
            "static": kw("static"),

            // types
            "string": type, "number": type, "bool": type, "any": type
          };

          for (var attr in tsKeywords) {
            jsKeywords[attr] = tsKeywords[attr];
          }
        }

        return jsKeywords;
      }();

      var isOperatorChar = /[+\-*&%=<>!?|~^]/;

      function nextUntilUnescaped(stream, end) {
        var escaped = false,
            next;
        while ((next = stream.next()) != null) {
          if (next == end && !escaped) return false;
          escaped = !escaped && next == "\\";
        }
        return escaped;
      }

      // Used as scratch variables to communicate multiple values without
      // consing up tons of objects.
      var type, content;
      function ret(tp, style, cont) {
        type = tp;content = cont;
        return style;
      }
      function tokenBase(stream, state) {
        var ch = stream.next();
        if (ch == '"' || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
          return ret("number", "number");
        } else if (ch == "." && stream.match("..")) {
          return ret("spread", "meta");
        } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
          return ret(ch);
        } else if (ch == "=" && stream.eat(">")) {
          return ret("=>");
        } else if (ch == "0" && stream.eat(/x/i)) {
          stream.eatWhile(/[\da-f]/i);
          return ret("number", "number");
        } else if (/\d/.test(ch)) {
          stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
          return ret("number", "number");
        } else if (ch == "/") {
          if (stream.eat("*")) {
            state.tokenize = tokenComment;
            return tokenComment(stream, state);
          } else if (stream.eat("/")) {
            stream.skipToEnd();
            return ret("comment", "comment");
          } else if (state.lastType == "operator" || state.lastType == "keyword c" || state.lastType == "sof" || /^[\[{}\(,;:]$/.test(state.lastType)) {
            nextUntilUnescaped(stream, "/");
            stream.eatWhile(/[gimy]/); // 'y' is "sticky" option in Mozilla
            return ret("regexp", "string-2");
          } else {
            stream.eatWhile(isOperatorChar);
            return ret("operator", null, stream.current());
          }
        } else if (ch == "`") {
          state.tokenize = tokenQuasi;
          return tokenQuasi(stream, state);
        } else if (ch == "#") {
          stream.skipToEnd();
          return ret("error", "error");
        } else if (isOperatorChar.test(ch)) {
          stream.eatWhile(isOperatorChar);
          return ret("operator", null, stream.current());
        } else {
          stream.eatWhile(/[\w\$_]/);
          var word = stream.current(),
              known = keywords.propertyIsEnumerable(word) && keywords[word];
          return known && state.lastType != "." ? ret(known.type, known.style, word) : ret("variable", "variable", word);
        }
      }

      function tokenString(quote) {
        return function (stream, state) {
          if (!nextUntilUnescaped(stream, quote)) state.tokenize = tokenBase;
          return ret("string", "string");
        };
      }

      function tokenComment(stream, state) {
        var maybeEnd = false,
            ch;
        while (ch = stream.next()) {
          if (ch == "/" && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = ch == "*";
        }
        return ret("comment", "comment");
      }

      function tokenQuasi(stream, state) {
        var escaped = false,
            next;
        while ((next = stream.next()) != null) {
          if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
            state.tokenize = tokenBase;
            break;
          }
          escaped = !escaped && next == "\\";
        }
        return ret("quasi", "string-2", stream.current());
      }

      var brackets = "([{}])";
      // This is a crude lookahead trick to try and notice that we're
      // parsing the argument patterns for a fat-arrow function before we
      // actually hit the arrow token. It only works if the arrow is on
      // the same line as the arguments and there's no strange noise
      // (comments) in between. Fallback is to only notice when we hit the
      // arrow, and not declare the arguments as locals for the arrow
      // body.
      function findFatArrow(stream, state) {
        if (state.fatArrowAt) state.fatArrowAt = null;
        var arrow = stream.string.indexOf("=>", stream.start);
        if (arrow < 0) return;

        var depth = 0,
            sawSomething = false;
        for (var pos = arrow - 1; pos >= 0; --pos) {
          var ch = stream.string.charAt(pos);
          var bracket = brackets.indexOf(ch);
          if (bracket >= 0 && bracket < 3) {
            if (!depth) {
              ++pos;break;
            }
            if (--depth == 0) break;
          } else if (bracket >= 3 && bracket < 6) {
            ++depth;
          } else if (/[$\w]/.test(ch)) {
            sawSomething = true;
          } else if (sawSomething && !depth) {
            ++pos;
            break;
          }
        }
        if (sawSomething && !depth) state.fatArrowAt = pos;
      }

      // Parser

      var atomicTypes = { "atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true };

      function JSLexical(indented, column, type, align, prev, info) {
        this.indented = indented;
        this.column = column;
        this.type = type;
        this.prev = prev;
        this.info = info;
        if (align != null) this.align = align;
      }

      function inScope(state, varname) {
        for (var v = state.localVars; v; v = v.next) if (v.name == varname) return true;
        for (var cx = state.context; cx; cx = cx.prev) {
          for (var v = cx.vars; v; v = v.next) if (v.name == varname) return true;
        }
      }

      function parseJS(state, style, type, content, stream) {
        var cc = state.cc;
        // Communicate our context to the combinators.
        // (Less wasteful than consing up a hundred closures on every call.)
        cx.state = state;cx.stream = stream;cx.marked = null, cx.cc = cc;

        if (!state.lexical.hasOwnProperty("align")) state.lexical.align = true;

        while (true) {
          var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
          if (combinator(type, content)) {
            while (cc.length && cc[cc.length - 1].lex) cc.pop()();
            if (cx.marked) return cx.marked;
            if (type == "variable" && inScope(state, content)) return "variable-2";
            return style;
          }
        }
      }

      // Combinator utils

      var cx = { state: null, column: null, marked: null, cc: null };
      function pass() {
        for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
      }
      function cont() {
        pass.apply(null, arguments);
        return true;
      }
      function register(varname) {
        function inList(list) {
          for (var v = list; v; v = v.next) if (v.name == varname) return true;
          return false;
        }
        var state = cx.state;
        if (state.context) {
          cx.marked = "def";
          if (inList(state.localVars)) return;
          state.localVars = { name: varname, next: state.localVars };
        } else {
          if (inList(state.globalVars)) return;
          if (parserConfig.globalVars) state.globalVars = { name: varname, next: state.globalVars };
        }
      }

      // Combinators

      var defaultVars = { name: "this", next: { name: "arguments" } };
      function pushcontext() {
        cx.state.context = { prev: cx.state.context, vars: cx.state.localVars };
        cx.state.localVars = defaultVars;
      }
      function popcontext() {
        cx.state.localVars = cx.state.context.vars;
        cx.state.context = cx.state.context.prev;
      }
      function pushlex(type, info) {
        var result = function () {
          var state = cx.state,
              indent = state.indented;
          if (state.lexical.type == "stat") indent = state.lexical.indented;
          state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
        };
        result.lex = true;
        return result;
      }
      function poplex() {
        var state = cx.state;
        if (state.lexical.prev) {
          if (state.lexical.type == ")") state.indented = state.lexical.indented;
          state.lexical = state.lexical.prev;
        }
      }
      poplex.lex = true;

      function expect(wanted) {
        return function (type) {
          if (type == wanted) return cont();else if (wanted == ";") return pass();else return cont(arguments.callee);
        };
      }

      function statement(type, value) {
        if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
        if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);
        if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
        if (type == "{") return cont(pushlex("}"), block, poplex);
        if (type == ";") return cont();
        if (type == "if") return cont(pushlex("form"), expression, statement, poplex, maybeelse);
        if (type == "function") return cont(functiondef);
        if (type == "for") return cont(pushlex("form"), forspec, poplex, statement, poplex);
        if (type == "variable") return cont(pushlex("stat"), maybelabel);
        if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"), block, poplex, poplex);
        if (type == "case") return cont(expression, expect(":"));
        if (type == "default") return cont(expect(":"));
        if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"), statement, poplex, popcontext);
        if (type == "module") return cont(pushlex("form"), pushcontext, afterModule, popcontext, poplex);
        if (type == "class") return cont(pushlex("form"), className, objlit, poplex);
        if (type == "export") return cont(pushlex("form"), afterExport, poplex);
        if (type == "import") return cont(pushlex("form"), afterImport, poplex);
        return pass(pushlex("stat"), expression, expect(";"), poplex);
      }
      function expression(type) {
        return expressionInner(type, false);
      }
      function expressionNoComma(type) {
        return expressionInner(type, true);
      }
      function expressionInner(type, noComma) {
        if (cx.state.fatArrowAt == cx.stream.start) {
          var body = noComma ? arrowBodyNoComma : arrowBody;
          if (type == "(") return cont(pushcontext, commasep(pattern, ")"), expect("=>"), body, popcontext);else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
        }

        var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
        if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
        if (type == "function") return cont(functiondef);
        if (type == "keyword c") return cont(noComma ? maybeexpressionNoComma : maybeexpression);
        if (type == "(") return cont(pushlex(")"), maybeexpression, comprehension, expect(")"), poplex, maybeop);
        if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
        if (type == "[") return cont(pushlex("]"), expressionNoComma, maybeArrayComprehension, poplex, maybeop);
        if (type == "{") return cont(commasep(objprop, "}"), maybeop);
        return cont();
      }
      function maybeexpression(type) {
        if (type.match(/[;\}\)\],]/)) return pass();
        return pass(expression);
      }
      function maybeexpressionNoComma(type) {
        if (type.match(/[;\}\)\],]/)) return pass();
        return pass(expressionNoComma);
      }

      function maybeoperatorComma(type, value) {
        if (type == ",") return cont(expression);
        return maybeoperatorNoComma(type, value, false);
      }
      function maybeoperatorNoComma(type, value, noComma) {
        var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
        var expr = noComma == false ? expression : expressionNoComma;
        if (value == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
        if (type == "operator") {
          if (/\+\+|--/.test(value)) return cont(me);
          if (value == "?") return cont(expression, expect(":"), expr);
          return cont(expr);
        }
        if (type == "quasi") {
          cx.cc.push(me);return quasi(value);
        }
        if (type == ";") return;
        if (type == "(") return cont(commasep(expressionNoComma, ")", "call"), me);
        if (type == ".") return cont(property, me);
        if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
      }
      function quasi(value) {
        if (!value) debugger;
        if (value.slice(value.length - 2) != "${") return cont();
        return cont(expression, continueQuasi);
      }
      function continueQuasi(type) {
        if (type == "}") {
          cx.marked = "string-2";
          cx.state.tokenize = tokenQuasi;
          return cont();
        }
      }
      function arrowBody(type) {
        findFatArrow(cx.stream, cx.state);
        if (type == "{") return pass(statement);
        return pass(expression);
      }
      function arrowBodyNoComma(type) {
        findFatArrow(cx.stream, cx.state);
        if (type == "{") return pass(statement);
        return pass(expressionNoComma);
      }
      function maybelabel(type) {
        if (type == ":") return cont(poplex, statement);
        return pass(maybeoperatorComma, expect(";"), poplex);
      }
      function property(type) {
        if (type == "variable") {
          cx.marked = "property";return cont();
        }
      }
      function objprop(type, value) {
        if (type == "variable") {
          cx.marked = "property";
          if (value == "get" || value == "set") return cont(getterSetter);
        } else if (type == "number" || type == "string") {
          cx.marked = type + " property";
        } else if (type == "[") {
          return cont(expression, expect("]"), afterprop);
        }
        if (atomicTypes.hasOwnProperty(type)) return cont(afterprop);
      }
      function getterSetter(type) {
        if (type != "variable") return pass(afterprop);
        cx.marked = "property";
        return cont(functiondef);
      }
      function afterprop(type) {
        if (type == ":") return cont(expressionNoComma);
        if (type == "(") return pass(functiondef);
      }
      function commasep(what, end, info) {
        function proceed(type) {
          if (type == ",") {
            var lex = cx.state.lexical;
            if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
            return cont(what, proceed);
          }
          if (type == end) return cont();
          return cont(expect(end));
        }
        return function (type) {
          if (type == end) return cont();
          if (info === false) return pass(what, proceed);
          return pass(pushlex(end, info), what, proceed, poplex);
        };
      }
      function block(type) {
        if (type == "}") return cont();
        return pass(statement, block);
      }
      function maybetype(type) {
        if (isTS && type == ":") return cont(typedef);
      }
      function typedef(type) {
        if (type == "variable") {
          cx.marked = "variable-3";return cont();
        }
      }
      function vardef() {
        return pass(pattern, maybetype, maybeAssign, vardefCont);
      }
      function pattern(type, value) {
        if (type == "variable") {
          register(value);return cont();
        }
        if (type == "[") return cont(commasep(pattern, "]"));
        if (type == "{") return cont(commasep(proppattern, "}"));
      }
      function proppattern(type, value) {
        if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
          register(value);
          return cont(maybeAssign);
        }
        if (type == "variable") cx.marked = "property";
        return cont(expect(":"), pattern, maybeAssign);
      }
      function maybeAssign(_type, value) {
        if (value == "=") return cont(expressionNoComma);
      }
      function vardefCont(type) {
        if (type == ",") return cont(vardef);
      }
      function maybeelse(type, value) {
        if (type == "keyword b" && value == "else") return cont(pushlex("form"), statement, poplex);
      }
      function forspec(type) {
        if (type == "(") return cont(pushlex(")"), forspec1, expect(")"));
      }
      function forspec1(type) {
        if (type == "var") return cont(vardef, expect(";"), forspec2);
        if (type == ";") return cont(forspec2);
        if (type == "variable") return cont(formaybeinof);
        return pass(expression, expect(";"), forspec2);
      }
      function formaybeinof(_type, value) {
        if (value == "in" || value == "of") {
          cx.marked = "keyword";return cont(expression);
        }
        return cont(maybeoperatorComma, forspec2);
      }
      function forspec2(type, value) {
        if (type == ";") return cont(forspec3);
        if (value == "in" || value == "of") {
          cx.marked = "keyword";return cont(expression);
        }
        return pass(expression, expect(";"), forspec3);
      }
      function forspec3(type) {
        if (type != ")") cont(expression);
      }
      function functiondef(type, value) {
        if (value == "*") {
          cx.marked = "keyword";return cont(functiondef);
        }
        if (type == "variable") {
          register(value);return cont(functiondef);
        }
        if (type == "(") return cont(pushcontext, commasep(funarg, ")"), statement, popcontext);
      }
      function funarg(type) {
        if (type == "spread") return cont(funarg);
        return pass(pattern, maybetype);
      }
      function className(type, value) {
        if (type == "variable") {
          register(value);return cont(classNameAfter);
        }
      }
      function classNameAfter(_type, value) {
        if (value == "extends") return cont(expression);
      }
      function objlit(type) {
        if (type == "{") return cont(commasep(objprop, "}"));
      }
      function afterModule(type, value) {
        if (type == "string") return cont(statement);
        if (type == "variable") {
          register(value);return cont(maybeFrom);
        }
      }
      function afterExport(_type, value) {
        if (value == "*") {
          cx.marked = "keyword";return cont(maybeFrom, expect(";"));
        }
        if (value == "default") {
          cx.marked = "keyword";return cont(expression, expect(";"));
        }
        return pass(statement);
      }
      function afterImport(type) {
        if (type == "string") return cont();
        return pass(importSpec, maybeFrom);
      }
      function importSpec(type, value) {
        if (type == "{") return cont(commasep(importSpec, "}"));
        if (type == "variable") register(value);
        return cont();
      }
      function maybeFrom(_type, value) {
        if (value == "from") {
          cx.marked = "keyword";return cont(expression);
        }
      }
      function maybeArrayComprehension(type) {
        if (type == "for") return pass(comprehension);
        if (type == ",") return cont(commasep(expressionNoComma, "]", false));
        return pass(commasep(expressionNoComma, "]", false));
      }
      function comprehension(type) {
        if (type == "for") return cont(forspec, comprehension);
        if (type == "if") return cont(expression, comprehension);
      }

      // Interface

      return {
        startState: function (basecolumn) {
          var state = {
            tokenize: tokenBase,
            lastType: "sof",
            cc: [],
            lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
            localVars: parserConfig.localVars,
            context: parserConfig.localVars && { vars: parserConfig.localVars },
            indented: 0
          };
          if (parserConfig.globalVars) state.globalVars = parserConfig.globalVars;
          return state;
        },

        token: function (stream, state) {
          if (stream.sol()) {
            if (!state.lexical.hasOwnProperty("align")) state.lexical.align = false;
            state.indented = stream.indentation();
            findFatArrow(stream, state);
          }
          if (state.tokenize != tokenComment && stream.eatSpace()) return null;
          var style = state.tokenize(stream, state);
          if (type == "comment") return style;
          state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
          return parseJS(state, style, type, content, stream);
        },

        indent: function (state, textAfter) {
          if (state.tokenize == tokenComment) return CodeMirror.Pass;
          if (state.tokenize != tokenBase) return 0;
          var firstChar = textAfter && textAfter.charAt(0),
              lexical = state.lexical;
          // Kludge to prevent 'maybelse' from blocking lexical scope pops
          for (var i = state.cc.length - 1; i >= 0; --i) {
            var c = state.cc[i];
            if (c == poplex) lexical = lexical.prev;else if (c != maybeelse) break;
          }
          if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;
          if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat") lexical = lexical.prev;
          var type = lexical.type,
              closing = firstChar == type;

          if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);else if (type == "form" && firstChar == "{") return lexical.indented;else if (type == "form") return lexical.indented + indentUnit;else if (type == "stat") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? statementIndent || indentUnit : 0);else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false) return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : indentUnit);
        },

        electricChars: ":{}",
        blockCommentStart: jsonMode ? null : "/*",
        blockCommentEnd: jsonMode ? null : "*/",
        lineComment: jsonMode ? null : "//",
        fold: "brace",

        helperType: jsonMode ? "json" : "javascript",
        jsonMode: jsonMode
      };
    });

    CodeMirror.defineMIME("text/javascript", "javascript");
    CodeMirror.defineMIME("text/ecmascript", "javascript");
    CodeMirror.defineMIME("application/javascript", "javascript");
    CodeMirror.defineMIME("application/ecmascript", "javascript");
    CodeMirror.defineMIME("application/json", { name: "javascript", json: true });
    CodeMirror.defineMIME("application/x-json", { name: "javascript", json: true });
    CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
    CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("81", ["80"], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    CodeMirror.defineMode("css", function (config, parserConfig) {
      "use strict";

      if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");

      var indentUnit = config.indentUnit || config.tabSize || 2,
          hooks = parserConfig.hooks || {},
          atMediaTypes = parserConfig.atMediaTypes || {},
          atMediaFeatures = parserConfig.atMediaFeatures || {},
          propertyKeywords = parserConfig.propertyKeywords || {},
          colorKeywords = parserConfig.colorKeywords || {},
          valueKeywords = parserConfig.valueKeywords || {},
          allowNested = !!parserConfig.allowNested,
          type = null;

      function ret(style, tp) {
        type = tp;return style;
      }

      function tokenBase(stream, state) {
        var ch = stream.next();
        if (hooks[ch]) {
          // result[0] is style and result[1] is type
          var result = hooks[ch](stream, state);
          if (result !== false) return result;
        }
        if (ch == "@") {
          stream.eatWhile(/[\w\\\-]/);return ret("def", stream.current());
        } else if (ch == "=") ret(null, "compare");else if ((ch == "~" || ch == "|") && stream.eat("=")) return ret(null, "compare");else if (ch == "\"" || ch == "'") {
          state.tokenize = tokenString(ch);
          return state.tokenize(stream, state);
        } else if (ch == "#") {
          stream.eatWhile(/[\w\\\-]/);
          return ret("atom", "hash");
        } else if (ch == "!") {
          stream.match(/^\s*\w*/);
          return ret("keyword", "important");
        } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
          stream.eatWhile(/[\w.%]/);
          return ret("number", "unit");
        } else if (ch === "-") {
          if (/\d/.test(stream.peek())) {
            stream.eatWhile(/[\w.%]/);
            return ret("number", "unit");
          } else if (stream.match(/^[^-]+-/)) {
            return ret("meta", "meta");
          }
        } else if (/[,+>*\/]/.test(ch)) {
          return ret(null, "select-op");
        } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
          return ret("qualifier", "qualifier");
        } else if (ch == ":") {
          return ret("operator", ch);
        } else if (/[;{}\[\]\(\)]/.test(ch)) {
          return ret(null, ch);
        } else if (ch == "u" && stream.match("rl(")) {
          stream.backUp(1);
          state.tokenize = tokenParenthesized;
          return ret("property", "variable");
        } else {
          stream.eatWhile(/[\w\\\-]/);
          return ret("property", "variable");
        }
      }

      function tokenString(quote, nonInclusive) {
        return function (stream, state) {
          var escaped = false,
              ch;
          while ((ch = stream.next()) != null) {
            if (ch == quote && !escaped) break;
            escaped = !escaped && ch == "\\";
          }
          if (!escaped) {
            if (nonInclusive) stream.backUp(1);
            state.tokenize = tokenBase;
          }
          return ret("string", "string");
        };
      }

      function tokenParenthesized(stream, state) {
        stream.next(); // Must be '('
        if (!stream.match(/\s*[\"\']/, false)) state.tokenize = tokenString(")", true);else state.tokenize = tokenBase;
        return ret(null, "(");
      }

      return {
        startState: function (base) {
          return { tokenize: tokenBase,
            baseIndent: base || 0,
            stack: [],
            lastToken: null };
        },

        token: function (stream, state) {

          // Use these terms when applicable (see http://www.xanthir.com/blog/b4E50)
          //
          // rule** or **ruleset:
          // A selector + braces combo, or an at-rule.
          //
          // declaration block:
          // A sequence of declarations.
          //
          // declaration:
          // A property + colon + value combo.
          //
          // property value:
          // The entire value of a property.
          //
          // component value:
          // A single piece of a property value. Like the 5px in
          // text-shadow: 0 0 5px blue;. Can also refer to things that are
          // multiple terms, like the 1-4 terms that make up the background-size
          // portion of the background shorthand.
          //
          // term:
          // The basic unit of author-facing CSS, like a single number (5),
          // dimension (5px), string ("foo"), or function. Officially defined
          //  by the CSS 2.1 grammar (look for the 'term' production)
          //
          //
          // simple selector:
          // A single atomic selector, like a type selector, an attr selector, a
          // class selector, etc.
          //
          // compound selector:
          // One or more simple selectors without a combinator. div.example is
          // compound, div > .example is not.
          //
          // complex selector:
          // One or more compound selectors chained with combinators.
          //
          // combinator:
          // The parts of selectors that express relationships. There are four
          // currently - the space (descendant combinator), the greater-than
          // bracket (child combinator), the plus sign (next sibling combinator),
          // and the tilda (following sibling combinator).
          //
          // sequence of selectors:
          // One or more of the named type of selector chained with commas.

          state.tokenize = state.tokenize || tokenBase;
          if (state.tokenize == tokenBase && stream.eatSpace()) return null;
          var style = state.tokenize(stream, state);
          if (style && typeof style != "string") style = ret(style[0], style[1]);

          // Changing style returned based on context
          var context = state.stack[state.stack.length - 1];
          if (style == "variable") {
            if (type == "variable-definition") state.stack.push("propertyValue");
            return state.lastToken = "variable-2";
          } else if (style == "property") {
            var word = stream.current().toLowerCase();
            if (context == "propertyValue") {
              if (valueKeywords.hasOwnProperty(word)) {
                style = "string-2";
              } else if (colorKeywords.hasOwnProperty(word)) {
                style = "keyword";
              } else {
                style = "variable-2";
              }
            } else if (context == "rule") {
              if (!propertyKeywords.hasOwnProperty(word)) {
                style += " error";
              }
            } else if (context == "block") {
              // if a value is present in both property, value, or color, the order
              // of preference is property -> color -> value
              if (propertyKeywords.hasOwnProperty(word)) {
                style = "property";
              } else if (colorKeywords.hasOwnProperty(word)) {
                style = "keyword";
              } else if (valueKeywords.hasOwnProperty(word)) {
                style = "string-2";
              } else {
                style = "tag";
              }
            } else if (!context || context == "@media{") {
              style = "tag";
            } else if (context == "@media") {
              if (atMediaTypes[stream.current()]) {
                style = "attribute"; // Known attribute
              } else if (/^(only|not)$/.test(word)) {
                style = "keyword";
              } else if (word == "and") {
                style = "error"; // "and" is only allowed in @mediaType
              } else if (atMediaFeatures.hasOwnProperty(word)) {
                style = "error"; // Known property, should be in @mediaType(
              } else {
                // Unknown, expecting keyword or attribute, assuming attribute
                style = "attribute error";
              }
            } else if (context == "@mediaType") {
              if (atMediaTypes.hasOwnProperty(word)) {
                style = "attribute";
              } else if (word == "and") {
                style = "operator";
              } else if (/^(only|not)$/.test(word)) {
                style = "error"; // Only allowed in @media
              } else {
                // Unknown attribute or property, but expecting property (preceded
                // by "and"). Should be in parentheses
                style = "error";
              }
            } else if (context == "@mediaType(") {
              if (propertyKeywords.hasOwnProperty(word)) {
                // do nothing, remains "property"
              } else if (atMediaTypes.hasOwnProperty(word)) {
                style = "error"; // Known property, should be in parentheses
              } else if (word == "and") {
                style = "operator";
              } else if (/^(only|not)$/.test(word)) {
                style = "error"; // Only allowed in @media
              } else {
                style += " error";
              }
            } else if (context == "@import") {
              style = "tag";
            } else {
              style = "error";
            }
          } else if (style == "atom") {
            if (!context || context == "@media{" || context == "block") {
              style = "builtin";
            } else if (context == "propertyValue") {
              if (!/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current())) {
                style += " error";
              }
            } else {
              style = "error";
            }
          } else if (context == "@media" && type == "{") {
            style = "error";
          }

          // Push/pop context stack
          if (type == "{") {
            if (context == "@media" || context == "@mediaType") {
              state.stack[state.stack.length - 1] = "@media{";
            } else {
              var newContext = allowNested ? "block" : "rule";
              state.stack.push(newContext);
            }
          } else if (type == "}") {
            if (context == "interpolation") style = "operator";
            // Pop off end of array until { is reached
            while (state.stack.length) {
              var removed = state.stack.pop();
              if (removed.indexOf("{") > -1 || removed == "block" || removed == "rule") {
                break;
              }
            }
          } else if (type == "interpolation") state.stack.push("interpolation");else if (type == "@media") state.stack.push("@media");else if (type == "@import") state.stack.push("@import");else if (context == "@media" && /\b(keyword|attribute)\b/.test(style)) state.stack[state.stack.length - 1] = "@mediaType";else if (context == "@mediaType" && stream.current() == ",") state.stack[state.stack.length - 1] = "@media";else if (type == "(") {
            if (context == "@media" || context == "@mediaType") {
              // Make sure @mediaType is used to avoid error on {
              state.stack[state.stack.length - 1] = "@mediaType";
              state.stack.push("@mediaType(");
            } else state.stack.push("(");
          } else if (type == ")") {
            // Pop off end of array until ( is reached
            while (state.stack.length) {
              var removed = state.stack.pop();
              if (removed.indexOf("(") > -1) {
                break;
              }
            }
          } else if (type == ":" && state.lastToken == "property") state.stack.push("propertyValue");else if (context == "propertyValue" && type == ";") state.stack.pop();else if (context == "@import" && type == ";") state.stack.pop();

          return state.lastToken = style;
        },

        indent: function (state, textAfter) {
          var n = state.stack.length;
          if (/^\}/.test(textAfter)) n -= state.stack[n - 1] == "propertyValue" ? 2 : 1;
          return state.baseIndent + n * indentUnit;
        },

        electricChars: "}",
        blockCommentStart: "/*",
        blockCommentEnd: "*/",
        fold: "brace"
      };
    });

    (function () {
      function keySet(array) {
        var keys = {};
        for (var i = 0; i < array.length; ++i) {
          keys[array[i]] = true;
        }
        return keys;
      }

      var atMediaTypes = keySet(["all", "aural", "braille", "handheld", "print", "projection", "screen", "tty", "tv", "embossed"]);

      var atMediaFeatures = keySet(["width", "min-width", "max-width", "height", "min-height", "max-height", "device-width", "min-device-width", "max-device-width", "device-height", "min-device-height", "max-device-height", "aspect-ratio", "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio", "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color", "max-color", "color-index", "min-color-index", "max-color-index", "monochrome", "min-monochrome", "max-monochrome", "resolution", "min-resolution", "max-resolution", "scan", "grid"]);

      var propertyKeywords = keySet(["align-content", "align-items", "align-self", "alignment-adjust", "alignment-baseline", "anchor-point", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "appearance", "azimuth", "backface-visibility", "background", "background-attachment", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "baseline-shift", "binding", "bleed", "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target", "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "clear", "clip", "color", "color-profile", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "dominant-baseline", "drop-initial-after-adjust", "drop-initial-after-align", "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size", "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings", "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-weight", "grid-cell", "grid-column", "grid-column-align", "grid-column-sizing", "grid-column-span", "grid-columns", "grid-flow", "grid-row", "grid-row-align", "grid-row-sizing", "grid-row-span", "grid-rows", "grid-template", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "inline-box-align", "justify-content", "left", "letter-spacing", "line-break", "line-height", "line-stacking", "line-stacking-ruby", "line-stacking-shift", "line-stacking-strategy", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marker-offset", "marks", "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed", "marquee-style", "max-height", "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "page-break-inside", "page-policy", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pitch", "pitch-range", "play-during", "position", "presentation-level", "punctuation-trim", "quotes", "region-break-after", "region-break-before", "region-break-inside", "region-fragment", "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness", "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span", "shape-inside", "shape-outside", "size", "speak", "speak-as", "speak-header", "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size", "table-layout", "target", "target-name", "target-new", "target-position", "text-align", "text-align-last", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-skip", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-height", "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow", "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position", "text-wrap", "top", "transform", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "volume", "white-space", "widows", "width", "word-break", "word-spacing", "word-wrap", "z-index", "zoom",
      // SVG-specific
      "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color", "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering", "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering", "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal", "glyph-orientation-vertical", "kerning", "text-anchor", "writing-mode"]);

      var colorKeywords = keySet(["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"]);

      var valueKeywords = keySet(["above", "absolute", "activeborder", "activecaption", "afar", "after-white-space", "ahead", "alias", "all", "all-scroll", "alternate", "always", "amharic", "amharic-abegede", "antialiased", "appworkspace", "arabic-indic", "armenian", "asterisks", "auto", "avoid", "avoid-column", "avoid-page", "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary", "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break", "break-all", "break-word", "button", "button-bevel", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "cambodian", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-earthly-branch", "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote", "col-resize", "collapse", "column", "compact", "condensed", "contain", "content", "content-box", "context-menu", "continuous", "copy", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "destination-atop", "destination-in", "destination-out", "destination-over", "devanagari", "disc", "discard", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede", "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er", "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er", "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et", "ethiopic-halehame-gez", "ethiopic-halehame-om-et", "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et", "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig", "ew-resize", "expanded", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "footnotes", "forwards", "from", "geometricPrecision", "georgian", "graytext", "groove", "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hebrew", "help", "hidden", "hide", "higher", "highlight", "highlighttext", "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer", "landscape", "lao", "large", "larger", "left", "level", "lighter", "line-through", "linear", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian", "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lower-roman", "lowercase", "ltr", "malayalam", "match", "media-controls-background", "media-current-time-display", "media-fullscreen-button", "media-mute-button", "media-play-button", "media-return-to-realtime-button", "media-rewind-button", "media-seek-back-button", "media-seek-forward-button", "media-slider", "media-sliderthumb", "media-time-remaining-display", "media-volume-slider", "media-volume-slider-container", "media-volume-sliderthumb", "medium", "menu", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic", "mix", "mongolian", "monospace", "move", "multiple", "myanmar", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote", "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset", "outside", "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused", "persian", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "round", "row-resize", "rtl", "run-in", "running", "s-resize", "sans-serif", "scroll", "scrollbar", "se-resize", "searchfield", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama", "single", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "solid", "somali", "source-atop", "source-in", "source-out", "source-over", "space", "square", "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub", "subpixel-antialiased", "super", "sw-resize", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er", "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top", "transparent", "ultra-condensed", "ultra-expanded", "underline", "up", "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal", "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "x-large", "x-small", "xor", "xx-large", "xx-small"]);

      function tokenCComment(stream, state) {
        var maybeEnd = false,
            ch;
        while ((ch = stream.next()) != null) {
          if (maybeEnd && ch == "/") {
            state.tokenize = null;
            break;
          }
          maybeEnd = ch == "*";
        }
        return ["comment", "comment"];
      }

      CodeMirror.defineMIME("text/css", {
        atMediaTypes: atMediaTypes,
        atMediaFeatures: atMediaFeatures,
        propertyKeywords: propertyKeywords,
        colorKeywords: colorKeywords,
        valueKeywords: valueKeywords,
        hooks: {
          "<": function (stream, state) {
            function tokenSGMLComment(stream, state) {
              var dashes = 0,
                  ch;
              while ((ch = stream.next()) != null) {
                if (dashes >= 2 && ch == ">") {
                  state.tokenize = null;
                  break;
                }
                dashes = ch == "-" ? dashes + 1 : 0;
              }
              return ["comment", "comment"];
            }
            if (stream.eat("!")) {
              state.tokenize = tokenSGMLComment;
              return tokenSGMLComment(stream, state);
            }
          },
          "/": function (stream, state) {
            if (stream.eat("*")) {
              state.tokenize = tokenCComment;
              return tokenCComment(stream, state);
            }
            return false;
          }
        },
        name: "css"
      });

      CodeMirror.defineMIME("text/x-scss", {
        atMediaTypes: atMediaTypes,
        atMediaFeatures: atMediaFeatures,
        propertyKeywords: propertyKeywords,
        colorKeywords: colorKeywords,
        valueKeywords: valueKeywords,
        allowNested: true,
        hooks: {
          ":": function (stream) {
            if (stream.match(/\s*{/)) {
              return [null, "{"];
            }
            return false;
          },
          "$": function (stream) {
            stream.match(/^[\w-]+/);
            if (stream.peek() == ":") {
              return ["variable", "variable-definition"];
            }
            return ["variable", "variable"];
          },
          ",": function (stream, state) {
            if (state.stack[state.stack.length - 1] == "propertyValue" && stream.match(/^ *\$/, false)) {
              return ["operator", ";"];
            }
          },
          "/": function (stream, state) {
            if (stream.eat("/")) {
              stream.skipToEnd();
              return ["comment", "comment"];
            } else if (stream.eat("*")) {
              state.tokenize = tokenCComment;
              return tokenCComment(stream, state);
            } else {
              return ["operator", "operator"];
            }
          },
          "#": function (stream) {
            if (stream.eat("{")) {
              return ["operator", "interpolation"];
            } else {
              stream.eatWhile(/[\w\\\-]/);
              return ["atom", "hash"];
            }
          }
        },
        name: "css"
      });
    })();
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("82", ["80"], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    CodeMirror.defineMode("htmlmixed", function (config, parserConfig) {
      var htmlMode = CodeMirror.getMode(config, { name: "xml", htmlMode: true });
      var cssMode = CodeMirror.getMode(config, "css");

      var scriptTypes = [],
          scriptTypesConf = parserConfig && parserConfig.scriptTypes;
      scriptTypes.push({ matches: /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^$/i,
        mode: CodeMirror.getMode(config, "javascript") });
      if (scriptTypesConf) for (var i = 0; i < scriptTypesConf.length; ++i) {
        var conf = scriptTypesConf[i];
        scriptTypes.push({ matches: conf.matches, mode: conf.mode && CodeMirror.getMode(config, conf.mode) });
      }
      scriptTypes.push({ matches: /./,
        mode: CodeMirror.getMode(config, "text/plain") });

      function html(stream, state) {
        var tagName = state.htmlState.tagName;
        var style = htmlMode.token(stream, state.htmlState);
        if (tagName == "script" && /\btag\b/.test(style) && stream.current() == ">") {
          // Script block: mode to change to depends on type attribute
          var scriptType = stream.string.slice(Math.max(0, stream.pos - 100), stream.pos).match(/\btype\s*=\s*("[^"]+"|'[^']+'|\S+)[^<]*$/i);
          scriptType = scriptType ? scriptType[1] : "";
          if (scriptType && /[\"\']/.test(scriptType.charAt(0))) scriptType = scriptType.slice(1, scriptType.length - 1);
          for (var i = 0; i < scriptTypes.length; ++i) {
            var tp = scriptTypes[i];
            if (typeof tp.matches == "string" ? scriptType == tp.matches : tp.matches.test(scriptType)) {
              if (tp.mode) {
                state.token = script;
                state.localMode = tp.mode;
                state.localState = tp.mode.startState && tp.mode.startState(htmlMode.indent(state.htmlState, ""));
              }
              break;
            }
          }
        } else if (tagName == "style" && /\btag\b/.test(style) && stream.current() == ">") {
          state.token = css;
          state.localMode = cssMode;
          state.localState = cssMode.startState(htmlMode.indent(state.htmlState, ""));
        }
        return style;
      }
      function maybeBackup(stream, pat, style) {
        var cur = stream.current();
        var close = cur.search(pat),
            m;
        if (close > -1) stream.backUp(cur.length - close);else if (m = cur.match(/<\/?$/)) {
          stream.backUp(cur.length);
          if (!stream.match(pat, false)) stream.match(cur);
        }
        return style;
      }
      function script(stream, state) {
        if (stream.match(/^<\/\s*script\s*>/i, false)) {
          state.token = html;
          state.localState = state.localMode = null;
          return html(stream, state);
        }
        return maybeBackup(stream, /<\/\s*script\s*>/, state.localMode.token(stream, state.localState));
      }
      function css(stream, state) {
        if (stream.match(/^<\/\s*style\s*>/i, false)) {
          state.token = html;
          state.localState = state.localMode = null;
          return html(stream, state);
        }
        return maybeBackup(stream, /<\/\s*style\s*>/, cssMode.token(stream, state.localState));
      }

      return {
        startState: function () {
          var state = htmlMode.startState();
          return { token: html, localMode: null, localState: null, htmlState: state };
        },

        copyState: function (state) {
          if (state.localState) var local = CodeMirror.copyState(state.localMode, state.localState);
          return { token: state.token, localMode: state.localMode, localState: local,
            htmlState: CodeMirror.copyState(htmlMode, state.htmlState) };
        },

        token: function (stream, state) {
          return state.token(stream, state);
        },

        indent: function (state, textAfter) {
          if (!state.localMode || /^\s*<\//.test(textAfter)) return htmlMode.indent(state.htmlState, textAfter);else if (state.localMode.indent) return state.localMode.indent(state.localState, textAfter);else return CodeMirror.Pass;
        },

        electricChars: "/{}:",

        innerMode: function (state) {
          return { state: state.localState || state.htmlState, mode: state.localMode || htmlMode };
        }
      };
    }, "xml", "javascript", "css");

    CodeMirror.defineMIME("text/html", "htmlmixed");
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("80", [], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    // CodeMirror version 3.20
    //
    // CodeMirror is the only global var we claim
    window.CodeMirror = function () {
      "use strict";

      // BROWSER SNIFFING

      // Crude, but necessary to handle a number of hard-to-feature-detect
      // bugs and behavior differences.

      var gecko = /gecko\/\d/i.test(navigator.userAgent);
      // IE11 currently doesn't count as 'ie', since it has almost none of
      // the same bugs as earlier versions. Use ie_gt10 to handle
      // incompatibilities in that version.
      var ie = /MSIE \d/.test(navigator.userAgent);
      var ie_lt8 = ie && (document.documentMode == null || document.documentMode < 8);
      var ie_lt9 = ie && (document.documentMode == null || document.documentMode < 9);
      var ie_gt10 = /Trident\/([7-9]|\d{2,})\./.test(navigator.userAgent);
      var webkit = /WebKit\//.test(navigator.userAgent);
      var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
      var chrome = /Chrome\//.test(navigator.userAgent);
      var opera = /Opera\//.test(navigator.userAgent);
      var safari = /Apple Computer/.test(navigator.vendor);
      var khtml = /KHTML\//.test(navigator.userAgent);
      var mac_geLion = /Mac OS X 1\d\D([7-9]|\d\d)\D/.test(navigator.userAgent);
      var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
      var phantom = /PhantomJS/.test(navigator.userAgent);

      var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
      // This is woefully incomplete. Suggestions for alternative methods welcome.
      var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
      var mac = ios || /Mac/.test(navigator.platform);
      var windows = /win/i.test(navigator.platform);

      var opera_version = opera && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
      if (opera_version) opera_version = Number(opera_version[1]);
      if (opera_version && opera_version >= 15) {
        opera = false;webkit = true;
      }
      // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
      var flipCtrlCmd = mac && (qtwebkit || opera && (opera_version == null || opera_version < 12.11));
      var captureMiddleClick = gecko || ie && !ie_lt9;

      // Optimize some code when these features are not used
      var sawReadOnlySpans = false,
          sawCollapsedSpans = false;

      // CONSTRUCTOR

      function CodeMirror(place, options) {
        if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);

        this.options = options = options || {};
        // Determine effective options based on given values and defaults.
        for (var opt in defaults) if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt)) options[opt] = defaults[opt];
        setGuttersForLineNumbers(options);

        var docStart = typeof options.value == "string" ? 0 : options.value.first;
        var display = this.display = makeDisplay(place, docStart);
        display.wrapper.CodeMirror = this;
        updateGutters(this);
        if (options.autofocus && !mobile) focusInput(this);

        this.state = { keyMaps: [],
          overlays: [],
          modeGen: 0,
          overwrite: false, focused: false,
          suppressEdits: false, pasteIncoming: false,
          draggingText: false,
          highlight: new Delayed() };

        themeChanged(this);
        if (options.lineWrapping) this.display.wrapper.className += " CodeMirror-wrap";

        var doc = options.value;
        if (typeof doc == "string") doc = new Doc(options.value, options.mode);
        operation(this, attachDoc)(this, doc);

        // Override magic textarea content restore that IE sometimes does
        // on our hidden textarea on reload
        if (ie) setTimeout(bind(resetInput, this, true), 20);

        registerEventHandlers(this);
        // IE throws unspecified error in certain cases, when
        // trying to access activeElement before onload
        var hasFocus;try {
          hasFocus = document.activeElement == display.input;
        } catch (e) {}
        if (hasFocus || options.autofocus && !mobile) setTimeout(bind(onFocus, this), 20);else onBlur(this);

        operation(this, function () {
          for (var opt in optionHandlers) if (optionHandlers.propertyIsEnumerable(opt)) optionHandlers[opt](this, options[opt], Init);
          for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);
        })();
      }

      // DISPLAY CONSTRUCTOR

      function makeDisplay(place, docStart) {
        var d = {};

        var input = d.input = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none; font-size: 4px;");
        if (webkit) input.style.width = "1000px";else input.setAttribute("wrap", "off");
        // if border: 0; -- iOS fails to open keyboard (issue #1287)
        if (ios) input.style.border = "1px solid black";
        input.setAttribute("autocorrect", "off");input.setAttribute("autocapitalize", "off");input.setAttribute("spellcheck", "false");

        // Wraps and hides input textarea
        d.inputDiv = elt("div", [input], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
        // The actual fake scrollbars.
        d.scrollbarH = elt("div", [elt("div", null, null, "height: 1px")], "CodeMirror-hscrollbar");
        d.scrollbarV = elt("div", [elt("div", null, null, "width: 1px")], "CodeMirror-vscrollbar");
        d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
        d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
        // DIVs containing the selection and the actual code
        d.lineDiv = elt("div", null, "CodeMirror-code");
        d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
        // Blinky cursor, and element used to ensure cursor fits at the end of a line
        d.cursor = elt("div", "\u00a0", "CodeMirror-cursor");
        // Secondary cursor, shown when on a 'jump' in bi-directional text
        d.otherCursor = elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor");
        // Used to measure text size
        d.measure = elt("div", null, "CodeMirror-measure");
        // Wraps everything that needs to exist inside the vertically-padded coordinate system
        d.lineSpace = elt("div", [d.measure, d.selectionDiv, d.lineDiv, d.cursor, d.otherCursor], null, "position: relative; outline: none");
        // Moved around its parent to cover visible view
        d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
        // Set to the height of the text, causes scrolling
        d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
        // D is needed because behavior of elts with overflow: auto and padding is inconsistent across browsers
        d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerCutOff + "px; width: 1px;");
        // Will contain the gutters, if any
        d.gutters = elt("div", null, "CodeMirror-gutters");
        d.lineGutter = null;
        // Provides scrolling
        d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
        d.scroller.setAttribute("tabIndex", "-1");
        // The element in which the editor lives.
        d.wrapper = elt("div", [d.inputDiv, d.scrollbarH, d.scrollbarV, d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
        // Work around IE7 z-index bug
        if (ie_lt8) {
          d.gutters.style.zIndex = -1;d.scroller.style.paddingRight = 0;
        }
        if (place.appendChild) place.appendChild(d.wrapper);else place(d.wrapper);

        // Needed to hide big blue blinking cursor on Mobile Safari
        if (ios) input.style.width = "0px";
        if (!webkit) d.scroller.draggable = true;
        // Needed to handle Tab key in KHTML
        if (khtml) {
          d.inputDiv.style.height = "1px";d.inputDiv.style.position = "absolute";
        }
        // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
        else if (ie_lt8) d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = "18px";

        // Current visible range (may be bigger than the view window).
        d.viewOffset = d.lastSizeC = 0;
        d.showingFrom = d.showingTo = docStart;

        // Used to only resize the line number gutter when necessary (when
        // the amount of lines crosses a boundary that makes its width change)
        d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
        // See readInput and resetInput
        d.prevInput = "";
        // Set to true when a non-horizontal-scrolling widget is added. As
        // an optimization, widget aligning is skipped when d is false.
        d.alignWidgets = false;
        // Flag that indicates whether we currently expect input to appear
        // (after some event like 'keypress' or 'input') and are polling
        // intensively.
        d.pollingFast = false;
        // Self-resetting timeout for the poller
        d.poll = new Delayed();

        d.cachedCharWidth = d.cachedTextHeight = null;
        d.measureLineCache = [];
        d.measureLineCachePos = 0;

        // Tracks when resetInput has punted to just putting a short
        // string instead of the (large) selection.
        d.inaccurateSelection = false;

        // Tracks the maximum line length so that the horizontal scrollbar
        // can be kept static when scrolling.
        d.maxLine = null;
        d.maxLineLength = 0;
        d.maxLineChanged = false;

        // Used for measuring wheel scrolling granularity
        d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

        return d;
      }

      // STATE UPDATES

      // Used to get the editor into a consistent state again when options change.

      function loadMode(cm) {
        cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
        cm.doc.iter(function (line) {
          if (line.stateAfter) line.stateAfter = null;
          if (line.styles) line.styles = null;
        });
        cm.doc.frontier = cm.doc.first;
        startWorker(cm, 100);
        cm.state.modeGen++;
        if (cm.curOp) regChange(cm);
      }

      function wrappingChanged(cm) {
        if (cm.options.lineWrapping) {
          cm.display.wrapper.className += " CodeMirror-wrap";
          cm.display.sizer.style.minWidth = "";
        } else {
          cm.display.wrapper.className = cm.display.wrapper.className.replace(" CodeMirror-wrap", "");
          computeMaxLength(cm);
        }
        estimateLineHeights(cm);
        regChange(cm);
        clearCaches(cm);
        setTimeout(function () {
          updateScrollbars(cm);
        }, 100);
      }

      function estimateHeight(cm) {
        var th = textHeight(cm.display),
            wrapping = cm.options.lineWrapping;
        var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
        return function (line) {
          if (lineIsHidden(cm.doc, line)) return 0;else if (wrapping) return (Math.ceil(line.text.length / perLine) || 1) * th;else return th;
        };
      }

      function estimateLineHeights(cm) {
        var doc = cm.doc,
            est = estimateHeight(cm);
        doc.iter(function (line) {
          var estHeight = est(line);
          if (estHeight != line.height) updateLineHeight(line, estHeight);
        });
      }

      function keyMapChanged(cm) {
        var map = keyMap[cm.options.keyMap],
            style = map.style;
        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, "") + (style ? " cm-keymap-" + style : "");
        cm.state.disableInput = map.disableInput;
      }

      function themeChanged(cm) {
        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
        clearCaches(cm);
      }

      function guttersChanged(cm) {
        updateGutters(cm);
        regChange(cm);
        setTimeout(function () {
          alignHorizontally(cm);
        }, 20);
      }

      function updateGutters(cm) {
        var gutters = cm.display.gutters,
            specs = cm.options.gutters;
        removeChildren(gutters);
        for (var i = 0; i < specs.length; ++i) {
          var gutterClass = specs[i];
          var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
          if (gutterClass == "CodeMirror-linenumbers") {
            cm.display.lineGutter = gElt;
            gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
          }
        }
        gutters.style.display = i ? "" : "none";
      }

      function lineLength(doc, line) {
        if (line.height == 0) return 0;
        var len = line.text.length,
            merged,
            cur = line;
        while (merged = collapsedSpanAtStart(cur)) {
          var found = merged.find();
          cur = getLine(doc, found.from.line);
          len += found.from.ch - found.to.ch;
        }
        cur = line;
        while (merged = collapsedSpanAtEnd(cur)) {
          var found = merged.find();
          len -= cur.text.length - found.from.ch;
          cur = getLine(doc, found.to.line);
          len += cur.text.length - found.to.ch;
        }
        return len;
      }

      function computeMaxLength(cm) {
        var d = cm.display,
            doc = cm.doc;
        d.maxLine = getLine(doc, doc.first);
        d.maxLineLength = lineLength(doc, d.maxLine);
        d.maxLineChanged = true;
        doc.iter(function (line) {
          var len = lineLength(doc, line);
          if (len > d.maxLineLength) {
            d.maxLineLength = len;
            d.maxLine = line;
          }
        });
      }

      // Make sure the gutters options contains the element
      // "CodeMirror-linenumbers" when the lineNumbers option is true.
      function setGuttersForLineNumbers(options) {
        var found = indexOf(options.gutters, "CodeMirror-linenumbers");
        if (found == -1 && options.lineNumbers) {
          options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
        } else if (found > -1 && !options.lineNumbers) {
          options.gutters = options.gutters.slice(0);
          options.gutters.splice(found, 1);
        }
      }

      // SCROLLBARS

      // Re-synchronize the fake scrollbars with the actual size of the
      // content. Optionally force a scrollTop.
      function updateScrollbars(cm) {
        var d = cm.display,
            docHeight = cm.doc.height;
        var totalHeight = docHeight + paddingVert(d);
        d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + "px";
        d.gutters.style.height = Math.max(totalHeight, d.scroller.clientHeight - scrollerCutOff) + "px";
        var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);
        var needsH = d.scroller.scrollWidth > d.scroller.clientWidth + 1;
        var needsV = scrollHeight > d.scroller.clientHeight + 1;
        if (needsV) {
          d.scrollbarV.style.display = "block";
          d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + "px" : "0";
          d.scrollbarV.firstChild.style.height = scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight + "px";
        } else {
          d.scrollbarV.style.display = "";
          d.scrollbarV.firstChild.style.height = "0";
        }
        if (needsH) {
          d.scrollbarH.style.display = "block";
          d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + "px" : "0";
          d.scrollbarH.firstChild.style.width = d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth + "px";
        } else {
          d.scrollbarH.style.display = "";
          d.scrollbarH.firstChild.style.width = "0";
        }
        if (needsH && needsV) {
          d.scrollbarFiller.style.display = "block";
          d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + "px";
        } else d.scrollbarFiller.style.display = "";
        if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
          d.gutterFiller.style.display = "block";
          d.gutterFiller.style.height = scrollbarWidth(d.measure) + "px";
          d.gutterFiller.style.width = d.gutters.offsetWidth + "px";
        } else d.gutterFiller.style.display = "";

        if (mac_geLion && scrollbarWidth(d.measure) === 0) {
          d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? "18px" : "12px";
          d.scrollbarV.style.pointerEvents = d.scrollbarH.style.pointerEvents = "none";
        }
      }

      function visibleLines(display, doc, viewPort) {
        var top = display.scroller.scrollTop,
            height = display.wrapper.clientHeight;
        if (typeof viewPort == "number") top = viewPort;else if (viewPort) {
          top = viewPort.top;height = viewPort.bottom - viewPort.top;
        }
        top = Math.floor(top - paddingTop(display));
        var bottom = Math.ceil(top + height);
        return { from: lineAtHeight(doc, top), to: lineAtHeight(doc, bottom) };
      }

      // LINE NUMBERS

      function alignHorizontally(cm) {
        var display = cm.display;
        if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
        var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
        var gutterW = display.gutters.offsetWidth,
            l = comp + "px";
        for (var n = display.lineDiv.firstChild; n; n = n.nextSibling) if (n.alignable) {
          for (var i = 0, a = n.alignable; i < a.length; ++i) a[i].style.left = l;
        }
        if (cm.options.fixedGutter) display.gutters.style.left = comp + gutterW + "px";
      }

      function maybeUpdateLineNumberWidth(cm) {
        if (!cm.options.lineNumbers) return false;
        var doc = cm.doc,
            last = lineNumberFor(cm.options, doc.first + doc.size - 1),
            display = cm.display;
        if (last.length != display.lineNumChars) {
          var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
          var innerW = test.firstChild.offsetWidth,
              padding = test.offsetWidth - innerW;
          display.lineGutter.style.width = "";
          display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);
          display.lineNumWidth = display.lineNumInnerWidth + padding;
          display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
          display.lineGutter.style.width = display.lineNumWidth + "px";
          return true;
        }
        return false;
      }

      function lineNumberFor(options, i) {
        return String(options.lineNumberFormatter(i + options.firstLineNumber));
      }
      function compensateForHScroll(display) {
        return getRect(display.scroller).left - getRect(display.sizer).left;
      }

      // DISPLAY DRAWING

      function updateDisplay(cm, changes, viewPort, forced) {
        var oldFrom = cm.display.showingFrom,
            oldTo = cm.display.showingTo,
            updated;
        var visible = visibleLines(cm.display, cm.doc, viewPort);
        for (var first = true;; first = false) {
          var oldWidth = cm.display.scroller.clientWidth;
          if (!updateDisplayInner(cm, changes, visible, forced)) break;
          updated = true;
          changes = [];
          updateSelection(cm);
          updateScrollbars(cm);
          if (first && cm.options.lineWrapping && oldWidth != cm.display.scroller.clientWidth) {
            forced = true;
            continue;
          }
          forced = false;

          // Clip forced viewport to actual scrollable area
          if (viewPort) viewPort = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, typeof viewPort == "number" ? viewPort : viewPort.top);
          visible = visibleLines(cm.display, cm.doc, viewPort);
          if (visible.from >= cm.display.showingFrom && visible.to <= cm.display.showingTo) break;
        }

        if (updated) {
          signalLater(cm, "update", cm);
          if (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo) signalLater(cm, "viewportChange", cm, cm.display.showingFrom, cm.display.showingTo);
        }
        return updated;
      }

      // Uses a set of changes plus the current scroll position to
      // determine which DOM updates have to be made, and makes the
      // updates.
      function updateDisplayInner(cm, changes, visible, forced) {
        var display = cm.display,
            doc = cm.doc;
        if (!display.wrapper.clientWidth) {
          display.showingFrom = display.showingTo = doc.first;
          display.viewOffset = 0;
          return;
        }

        // Bail out if the visible area is already rendered and nothing changed.
        if (!forced && changes.length == 0 && visible.from > display.showingFrom && visible.to < display.showingTo) return;

        if (maybeUpdateLineNumberWidth(cm)) changes = [{ from: doc.first, to: doc.first + doc.size }];
        var gutterW = display.sizer.style.marginLeft = display.gutters.offsetWidth + "px";
        display.scrollbarH.style.left = cm.options.fixedGutter ? gutterW : "0";

        // Used to determine which lines need their line numbers updated
        var positionsChangedFrom = Infinity;
        if (cm.options.lineNumbers) for (var i = 0; i < changes.length; ++i) if (changes[i].diff && changes[i].from < positionsChangedFrom) {
          positionsChangedFrom = changes[i].from;
        }

        var end = doc.first + doc.size;
        var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);
        var to = Math.min(end, visible.to + cm.options.viewportMargin);
        if (display.showingFrom < from && from - display.showingFrom < 20) from = Math.max(doc.first, display.showingFrom);
        if (display.showingTo > to && display.showingTo - to < 20) to = Math.min(end, display.showingTo);
        if (sawCollapsedSpans) {
          from = lineNo(visualLine(doc, getLine(doc, from)));
          while (to < end && lineIsHidden(doc, getLine(doc, to))) ++to;
        }

        // Create a range of theoretically intact lines, and punch holes
        // in that using the change info.
        var intact = [{ from: Math.max(display.showingFrom, doc.first),
          to: Math.min(display.showingTo, end) }];
        if (intact[0].from >= intact[0].to) intact = [];else intact = computeIntact(intact, changes);
        // When merged lines are present, we might have to reduce the
        // intact ranges because changes in continued fragments of the
        // intact lines do require the lines to be redrawn.
        if (sawCollapsedSpans) for (var i = 0; i < intact.length; ++i) {
          var range = intact[i],
              merged;
          while (merged = collapsedSpanAtEnd(getLine(doc, range.to - 1))) {
            var newTo = merged.find().from.line;
            if (newTo > range.from) range.to = newTo;else {
              intact.splice(i--, 1);break;
            }
          }
        }

        // Clip off the parts that won't be visible
        var intactLines = 0;
        for (var i = 0; i < intact.length; ++i) {
          var range = intact[i];
          if (range.from < from) range.from = from;
          if (range.to > to) range.to = to;
          if (range.from >= range.to) intact.splice(i--, 1);else intactLines += range.to - range.from;
        }
        if (!forced && intactLines == to - from && from == display.showingFrom && to == display.showingTo) {
          updateViewOffset(cm);
          return;
        }
        intact.sort(function (a, b) {
          return a.from - b.from;
        });

        // Avoid crashing on IE's "unspecified error" when in iframes
        try {
          var focused = document.activeElement;
        } catch (e) {}
        if (intactLines < (to - from) * .7) display.lineDiv.style.display = "none";
        patchDisplay(cm, from, to, intact, positionsChangedFrom);
        display.lineDiv.style.display = "";
        if (focused && document.activeElement != focused && focused.offsetHeight) focused.focus();

        var different = from != display.showingFrom || to != display.showingTo || display.lastSizeC != display.wrapper.clientHeight;
        // This is just a bogus formula that detects when the editor is
        // resized or the font size changes.
        if (different) {
          display.lastSizeC = display.wrapper.clientHeight;
          startWorker(cm, 400);
        }
        display.showingFrom = from;display.showingTo = to;

        updateHeightsInViewport(cm);
        updateViewOffset(cm);

        return true;
      }

      function updateHeightsInViewport(cm) {
        var display = cm.display;
        var prevBottom = display.lineDiv.offsetTop;
        for (var node = display.lineDiv.firstChild, height; node; node = node.nextSibling) if (node.lineObj) {
          if (ie_lt8) {
            var bot = node.offsetTop + node.offsetHeight;
            height = bot - prevBottom;
            prevBottom = bot;
          } else {
            var box = getRect(node);
            height = box.bottom - box.top;
          }
          var diff = node.lineObj.height - height;
          if (height < 2) height = textHeight(display);
          if (diff > .001 || diff < -.001) {
            updateLineHeight(node.lineObj, height);
            var widgets = node.lineObj.widgets;
            if (widgets) for (var i = 0; i < widgets.length; ++i) widgets[i].height = widgets[i].node.offsetHeight;
          }
        }
      }

      function updateViewOffset(cm) {
        var off = cm.display.viewOffset = heightAtLine(cm, getLine(cm.doc, cm.display.showingFrom));
        // Position the mover div to align with the current virtual scroll position
        cm.display.mover.style.top = off + "px";
      }

      function computeIntact(intact, changes) {
        for (var i = 0, l = changes.length || 0; i < l; ++i) {
          var change = changes[i],
              intact2 = [],
              diff = change.diff || 0;
          for (var j = 0, l2 = intact.length; j < l2; ++j) {
            var range = intact[j];
            if (change.to <= range.from && change.diff) {
              intact2.push({ from: range.from + diff, to: range.to + diff });
            } else if (change.to <= range.from || change.from >= range.to) {
              intact2.push(range);
            } else {
              if (change.from > range.from) intact2.push({ from: range.from, to: change.from });
              if (change.to < range.to) intact2.push({ from: change.to + diff, to: range.to + diff });
            }
          }
          intact = intact2;
        }
        return intact;
      }

      function getDimensions(cm) {
        var d = cm.display,
            left = {},
            width = {};
        for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
          left[cm.options.gutters[i]] = n.offsetLeft;
          width[cm.options.gutters[i]] = n.offsetWidth;
        }
        return { fixedPos: compensateForHScroll(d),
          gutterTotalWidth: d.gutters.offsetWidth,
          gutterLeft: left,
          gutterWidth: width,
          wrapperWidth: d.wrapper.clientWidth };
      }

      function patchDisplay(cm, from, to, intact, updateNumbersFrom) {
        var dims = getDimensions(cm);
        var display = cm.display,
            lineNumbers = cm.options.lineNumbers;
        if (!intact.length && (!webkit || !cm.display.currentWheelTarget)) removeChildren(display.lineDiv);
        var container = display.lineDiv,
            cur = container.firstChild;

        function rm(node) {
          var next = node.nextSibling;
          if (webkit && mac && cm.display.currentWheelTarget == node) {
            node.style.display = "none";
            node.lineObj = null;
          } else {
            node.parentNode.removeChild(node);
          }
          return next;
        }

        var nextIntact = intact.shift(),
            lineN = from;
        cm.doc.iter(from, to, function (line) {
          if (nextIntact && nextIntact.to == lineN) nextIntact = intact.shift();
          if (lineIsHidden(cm.doc, line)) {
            if (line.height != 0) updateLineHeight(line, 0);
            if (line.widgets && cur && cur.previousSibling) for (var i = 0; i < line.widgets.length; ++i) {
              var w = line.widgets[i];
              if (w.showIfHidden) {
                var prev = cur.previousSibling;
                if (/pre/i.test(prev.nodeName)) {
                  var wrap = elt("div", null, null, "position: relative");
                  prev.parentNode.replaceChild(wrap, prev);
                  wrap.appendChild(prev);
                  prev = wrap;
                }
                var wnode = prev.appendChild(elt("div", [w.node], "CodeMirror-linewidget"));
                if (!w.handleMouseEvents) wnode.ignoreEvents = true;
                positionLineWidget(w, wnode, prev, dims);
              }
            }
          } else if (nextIntact && nextIntact.from <= lineN && nextIntact.to > lineN) {
            // This line is intact. Skip to the actual node. Update its
            // line number if needed.
            while (cur.lineObj != line) cur = rm(cur);
            if (lineNumbers && updateNumbersFrom <= lineN && cur.lineNumber) setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineN));
            cur = cur.nextSibling;
          } else {
            // For lines with widgets, make an attempt to find and reuse
            // the existing element, so that widgets aren't needlessly
            // removed and re-inserted into the dom
            if (line.widgets) for (var j = 0, search = cur, reuse; search && j < 20; ++j, search = search.nextSibling) if (search.lineObj == line && /div/i.test(search.nodeName)) {
              reuse = search;break;
            }
            // This line needs to be generated.
            var lineNode = buildLineElement(cm, line, lineN, dims, reuse);
            if (lineNode != reuse) {
              container.insertBefore(lineNode, cur);
            } else {
              while (cur != reuse) cur = rm(cur);
              cur = cur.nextSibling;
            }

            lineNode.lineObj = line;
          }
          ++lineN;
        });
        while (cur) cur = rm(cur);
      }

      function buildLineElement(cm, line, lineNo, dims, reuse) {
        var built = buildLineContent(cm, line),
            lineElement = built.pre;
        var markers = line.gutterMarkers,
            display = cm.display,
            wrap;

        var bgClass = built.bgClass ? built.bgClass + " " + (line.bgClass || "") : line.bgClass;
        if (!cm.options.lineNumbers && !markers && !bgClass && !line.wrapClass && !line.widgets) return lineElement;

        // Lines with gutter elements, widgets or a background class need
        // to be wrapped again, and have the extra elements added to the
        // wrapper div

        if (reuse) {
          reuse.alignable = null;
          var isOk = true,
              widgetsSeen = 0,
              insertBefore = null;
          for (var n = reuse.firstChild, next; n; n = next) {
            next = n.nextSibling;
            if (!/\bCodeMirror-linewidget\b/.test(n.className)) {
              reuse.removeChild(n);
            } else {
              for (var i = 0; i < line.widgets.length; ++i) {
                var widget = line.widgets[i];
                if (widget.node == n.firstChild) {
                  if (!widget.above && !insertBefore) insertBefore = n;
                  positionLineWidget(widget, n, reuse, dims);
                  ++widgetsSeen;
                  break;
                }
              }
              if (i == line.widgets.length) {
                isOk = false;break;
              }
            }
          }
          reuse.insertBefore(lineElement, insertBefore);
          if (isOk && widgetsSeen == line.widgets.length) {
            wrap = reuse;
            reuse.className = line.wrapClass || "";
          }
        }
        if (!wrap) {
          wrap = elt("div", null, line.wrapClass, "position: relative");
          wrap.appendChild(lineElement);
        }
        // Kludge to make sure the styled element lies behind the selection (by z-index)
        if (bgClass) wrap.insertBefore(elt("div", null, bgClass + " CodeMirror-linebackground"), wrap.firstChild);
        if (cm.options.lineNumbers || markers) {
          var gutterWrap = wrap.insertBefore(elt("div", null, null, "position: absolute; left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"), wrap.firstChild);
          if (cm.options.fixedGutter) (wrap.alignable || (wrap.alignable = [])).push(gutterWrap);
          if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) wrap.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineNo), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + display.lineNumInnerWidth + "px"));
          if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {
            var id = cm.options.gutters[k],
                found = markers.hasOwnProperty(id) && markers[id];
            if (found) gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
          }
        }
        if (ie_lt8) wrap.style.zIndex = 2;
        if (line.widgets && wrap != reuse) for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
          var widget = ws[i],
              node = elt("div", [widget.node], "CodeMirror-linewidget");
          if (!widget.handleMouseEvents) node.ignoreEvents = true;
          positionLineWidget(widget, node, wrap, dims);
          if (widget.above) wrap.insertBefore(node, cm.options.lineNumbers && line.height != 0 ? gutterWrap : lineElement);else wrap.appendChild(node);
          signalLater(widget, "redraw");
        }
        return wrap;
      }

      function positionLineWidget(widget, node, wrap, dims) {
        if (widget.noHScroll) {
          (wrap.alignable || (wrap.alignable = [])).push(node);
          var width = dims.wrapperWidth;
          node.style.left = dims.fixedPos + "px";
          if (!widget.coverGutter) {
            width -= dims.gutterTotalWidth;
            node.style.paddingLeft = dims.gutterTotalWidth + "px";
          }
          node.style.width = width + "px";
        }
        if (widget.coverGutter) {
          node.style.zIndex = 5;
          node.style.position = "relative";
          if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";
        }
      }

      // SELECTION / CURSOR

      function updateSelection(cm) {
        var display = cm.display;
        var collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);
        if (collapsed || cm.options.showCursorWhenSelecting) updateSelectionCursor(cm);else display.cursor.style.display = display.otherCursor.style.display = "none";
        if (!collapsed) updateSelectionRange(cm);else display.selectionDiv.style.display = "none";

        // Move the hidden textarea near the cursor to prevent scrolling artifacts
        if (cm.options.moveInputWithCursor) {
          var headPos = cursorCoords(cm, cm.doc.sel.head, "div");
          var wrapOff = getRect(display.wrapper),
              lineOff = getRect(display.lineDiv);
          display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top)) + "px";
          display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left)) + "px";
        }
      }

      // No selection, plain cursor
      function updateSelectionCursor(cm) {
        var display = cm.display,
            pos = cursorCoords(cm, cm.doc.sel.head, "div");
        display.cursor.style.left = pos.left + "px";
        display.cursor.style.top = pos.top + "px";
        display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
        display.cursor.style.display = "";

        if (pos.other) {
          display.otherCursor.style.display = "";
          display.otherCursor.style.left = pos.other.left + "px";
          display.otherCursor.style.top = pos.other.top + "px";
          display.otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
        } else {
          display.otherCursor.style.display = "none";
        }
      }

      // Highlight selection
      function updateSelectionRange(cm) {
        var display = cm.display,
            doc = cm.doc,
            sel = cm.doc.sel;
        var fragment = document.createDocumentFragment();
        var clientWidth = display.lineSpace.offsetWidth,
            pl = paddingLeft(cm.display);

        function add(left, top, width, bottom) {
          if (top < 0) top = 0;
          fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px; top: " + top + "px; width: " + (width == null ? clientWidth - left : width) + "px; height: " + (bottom - top) + "px"));
        }

        function drawForLine(line, fromArg, toArg) {
          var lineObj = getLine(doc, line);
          var lineLen = lineObj.text.length;
          var start, end;
          function coords(ch, bias) {
            return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
          }

          iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {
            var leftPos = coords(from, "left"),
                rightPos,
                left,
                right;
            if (from == to) {
              rightPos = leftPos;
              left = right = leftPos.left;
            } else {
              rightPos = coords(to - 1, "right");
              if (dir == "rtl") {
                var tmp = leftPos;leftPos = rightPos;rightPos = tmp;
              }
              left = leftPos.left;
              right = rightPos.right;
            }
            if (fromArg == null && from == 0) left = pl;
            if (rightPos.top - leftPos.top > 3) {
              // Different lines, draw top part
              add(left, leftPos.top, null, leftPos.bottom);
              left = pl;
              if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);
            }
            if (toArg == null && to == lineLen) right = clientWidth;
            if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left) start = leftPos;
            if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right) end = rightPos;
            if (left < pl + 1) left = pl;
            add(left, rightPos.top, right - left, rightPos.bottom);
          });
          return { start: start, end: end };
        }

        if (sel.from.line == sel.to.line) {
          drawForLine(sel.from.line, sel.from.ch, sel.to.ch);
        } else {
          var fromLine = getLine(doc, sel.from.line),
              toLine = getLine(doc, sel.to.line);
          var singleVLine = visualLine(doc, fromLine) == visualLine(doc, toLine);
          var leftEnd = drawForLine(sel.from.line, sel.from.ch, singleVLine ? fromLine.text.length : null).end;
          var rightStart = drawForLine(sel.to.line, singleVLine ? 0 : null, sel.to.ch).start;
          if (singleVLine) {
            if (leftEnd.top < rightStart.top - 2) {
              add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
              add(pl, rightStart.top, rightStart.left, rightStart.bottom);
            } else {
              add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
            }
          }
          if (leftEnd.bottom < rightStart.top) add(pl, leftEnd.bottom, null, rightStart.top);
        }

        removeChildrenAndAdd(display.selectionDiv, fragment);
        display.selectionDiv.style.display = "";
      }

      // Cursor-blinking
      function restartBlink(cm) {
        if (!cm.state.focused) return;
        var display = cm.display;
        clearInterval(display.blinker);
        var on = true;
        display.cursor.style.visibility = display.otherCursor.style.visibility = "";
        if (cm.options.cursorBlinkRate > 0) display.blinker = setInterval(function () {
          display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? "" : "hidden";
        }, cm.options.cursorBlinkRate);
      }

      // HIGHLIGHT WORKER

      function startWorker(cm, time) {
        if (cm.doc.mode.startState && cm.doc.frontier < cm.display.showingTo) cm.state.highlight.set(time, bind(highlightWorker, cm));
      }

      function highlightWorker(cm) {
        var doc = cm.doc;
        if (doc.frontier < doc.first) doc.frontier = doc.first;
        if (doc.frontier >= cm.display.showingTo) return;
        var end = +new Date() + cm.options.workTime;
        var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
        var changed = [],
            prevChange;
        doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.showingTo + 500), function (line) {
          if (doc.frontier >= cm.display.showingFrom) {
            // Visible
            var oldStyles = line.styles;
            line.styles = highlightLine(cm, line, state, true);
            var ischange = !oldStyles || oldStyles.length != line.styles.length;
            for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
            if (ischange) {
              if (prevChange && prevChange.end == doc.frontier) prevChange.end++;else changed.push(prevChange = { start: doc.frontier, end: doc.frontier + 1 });
            }
            line.stateAfter = copyState(doc.mode, state);
          } else {
            processLine(cm, line.text, state);
            line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
          }
          ++doc.frontier;
          if (+new Date() > end) {
            startWorker(cm, cm.options.workDelay);
            return true;
          }
        });
        if (changed.length) operation(cm, function () {
          for (var i = 0; i < changed.length; ++i) regChange(this, changed[i].start, changed[i].end);
        })();
      }

      // Finds the line to start with when starting a parse. Tries to
      // find a line with a stateAfter, so that it can start with a
      // valid state. If that fails, it returns the line with the
      // smallest indentation, which tends to need the least context to
      // parse correctly.
      function findStartLine(cm, n, precise) {
        var minindent,
            minline,
            doc = cm.doc;
        var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
        for (var search = n; search > lim; --search) {
          if (search <= doc.first) return doc.first;
          var line = getLine(doc, search - 1);
          if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
          var indented = countColumn(line.text, null, cm.options.tabSize);
          if (minline == null || minindent > indented) {
            minline = search - 1;
            minindent = indented;
          }
        }
        return minline;
      }

      function getStateBefore(cm, n, precise) {
        var doc = cm.doc,
            display = cm.display;
        if (!doc.mode.startState) return true;
        var pos = findStartLine(cm, n, precise),
            state = pos > doc.first && getLine(doc, pos - 1).stateAfter;
        if (!state) state = startState(doc.mode);else state = copyState(doc.mode, state);
        doc.iter(pos, n, function (line) {
          processLine(cm, line.text, state);
          var save = pos == n - 1 || pos % 5 == 0 || pos >= display.showingFrom && pos < display.showingTo;
          line.stateAfter = save ? copyState(doc.mode, state) : null;
          ++pos;
        });
        if (precise) doc.frontier = pos;
        return state;
      }

      // POSITION MEASUREMENT

      function paddingTop(display) {
        return display.lineSpace.offsetTop;
      }
      function paddingVert(display) {
        return display.mover.offsetHeight - display.lineSpace.offsetHeight;
      }
      function paddingLeft(display) {
        var e = removeChildrenAndAdd(display.measure, elt("pre", null, null, "text-align: left")).appendChild(elt("span", "x"));
        return e.offsetLeft;
      }

      function measureChar(cm, line, ch, data, bias) {
        var dir = -1;
        data = data || measureLine(cm, line);
        if (data.crude) {
          var left = data.left + ch * data.width;
          return { left: left, right: left + data.width, top: data.top, bottom: data.bottom };
        }

        for (var pos = ch;; pos += dir) {
          var r = data[pos];
          if (r) break;
          if (dir < 0 && pos == 0) dir = 1;
        }
        bias = pos > ch ? "left" : pos < ch ? "right" : bias;
        if (bias == "left" && r.leftSide) r = r.leftSide;else if (bias == "right" && r.rightSide) r = r.rightSide;
        return { left: pos < ch ? r.right : r.left,
          right: pos > ch ? r.left : r.right,
          top: r.top,
          bottom: r.bottom };
      }

      function findCachedMeasurement(cm, line) {
        var cache = cm.display.measureLineCache;
        for (var i = 0; i < cache.length; ++i) {
          var memo = cache[i];
          if (memo.text == line.text && memo.markedSpans == line.markedSpans && cm.display.scroller.clientWidth == memo.width && memo.classes == line.textClass + "|" + line.wrapClass) return memo;
        }
      }

      function clearCachedMeasurement(cm, line) {
        var exists = findCachedMeasurement(cm, line);
        if (exists) exists.text = exists.measure = exists.markedSpans = null;
      }

      function measureLine(cm, line) {
        // First look in the cache
        var cached = findCachedMeasurement(cm, line);
        if (cached) return cached.measure;

        // Failing that, recompute and store result in cache
        var measure = measureLineInner(cm, line);
        var cache = cm.display.measureLineCache;
        var memo = { text: line.text, width: cm.display.scroller.clientWidth,
          markedSpans: line.markedSpans, measure: measure,
          classes: line.textClass + "|" + line.wrapClass };
        if (cache.length == 16) cache[++cm.display.measureLineCachePos % 16] = memo;else cache.push(memo);
        return measure;
      }

      function measureLineInner(cm, line) {
        if (!cm.options.lineWrapping && line.text.length >= cm.options.crudeMeasuringFrom) return crudelyMeasureLine(cm, line);

        var display = cm.display,
            measure = emptyArray(line.text.length);
        var pre = buildLineContent(cm, line, measure, true).pre;

        // IE does not cache element positions of inline elements between
        // calls to getBoundingClientRect. This makes the loop below,
        // which gathers the positions of all the characters on the line,
        // do an amount of layout work quadratic to the number of
        // characters. When line wrapping is off, we try to improve things
        // by first subdividing the line into a bunch of inline blocks, so
        // that IE can reuse most of the layout information from caches
        // for those blocks. This does interfere with line wrapping, so it
        // doesn't work when wrapping is on, but in that case the
        // situation is slightly better, since IE does cache line-wrapping
        // information and only recomputes per-line.
        if (ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {
          var fragment = document.createDocumentFragment();
          var chunk = 10,
              n = pre.childNodes.length;
          for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {
            var wrap = elt("div", null, null, "display: inline-block");
            for (var j = 0; j < chunk && n; ++j) {
              wrap.appendChild(pre.firstChild);
              --n;
            }
            fragment.appendChild(wrap);
          }
          pre.appendChild(fragment);
        }

        removeChildrenAndAdd(display.measure, pre);

        var outer = getRect(display.lineDiv);
        var vranges = [],
            data = emptyArray(line.text.length),
            maxBot = pre.offsetHeight;
        // Work around an IE7/8 bug where it will sometimes have randomly
        // replaced our pre with a clone at this point.
        if (ie_lt9 && display.measure.first != pre) removeChildrenAndAdd(display.measure, pre);

        function measureRect(rect) {
          var top = rect.top - outer.top,
              bot = rect.bottom - outer.top;
          if (bot > maxBot) bot = maxBot;
          if (top < 0) top = 0;
          for (var i = vranges.length - 2; i >= 0; i -= 2) {
            var rtop = vranges[i],
                rbot = vranges[i + 1];
            if (rtop > bot || rbot < top) continue;
            if (rtop <= top && rbot >= bot || top <= rtop && bot >= rbot || Math.min(bot, rbot) - Math.max(top, rtop) >= bot - top >> 1) {
              vranges[i] = Math.min(top, rtop);
              vranges[i + 1] = Math.max(bot, rbot);
              break;
            }
          }
          if (i < 0) {
            i = vranges.length;vranges.push(top, bot);
          }
          return { left: rect.left - outer.left,
            right: rect.right - outer.left,
            top: i, bottom: null };
        }
        function finishRect(rect) {
          rect.bottom = vranges[rect.top + 1];
          rect.top = vranges[rect.top];
        }

        for (var i = 0, cur; i < measure.length; ++i) if (cur = measure[i]) {
          var node = cur,
              rect = null;
          // A widget might wrap, needs special care
          if (/\bCodeMirror-widget\b/.test(cur.className) && cur.getClientRects) {
            if (cur.firstChild.nodeType == 1) node = cur.firstChild;
            var rects = node.getClientRects();
            if (rects.length > 1) {
              rect = data[i] = measureRect(rects[0]);
              rect.rightSide = measureRect(rects[rects.length - 1]);
            }
          }
          if (!rect) rect = data[i] = measureRect(getRect(node));
          if (cur.measureRight) rect.right = getRect(cur.measureRight).left;
          if (cur.leftSide) rect.leftSide = measureRect(getRect(cur.leftSide));
        }
        removeChildren(cm.display.measure);
        for (var i = 0, cur; i < data.length; ++i) if (cur = data[i]) {
          finishRect(cur);
          if (cur.leftSide) finishRect(cur.leftSide);
          if (cur.rightSide) finishRect(cur.rightSide);
        }
        return data;
      }

      function crudelyMeasureLine(cm, line) {
        var copy = new Line(line.text.slice(0, 100), null);
        if (line.textClass) copy.textClass = line.textClass;
        var measure = measureLineInner(cm, copy);
        var left = measureChar(cm, copy, 0, measure, "left");
        var right = measureChar(cm, copy, 99, measure, "right");
        return { crude: true, top: left.top, left: left.left, bottom: left.bottom, width: (right.right - left.left) / 100 };
      }

      function measureLineWidth(cm, line) {
        var hasBadSpan = false;
        if (line.markedSpans) for (var i = 0; i < line.markedSpans; ++i) {
          var sp = line.markedSpans[i];
          if (sp.collapsed && (sp.to == null || sp.to == line.text.length)) hasBadSpan = true;
        }
        var cached = !hasBadSpan && findCachedMeasurement(cm, line);
        if (cached || line.text.length >= cm.options.crudeMeasuringFrom) return measureChar(cm, line, line.text.length, cached && cached.measure, "right").right;

        var pre = buildLineContent(cm, line, null, true).pre;
        var end = pre.appendChild(zeroWidthElement(cm.display.measure));
        removeChildrenAndAdd(cm.display.measure, pre);
        return getRect(end).right - getRect(cm.display.lineDiv).left;
      }

      function clearCaches(cm) {
        cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0;
        cm.display.cachedCharWidth = cm.display.cachedTextHeight = null;
        if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;
        cm.display.lineNumChars = null;
      }

      function pageScrollX() {
        return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
      }
      function pageScrollY() {
        return window.pageYOffset || (document.documentElement || document.body).scrollTop;
      }

      // Context is one of "line", "div" (display.lineDiv), "local"/null (editor), or "page"
      function intoCoordSystem(cm, lineObj, rect, context) {
        if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
          var size = widgetHeight(lineObj.widgets[i]);
          rect.top += size;rect.bottom += size;
        }
        if (context == "line") return rect;
        if (!context) context = "local";
        var yOff = heightAtLine(cm, lineObj);
        if (context == "local") yOff += paddingTop(cm.display);else yOff -= cm.display.viewOffset;
        if (context == "page" || context == "window") {
          var lOff = getRect(cm.display.lineSpace);
          yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
          var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
          rect.left += xOff;rect.right += xOff;
        }
        rect.top += yOff;rect.bottom += yOff;
        return rect;
      }

      // Context may be "window", "page", "div", or "local"/null
      // Result is in "div" coords
      function fromCoordSystem(cm, coords, context) {
        if (context == "div") return coords;
        var left = coords.left,
            top = coords.top;
        // First move into "page" coordinate system
        if (context == "page") {
          left -= pageScrollX();
          top -= pageScrollY();
        } else if (context == "local" || !context) {
          var localBox = getRect(cm.display.sizer);
          left += localBox.left;
          top += localBox.top;
        }

        var lineSpaceBox = getRect(cm.display.lineSpace);
        return { left: left - lineSpaceBox.left, top: top - lineSpaceBox.top };
      }

      function charCoords(cm, pos, context, lineObj, bias) {
        if (!lineObj) lineObj = getLine(cm.doc, pos.line);
        return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, null, bias), context);
      }

      function cursorCoords(cm, pos, context, lineObj, measurement) {
        lineObj = lineObj || getLine(cm.doc, pos.line);
        if (!measurement) measurement = measureLine(cm, lineObj);
        function get(ch, right) {
          var m = measureChar(cm, lineObj, ch, measurement, right ? "right" : "left");
          if (right) m.left = m.right;else m.right = m.left;
          return intoCoordSystem(cm, lineObj, m, context);
        }
        function getBidi(ch, partPos) {
          var part = order[partPos],
              right = part.level % 2;
          if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
            part = order[--partPos];
            ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
            right = true;
          } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
            part = order[++partPos];
            ch = bidiLeft(part) - part.level % 2;
            right = false;
          }
          if (right && ch == part.to && ch > part.from) return get(ch - 1);
          return get(ch, right);
        }
        var order = getOrder(lineObj),
            ch = pos.ch;
        if (!order) return get(ch);
        var partPos = getBidiPartAt(order, ch);
        var val = getBidi(ch, partPos);
        if (bidiOther != null) val.other = getBidi(ch, bidiOther);
        return val;
      }

      function PosWithInfo(line, ch, outside, xRel) {
        var pos = new Pos(line, ch);
        pos.xRel = xRel;
        if (outside) pos.outside = true;
        return pos;
      }

      // Coords must be lineSpace-local
      function coordsChar(cm, x, y) {
        var doc = cm.doc;
        y += cm.display.viewOffset;
        if (y < 0) return PosWithInfo(doc.first, 0, true, -1);
        var lineNo = lineAtHeight(doc, y),
            last = doc.first + doc.size - 1;
        if (lineNo > last) return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
        if (x < 0) x = 0;

        for (;;) {
          var lineObj = getLine(doc, lineNo);
          var found = coordsCharInner(cm, lineObj, lineNo, x, y);
          var merged = collapsedSpanAtEnd(lineObj);
          var mergedPos = merged && merged.find();
          if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0)) lineNo = mergedPos.to.line;else return found;
        }
      }

      function coordsCharInner(cm, lineObj, lineNo, x, y) {
        var innerOff = y - heightAtLine(cm, lineObj);
        var wrongLine = false,
            adjust = 2 * cm.display.wrapper.clientWidth;
        var measurement = measureLine(cm, lineObj);

        function getX(ch) {
          var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, measurement);
          wrongLine = true;
          if (innerOff > sp.bottom) return sp.left - adjust;else if (innerOff < sp.top) return sp.left + adjust;else wrongLine = false;
          return sp.left;
        }

        var bidi = getOrder(lineObj),
            dist = lineObj.text.length;
        var from = lineLeft(lineObj),
            to = lineRight(lineObj);
        var fromX = getX(from),
            fromOutside = wrongLine,
            toX = getX(to),
            toOutside = wrongLine;

        if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
        // Do a binary search between these bounds.
        for (;;) {
          if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
            var ch = x < fromX || x - fromX <= toX - x ? from : to;
            var xDiff = x - (ch == from ? fromX : toX);
            while (isExtendingChar.test(lineObj.text.charAt(ch))) ++ch;
            var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside, xDiff < 0 ? -1 : xDiff ? 1 : 0);
            return pos;
          }
          var step = Math.ceil(dist / 2),
              middle = from + step;
          if (bidi) {
            middle = from;
            for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
          }
          var middleX = getX(middle);
          if (middleX > x) {
            to = middle;toX = middleX;if (toOutside = wrongLine) toX += 1000;dist = step;
          } else {
            from = middle;fromX = middleX;fromOutside = wrongLine;dist -= step;
          }
        }
      }

      var measureText;
      function textHeight(display) {
        if (display.cachedTextHeight != null) return display.cachedTextHeight;
        if (measureText == null) {
          measureText = elt("pre");
          // Measure a bunch of lines, for browsers that compute
          // fractional heights.
          for (var i = 0; i < 49; ++i) {
            measureText.appendChild(document.createTextNode("x"));
            measureText.appendChild(elt("br"));
          }
          measureText.appendChild(document.createTextNode("x"));
        }
        removeChildrenAndAdd(display.measure, measureText);
        var height = measureText.offsetHeight / 50;
        if (height > 3) display.cachedTextHeight = height;
        removeChildren(display.measure);
        return height || 1;
      }

      function charWidth(display) {
        if (display.cachedCharWidth != null) return display.cachedCharWidth;
        var anchor = elt("span", "x");
        var pre = elt("pre", [anchor]);
        removeChildrenAndAdd(display.measure, pre);
        var width = anchor.offsetWidth;
        if (width > 2) display.cachedCharWidth = width;
        return width || 10;
      }

      // OPERATIONS

      // Operations are used to wrap changes in such a way that each
      // change won't have to update the cursor and display (which would
      // be awkward, slow, and error-prone), but instead updates are
      // batched and then all combined and executed at once.

      var nextOpId = 0;
      function startOperation(cm) {
        cm.curOp = {
          // An array of ranges of lines that have to be updated. See
          // updateDisplay.
          changes: [],
          forceUpdate: false,
          updateInput: null,
          userSelChange: null,
          textChanged: null,
          selectionChanged: false,
          cursorActivity: false,
          updateMaxLine: false,
          updateScrollPos: false,
          id: ++nextOpId
        };
        if (!delayedCallbackDepth++) delayedCallbacks = [];
      }

      function endOperation(cm) {
        var op = cm.curOp,
            doc = cm.doc,
            display = cm.display;
        cm.curOp = null;

        if (op.updateMaxLine) computeMaxLength(cm);
        if (display.maxLineChanged && !cm.options.lineWrapping && display.maxLine) {
          var width = measureLineWidth(cm, display.maxLine);
          display.sizer.style.minWidth = Math.max(0, width + 3 + scrollerCutOff) + "px";
          display.maxLineChanged = false;
          var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + display.sizer.offsetWidth - display.scroller.clientWidth);
          if (maxScrollLeft < doc.scrollLeft && !op.updateScrollPos) setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);
        }
        var newScrollPos, updated;
        if (op.updateScrollPos) {
          newScrollPos = op.updateScrollPos;
        } else if (op.selectionChanged && display.scroller.clientHeight) {
          // don't rescroll if not visible
          var coords = cursorCoords(cm, doc.sel.head);
          newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);
        }
        if (op.changes.length || op.forceUpdate || newScrollPos && newScrollPos.scrollTop != null) {
          updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop, op.forceUpdate);
          if (cm.display.scroller.offsetHeight) cm.doc.scrollTop = cm.display.scroller.scrollTop;
        }
        if (!updated && op.selectionChanged) updateSelection(cm);
        if (op.updateScrollPos) {
          var top = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, newScrollPos.scrollTop));
          var left = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, newScrollPos.scrollLeft));
          display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = top;
          display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = left;
          alignHorizontally(cm);
          if (op.scrollToPos) scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos.from), clipPos(cm.doc, op.scrollToPos.to), op.scrollToPos.margin);
        } else if (newScrollPos) {
          scrollCursorIntoView(cm);
        }
        if (op.selectionChanged) restartBlink(cm);

        if (cm.state.focused && op.updateInput) resetInput(cm, op.userSelChange);

        var hidden = op.maybeHiddenMarkers,
            unhidden = op.maybeUnhiddenMarkers;
        if (hidden) for (var i = 0; i < hidden.length; ++i) if (!hidden[i].lines.length) signal(hidden[i], "hide");
        if (unhidden) for (var i = 0; i < unhidden.length; ++i) if (unhidden[i].lines.length) signal(unhidden[i], "unhide");

        var delayed;
        if (! --delayedCallbackDepth) {
          delayed = delayedCallbacks;
          delayedCallbacks = null;
        }
        if (op.textChanged) signal(cm, "change", cm, op.textChanged);
        if (op.cursorActivity) signal(cm, "cursorActivity", cm);
        if (delayed) for (var i = 0; i < delayed.length; ++i) delayed[i]();
      }

      // Wraps a function in an operation. Returns the wrapped function.
      function operation(cm1, f) {
        return function () {
          var cm = cm1 || this,
              withOp = !cm.curOp;
          if (withOp) startOperation(cm);
          try {
            var result = f.apply(cm, arguments);
          } finally {
            if (withOp) endOperation(cm);
          }
          return result;
        };
      }
      function docOperation(f) {
        return function () {
          var withOp = this.cm && !this.cm.curOp,
              result;
          if (withOp) startOperation(this.cm);
          try {
            result = f.apply(this, arguments);
          } finally {
            if (withOp) endOperation(this.cm);
          }
          return result;
        };
      }
      function runInOp(cm, f) {
        var withOp = !cm.curOp,
            result;
        if (withOp) startOperation(cm);
        try {
          result = f();
        } finally {
          if (withOp) endOperation(cm);
        }
        return result;
      }

      function regChange(cm, from, to, lendiff) {
        if (from == null) from = cm.doc.first;
        if (to == null) to = cm.doc.first + cm.doc.size;
        cm.curOp.changes.push({ from: from, to: to, diff: lendiff });
      }

      // INPUT HANDLING

      function slowPoll(cm) {
        if (cm.display.pollingFast) return;
        cm.display.poll.set(cm.options.pollInterval, function () {
          readInput(cm);
          if (cm.state.focused) slowPoll(cm);
        });
      }

      function fastPoll(cm) {
        var missed = false;
        cm.display.pollingFast = true;
        function p() {
          var changed = readInput(cm);
          if (!changed && !missed) {
            missed = true;cm.display.poll.set(60, p);
          } else {
            cm.display.pollingFast = false;slowPoll(cm);
          }
        }
        cm.display.poll.set(20, p);
      }

      // prevInput is a hack to work with IME. If we reset the textarea
      // on every change, that breaks IME. So we look for changes
      // compared to the previous content instead. (Modern browsers have
      // events that indicate IME taking place, but these are not widely
      // supported or compatible enough yet to rely on.)
      function readInput(cm) {
        var input = cm.display.input,
            prevInput = cm.display.prevInput,
            doc = cm.doc,
            sel = doc.sel;
        if (!cm.state.focused || hasSelection(input) || isReadOnly(cm) || cm.state.disableInput) return false;
        if (cm.state.pasteIncoming && cm.state.fakedLastChar) {
          input.value = input.value.substring(0, input.value.length - 1);
          cm.state.fakedLastChar = false;
        }
        var text = input.value;
        if (text == prevInput && posEq(sel.from, sel.to)) return false;
        if (ie && !ie_lt9 && cm.display.inputHasSelection === text) {
          resetInput(cm, true);
          return false;
        }

        var withOp = !cm.curOp;
        if (withOp) startOperation(cm);
        sel.shift = false;
        var same = 0,
            l = Math.min(prevInput.length, text.length);
        while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;
        var from = sel.from,
            to = sel.to;
        if (same < prevInput.length) from = Pos(from.line, from.ch - (prevInput.length - same));else if (cm.state.overwrite && posEq(from, to) && !cm.state.pasteIncoming) to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + (text.length - same)));

        var updateInput = cm.curOp.updateInput;
        var changeEvent = { from: from, to: to, text: splitLines(text.slice(same)),
          origin: cm.state.pasteIncoming ? "paste" : "+input" };
        makeChange(cm.doc, changeEvent, "end");
        cm.curOp.updateInput = updateInput;
        signalLater(cm, "inputRead", cm, changeEvent);

        if (text.length > 1000 || text.indexOf("\n") > -1) input.value = cm.display.prevInput = "";else cm.display.prevInput = text;
        if (withOp) endOperation(cm);
        cm.state.pasteIncoming = false;
        return true;
      }

      function resetInput(cm, user) {
        var minimal,
            selected,
            doc = cm.doc;
        if (!posEq(doc.sel.from, doc.sel.to)) {
          cm.display.prevInput = "";
          minimal = hasCopyEvent && (doc.sel.to.line - doc.sel.from.line > 100 || (selected = cm.getSelection()).length > 1000);
          var content = minimal ? "-" : selected || cm.getSelection();
          cm.display.input.value = content;
          if (cm.state.focused) selectInput(cm.display.input);
          if (ie && !ie_lt9) cm.display.inputHasSelection = content;
        } else if (user) {
          cm.display.prevInput = cm.display.input.value = "";
          if (ie && !ie_lt9) cm.display.inputHasSelection = null;
        }
        cm.display.inaccurateSelection = minimal;
      }

      function focusInput(cm) {
        if (cm.options.readOnly != "nocursor" && (!mobile || document.activeElement != cm.display.input)) cm.display.input.focus();
      }

      function isReadOnly(cm) {
        return cm.options.readOnly || cm.doc.cantEdit;
      }

      // EVENT HANDLERS

      function registerEventHandlers(cm) {
        var d = cm.display;
        on(d.scroller, "mousedown", operation(cm, onMouseDown));
        if (ie) on(d.scroller, "dblclick", operation(cm, function (e) {
          if (signalDOMEvent(cm, e)) return;
          var pos = posFromMouse(cm, e);
          if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;
          e_preventDefault(e);
          var word = findWordAt(getLine(cm.doc, pos.line).text, pos);
          extendSelection(cm.doc, word.from, word.to);
        }));else on(d.scroller, "dblclick", function (e) {
          signalDOMEvent(cm, e) || e_preventDefault(e);
        });
        on(d.lineSpace, "selectstart", function (e) {
          if (!eventInWidget(d, e)) e_preventDefault(e);
        });
        // Gecko browsers fire contextmenu *after* opening the menu, at
        // which point we can't mess with it anymore. Context menu is
        // handled in onMouseDown for Gecko.
        if (!captureMiddleClick) on(d.scroller, "contextmenu", function (e) {
          onContextMenu(cm, e);
        });

        on(d.scroller, "scroll", function () {
          if (d.scroller.clientHeight) {
            setScrollTop(cm, d.scroller.scrollTop);
            setScrollLeft(cm, d.scroller.scrollLeft, true);
            signal(cm, "scroll", cm);
          }
        });
        on(d.scrollbarV, "scroll", function () {
          if (d.scroller.clientHeight) setScrollTop(cm, d.scrollbarV.scrollTop);
        });
        on(d.scrollbarH, "scroll", function () {
          if (d.scroller.clientHeight) setScrollLeft(cm, d.scrollbarH.scrollLeft);
        });

        on(d.scroller, "mousewheel", function (e) {
          onScrollWheel(cm, e);
        });
        on(d.scroller, "DOMMouseScroll", function (e) {
          onScrollWheel(cm, e);
        });

        function reFocus() {
          if (cm.state.focused) setTimeout(bind(focusInput, cm), 0);
        }
        on(d.scrollbarH, "mousedown", reFocus);
        on(d.scrollbarV, "mousedown", reFocus);
        // Prevent wrapper from ever scrolling
        on(d.wrapper, "scroll", function () {
          d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
        });

        var resizeTimer;
        function onResize() {
          if (resizeTimer == null) resizeTimer = setTimeout(function () {
            resizeTimer = null;
            // Might be a text scaling operation, clear size caches.
            d.cachedCharWidth = d.cachedTextHeight = knownScrollbarWidth = null;
            clearCaches(cm);
            runInOp(cm, bind(regChange, cm));
          }, 100);
        }
        on(window, "resize", onResize);
        // Above handler holds on to the editor and its data structures.
        // Here we poll to unregister it when the editor is no longer in
        // the document, so that it can be garbage-collected.
        function unregister() {
          for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode) {}
          if (p) setTimeout(unregister, 5000);else off(window, "resize", onResize);
        }
        setTimeout(unregister, 5000);

        on(d.input, "keyup", operation(cm, function (e) {
          if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;
          if (e.keyCode == 16) cm.doc.sel.shift = false;
        }));
        on(d.input, "input", function () {
          if (ie && !ie_lt9 && cm.display.inputHasSelection) cm.display.inputHasSelection = null;
          fastPoll(cm);
        });
        on(d.input, "keydown", operation(cm, onKeyDown));
        on(d.input, "keypress", operation(cm, onKeyPress));
        on(d.input, "focus", bind(onFocus, cm));
        on(d.input, "blur", bind(onBlur, cm));

        function drag_(e) {
          if (signalDOMEvent(cm, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))) return;
          e_stop(e);
        }
        if (cm.options.dragDrop) {
          on(d.scroller, "dragstart", function (e) {
            onDragStart(cm, e);
          });
          on(d.scroller, "dragenter", drag_);
          on(d.scroller, "dragover", drag_);
          on(d.scroller, "drop", operation(cm, onDrop));
        }
        on(d.scroller, "paste", function (e) {
          if (eventInWidget(d, e)) return;
          focusInput(cm);
          fastPoll(cm);
        });
        on(d.input, "paste", function () {
          // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206
          // Add a char to the end of textarea before paste occur so that
          // selection doesn't span to the end of textarea.
          if (webkit && !cm.state.fakedLastChar && !(new Date() - cm.state.lastMiddleDown < 200)) {
            var start = d.input.selectionStart,
                end = d.input.selectionEnd;
            d.input.value += "$";
            d.input.selectionStart = start;
            d.input.selectionEnd = end;
            cm.state.fakedLastChar = true;
          }
          cm.state.pasteIncoming = true;
          fastPoll(cm);
        });

        function prepareCopy() {
          if (d.inaccurateSelection) {
            d.prevInput = "";
            d.inaccurateSelection = false;
            d.input.value = cm.getSelection();
            selectInput(d.input);
          }
        }
        on(d.input, "cut", prepareCopy);
        on(d.input, "copy", prepareCopy);

        // Needed to handle Tab key in KHTML
        if (khtml) on(d.sizer, "mouseup", function () {
          if (document.activeElement == d.input) d.input.blur();
          focusInput(cm);
        });
      }

      function eventInWidget(display, e) {
        for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
          if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover) return true;
        }
      }

      function posFromMouse(cm, e, liberal) {
        var display = cm.display;
        if (!liberal) {
          var target = e_target(e);
          if (target == display.scrollbarH || target == display.scrollbarH.firstChild || target == display.scrollbarV || target == display.scrollbarV.firstChild || target == display.scrollbarFiller || target == display.gutterFiller) return null;
        }
        var x,
            y,
            space = getRect(display.lineSpace);
        // Fails unpredictably on IE[67] when mouse is dragged around quickly.
        try {
          x = e.clientX;y = e.clientY;
        } catch (e) {
          return null;
        }
        return coordsChar(cm, x - space.left, y - space.top);
      }

      var lastClick, lastDoubleClick;
      function onMouseDown(e) {
        if (signalDOMEvent(this, e)) return;
        var cm = this,
            display = cm.display,
            doc = cm.doc,
            sel = doc.sel;
        sel.shift = e.shiftKey;

        if (eventInWidget(display, e)) {
          if (!webkit) {
            display.scroller.draggable = false;
            setTimeout(function () {
              display.scroller.draggable = true;
            }, 100);
          }
          return;
        }
        if (clickInGutter(cm, e)) return;
        var start = posFromMouse(cm, e);

        switch (e_button(e)) {
          case 3:
            if (captureMiddleClick) onContextMenu.call(cm, cm, e);
            return;
          case 2:
            if (webkit) cm.state.lastMiddleDown = +new Date();
            if (start) extendSelection(cm.doc, start);
            setTimeout(bind(focusInput, cm), 20);
            e_preventDefault(e);
            return;
        }
        // For button 1, if it was clicked inside the editor
        // (posFromMouse returning non-null), we have to adjust the
        // selection.
        if (!start) {
          if (e_target(e) == display.scroller) e_preventDefault(e);return;
        }

        if (!cm.state.focused) onFocus(cm);

        var now = +new Date(),
            type = "single";
        if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {
          type = "triple";
          e_preventDefault(e);
          setTimeout(bind(focusInput, cm), 20);
          selectLine(cm, start.line);
        } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {
          type = "double";
          lastDoubleClick = { time: now, pos: start };
          e_preventDefault(e);
          var word = findWordAt(getLine(doc, start.line).text, start);
          extendSelection(cm.doc, word.from, word.to);
        } else {
          lastClick = { time: now, pos: start };
        }

        var last = start;
        if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) && !posLess(start, sel.from) && !posLess(sel.to, start) && type == "single") {
          var dragEnd = operation(cm, function (e2) {
            if (webkit) display.scroller.draggable = false;
            cm.state.draggingText = false;
            off(document, "mouseup", dragEnd);
            off(display.scroller, "drop", dragEnd);
            if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
              e_preventDefault(e2);
              extendSelection(cm.doc, start);
              focusInput(cm);
            }
          });
          // Let the drag handler handle this.
          if (webkit) display.scroller.draggable = true;
          cm.state.draggingText = dragEnd;
          // IE's approach to draggable
          if (display.scroller.dragDrop) display.scroller.dragDrop();
          on(document, "mouseup", dragEnd);
          on(display.scroller, "drop", dragEnd);
          return;
        }
        e_preventDefault(e);
        if (type == "single") extendSelection(cm.doc, clipPos(doc, start));

        var startstart = sel.from,
            startend = sel.to,
            lastPos = start;

        function doSelect(cur) {
          if (posEq(lastPos, cur)) return;
          lastPos = cur;

          if (type == "single") {
            extendSelection(cm.doc, clipPos(doc, start), cur);
            return;
          }

          startstart = clipPos(doc, startstart);
          startend = clipPos(doc, startend);
          if (type == "double") {
            var word = findWordAt(getLine(doc, cur.line).text, cur);
            if (posLess(cur, startstart)) extendSelection(cm.doc, word.from, startend);else extendSelection(cm.doc, startstart, word.to);
          } else if (type == "triple") {
            if (posLess(cur, startstart)) extendSelection(cm.doc, startend, clipPos(doc, Pos(cur.line, 0)));else extendSelection(cm.doc, startstart, clipPos(doc, Pos(cur.line + 1, 0)));
          }
        }

        var editorSize = getRect(display.wrapper);
        // Used to ensure timeout re-tries don't fire when another extend
        // happened in the meantime (clearTimeout isn't reliable -- at
        // least on Chrome, the timeouts still happen even when cleared,
        // if the clear happens after their scheduled firing time).
        var counter = 0;

        function extend(e) {
          var curCount = ++counter;
          var cur = posFromMouse(cm, e, true);
          if (!cur) return;
          if (!posEq(cur, last)) {
            if (!cm.state.focused) onFocus(cm);
            last = cur;
            doSelect(cur);
            var visible = visibleLines(display, doc);
            if (cur.line >= visible.to || cur.line < visible.from) setTimeout(operation(cm, function () {
              if (counter == curCount) extend(e);
            }), 150);
          } else {
            var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
            if (outside) setTimeout(operation(cm, function () {
              if (counter != curCount) return;
              display.scroller.scrollTop += outside;
              extend(e);
            }), 50);
          }
        }

        function done(e) {
          counter = Infinity;
          e_preventDefault(e);
          focusInput(cm);
          off(document, "mousemove", move);
          off(document, "mouseup", up);
        }

        var move = operation(cm, function (e) {
          if (!ie && !e_button(e)) done(e);else extend(e);
        });
        var up = operation(cm, done);
        on(document, "mousemove", move);
        on(document, "mouseup", up);
      }

      function gutterEvent(cm, e, type, prevent, signalfn) {
        try {
          var mX = e.clientX,
              mY = e.clientY;
        } catch (e) {
          return false;
        }
        if (mX >= Math.floor(getRect(cm.display.gutters).right)) return false;
        if (prevent) e_preventDefault(e);

        var display = cm.display;
        var lineBox = getRect(display.lineDiv);

        if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
        mY -= lineBox.top - display.viewOffset;

        for (var i = 0; i < cm.options.gutters.length; ++i) {
          var g = display.gutters.childNodes[i];
          if (g && getRect(g).right >= mX) {
            var line = lineAtHeight(cm.doc, mY);
            var gutter = cm.options.gutters[i];
            signalfn(cm, type, cm, line, gutter, e);
            return e_defaultPrevented(e);
          }
        }
      }

      function contextMenuInGutter(cm, e) {
        if (!hasHandler(cm, "gutterContextMenu")) return false;
        return gutterEvent(cm, e, "gutterContextMenu", false, signal);
      }

      function clickInGutter(cm, e) {
        return gutterEvent(cm, e, "gutterClick", true, signalLater);
      }

      // Kludge to work around strange IE behavior where it'll sometimes
      // re-fire a series of drag-related events right after the drop (#1551)
      var lastDrop = 0;

      function onDrop(e) {
        var cm = this;
        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))) return;
        e_preventDefault(e);
        if (ie) lastDrop = +new Date();
        var pos = posFromMouse(cm, e, true),
            files = e.dataTransfer.files;
        if (!pos || isReadOnly(cm)) return;
        if (files && files.length && window.FileReader && window.File) {
          var n = files.length,
              text = Array(n),
              read = 0;
          var loadFile = function (file, i) {
            var reader = new FileReader();
            reader.onload = function () {
              text[i] = reader.result;
              if (++read == n) {
                pos = clipPos(cm.doc, pos);
                makeChange(cm.doc, { from: pos, to: pos, text: splitLines(text.join("\n")), origin: "paste" }, "around");
              }
            };
            reader.readAsText(file);
          };
          for (var i = 0; i < n; ++i) loadFile(files[i], i);
        } else {
          // Don't do a replace if the drop happened inside of the selected text.
          if (cm.state.draggingText && !(posLess(pos, cm.doc.sel.from) || posLess(cm.doc.sel.to, pos))) {
            cm.state.draggingText(e);
            // Ensure the editor is re-focused
            setTimeout(bind(focusInput, cm), 20);
            return;
          }
          try {
            var text = e.dataTransfer.getData("Text");
            if (text) {
              var curFrom = cm.doc.sel.from,
                  curTo = cm.doc.sel.to;
              setSelection(cm.doc, pos, pos);
              if (cm.state.draggingText) replaceRange(cm.doc, "", curFrom, curTo, "paste");
              cm.replaceSelection(text, null, "paste");
              focusInput(cm);
            }
          } catch (e) {}
        }
      }

      function onDragStart(cm, e) {
        if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
          e_stop(e);return;
        }
        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;

        var txt = cm.getSelection();
        e.dataTransfer.setData("Text", txt);

        // Use dummy image instead of default browsers image.
        // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
        if (e.dataTransfer.setDragImage && !safari) {
          var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
          img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
          if (opera) {
            img.width = img.height = 1;
            cm.display.wrapper.appendChild(img);
            // Force a relayout, or Opera won't use our image for some obscure reason
            img._top = img.offsetTop;
          }
          e.dataTransfer.setDragImage(img, 0, 0);
          if (opera) img.parentNode.removeChild(img);
        }
      }

      function setScrollTop(cm, val) {
        if (Math.abs(cm.doc.scrollTop - val) < 2) return;
        cm.doc.scrollTop = val;
        if (!gecko) updateDisplay(cm, [], val);
        if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
        if (cm.display.scrollbarV.scrollTop != val) cm.display.scrollbarV.scrollTop = val;
        if (gecko) updateDisplay(cm, []);
        startWorker(cm, 100);
      }
      function setScrollLeft(cm, val, isScroller) {
        if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
        val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
        cm.doc.scrollLeft = val;
        alignHorizontally(cm);
        if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
        if (cm.display.scrollbarH.scrollLeft != val) cm.display.scrollbarH.scrollLeft = val;
      }

      // Since the delta values reported on mouse wheel events are
      // unstandardized between browsers and even browser versions, and
      // generally horribly unpredictable, this code starts by measuring
      // the scroll effect that the first few mouse wheel events have,
      // and, from that, detects the way it can convert deltas to pixel
      // offsets afterwards.
      //
      // The reason we want to know the amount a wheel event will scroll
      // is that it gives us a chance to update the display before the
      // actual scrolling happens, reducing flickering.

      var wheelSamples = 0,
          wheelPixelsPerUnit = null;
      // Fill in a browser-detected starting value on browsers where we
      // know one. These don't have to be accurate -- the result of them
      // being wrong would just be a slight flicker on the first wheel
      // scroll (if it is large enough).
      if (ie) wheelPixelsPerUnit = -.53;else if (gecko) wheelPixelsPerUnit = 15;else if (chrome) wheelPixelsPerUnit = -.7;else if (safari) wheelPixelsPerUnit = -1 / 3;

      function onScrollWheel(cm, e) {
        var dx = e.wheelDeltaX,
            dy = e.wheelDeltaY;
        if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
        if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;else if (dy == null) dy = e.wheelDelta;

        var display = cm.display,
            scroll = display.scroller;
        // Quit if there's nothing to scroll here
        if (!(dx && scroll.scrollWidth > scroll.clientWidth || dy && scroll.scrollHeight > scroll.clientHeight)) return;

        // Webkit browsers on OS X abort momentum scrolls when the target
        // of the scroll event is removed from the scrollable element.
        // This hack (see related code in patchDisplay) makes sure the
        // element is kept around.
        if (dy && mac && webkit) {
          for (var cur = e.target; cur != scroll; cur = cur.parentNode) {
            if (cur.lineObj) {
              cm.display.currentWheelTarget = cur;
              break;
            }
          }
        }

        // On some browsers, horizontal scrolling will cause redraws to
        // happen before the gutter has been realigned, causing it to
        // wriggle around in a most unseemly way. When we have an
        // estimated pixels/delta value, we just handle horizontal
        // scrolling entirely here. It'll be slightly off from native, but
        // better than glitching out.
        if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {
          if (dy) setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
          setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
          e_preventDefault(e);
          display.wheelStartX = null; // Abort measurement, if in progress
          return;
        }

        if (dy && wheelPixelsPerUnit != null) {
          var pixels = dy * wheelPixelsPerUnit;
          var top = cm.doc.scrollTop,
              bot = top + display.wrapper.clientHeight;
          if (pixels < 0) top = Math.max(0, top + pixels - 50);else bot = Math.min(cm.doc.height, bot + pixels + 50);
          updateDisplay(cm, [], { top: top, bottom: bot });
        }

        if (wheelSamples < 20) {
          if (display.wheelStartX == null) {
            display.wheelStartX = scroll.scrollLeft;display.wheelStartY = scroll.scrollTop;
            display.wheelDX = dx;display.wheelDY = dy;
            setTimeout(function () {
              if (display.wheelStartX == null) return;
              var movedX = scroll.scrollLeft - display.wheelStartX;
              var movedY = scroll.scrollTop - display.wheelStartY;
              var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
              display.wheelStartX = display.wheelStartY = null;
              if (!sample) return;
              wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
              ++wheelSamples;
            }, 200);
          } else {
            display.wheelDX += dx;display.wheelDY += dy;
          }
        }
      }

      function doHandleBinding(cm, bound, dropShift) {
        if (typeof bound == "string") {
          bound = commands[bound];
          if (!bound) return false;
        }
        // Ensure previous input has been read, so that the handler sees a
        // consistent view of the document
        if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;
        var doc = cm.doc,
            prevShift = doc.sel.shift,
            done = false;
        try {
          if (isReadOnly(cm)) cm.state.suppressEdits = true;
          if (dropShift) doc.sel.shift = false;
          done = bound(cm) != Pass;
        } finally {
          doc.sel.shift = prevShift;
          cm.state.suppressEdits = false;
        }
        return done;
      }

      function allKeyMaps(cm) {
        var maps = cm.state.keyMaps.slice(0);
        if (cm.options.extraKeys) maps.push(cm.options.extraKeys);
        maps.push(cm.options.keyMap);
        return maps;
      }

      var maybeTransition;
      function handleKeyBinding(cm, e) {
        // Handle auto keymap transitions
        var startMap = getKeyMap(cm.options.keyMap),
            next = startMap.auto;
        clearTimeout(maybeTransition);
        if (next && !isModifierKey(e)) maybeTransition = setTimeout(function () {
          if (getKeyMap(cm.options.keyMap) == startMap) {
            cm.options.keyMap = next.call ? next.call(null, cm) : next;
            keyMapChanged(cm);
          }
        }, 50);

        var name = keyName(e, true),
            handled = false;
        if (!name) return false;
        var keymaps = allKeyMaps(cm);

        if (e.shiftKey) {
          // First try to resolve full name (including 'Shift-'). Failing
          // that, see if there is a cursor-motion command (starting with
          // 'go') bound to the keyname without 'Shift-'.
          handled = lookupKey("Shift-" + name, keymaps, function (b) {
            return doHandleBinding(cm, b, true);
          }) || lookupKey(name, keymaps, function (b) {
            if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) return doHandleBinding(cm, b);
          });
        } else {
          handled = lookupKey(name, keymaps, function (b) {
            return doHandleBinding(cm, b);
          });
        }

        if (handled) {
          e_preventDefault(e);
          restartBlink(cm);
          if (ie_lt9) {
            e.oldKeyCode = e.keyCode;e.keyCode = 0;
          }
          signalLater(cm, "keyHandled", cm, name, e);
        }
        return handled;
      }

      function handleCharBinding(cm, e, ch) {
        var handled = lookupKey("'" + ch + "'", allKeyMaps(cm), function (b) {
          return doHandleBinding(cm, b, true);
        });
        if (handled) {
          e_preventDefault(e);
          restartBlink(cm);
          signalLater(cm, "keyHandled", cm, "'" + ch + "'", e);
        }
        return handled;
      }

      var lastStoppedKey = null;
      function onKeyDown(e) {
        var cm = this;
        if (!cm.state.focused) onFocus(cm);
        if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;
        if (ie && e.keyCode == 27) e.returnValue = false;
        var code = e.keyCode;
        // IE does strange things with escape.
        cm.doc.sel.shift = code == 16 || e.shiftKey;
        // First give onKeyEvent option a chance to handle this.
        var handled = handleKeyBinding(cm, e);
        if (opera) {
          lastStoppedKey = handled ? code : null;
          // Opera has no cut event... we try to at least catch the key combo
          if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) cm.replaceSelection("");
        }
      }

      function onKeyPress(e) {
        var cm = this;
        if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;
        var keyCode = e.keyCode,
            charCode = e.charCode;
        if (opera && keyCode == lastStoppedKey) {
          lastStoppedKey = null;e_preventDefault(e);return;
        }
        if ((opera && (!e.which || e.which < 10) || khtml) && handleKeyBinding(cm, e)) return;
        var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
        if (this.options.electricChars && this.doc.mode.electricChars && this.options.smartIndent && !isReadOnly(this) && this.doc.mode.electricChars.indexOf(ch) > -1) setTimeout(operation(cm, function () {
          indentLine(cm, cm.doc.sel.to.line, "smart");
        }), 75);
        if (handleCharBinding(cm, e, ch)) return;
        if (ie && !ie_lt9) cm.display.inputHasSelection = null;
        fastPoll(cm);
      }

      function onFocus(cm) {
        if (cm.options.readOnly == "nocursor") return;
        if (!cm.state.focused) {
          signal(cm, "focus", cm);
          cm.state.focused = true;
          if (cm.display.wrapper.className.search(/\bCodeMirror-focused\b/) == -1) cm.display.wrapper.className += " CodeMirror-focused";
          if (!cm.curOp) {
            resetInput(cm, true);
            if (webkit) setTimeout(bind(resetInput, cm, true), 0); // Issue #1730
          }
        }
        slowPoll(cm);
        restartBlink(cm);
      }
      function onBlur(cm) {
        if (cm.state.focused) {
          signal(cm, "blur", cm);
          cm.state.focused = false;
          cm.display.wrapper.className = cm.display.wrapper.className.replace(" CodeMirror-focused", "");
        }
        clearInterval(cm.display.blinker);
        setTimeout(function () {
          if (!cm.state.focused) cm.doc.sel.shift = false;
        }, 150);
      }

      var detectingSelectAll;
      function onContextMenu(cm, e) {
        if (signalDOMEvent(cm, e, "contextmenu")) return;
        var display = cm.display,
            sel = cm.doc.sel;
        if (eventInWidget(display, e) || contextMenuInGutter(cm, e)) return;

        var pos = posFromMouse(cm, e),
            scrollPos = display.scroller.scrollTop;
        if (!pos || opera) return; // Opera is difficult.

        // Reset the current text selection only if the click is done outside of the selection
        // and 'resetSelectionOnContextMenu' option is true.
        var reset = cm.options.resetSelectionOnContextMenu;
        if (reset && (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to))) operation(cm, setSelection)(cm.doc, pos, pos);

        var oldCSS = display.input.style.cssText;
        display.inputDiv.style.position = "absolute";
        display.input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) + "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: white; outline: none;" + "border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);";
        focusInput(cm);
        resetInput(cm, true);
        // Adds "Select all" to context menu in FF
        if (posEq(sel.from, sel.to)) display.input.value = display.prevInput = " ";

        function prepareSelectAllHack() {
          if (display.input.selectionStart != null) {
            var extval = display.input.value = "\u200b" + (posEq(sel.from, sel.to) ? "" : display.input.value);
            display.prevInput = "\u200b";
            display.input.selectionStart = 1;display.input.selectionEnd = extval.length;
          }
        }
        function rehide() {
          display.inputDiv.style.position = "relative";
          display.input.style.cssText = oldCSS;
          if (ie_lt9) display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;
          slowPoll(cm);

          // Try to detect the user choosing select-all
          if (display.input.selectionStart != null) {
            if (!ie || ie_lt9) prepareSelectAllHack();
            clearTimeout(detectingSelectAll);
            var i = 0,
                poll = function () {
              if (display.prevInput == " " && display.input.selectionStart == 0) operation(cm, commands.selectAll)(cm);else if (i++ < 10) detectingSelectAll = setTimeout(poll, 500);else resetInput(cm);
            };
            detectingSelectAll = setTimeout(poll, 200);
          }
        }

        if (ie && !ie_lt9) prepareSelectAllHack();
        if (captureMiddleClick) {
          e_stop(e);
          var mouseup = function () {
            off(window, "mouseup", mouseup);
            setTimeout(rehide, 20);
          };
          on(window, "mouseup", mouseup);
        } else {
          setTimeout(rehide, 50);
        }
      }

      // UPDATING

      var changeEnd = CodeMirror.changeEnd = function (change) {
        if (!change.text) return change.to;
        return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
      };

      // Make sure a position will be valid after the given change.
      function clipPostChange(doc, change, pos) {
        if (!posLess(change.from, pos)) return clipPos(doc, pos);
        var diff = change.text.length - 1 - (change.to.line - change.from.line);
        if (pos.line > change.to.line + diff) {
          var preLine = pos.line - diff,
              lastLine = doc.first + doc.size - 1;
          if (preLine > lastLine) return Pos(lastLine, getLine(doc, lastLine).text.length);
          return clipToLen(pos, getLine(doc, preLine).text.length);
        }
        if (pos.line == change.to.line + diff) return clipToLen(pos, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0) + getLine(doc, change.to.line).text.length - change.to.ch);
        var inside = pos.line - change.from.line;
        return clipToLen(pos, change.text[inside].length + (inside ? 0 : change.from.ch));
      }

      // Hint can be null|"end"|"start"|"around"|{anchor,head}
      function computeSelAfterChange(doc, change, hint) {
        if (hint && typeof hint == "object") // Assumed to be {anchor, head} object
          return { anchor: clipPostChange(doc, change, hint.anchor),
            head: clipPostChange(doc, change, hint.head) };

        if (hint == "start") return { anchor: change.from, head: change.from };

        var end = changeEnd(change);
        if (hint == "around") return { anchor: change.from, head: end };
        if (hint == "end") return { anchor: end, head: end };

        // hint is null, leave the selection alone as much as possible
        var adjustPos = function (pos) {
          if (posLess(pos, change.from)) return pos;
          if (!posLess(change.to, pos)) return end;

          var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,
              ch = pos.ch;
          if (pos.line == change.to.line) ch += end.ch - change.to.ch;
          return Pos(line, ch);
        };
        return { anchor: adjustPos(doc.sel.anchor), head: adjustPos(doc.sel.head) };
      }

      function filterChange(doc, change, update) {
        var obj = {
          canceled: false,
          from: change.from,
          to: change.to,
          text: change.text,
          origin: change.origin,
          cancel: function () {
            this.canceled = true;
          }
        };
        if (update) obj.update = function (from, to, text, origin) {
          if (from) this.from = clipPos(doc, from);
          if (to) this.to = clipPos(doc, to);
          if (text) this.text = text;
          if (origin !== undefined) this.origin = origin;
        };
        signal(doc, "beforeChange", doc, obj);
        if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);

        if (obj.canceled) return null;
        return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };
      }

      // Replace the range from from to to by the strings in replacement.
      // change is a {from, to, text [, origin]} object
      function makeChange(doc, change, selUpdate, ignoreReadOnly) {
        if (doc.cm) {
          if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);
          if (doc.cm.state.suppressEdits) return;
        }

        if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
          change = filterChange(doc, change, true);
          if (!change) return;
        }

        // Possibly split or suppress the update based on the presence
        // of read-only spans in its range.
        var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
        if (split) {
          for (var i = split.length - 1; i >= 1; --i) makeChangeNoReadonly(doc, { from: split[i].from, to: split[i].to, text: [""] });
          if (split.length) makeChangeNoReadonly(doc, { from: split[0].from, to: split[0].to, text: change.text }, selUpdate);
        } else {
          makeChangeNoReadonly(doc, change, selUpdate);
        }
      }

      function makeChangeNoReadonly(doc, change, selUpdate) {
        if (change.text.length == 1 && change.text[0] == "" && posEq(change.from, change.to)) return;
        var selAfter = computeSelAfterChange(doc, change, selUpdate);
        addToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

        makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
        var rebased = [];

        linkedDocs(doc, function (doc, sharedHist) {
          if (!sharedHist && indexOf(rebased, doc.history) == -1) {
            rebaseHist(doc.history, change);
            rebased.push(doc.history);
          }
          makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
        });
      }

      function makeChangeFromHistory(doc, type) {
        if (doc.cm && doc.cm.state.suppressEdits) return;

        var hist = doc.history;
        var event = (type == "undo" ? hist.done : hist.undone).pop();
        if (!event) return;

        var anti = { changes: [], anchorBefore: event.anchorAfter, headBefore: event.headAfter,
          anchorAfter: event.anchorBefore, headAfter: event.headBefore,
          generation: hist.generation };
        (type == "undo" ? hist.undone : hist.done).push(anti);
        hist.generation = event.generation || ++hist.maxGeneration;

        var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

        for (var i = event.changes.length - 1; i >= 0; --i) {
          var change = event.changes[i];
          change.origin = type;
          if (filter && !filterChange(doc, change, false)) {
            (type == "undo" ? hist.done : hist.undone).length = 0;
            return;
          }

          anti.changes.push(historyChangeFromChange(doc, change));

          var after = i ? computeSelAfterChange(doc, change, null) : { anchor: event.anchorBefore, head: event.headBefore };
          makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
          var rebased = [];

          linkedDocs(doc, function (doc, sharedHist) {
            if (!sharedHist && indexOf(rebased, doc.history) == -1) {
              rebaseHist(doc.history, change);
              rebased.push(doc.history);
            }
            makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
          });
        }
      }

      function shiftDoc(doc, distance) {
        function shiftPos(pos) {
          return Pos(pos.line + distance, pos.ch);
        }
        doc.first += distance;
        if (doc.cm) regChange(doc.cm, doc.first, doc.first, distance);
        doc.sel.head = shiftPos(doc.sel.head);doc.sel.anchor = shiftPos(doc.sel.anchor);
        doc.sel.from = shiftPos(doc.sel.from);doc.sel.to = shiftPos(doc.sel.to);
      }

      function makeChangeSingleDoc(doc, change, selAfter, spans) {
        if (doc.cm && !doc.cm.curOp) return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

        if (change.to.line < doc.first) {
          shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
          return;
        }
        if (change.from.line > doc.lastLine()) return;

        // Clip the change to the size of this doc
        if (change.from.line < doc.first) {
          var shift = change.text.length - 1 - (doc.first - change.from.line);
          shiftDoc(doc, shift);
          change = { from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
            text: [lst(change.text)], origin: change.origin };
        }
        var last = doc.lastLine();
        if (change.to.line > last) {
          change = { from: change.from, to: Pos(last, getLine(doc, last).text.length),
            text: [change.text[0]], origin: change.origin };
        }

        change.removed = getBetween(doc, change.from, change.to);

        if (!selAfter) selAfter = computeSelAfterChange(doc, change, null);
        if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans, selAfter);else updateDoc(doc, change, spans, selAfter);
      }

      function makeChangeSingleDocInEditor(cm, change, spans, selAfter) {
        var doc = cm.doc,
            display = cm.display,
            from = change.from,
            to = change.to;

        var recomputeMaxLength = false,
            checkWidthStart = from.line;
        if (!cm.options.lineWrapping) {
          checkWidthStart = lineNo(visualLine(doc, getLine(doc, from.line)));
          doc.iter(checkWidthStart, to.line + 1, function (line) {
            if (line == display.maxLine) {
              recomputeMaxLength = true;
              return true;
            }
          });
        }

        if (!posLess(doc.sel.head, change.from) && !posLess(change.to, doc.sel.head)) cm.curOp.cursorActivity = true;

        updateDoc(doc, change, spans, selAfter, estimateHeight(cm));

        if (!cm.options.lineWrapping) {
          doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
            var len = lineLength(doc, line);
            if (len > display.maxLineLength) {
              display.maxLine = line;
              display.maxLineLength = len;
              display.maxLineChanged = true;
              recomputeMaxLength = false;
            }
          });
          if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
        }

        // Adjust frontier, schedule worker
        doc.frontier = Math.min(doc.frontier, from.line);
        startWorker(cm, 400);

        var lendiff = change.text.length - (to.line - from.line) - 1;
        // Remember that these lines changed, for updating the display
        regChange(cm, from.line, to.line + 1, lendiff);

        if (hasHandler(cm, "change")) {
          var changeObj = { from: from, to: to,
            text: change.text,
            removed: change.removed,
            origin: change.origin };
          if (cm.curOp.textChanged) {
            for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next) {}
            cur.next = changeObj;
          } else cm.curOp.textChanged = changeObj;
        }
      }

      function replaceRange(doc, code, from, to, origin) {
        if (!to) to = from;
        if (posLess(to, from)) {
          var tmp = to;to = from;from = tmp;
        }
        if (typeof code == "string") code = splitLines(code);
        makeChange(doc, { from: from, to: to, text: code, origin: origin }, null);
      }

      // POSITION OBJECT

      function Pos(line, ch) {
        if (!(this instanceof Pos)) return new Pos(line, ch);
        this.line = line;this.ch = ch;
      }
      CodeMirror.Pos = Pos;

      function posEq(a, b) {
        return a.line == b.line && a.ch == b.ch;
      }
      function posLess(a, b) {
        return a.line < b.line || a.line == b.line && a.ch < b.ch;
      }
      function copyPos(x) {
        return Pos(x.line, x.ch);
      }

      // SELECTION

      function clipLine(doc, n) {
        return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
      }
      function clipPos(doc, pos) {
        if (pos.line < doc.first) return Pos(doc.first, 0);
        var last = doc.first + doc.size - 1;
        if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
        return clipToLen(pos, getLine(doc, pos.line).text.length);
      }
      function clipToLen(pos, linelen) {
        var ch = pos.ch;
        if (ch == null || ch > linelen) return Pos(pos.line, linelen);else if (ch < 0) return Pos(pos.line, 0);else return pos;
      }
      function isLine(doc, l) {
        return l >= doc.first && l < doc.first + doc.size;
      }

      // If shift is held, this will move the selection anchor. Otherwise,
      // it'll set the whole selection.
      function extendSelection(doc, pos, other, bias) {
        if (doc.sel.shift || doc.sel.extend) {
          var anchor = doc.sel.anchor;
          if (other) {
            var posBefore = posLess(pos, anchor);
            if (posBefore != posLess(other, anchor)) {
              anchor = pos;
              pos = other;
            } else if (posBefore != posLess(pos, other)) {
              pos = other;
            }
          }
          setSelection(doc, anchor, pos, bias);
        } else {
          setSelection(doc, pos, other || pos, bias);
        }
        if (doc.cm) doc.cm.curOp.userSelChange = true;
      }

      function filterSelectionChange(doc, anchor, head) {
        var obj = { anchor: anchor, head: head };
        signal(doc, "beforeSelectionChange", doc, obj);
        if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
        obj.anchor = clipPos(doc, obj.anchor);obj.head = clipPos(doc, obj.head);
        return obj;
      }

      // Update the selection. Last two args are only used by
      // updateDoc, since they have to be expressed in the line
      // numbers before the update.
      function setSelection(doc, anchor, head, bias, checkAtomic) {
        if (!checkAtomic && hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
          var filtered = filterSelectionChange(doc, anchor, head);
          head = filtered.head;
          anchor = filtered.anchor;
        }

        var sel = doc.sel;
        sel.goalColumn = null;
        if (bias == null) bias = posLess(head, sel.head) ? -1 : 1;
        // Skip over atomic spans.
        if (checkAtomic || !posEq(anchor, sel.anchor)) anchor = skipAtomic(doc, anchor, bias, checkAtomic != "push");
        if (checkAtomic || !posEq(head, sel.head)) head = skipAtomic(doc, head, bias, checkAtomic != "push");

        if (posEq(sel.anchor, anchor) && posEq(sel.head, head)) return;

        sel.anchor = anchor;sel.head = head;
        var inv = posLess(head, anchor);
        sel.from = inv ? head : anchor;
        sel.to = inv ? anchor : head;

        if (doc.cm) doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = doc.cm.curOp.cursorActivity = true;

        signalLater(doc, "cursorActivity", doc);
      }

      function reCheckSelection(cm) {
        setSelection(cm.doc, cm.doc.sel.from, cm.doc.sel.to, null, "push");
      }

      function skipAtomic(doc, pos, bias, mayClear) {
        var flipped = false,
            curPos = pos;
        var dir = bias || 1;
        doc.cantEdit = false;
        search: for (;;) {
          var line = getLine(doc, curPos.line);
          if (line.markedSpans) {
            for (var i = 0; i < line.markedSpans.length; ++i) {
              var sp = line.markedSpans[i],
                  m = sp.marker;
              if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) && (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
                if (mayClear) {
                  signal(m, "beforeCursorEnter");
                  if (m.explicitlyCleared) {
                    if (!line.markedSpans) break;else {
                      --i;continue;
                    }
                  }
                }
                if (!m.atomic) continue;
                var newPos = m.find()[dir < 0 ? "from" : "to"];
                if (posEq(newPos, curPos)) {
                  newPos.ch += dir;
                  if (newPos.ch < 0) {
                    if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));else newPos = null;
                  } else if (newPos.ch > line.text.length) {
                    if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);else newPos = null;
                  }
                  if (!newPos) {
                    if (flipped) {
                      // Driven in a corner -- no valid cursor position found at all
                      // -- try again *with* clearing, if we didn't already
                      if (!mayClear) return skipAtomic(doc, pos, bias, true);
                      // Otherwise, turn off editing until further notice, and return the start of the doc
                      doc.cantEdit = true;
                      return Pos(doc.first, 0);
                    }
                    flipped = true;newPos = pos;dir = -dir;
                  }
                }
                curPos = newPos;
                continue search;
              }
            }
          }
          return curPos;
        }
      }

      // SCROLLING

      function scrollCursorIntoView(cm) {
        var coords = scrollPosIntoView(cm, cm.doc.sel.head, null, cm.options.cursorScrollMargin);
        if (!cm.state.focused) return;
        var display = cm.display,
            box = getRect(display.sizer),
            doScroll = null;
        if (coords.top + box.top < 0) doScroll = true;else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
        if (doScroll != null && !phantom) {
          var hidden = display.cursor.style.display == "none";
          if (hidden) {
            display.cursor.style.display = "";
            display.cursor.style.left = coords.left + "px";
            display.cursor.style.top = coords.top - display.viewOffset + "px";
          }
          display.cursor.scrollIntoView(doScroll);
          if (hidden) display.cursor.style.display = "none";
        }
      }

      function scrollPosIntoView(cm, pos, end, margin) {
        if (margin == null) margin = 0;
        for (;;) {
          var changed = false,
              coords = cursorCoords(cm, pos);
          var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
          var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left), Math.min(coords.top, endCoords.top) - margin, Math.max(coords.left, endCoords.left), Math.max(coords.bottom, endCoords.bottom) + margin);
          var startTop = cm.doc.scrollTop,
              startLeft = cm.doc.scrollLeft;
          if (scrollPos.scrollTop != null) {
            setScrollTop(cm, scrollPos.scrollTop);
            if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
          }
          if (scrollPos.scrollLeft != null) {
            setScrollLeft(cm, scrollPos.scrollLeft);
            if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
          }
          if (!changed) return coords;
        }
      }

      function scrollIntoView(cm, x1, y1, x2, y2) {
        var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
        if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
        if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
      }

      function calculateScrollPos(cm, x1, y1, x2, y2) {
        var display = cm.display,
            snapMargin = textHeight(cm.display);
        if (y1 < 0) y1 = 0;
        var screen = display.scroller.clientHeight - scrollerCutOff,
            screentop = display.scroller.scrollTop,
            result = {};
        var docBottom = cm.doc.height + paddingVert(display);
        var atTop = y1 < snapMargin,
            atBottom = y2 > docBottom - snapMargin;
        if (y1 < screentop) {
          result.scrollTop = atTop ? 0 : y1;
        } else if (y2 > screentop + screen) {
          var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
          if (newTop != screentop) result.scrollTop = newTop;
        }

        var screenw = display.scroller.clientWidth - scrollerCutOff,
            screenleft = display.scroller.scrollLeft;
        x1 += display.gutters.offsetWidth;x2 += display.gutters.offsetWidth;
        var gutterw = display.gutters.offsetWidth;
        var atLeft = x1 < gutterw + 10;
        if (x1 < screenleft + gutterw || atLeft) {
          if (atLeft) x1 = 0;
          result.scrollLeft = Math.max(0, x1 - 10 - gutterw);
        } else if (x2 > screenw + screenleft - 3) {
          result.scrollLeft = x2 + 10 - screenw;
        }
        return result;
      }

      function updateScrollPos(cm, left, top) {
        cm.curOp.updateScrollPos = { scrollLeft: left == null ? cm.doc.scrollLeft : left,
          scrollTop: top == null ? cm.doc.scrollTop : top };
      }

      function addToScrollPos(cm, left, top) {
        var pos = cm.curOp.updateScrollPos || (cm.curOp.updateScrollPos = { scrollLeft: cm.doc.scrollLeft, scrollTop: cm.doc.scrollTop });
        var scroll = cm.display.scroller;
        pos.scrollTop = Math.max(0, Math.min(scroll.scrollHeight - scroll.clientHeight, pos.scrollTop + top));
        pos.scrollLeft = Math.max(0, Math.min(scroll.scrollWidth - scroll.clientWidth, pos.scrollLeft + left));
      }

      // API UTILITIES

      function indentLine(cm, n, how, aggressive) {
        var doc = cm.doc;
        if (how == null) how = "add";
        if (how == "smart") {
          if (!cm.doc.mode.indent) how = "prev";else var state = getStateBefore(cm, n);
        }

        var tabSize = cm.options.tabSize;
        var line = getLine(doc, n),
            curSpace = countColumn(line.text, null, tabSize);
        var curSpaceString = line.text.match(/^\s*/)[0],
            indentation;
        if (how == "smart") {
          indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
          if (indentation == Pass) {
            if (!aggressive) return;
            how = "prev";
          }
        }
        if (how == "prev") {
          if (n > doc.first) indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);else indentation = 0;
        } else if (how == "add") {
          indentation = curSpace + cm.options.indentUnit;
        } else if (how == "subtract") {
          indentation = curSpace - cm.options.indentUnit;
        } else if (typeof how == "number") {
          indentation = curSpace + how;
        }
        indentation = Math.max(0, indentation);

        var indentString = "",
            pos = 0;
        if (cm.options.indentWithTabs) for (var i = Math.floor(indentation / tabSize); i; --i) {
          pos += tabSize;indentString += "\t";
        }
        if (pos < indentation) indentString += spaceStr(indentation - pos);

        if (indentString != curSpaceString) replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");else if (doc.sel.head.line == n && doc.sel.head.ch < curSpaceString.length) setSelection(doc, Pos(n, curSpaceString.length), Pos(n, curSpaceString.length), 1);
        line.stateAfter = null;
      }

      function changeLine(cm, handle, op) {
        var no = handle,
            line = handle,
            doc = cm.doc;
        if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));else no = lineNo(handle);
        if (no == null) return null;
        if (op(line, no)) regChange(cm, no, no + 1);else return null;
        return line;
      }

      function findPosH(doc, pos, dir, unit, visually) {
        var line = pos.line,
            ch = pos.ch,
            origDir = dir;
        var lineObj = getLine(doc, line);
        var possible = true;
        function findNextLine() {
          var l = line + dir;
          if (l < doc.first || l >= doc.first + doc.size) return possible = false;
          line = l;
          return lineObj = getLine(doc, l);
        }
        function moveOnce(boundToLine) {
          var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
          if (next == null) {
            if (!boundToLine && findNextLine()) {
              if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);else ch = dir < 0 ? lineObj.text.length : 0;
            } else return possible = false;
          } else ch = next;
          return true;
        }

        if (unit == "char") moveOnce();else if (unit == "column") moveOnce(true);else if (unit == "word" || unit == "group") {
          var sawType = null,
              group = unit == "group";
          for (var first = true;; first = false) {
            if (dir < 0 && !moveOnce(!first)) break;
            var cur = lineObj.text.charAt(ch) || "\n";
            var type = isWordChar(cur) ? "w" : !group ? null : /\s/.test(cur) ? null : "p";
            if (sawType && sawType != type) {
              if (dir < 0) {
                dir = 1;moveOnce();
              }
              break;
            }
            if (type) sawType = type;
            if (dir > 0 && !moveOnce(!first)) break;
          }
        }
        var result = skipAtomic(doc, Pos(line, ch), origDir, true);
        if (!possible) result.hitSide = true;
        return result;
      }

      function findPosV(cm, pos, dir, unit) {
        var doc = cm.doc,
            x = pos.left,
            y;
        if (unit == "page") {
          var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
          y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));
        } else if (unit == "line") {
          y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
        }
        for (;;) {
          var target = coordsChar(cm, x, y);
          if (!target.outside) break;
          if (dir < 0 ? y <= 0 : y >= doc.height) {
            target.hitSide = true;break;
          }
          y += dir * 5;
        }
        return target;
      }

      function findWordAt(line, pos) {
        var start = pos.ch,
            end = pos.ch;
        if (line) {
          if ((pos.xRel < 0 || end == line.length) && start) --start;else ++end;
          var startChar = line.charAt(start);
          var check = isWordChar(startChar) ? isWordChar : /\s/.test(startChar) ? function (ch) {
            return (/\s/.test(ch)
            );
          } : function (ch) {
            return !/\s/.test(ch) && !isWordChar(ch);
          };
          while (start > 0 && check(line.charAt(start - 1))) --start;
          while (end < line.length && check(line.charAt(end))) ++end;
        }
        return { from: Pos(pos.line, start), to: Pos(pos.line, end) };
      }

      function selectLine(cm, line) {
        extendSelection(cm.doc, Pos(line, 0), clipPos(cm.doc, Pos(line + 1, 0)));
      }

      // PROTOTYPE

      // The publicly visible API. Note that operation(null, f) means
      // 'wrap f in an operation, performed on its `this` parameter'

      CodeMirror.prototype = {
        constructor: CodeMirror,
        focus: function () {
          window.focus();focusInput(this);fastPoll(this);
        },

        setOption: function (option, value) {
          var options = this.options,
              old = options[option];
          if (options[option] == value && option != "mode") return;
          options[option] = value;
          if (optionHandlers.hasOwnProperty(option)) operation(this, optionHandlers[option])(this, value, old);
        },

        getOption: function (option) {
          return this.options[option];
        },
        getDoc: function () {
          return this.doc;
        },

        addKeyMap: function (map, bottom) {
          this.state.keyMaps[bottom ? "push" : "unshift"](map);
        },
        removeKeyMap: function (map) {
          var maps = this.state.keyMaps;
          for (var i = 0; i < maps.length; ++i) if (maps[i] == map || typeof maps[i] != "string" && maps[i].name == map) {
            maps.splice(i, 1);
            return true;
          }
        },

        addOverlay: operation(null, function (spec, options) {
          var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
          if (mode.startState) throw new Error("Overlays may not be stateful.");
          this.state.overlays.push({ mode: mode, modeSpec: spec, opaque: options && options.opaque });
          this.state.modeGen++;
          regChange(this);
        }),
        removeOverlay: operation(null, function (spec) {
          var overlays = this.state.overlays;
          for (var i = 0; i < overlays.length; ++i) {
            var cur = overlays[i].modeSpec;
            if (cur == spec || typeof spec == "string" && cur.name == spec) {
              overlays.splice(i, 1);
              this.state.modeGen++;
              regChange(this);
              return;
            }
          }
        }),

        indentLine: operation(null, function (n, dir, aggressive) {
          if (typeof dir != "string" && typeof dir != "number") {
            if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";else dir = dir ? "add" : "subtract";
          }
          if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
        }),
        indentSelection: operation(null, function (how) {
          var sel = this.doc.sel;
          if (posEq(sel.from, sel.to)) return indentLine(this, sel.from.line, how);
          var e = sel.to.line - (sel.to.ch ? 0 : 1);
          for (var i = sel.from.line; i <= e; ++i) indentLine(this, i, how);
        }),

        // Fetch the parser token for a given character. Useful for hacks
        // that want to inspect the mode state (say, for completion).
        getTokenAt: function (pos, precise) {
          var doc = this.doc;
          pos = clipPos(doc, pos);
          var state = getStateBefore(this, pos.line, precise),
              mode = this.doc.mode;
          var line = getLine(doc, pos.line);
          var stream = new StringStream(line.text, this.options.tabSize);
          while (stream.pos < pos.ch && !stream.eol()) {
            stream.start = stream.pos;
            var style = mode.token(stream, state);
          }
          return { start: stream.start,
            end: stream.pos,
            string: stream.current(),
            className: style || null, // Deprecated, use 'type' instead
            type: style || null,
            state: state };
        },

        getTokenTypeAt: function (pos) {
          pos = clipPos(this.doc, pos);
          var styles = getLineStyles(this, getLine(this.doc, pos.line));
          var before = 0,
              after = (styles.length - 1) / 2,
              ch = pos.ch;
          if (ch == 0) return styles[2];
          for (;;) {
            var mid = before + after >> 1;
            if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;else if (styles[mid * 2 + 1] < ch) before = mid + 1;else return styles[mid * 2 + 2];
          }
        },

        getModeAt: function (pos) {
          var mode = this.doc.mode;
          if (!mode.innerMode) return mode;
          return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
        },

        getHelper: function (pos, type) {
          if (!helpers.hasOwnProperty(type)) return;
          var help = helpers[type],
              mode = this.getModeAt(pos);
          return mode[type] && help[mode[type]] || mode.helperType && help[mode.helperType] || help[mode.name];
        },

        getStateAfter: function (line, precise) {
          var doc = this.doc;
          line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
          return getStateBefore(this, line + 1, precise);
        },

        cursorCoords: function (start, mode) {
          var pos,
              sel = this.doc.sel;
          if (start == null) pos = sel.head;else if (typeof start == "object") pos = clipPos(this.doc, start);else pos = start ? sel.from : sel.to;
          return cursorCoords(this, pos, mode || "page");
        },

        charCoords: function (pos, mode) {
          return charCoords(this, clipPos(this.doc, pos), mode || "page");
        },

        coordsChar: function (coords, mode) {
          coords = fromCoordSystem(this, coords, mode || "page");
          return coordsChar(this, coords.left, coords.top);
        },

        lineAtHeight: function (height, mode) {
          height = fromCoordSystem(this, { top: height, left: 0 }, mode || "page").top;
          return lineAtHeight(this.doc, height + this.display.viewOffset);
        },
        heightAtLine: function (line, mode) {
          var end = false,
              last = this.doc.first + this.doc.size - 1;
          if (line < this.doc.first) line = this.doc.first;else if (line > last) {
            line = last;end = true;
          }
          var lineObj = getLine(this.doc, line);
          return intoCoordSystem(this, getLine(this.doc, line), { top: 0, left: 0 }, mode || "page").top + (end ? lineObj.height : 0);
        },

        defaultTextHeight: function () {
          return textHeight(this.display);
        },
        defaultCharWidth: function () {
          return charWidth(this.display);
        },

        setGutterMarker: operation(null, function (line, gutterID, value) {
          return changeLine(this, line, function (line) {
            var markers = line.gutterMarkers || (line.gutterMarkers = {});
            markers[gutterID] = value;
            if (!value && isEmpty(markers)) line.gutterMarkers = null;
            return true;
          });
        }),

        clearGutter: operation(null, function (gutterID) {
          var cm = this,
              doc = cm.doc,
              i = doc.first;
          doc.iter(function (line) {
            if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
              line.gutterMarkers[gutterID] = null;
              regChange(cm, i, i + 1);
              if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
            }
            ++i;
          });
        }),

        addLineClass: operation(null, function (handle, where, cls) {
          return changeLine(this, handle, function (line) {
            var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";
            if (!line[prop]) line[prop] = cls;else if (new RegExp("(?:^|\\s)" + cls + "(?:$|\\s)").test(line[prop])) return false;else line[prop] += " " + cls;
            return true;
          });
        }),

        removeLineClass: operation(null, function (handle, where, cls) {
          return changeLine(this, handle, function (line) {
            var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";
            var cur = line[prop];
            if (!cur) return false;else if (cls == null) line[prop] = null;else {
              var found = cur.match(new RegExp("(?:^|\\s+)" + cls + "(?:$|\\s+)"));
              if (!found) return false;
              var end = found.index + found[0].length;
              line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
            }
            return true;
          });
        }),

        addLineWidget: operation(null, function (handle, node, options) {
          return addLineWidget(this, handle, node, options);
        }),

        removeLineWidget: function (widget) {
          widget.clear();
        },

        lineInfo: function (line) {
          if (typeof line == "number") {
            if (!isLine(this.doc, line)) return null;
            var n = line;
            line = getLine(this.doc, line);
            if (!line) return null;
          } else {
            var n = lineNo(line);
            if (n == null) return null;
          }
          return { line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
            widgets: line.widgets };
        },

        getViewport: function () {
          return { from: this.display.showingFrom, to: this.display.showingTo };
        },

        addWidget: function (pos, node, scroll, vert, horiz) {
          var display = this.display;
          pos = cursorCoords(this, clipPos(this.doc, pos));
          var top = pos.bottom,
              left = pos.left;
          node.style.position = "absolute";
          display.sizer.appendChild(node);
          if (vert == "over") {
            top = pos.top;
          } else if (vert == "above" || vert == "near") {
            var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
                hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
            // Default to positioning above (if specified and possible); otherwise default to positioning below
            if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) top = pos.top - node.offsetHeight;else if (pos.bottom + node.offsetHeight <= vspace) top = pos.bottom;
            if (left + node.offsetWidth > hspace) left = hspace - node.offsetWidth;
          }
          node.style.top = top + "px";
          node.style.left = node.style.right = "";
          if (horiz == "right") {
            left = display.sizer.clientWidth - node.offsetWidth;
            node.style.right = "0px";
          } else {
            if (horiz == "left") left = 0;else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
            node.style.left = left + "px";
          }
          if (scroll) scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
        },

        triggerOnKeyDown: operation(null, onKeyDown),

        execCommand: function (cmd) {
          return commands[cmd](this);
        },

        findPosH: function (from, amount, unit, visually) {
          var dir = 1;
          if (amount < 0) {
            dir = -1;amount = -amount;
          }
          for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
            cur = findPosH(this.doc, cur, dir, unit, visually);
            if (cur.hitSide) break;
          }
          return cur;
        },

        moveH: operation(null, function (dir, unit) {
          var sel = this.doc.sel,
              pos;
          if (sel.shift || sel.extend || posEq(sel.from, sel.to)) pos = findPosH(this.doc, sel.head, dir, unit, this.options.rtlMoveVisually);else pos = dir < 0 ? sel.from : sel.to;
          extendSelection(this.doc, pos, pos, dir);
        }),

        deleteH: operation(null, function (dir, unit) {
          var sel = this.doc.sel;
          if (!posEq(sel.from, sel.to)) replaceRange(this.doc, "", sel.from, sel.to, "+delete");else replaceRange(this.doc, "", sel.from, findPosH(this.doc, sel.head, dir, unit, false), "+delete");
          this.curOp.userSelChange = true;
        }),

        findPosV: function (from, amount, unit, goalColumn) {
          var dir = 1,
              x = goalColumn;
          if (amount < 0) {
            dir = -1;amount = -amount;
          }
          for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
            var coords = cursorCoords(this, cur, "div");
            if (x == null) x = coords.left;else coords.left = x;
            cur = findPosV(this, coords, dir, unit);
            if (cur.hitSide) break;
          }
          return cur;
        },

        moveV: operation(null, function (dir, unit) {
          var sel = this.doc.sel;
          var pos = cursorCoords(this, sel.head, "div");
          if (sel.goalColumn != null) pos.left = sel.goalColumn;
          var target = findPosV(this, pos, dir, unit);

          if (unit == "page") addToScrollPos(this, 0, charCoords(this, target, "div").top - pos.top);
          extendSelection(this.doc, target, target, dir);
          sel.goalColumn = pos.left;
        }),

        toggleOverwrite: function (value) {
          if (value != null && value == this.state.overwrite) return;
          if (this.state.overwrite = !this.state.overwrite) this.display.cursor.className += " CodeMirror-overwrite";else this.display.cursor.className = this.display.cursor.className.replace(" CodeMirror-overwrite", "");
        },
        hasFocus: function () {
          return this.state.focused;
        },

        scrollTo: operation(null, function (x, y) {
          updateScrollPos(this, x, y);
        }),
        getScrollInfo: function () {
          var scroller = this.display.scroller,
              co = scrollerCutOff;
          return { left: scroller.scrollLeft, top: scroller.scrollTop,
            height: scroller.scrollHeight - co, width: scroller.scrollWidth - co,
            clientHeight: scroller.clientHeight - co, clientWidth: scroller.clientWidth - co };
        },

        scrollIntoView: operation(null, function (range, margin) {
          if (range == null) range = { from: this.doc.sel.head, to: null };else if (typeof range == "number") range = { from: Pos(range, 0), to: null };else if (range.from == null) range = { from: range, to: null };
          if (!range.to) range.to = range.from;
          if (!margin) margin = 0;

          var coords = range;
          if (range.from.line != null) {
            this.curOp.scrollToPos = { from: range.from, to: range.to, margin: margin };
            coords = { from: cursorCoords(this, range.from),
              to: cursorCoords(this, range.to) };
          }
          var sPos = calculateScrollPos(this, Math.min(coords.from.left, coords.to.left), Math.min(coords.from.top, coords.to.top) - margin, Math.max(coords.from.right, coords.to.right), Math.max(coords.from.bottom, coords.to.bottom) + margin);
          updateScrollPos(this, sPos.scrollLeft, sPos.scrollTop);
        }),

        setSize: operation(null, function (width, height) {
          function interpret(val) {
            return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
          }
          if (width != null) this.display.wrapper.style.width = interpret(width);
          if (height != null) this.display.wrapper.style.height = interpret(height);
          if (this.options.lineWrapping) this.display.measureLineCache.length = this.display.measureLineCachePos = 0;
          this.curOp.forceUpdate = true;
        }),

        operation: function (f) {
          return runInOp(this, f);
        },

        refresh: operation(null, function () {
          var badHeight = this.display.cachedTextHeight == null;
          clearCaches(this);
          updateScrollPos(this, this.doc.scrollLeft, this.doc.scrollTop);
          regChange(this);
          if (badHeight) estimateLineHeights(this);
        }),

        swapDoc: operation(null, function (doc) {
          var old = this.doc;
          old.cm = null;
          attachDoc(this, doc);
          clearCaches(this);
          resetInput(this, true);
          updateScrollPos(this, doc.scrollLeft, doc.scrollTop);
          signalLater(this, "swapDoc", this, old);
          return old;
        }),

        getInputField: function () {
          return this.display.input;
        },
        getWrapperElement: function () {
          return this.display.wrapper;
        },
        getScrollerElement: function () {
          return this.display.scroller;
        },
        getGutterElement: function () {
          return this.display.gutters;
        }
      };
      eventMixin(CodeMirror);

      // OPTION DEFAULTS

      var optionHandlers = CodeMirror.optionHandlers = {};

      // The default configuration options.
      var defaults = CodeMirror.defaults = {};

      function option(name, deflt, handle, notOnInit) {
        CodeMirror.defaults[name] = deflt;
        if (handle) optionHandlers[name] = notOnInit ? function (cm, val, old) {
          if (old != Init) handle(cm, val, old);
        } : handle;
      }

      var Init = CodeMirror.Init = { toString: function () {
          return "CodeMirror.Init";
        } };

      // These two are, on init, called from the constructor because they
      // have to be initialized before the editor can start at all.
      option("value", "", function (cm, val) {
        cm.setValue(val);
      }, true);
      option("mode", null, function (cm, val) {
        cm.doc.modeOption = val;
        loadMode(cm);
      }, true);

      option("indentUnit", 2, loadMode, true);
      option("indentWithTabs", false);
      option("smartIndent", true);
      option("tabSize", 4, function (cm) {
        loadMode(cm);
        clearCaches(cm);
        regChange(cm);
      }, true);
      option("specialChars", /[\t\u0000-\u0019\u00ad\u200b\u2028\u2029\ufeff]/g, function (cm, val) {
        cm.options.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
        cm.refresh();
      }, true);
      option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) {
        cm.refresh();
      }, true);
      option("electricChars", true);
      option("rtlMoveVisually", !windows);
      option("wholeLineUpdateBefore", true);

      option("theme", "default", function (cm) {
        themeChanged(cm);
        guttersChanged(cm);
      }, true);
      option("keyMap", "default", keyMapChanged);
      option("extraKeys", null);

      option("onKeyEvent", null);
      option("onDragEvent", null);

      option("lineWrapping", false, wrappingChanged, true);
      option("gutters", [], function (cm) {
        setGuttersForLineNumbers(cm.options);
        guttersChanged(cm);
      }, true);
      option("fixedGutter", true, function (cm, val) {
        cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
        cm.refresh();
      }, true);
      option("coverGutterNextToScrollbar", false, updateScrollbars, true);
      option("lineNumbers", false, function (cm) {
        setGuttersForLineNumbers(cm.options);
        guttersChanged(cm);
      }, true);
      option("firstLineNumber", 1, guttersChanged, true);
      option("lineNumberFormatter", function (integer) {
        return integer;
      }, guttersChanged, true);
      option("showCursorWhenSelecting", false, updateSelection, true);

      option("resetSelectionOnContextMenu", true);

      option("readOnly", false, function (cm, val) {
        if (val == "nocursor") {
          onBlur(cm);
          cm.display.input.blur();
          cm.display.disabled = true;
        } else {
          cm.display.disabled = false;
          if (!val) resetInput(cm, true);
        }
      });
      option("dragDrop", true);

      option("cursorBlinkRate", 530);
      option("cursorScrollMargin", 0);
      option("cursorHeight", 1);
      option("workTime", 100);
      option("workDelay", 100);
      option("flattenSpans", true);
      option("pollInterval", 100);
      option("undoDepth", 40, function (cm, val) {
        cm.doc.history.undoDepth = val;
      });
      option("historyEventDelay", 500);
      option("viewportMargin", 10, function (cm) {
        cm.refresh();
      }, true);
      option("maxHighlightLength", 10000, function (cm) {
        loadMode(cm);cm.refresh();
      }, true);
      option("crudeMeasuringFrom", 10000);
      option("moveInputWithCursor", true, function (cm, val) {
        if (!val) cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;
      });

      option("tabindex", null, function (cm, val) {
        cm.display.input.tabIndex = val || "";
      });
      option("autofocus", null);

      // MODE DEFINITION AND QUERYING

      // Known modes, by name and by MIME
      var modes = CodeMirror.modes = {},
          mimeModes = CodeMirror.mimeModes = {};

      CodeMirror.defineMode = function (name, mode) {
        if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
        if (arguments.length > 2) {
          mode.dependencies = [];
          for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i]);
        }
        modes[name] = mode;
      };

      CodeMirror.defineMIME = function (mime, spec) {
        mimeModes[mime] = spec;
      };

      CodeMirror.resolveMode = function (spec) {
        if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
          spec = mimeModes[spec];
        } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
          var found = mimeModes[spec.name];
          spec = createObj(found, spec);
          spec.name = found.name;
        } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
          return CodeMirror.resolveMode("application/xml");
        }
        if (typeof spec == "string") return { name: spec };else return spec || { name: "null" };
      };

      CodeMirror.getMode = function (options, spec) {
        var spec = CodeMirror.resolveMode(spec);
        var mfactory = modes[spec.name];
        if (!mfactory) return CodeMirror.getMode(options, "text/plain");
        var modeObj = mfactory(options, spec);
        if (modeExtensions.hasOwnProperty(spec.name)) {
          var exts = modeExtensions[spec.name];
          for (var prop in exts) {
            if (!exts.hasOwnProperty(prop)) continue;
            if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
            modeObj[prop] = exts[prop];
          }
        }
        modeObj.name = spec.name;

        return modeObj;
      };

      CodeMirror.defineMode("null", function () {
        return { token: function (stream) {
            stream.skipToEnd();
          } };
      });
      CodeMirror.defineMIME("text/plain", "null");

      var modeExtensions = CodeMirror.modeExtensions = {};
      CodeMirror.extendMode = function (mode, properties) {
        var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
        copyObj(properties, exts);
      };

      // EXTENSIONS

      CodeMirror.defineExtension = function (name, func) {
        CodeMirror.prototype[name] = func;
      };
      CodeMirror.defineDocExtension = function (name, func) {
        Doc.prototype[name] = func;
      };
      CodeMirror.defineOption = option;

      var initHooks = [];
      CodeMirror.defineInitHook = function (f) {
        initHooks.push(f);
      };

      var helpers = CodeMirror.helpers = {};
      CodeMirror.registerHelper = function (type, name, value) {
        if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {};
        helpers[type][name] = value;
      };

      // UTILITIES

      CodeMirror.isWordChar = isWordChar;

      // MODE STATE HANDLING

      // Utility functions for working with state. Exported because modes
      // sometimes need to do this.
      function copyState(mode, state) {
        if (state === true) return state;
        if (mode.copyState) return mode.copyState(state);
        var nstate = {};
        for (var n in state) {
          var val = state[n];
          if (val instanceof Array) val = val.concat([]);
          nstate[n] = val;
        }
        return nstate;
      }
      CodeMirror.copyState = copyState;

      function startState(mode, a1, a2) {
        return mode.startState ? mode.startState(a1, a2) : true;
      }
      CodeMirror.startState = startState;

      CodeMirror.innerMode = function (mode, state) {
        while (mode.innerMode) {
          var info = mode.innerMode(state);
          if (!info || info.mode == mode) break;
          state = info.state;
          mode = info.mode;
        }
        return info || { mode: mode, state: state };
      };

      // STANDARD COMMANDS

      var commands = CodeMirror.commands = {
        selectAll: function (cm) {
          cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()));
        },
        killLine: function (cm) {
          var from = cm.getCursor(true),
              to = cm.getCursor(false),
              sel = !posEq(from, to);
          if (!sel && cm.getLine(from.line).length == from.ch) cm.replaceRange("", from, Pos(from.line + 1, 0), "+delete");else cm.replaceRange("", from, sel ? to : Pos(from.line), "+delete");
        },
        deleteLine: function (cm) {
          var l = cm.getCursor().line;
          cm.replaceRange("", Pos(l, 0), Pos(l), "+delete");
        },
        delLineLeft: function (cm) {
          var cur = cm.getCursor();
          cm.replaceRange("", Pos(cur.line, 0), cur, "+delete");
        },
        undo: function (cm) {
          cm.undo();
        },
        redo: function (cm) {
          cm.redo();
        },
        goDocStart: function (cm) {
          cm.extendSelection(Pos(cm.firstLine(), 0));
        },
        goDocEnd: function (cm) {
          cm.extendSelection(Pos(cm.lastLine()));
        },
        goLineStart: function (cm) {
          cm.extendSelection(lineStart(cm, cm.getCursor().line));
        },
        goLineStartSmart: function (cm) {
          var cur = cm.getCursor(),
              start = lineStart(cm, cur.line);
          var line = cm.getLineHandle(start.line);
          var order = getOrder(line);
          if (!order || order[0].level == 0) {
            var firstNonWS = Math.max(0, line.text.search(/\S/));
            var inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;
            cm.extendSelection(Pos(start.line, inWS ? 0 : firstNonWS));
          } else cm.extendSelection(start);
        },
        goLineEnd: function (cm) {
          cm.extendSelection(lineEnd(cm, cm.getCursor().line));
        },
        goLineRight: function (cm) {
          var top = cm.charCoords(cm.getCursor(), "div").top + 5;
          cm.extendSelection(cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top }, "div"));
        },
        goLineLeft: function (cm) {
          var top = cm.charCoords(cm.getCursor(), "div").top + 5;
          cm.extendSelection(cm.coordsChar({ left: 0, top: top }, "div"));
        },
        goLineUp: function (cm) {
          cm.moveV(-1, "line");
        },
        goLineDown: function (cm) {
          cm.moveV(1, "line");
        },
        goPageUp: function (cm) {
          cm.moveV(-1, "page");
        },
        goPageDown: function (cm) {
          cm.moveV(1, "page");
        },
        goCharLeft: function (cm) {
          cm.moveH(-1, "char");
        },
        goCharRight: function (cm) {
          cm.moveH(1, "char");
        },
        goColumnLeft: function (cm) {
          cm.moveH(-1, "column");
        },
        goColumnRight: function (cm) {
          cm.moveH(1, "column");
        },
        goWordLeft: function (cm) {
          cm.moveH(-1, "word");
        },
        goGroupRight: function (cm) {
          cm.moveH(1, "group");
        },
        goGroupLeft: function (cm) {
          cm.moveH(-1, "group");
        },
        goWordRight: function (cm) {
          cm.moveH(1, "word");
        },
        delCharBefore: function (cm) {
          cm.deleteH(-1, "char");
        },
        delCharAfter: function (cm) {
          cm.deleteH(1, "char");
        },
        delWordBefore: function (cm) {
          cm.deleteH(-1, "word");
        },
        delWordAfter: function (cm) {
          cm.deleteH(1, "word");
        },
        delGroupBefore: function (cm) {
          cm.deleteH(-1, "group");
        },
        delGroupAfter: function (cm) {
          cm.deleteH(1, "group");
        },
        indentAuto: function (cm) {
          cm.indentSelection("smart");
        },
        indentMore: function (cm) {
          cm.indentSelection("add");
        },
        indentLess: function (cm) {
          cm.indentSelection("subtract");
        },
        insertTab: function (cm) {
          cm.replaceSelection("\t", "end", "+input");
        },
        defaultTab: function (cm) {
          if (cm.somethingSelected()) cm.indentSelection("add");else cm.replaceSelection("\t", "end", "+input");
        },
        transposeChars: function (cm) {
          var cur = cm.getCursor(),
              line = cm.getLine(cur.line);
          if (cur.ch > 0 && cur.ch < line.length - 1) cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1), Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));
        },
        newlineAndIndent: function (cm) {
          operation(cm, function () {
            cm.replaceSelection("\n", "end", "+input");
            cm.indentLine(cm.getCursor().line, null, true);
          })();
        },
        toggleOverwrite: function (cm) {
          cm.toggleOverwrite();
        }
      };

      // STANDARD KEYMAPS

      var keyMap = CodeMirror.keyMap = {};
      keyMap.basic = {
        "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
        "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
        "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
        "Tab": "defaultTab", "Shift-Tab": "indentAuto",
        "Enter": "newlineAndIndent", "Insert": "toggleOverwrite"
      };
      // Note that the save and find-related commands aren't defined by
      // default. Unknown commands are simply ignored.
      keyMap.pcDefault = {
        "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
        "Ctrl-Home": "goDocStart", "Alt-Up": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Down": "goDocEnd",
        "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
        "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
        "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
        "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
        fallthrough: "basic"
      };
      keyMap.macDefault = {
        "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
        "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
        "Alt-Right": "goGroupRight", "Cmd-Left": "goLineStart", "Cmd-Right": "goLineEnd", "Alt-Backspace": "delGroupBefore",
        "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
        "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
        "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delLineLeft",
        fallthrough: ["basic", "emacsy"]
      };
      keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;
      keyMap.emacsy = {
        "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
        "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
        "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
        "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"
      };

      // KEYMAP DISPATCH

      function getKeyMap(val) {
        if (typeof val == "string") return keyMap[val];else return val;
      }

      function lookupKey(name, maps, handle) {
        function lookup(map) {
          map = getKeyMap(map);
          var found = map[name];
          if (found === false) return "stop";
          if (found != null && handle(found)) return true;
          if (map.nofallthrough) return "stop";

          var fallthrough = map.fallthrough;
          if (fallthrough == null) return false;
          if (Object.prototype.toString.call(fallthrough) != "[object Array]") return lookup(fallthrough);
          for (var i = 0, e = fallthrough.length; i < e; ++i) {
            var done = lookup(fallthrough[i]);
            if (done) return done;
          }
          return false;
        }

        for (var i = 0; i < maps.length; ++i) {
          var done = lookup(maps[i]);
          if (done) return done != "stop";
        }
      }
      function isModifierKey(event) {
        var name = keyNames[event.keyCode];
        return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
      }
      function keyName(event, noShift) {
        if (opera && event.keyCode == 34 && event["char"]) return false;
        var name = keyNames[event.keyCode];
        if (name == null || event.altGraphKey) return false;
        if (event.altKey) name = "Alt-" + name;
        if (flipCtrlCmd ? event.metaKey : event.ctrlKey) name = "Ctrl-" + name;
        if (flipCtrlCmd ? event.ctrlKey : event.metaKey) name = "Cmd-" + name;
        if (!noShift && event.shiftKey) name = "Shift-" + name;
        return name;
      }
      CodeMirror.lookupKey = lookupKey;
      CodeMirror.isModifierKey = isModifierKey;
      CodeMirror.keyName = keyName;

      // FROMTEXTAREA

      CodeMirror.fromTextArea = function (textarea, options) {
        if (!options) options = {};
        options.value = textarea.value;
        if (!options.tabindex && textarea.tabindex) options.tabindex = textarea.tabindex;
        if (!options.placeholder && textarea.placeholder) options.placeholder = textarea.placeholder;
        // Set autofocus to true if this textarea is focused, or if it has
        // autofocus and no other element is focused.
        if (options.autofocus == null) {
          var hasFocus = document.body;
          // doc.activeElement occasionally throws on IE
          try {
            hasFocus = document.activeElement;
          } catch (e) {}
          options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
        }

        function save() {
          textarea.value = cm.getValue();
        }
        if (textarea.form) {
          on(textarea.form, "submit", save);
          // Deplorable hack to make the submit method do the right thing.
          if (!options.leaveSubmitMethodAlone) {
            var form = textarea.form,
                realSubmit = form.submit;
            try {
              var wrappedSubmit = form.submit = function () {
                save();
                form.submit = realSubmit;
                form.submit();
                form.submit = wrappedSubmit;
              };
            } catch (e) {}
          }
        }

        textarea.style.display = "none";
        var cm = CodeMirror(function (node) {
          textarea.parentNode.insertBefore(node, textarea.nextSibling);
        }, options);
        cm.save = save;
        cm.getTextArea = function () {
          return textarea;
        };
        cm.toTextArea = function () {
          save();
          textarea.parentNode.removeChild(cm.getWrapperElement());
          textarea.style.display = "";
          if (textarea.form) {
            off(textarea.form, "submit", save);
            if (typeof textarea.form.submit == "function") textarea.form.submit = realSubmit;
          }
        };
        return cm;
      };

      // STRING STREAM

      // Fed to the mode parsers, provides helper functions to make
      // parsers more succinct.

      // The character stream used by a mode's parser.
      function StringStream(string, tabSize) {
        this.pos = this.start = 0;
        this.string = string;
        this.tabSize = tabSize || 8;
        this.lastColumnPos = this.lastColumnValue = 0;
      }

      StringStream.prototype = {
        eol: function () {
          return this.pos >= this.string.length;
        },
        sol: function () {
          return this.pos == 0;
        },
        peek: function () {
          return this.string.charAt(this.pos) || undefined;
        },
        next: function () {
          if (this.pos < this.string.length) return this.string.charAt(this.pos++);
        },
        eat: function (match) {
          var ch = this.string.charAt(this.pos);
          if (typeof match == "string") var ok = ch == match;else var ok = ch && (match.test ? match.test(ch) : match(ch));
          if (ok) {
            ++this.pos;return ch;
          }
        },
        eatWhile: function (match) {
          var start = this.pos;
          while (this.eat(match)) {}
          return this.pos > start;
        },
        eatSpace: function () {
          var start = this.pos;
          while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
          return this.pos > start;
        },
        skipToEnd: function () {
          this.pos = this.string.length;
        },
        skipTo: function (ch) {
          var found = this.string.indexOf(ch, this.pos);
          if (found > -1) {
            this.pos = found;return true;
          }
        },
        backUp: function (n) {
          this.pos -= n;
        },
        column: function () {
          if (this.lastColumnPos < this.start) {
            this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
            this.lastColumnPos = this.start;
          }
          return this.lastColumnValue;
        },
        indentation: function () {
          return countColumn(this.string, null, this.tabSize);
        },
        match: function (pattern, consume, caseInsensitive) {
          if (typeof pattern == "string") {
            var cased = function (str) {
              return caseInsensitive ? str.toLowerCase() : str;
            };
            var substr = this.string.substr(this.pos, pattern.length);
            if (cased(substr) == cased(pattern)) {
              if (consume !== false) this.pos += pattern.length;
              return true;
            }
          } else {
            var match = this.string.slice(this.pos).match(pattern);
            if (match && match.index > 0) return null;
            if (match && consume !== false) this.pos += match[0].length;
            return match;
          }
        },
        current: function () {
          return this.string.slice(this.start, this.pos);
        }
      };
      CodeMirror.StringStream = StringStream;

      // TEXTMARKERS

      function TextMarker(doc, type) {
        this.lines = [];
        this.type = type;
        this.doc = doc;
      }
      CodeMirror.TextMarker = TextMarker;
      eventMixin(TextMarker);

      TextMarker.prototype.clear = function () {
        if (this.explicitlyCleared) return;
        var cm = this.doc.cm,
            withOp = cm && !cm.curOp;
        if (withOp) startOperation(cm);
        if (hasHandler(this, "clear")) {
          var found = this.find();
          if (found) signalLater(this, "clear", found.from, found.to);
        }
        var min = null,
            max = null;
        for (var i = 0; i < this.lines.length; ++i) {
          var line = this.lines[i];
          var span = getMarkedSpanFor(line.markedSpans, this);
          if (span.to != null) max = lineNo(line);
          line.markedSpans = removeMarkedSpan(line.markedSpans, span);
          if (span.from != null) min = lineNo(line);else if (this.collapsed && !lineIsHidden(this.doc, line) && cm) updateLineHeight(line, textHeight(cm.display));
        }
        if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
          var visual = visualLine(cm.doc, this.lines[i]),
              len = lineLength(cm.doc, visual);
          if (len > cm.display.maxLineLength) {
            cm.display.maxLine = visual;
            cm.display.maxLineLength = len;
            cm.display.maxLineChanged = true;
          }
        }

        if (min != null && cm) regChange(cm, min, max + 1);
        this.lines.length = 0;
        this.explicitlyCleared = true;
        if (this.atomic && this.doc.cantEdit) {
          this.doc.cantEdit = false;
          if (cm) reCheckSelection(cm);
        }
        if (withOp) endOperation(cm);
      };

      TextMarker.prototype.find = function () {
        var from, to;
        for (var i = 0; i < this.lines.length; ++i) {
          var line = this.lines[i];
          var span = getMarkedSpanFor(line.markedSpans, this);
          if (span.from != null || span.to != null) {
            var found = lineNo(line);
            if (span.from != null) from = Pos(found, span.from);
            if (span.to != null) to = Pos(found, span.to);
          }
        }
        if (this.type == "bookmark") return from;
        return from && { from: from, to: to };
      };

      TextMarker.prototype.changed = function () {
        var pos = this.find(),
            cm = this.doc.cm;
        if (!pos || !cm) return;
        if (this.type != "bookmark") pos = pos.from;
        var line = getLine(this.doc, pos.line);
        clearCachedMeasurement(cm, line);
        if (pos.line >= cm.display.showingFrom && pos.line < cm.display.showingTo) {
          for (var node = cm.display.lineDiv.firstChild; node; node = node.nextSibling) if (node.lineObj == line) {
            if (node.offsetHeight != line.height) updateLineHeight(line, node.offsetHeight);
            break;
          }
          runInOp(cm, function () {
            cm.curOp.selectionChanged = cm.curOp.forceUpdate = cm.curOp.updateMaxLine = true;
          });
        }
      };

      TextMarker.prototype.attachLine = function (line) {
        if (!this.lines.length && this.doc.cm) {
          var op = this.doc.cm.curOp;
          if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
        }
        this.lines.push(line);
      };
      TextMarker.prototype.detachLine = function (line) {
        this.lines.splice(indexOf(this.lines, line), 1);
        if (!this.lines.length && this.doc.cm) {
          var op = this.doc.cm.curOp;
          (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
        }
      };

      function markText(doc, from, to, options, type) {
        if (options && options.shared) return markTextShared(doc, from, to, options, type);
        if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);

        var marker = new TextMarker(doc, type);
        if (posLess(to, from) || posEq(from, to) && type == "range" && !(options.inclusiveLeft && options.inclusiveRight)) return marker;
        if (options) copyObj(options, marker);
        if (marker.replacedWith) {
          marker.collapsed = true;
          marker.replacedWith = elt("span", [marker.replacedWith], "CodeMirror-widget");
          if (!options.handleMouseEvents) marker.replacedWith.ignoreEvents = true;
        }
        if (marker.collapsed) sawCollapsedSpans = true;

        if (marker.addToHistory) addToHistory(doc, { from: from, to: to, origin: "markText" }, { head: doc.sel.head, anchor: doc.sel.anchor }, NaN);

        var curLine = from.line,
            size = 0,
            collapsedAtStart,
            collapsedAtEnd,
            cm = doc.cm,
            updateMaxLine;
        doc.iter(curLine, to.line + 1, function (line) {
          if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(doc, line) == cm.display.maxLine) updateMaxLine = true;
          var span = { from: null, to: null, marker: marker };
          size += line.text.length;
          if (curLine == from.line) {
            span.from = from.ch;size -= from.ch;
          }
          if (curLine == to.line) {
            span.to = to.ch;size -= line.text.length - to.ch;
          }
          if (marker.collapsed) {
            if (curLine == to.line) collapsedAtEnd = collapsedSpanAt(line, to.ch);
            if (curLine == from.line) collapsedAtStart = collapsedSpanAt(line, from.ch);else updateLineHeight(line, 0);
          }
          addMarkedSpan(line, span);
          ++curLine;
        });
        if (marker.collapsed) doc.iter(from.line, to.line + 1, function (line) {
          if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
        });

        if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function () {
          marker.clear();
        });

        if (marker.readOnly) {
          sawReadOnlySpans = true;
          if (doc.history.done.length || doc.history.undone.length) doc.clearHistory();
        }
        if (marker.collapsed) {
          if (collapsedAtStart != collapsedAtEnd) throw new Error("Inserting collapsed marker overlapping an existing one");
          marker.size = size;
          marker.atomic = true;
        }
        if (cm) {
          if (updateMaxLine) cm.curOp.updateMaxLine = true;
          if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.collapsed) regChange(cm, from.line, to.line + 1);
          if (marker.atomic) reCheckSelection(cm);
        }
        return marker;
      }

      // SHARED TEXTMARKERS

      function SharedTextMarker(markers, primary) {
        this.markers = markers;
        this.primary = primary;
        for (var i = 0, me = this; i < markers.length; ++i) {
          markers[i].parent = this;
          on(markers[i], "clear", function () {
            me.clear();
          });
        }
      }
      CodeMirror.SharedTextMarker = SharedTextMarker;
      eventMixin(SharedTextMarker);

      SharedTextMarker.prototype.clear = function () {
        if (this.explicitlyCleared) return;
        this.explicitlyCleared = true;
        for (var i = 0; i < this.markers.length; ++i) this.markers[i].clear();
        signalLater(this, "clear");
      };
      SharedTextMarker.prototype.find = function () {
        return this.primary.find();
      };

      function markTextShared(doc, from, to, options, type) {
        options = copyObj(options);
        options.shared = false;
        var markers = [markText(doc, from, to, options, type)],
            primary = markers[0];
        var widget = options.replacedWith;
        linkedDocs(doc, function (doc) {
          if (widget) options.replacedWith = widget.cloneNode(true);
          markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
          for (var i = 0; i < doc.linked.length; ++i) if (doc.linked[i].isParent) return;
          primary = lst(markers);
        });
        return new SharedTextMarker(markers, primary);
      }

      // TEXTMARKER SPANS

      function getMarkedSpanFor(spans, marker) {
        if (spans) for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];
          if (span.marker == marker) return span;
        }
      }
      function removeMarkedSpan(spans, span) {
        for (var r, i = 0; i < spans.length; ++i) if (spans[i] != span) (r || (r = [])).push(spans[i]);
        return r;
      }
      function addMarkedSpan(line, span) {
        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
        span.marker.attachLine(line);
      }

      function markedSpansBefore(old, startCh, isInsert) {
        if (old) for (var i = 0, nw; i < old.length; ++i) {
          var span = old[i],
              marker = span.marker;
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
          if (startsBefore || (marker.inclusiveLeft && marker.inclusiveRight || marker.type == "bookmark") && span.from == startCh && (!isInsert || !span.marker.insertLeft)) {
            var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
            (nw || (nw = [])).push({ from: span.from,
              to: endsAfter ? null : span.to,
              marker: marker });
          }
        }
        return nw;
      }

      function markedSpansAfter(old, endCh, isInsert) {
        if (old) for (var i = 0, nw; i < old.length; ++i) {
          var span = old[i],
              marker = span.marker;
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
          if (endsAfter || marker.type == "bookmark" && span.from == endCh && (!isInsert || span.marker.insertLeft)) {
            var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
            (nw || (nw = [])).push({ from: startsBefore ? null : span.from - endCh,
              to: span.to == null ? null : span.to - endCh,
              marker: marker });
          }
        }
        return nw;
      }

      function stretchSpansOverChange(doc, change) {
        var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
        var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
        if (!oldFirst && !oldLast) return null;

        var startCh = change.from.ch,
            endCh = change.to.ch,
            isInsert = posEq(change.from, change.to);
        // Get the spans that 'stick out' on both sides
        var first = markedSpansBefore(oldFirst, startCh, isInsert);
        var last = markedSpansAfter(oldLast, endCh, isInsert);

        // Next, merge those two ends
        var sameLine = change.text.length == 1,
            offset = lst(change.text).length + (sameLine ? startCh : 0);
        if (first) {
          // Fix up .to properties of first
          for (var i = 0; i < first.length; ++i) {
            var span = first[i];
            if (span.to == null) {
              var found = getMarkedSpanFor(last, span.marker);
              if (!found) span.to = startCh;else if (sameLine) span.to = found.to == null ? null : found.to + offset;
            }
          }
        }
        if (last) {
          // Fix up .from in last (or move them into first in case of sameLine)
          for (var i = 0; i < last.length; ++i) {
            var span = last[i];
            if (span.to != null) span.to += offset;
            if (span.from == null) {
              var found = getMarkedSpanFor(first, span.marker);
              if (!found) {
                span.from = offset;
                if (sameLine) (first || (first = [])).push(span);
              }
            } else {
              span.from += offset;
              if (sameLine) (first || (first = [])).push(span);
            }
          }
        }
        if (sameLine && first) {
          // Make sure we didn't create any zero-length spans
          for (var i = 0; i < first.length; ++i) if (first[i].from != null && first[i].from == first[i].to && first[i].marker.type != "bookmark") first.splice(i--, 1);
          if (!first.length) first = null;
        }

        var newMarkers = [first];
        if (!sameLine) {
          // Fill gap with whole-line-spans
          var gap = change.text.length - 2,
              gapMarkers;
          if (gap > 0 && first) for (var i = 0; i < first.length; ++i) if (first[i].to == null) (gapMarkers || (gapMarkers = [])).push({ from: null, to: null, marker: first[i].marker });
          for (var i = 0; i < gap; ++i) newMarkers.push(gapMarkers);
          newMarkers.push(last);
        }
        return newMarkers;
      }

      function mergeOldSpans(doc, change) {
        var old = getOldSpans(doc, change);
        var stretched = stretchSpansOverChange(doc, change);
        if (!old) return stretched;
        if (!stretched) return old;

        for (var i = 0; i < old.length; ++i) {
          var oldCur = old[i],
              stretchCur = stretched[i];
          if (oldCur && stretchCur) {
            spans: for (var j = 0; j < stretchCur.length; ++j) {
              var span = stretchCur[j];
              for (var k = 0; k < oldCur.length; ++k) if (oldCur[k].marker == span.marker) continue spans;
              oldCur.push(span);
            }
          } else if (stretchCur) {
            old[i] = stretchCur;
          }
        }
        return old;
      }

      function removeReadOnlyRanges(doc, from, to) {
        var markers = null;
        doc.iter(from.line, to.line + 1, function (line) {
          if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
            var mark = line.markedSpans[i].marker;
            if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) (markers || (markers = [])).push(mark);
          }
        });
        if (!markers) return null;
        var parts = [{ from: from, to: to }];
        for (var i = 0; i < markers.length; ++i) {
          var mk = markers[i],
              m = mk.find();
          for (var j = 0; j < parts.length; ++j) {
            var p = parts[j];
            if (posLess(p.to, m.from) || posLess(m.to, p.from)) continue;
            var newParts = [j, 1];
            if (posLess(p.from, m.from) || !mk.inclusiveLeft && posEq(p.from, m.from)) newParts.push({ from: p.from, to: m.from });
            if (posLess(m.to, p.to) || !mk.inclusiveRight && posEq(p.to, m.to)) newParts.push({ from: m.to, to: p.to });
            parts.splice.apply(parts, newParts);
            j += newParts.length - 1;
          }
        }
        return parts;
      }

      function collapsedSpanAt(line, ch) {
        var sps = sawCollapsedSpans && line.markedSpans,
            found;
        if (sps) for (var sp, i = 0; i < sps.length; ++i) {
          sp = sps[i];
          if (!sp.marker.collapsed) continue;
          if ((sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || found.width < sp.marker.width)) found = sp.marker;
        }
        return found;
      }
      function collapsedSpanAtStart(line) {
        return collapsedSpanAt(line, -1);
      }
      function collapsedSpanAtEnd(line) {
        return collapsedSpanAt(line, line.text.length + 1);
      }

      function visualLine(doc, line) {
        var merged;
        while (merged = collapsedSpanAtStart(line)) line = getLine(doc, merged.find().from.line);
        return line;
      }

      function lineIsHidden(doc, line) {
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps) for (var sp, i = 0; i < sps.length; ++i) {
          sp = sps[i];
          if (!sp.marker.collapsed) continue;
          if (sp.from == null) return true;
          if (sp.marker.replacedWith) continue;
          if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) return true;
        }
      }
      function lineIsHiddenInner(doc, line, span) {
        if (span.to == null) {
          var end = span.marker.find().to,
              endLine = getLine(doc, end.line);
          return lineIsHiddenInner(doc, endLine, getMarkedSpanFor(endLine.markedSpans, span.marker));
        }
        if (span.marker.inclusiveRight && span.to == line.text.length) return true;
        for (var sp, i = 0; i < line.markedSpans.length; ++i) {
          sp = line.markedSpans[i];
          if (sp.marker.collapsed && !sp.marker.replacedWith && sp.from == span.to && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) return true;
        }
      }

      function detachMarkedSpans(line) {
        var spans = line.markedSpans;
        if (!spans) return;
        for (var i = 0; i < spans.length; ++i) spans[i].marker.detachLine(line);
        line.markedSpans = null;
      }

      function attachMarkedSpans(line, spans) {
        if (!spans) return;
        for (var i = 0; i < spans.length; ++i) spans[i].marker.attachLine(line);
        line.markedSpans = spans;
      }

      // LINE WIDGETS

      var LineWidget = CodeMirror.LineWidget = function (cm, node, options) {
        if (options) for (var opt in options) if (options.hasOwnProperty(opt)) this[opt] = options[opt];
        this.cm = cm;
        this.node = node;
      };
      eventMixin(LineWidget);
      function widgetOperation(f) {
        return function () {
          var withOp = !this.cm.curOp;
          if (withOp) startOperation(this.cm);
          try {
            var result = f.apply(this, arguments);
          } finally {
            if (withOp) endOperation(this.cm);
          }
          return result;
        };
      }
      LineWidget.prototype.clear = widgetOperation(function () {
        var ws = this.line.widgets,
            no = lineNo(this.line);
        if (no == null || !ws) return;
        for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
        if (!ws.length) this.line.widgets = null;
        var aboveVisible = heightAtLine(this.cm, this.line) < this.cm.doc.scrollTop;
        updateLineHeight(this.line, Math.max(0, this.line.height - widgetHeight(this)));
        if (aboveVisible) addToScrollPos(this.cm, 0, -this.height);
        regChange(this.cm, no, no + 1);
      });
      LineWidget.prototype.changed = widgetOperation(function () {
        var oldH = this.height;
        this.height = null;
        var diff = widgetHeight(this) - oldH;
        if (!diff) return;
        updateLineHeight(this.line, this.line.height + diff);
        var no = lineNo(this.line);
        regChange(this.cm, no, no + 1);
      });

      function widgetHeight(widget) {
        if (widget.height != null) return widget.height;
        if (!widget.node.parentNode || widget.node.parentNode.nodeType != 1) removeChildrenAndAdd(widget.cm.display.measure, elt("div", [widget.node], null, "position: relative"));
        return widget.height = widget.node.offsetHeight;
      }

      function addLineWidget(cm, handle, node, options) {
        var widget = new LineWidget(cm, node, options);
        if (widget.noHScroll) cm.display.alignWidgets = true;
        changeLine(cm, handle, function (line) {
          var widgets = line.widgets || (line.widgets = []);
          if (widget.insertAt == null) widgets.push(widget);else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
          widget.line = line;
          if (!lineIsHidden(cm.doc, line) || widget.showIfHidden) {
            var aboveVisible = heightAtLine(cm, line) < cm.doc.scrollTop;
            updateLineHeight(line, line.height + widgetHeight(widget));
            if (aboveVisible) addToScrollPos(cm, 0, widget.height);
          }
          return true;
        });
        return widget;
      }

      // LINE DATA STRUCTURE

      // Line objects. These hold state related to a line, including
      // highlighting info (the styles array).
      var Line = CodeMirror.Line = function (text, markedSpans, estimateHeight) {
        this.text = text;
        attachMarkedSpans(this, markedSpans);
        this.height = estimateHeight ? estimateHeight(this) : 1;
      };
      eventMixin(Line);
      Line.prototype.lineNo = function () {
        return lineNo(this);
      };

      function updateLine(line, text, markedSpans, estimateHeight) {
        line.text = text;
        if (line.stateAfter) line.stateAfter = null;
        if (line.styles) line.styles = null;
        if (line.order != null) line.order = null;
        detachMarkedSpans(line);
        attachMarkedSpans(line, markedSpans);
        var estHeight = estimateHeight ? estimateHeight(line) : 1;
        if (estHeight != line.height) updateLineHeight(line, estHeight);
      }

      function cleanUpLine(line) {
        line.parent = null;
        detachMarkedSpans(line);
      }

      // Run the given mode's parser over a line, update the styles
      // array, which contains alternating fragments of text and CSS
      // classes.
      function runMode(cm, text, mode, state, f, forceToEnd) {
        var flattenSpans = mode.flattenSpans;
        if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;
        var curStart = 0,
            curStyle = null;
        var stream = new StringStream(text, cm.options.tabSize),
            style;
        if (text == "" && mode.blankLine) mode.blankLine(state);
        while (!stream.eol()) {
          if (stream.pos > cm.options.maxHighlightLength) {
            flattenSpans = false;
            if (forceToEnd) processLine(cm, text, state, stream.pos);
            stream.pos = text.length;
            style = null;
          } else {
            style = mode.token(stream, state);
          }
          if (!flattenSpans || curStyle != style) {
            if (curStart < stream.start) f(stream.start, curStyle);
            curStart = stream.start;curStyle = style;
          }
          stream.start = stream.pos;
        }
        while (curStart < stream.pos) {
          // Webkit seems to refuse to render text nodes longer than 57444 characters
          var pos = Math.min(stream.pos, curStart + 50000);
          f(pos, curStyle);
          curStart = pos;
        }
      }

      function highlightLine(cm, line, state, forceToEnd) {
        // A styles array always starts with a number identifying the
        // mode/overlays that it is based on (for easy invalidation).
        var st = [cm.state.modeGen];
        // Compute the base array of styles
        runMode(cm, line.text, cm.doc.mode, state, function (end, style) {
          st.push(end, style);
        }, forceToEnd);

        // Run overlays, adjust style array.
        for (var o = 0; o < cm.state.overlays.length; ++o) {
          var overlay = cm.state.overlays[o],
              i = 1,
              at = 0;
          runMode(cm, line.text, overlay.mode, true, function (end, style) {
            var start = i;
            // Ensure there's a token end at the current position, and that i points at it
            while (at < end) {
              var i_end = st[i];
              if (i_end > end) st.splice(i, 1, end, st[i + 1], i_end);
              i += 2;
              at = Math.min(end, i_end);
            }
            if (!style) return;
            if (overlay.opaque) {
              st.splice(start, i - start, end, style);
              i = start + 2;
            } else {
              for (; start < i; start += 2) {
                var cur = st[start + 1];
                st[start + 1] = cur ? cur + " " + style : style;
              }
            }
          });
        }

        return st;
      }

      function getLineStyles(cm, line) {
        if (!line.styles || line.styles[0] != cm.state.modeGen) line.styles = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
        return line.styles;
      }

      // Lightweight form of highlight -- proceed over this line and
      // update state, but don't save a style array.
      function processLine(cm, text, state, startAt) {
        var mode = cm.doc.mode;
        var stream = new StringStream(text, cm.options.tabSize);
        stream.start = stream.pos = startAt || 0;
        if (text == "" && mode.blankLine) mode.blankLine(state);
        while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
          mode.token(stream, state);
          stream.start = stream.pos;
        }
      }

      var styleToClassCache = {};
      function interpretTokenStyle(style, builder) {
        if (!style) return null;
        for (;;) {
          var lineClass = style.match(/(?:^|\s)line-(background-)?(\S+)/);
          if (!lineClass) break;
          style = style.slice(0, lineClass.index) + style.slice(lineClass.index + lineClass[0].length);
          var prop = lineClass[1] ? "bgClass" : "textClass";
          if (builder[prop] == null) builder[prop] = lineClass[2];else if (!new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)").test(builder[prop])) builder[prop] += " " + lineClass[2];
        }
        return styleToClassCache[style] || (styleToClassCache[style] = "cm-" + style.replace(/ +/g, " cm-"));
      }

      function buildLineContent(cm, realLine, measure, copyWidgets) {
        var merged,
            line = realLine,
            empty = true;
        while (merged = collapsedSpanAtStart(line)) line = getLine(cm.doc, merged.find().from.line);

        var builder = { pre: elt("pre"), col: 0, pos: 0,
          measure: null, measuredSomething: false, cm: cm,
          copyWidgets: copyWidgets };

        do {
          if (line.text) empty = false;
          builder.measure = line == realLine && measure;
          builder.pos = 0;
          builder.addToken = builder.measure ? buildTokenMeasure : buildToken;
          if ((ie || webkit) && cm.getOption("lineWrapping")) builder.addToken = buildTokenSplitSpaces(builder.addToken);
          var next = insertLineContent(line, builder, getLineStyles(cm, line));
          if (measure && line == realLine && !builder.measuredSomething) {
            measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure));
            builder.measuredSomething = true;
          }
          if (next) line = getLine(cm.doc, next.to.line);
        } while (next);

        if (measure && !builder.measuredSomething && !measure[0]) measure[0] = builder.pre.appendChild(empty ? elt("span", "\u00a0") : zeroWidthElement(cm.display.measure));
        if (!builder.pre.firstChild && !lineIsHidden(cm.doc, realLine)) builder.pre.appendChild(document.createTextNode("\u00a0"));

        var order;
        // Work around problem with the reported dimensions of single-char
        // direction spans on IE (issue #1129). See also the comment in
        // cursorCoords.
        if (measure && (ie || ie_gt10) && (order = getOrder(line))) {
          var l = order.length - 1;
          if (order[l].from == order[l].to) --l;
          var last = order[l],
              prev = order[l - 1];
          if (last.from + 1 == last.to && prev && last.level < prev.level) {
            var span = measure[builder.pos - 1];
            if (span) span.parentNode.insertBefore(span.measureRight = zeroWidthElement(cm.display.measure), span.nextSibling);
          }
        }

        var textClass = builder.textClass ? builder.textClass + " " + (realLine.textClass || "") : realLine.textClass;
        if (textClass) builder.pre.className = textClass;

        signal(cm, "renderLine", cm, realLine, builder.pre);
        return builder;
      }

      function defaultSpecialCharPlaceholder(ch) {
        var token = elt("span", "\u2022", "cm-invalidchar");
        token.title = "\\u" + ch.charCodeAt(0).toString(16);
        return token;
      }

      function buildToken(builder, text, style, startStyle, endStyle, title) {
        if (!text) return;
        var special = builder.cm.options.specialChars;
        if (!special.test(text)) {
          builder.col += text.length;
          var content = document.createTextNode(text);
        } else {
          var content = document.createDocumentFragment(),
              pos = 0;
          while (true) {
            special.lastIndex = pos;
            var m = special.exec(text);
            var skipped = m ? m.index - pos : text.length - pos;
            if (skipped) {
              content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));
              builder.col += skipped;
            }
            if (!m) break;
            pos += skipped + 1;
            if (m[0] == "\t") {
              var tabSize = builder.cm.options.tabSize,
                  tabWidth = tabSize - builder.col % tabSize;
              content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
              builder.col += tabWidth;
            } else {
              var token = builder.cm.options.specialCharPlaceholder(m[0]);
              content.appendChild(token);
              builder.col += 1;
            }
          }
        }
        if (style || startStyle || endStyle || builder.measure) {
          var fullStyle = style || "";
          if (startStyle) fullStyle += startStyle;
          if (endStyle) fullStyle += endStyle;
          var token = elt("span", [content], fullStyle);
          if (title) token.title = title;
          return builder.pre.appendChild(token);
        }
        builder.pre.appendChild(content);
      }

      function buildTokenMeasure(builder, text, style, startStyle, endStyle) {
        var wrapping = builder.cm.options.lineWrapping;
        for (var i = 0; i < text.length; ++i) {
          var ch = text.charAt(i),
              start = i == 0;
          if (ch >= "\ud800" && ch < "\udbff" && i < text.length - 1) {
            ch = text.slice(i, i + 2);
            ++i;
          } else if (i && wrapping && spanAffectsWrapping(text, i)) {
            builder.pre.appendChild(elt("wbr"));
          }
          var old = builder.measure[builder.pos];
          var span = builder.measure[builder.pos] = buildToken(builder, ch, style, start && startStyle, i == text.length - 1 && endStyle);
          if (old) span.leftSide = old.leftSide || old;
          // In IE single-space nodes wrap differently than spaces
          // embedded in larger text nodes, except when set to
          // white-space: normal (issue #1268).
          if (ie && wrapping && ch == " " && i && !/\s/.test(text.charAt(i - 1)) && i < text.length - 1 && !/\s/.test(text.charAt(i + 1))) span.style.whiteSpace = "normal";
          builder.pos += ch.length;
        }
        if (text.length) builder.measuredSomething = true;
      }

      function buildTokenSplitSpaces(inner) {
        function split(old) {
          var out = " ";
          for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\u00a0";
          out += " ";
          return out;
        }
        return function (builder, text, style, startStyle, endStyle, title) {
          return inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title);
        };
      }

      function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
        var widget = !ignoreWidget && marker.replacedWith;
        if (widget) {
          if (builder.copyWidgets) widget = widget.cloneNode(true);
          builder.pre.appendChild(widget);
          if (builder.measure) {
            if (size) {
              builder.measure[builder.pos] = widget;
            } else {
              var elt = zeroWidthElement(builder.cm.display.measure);
              if (marker.type == "bookmark" && !marker.insertLeft) builder.measure[builder.pos] = builder.pre.appendChild(elt);else if (builder.measure[builder.pos]) return;else builder.measure[builder.pos] = builder.pre.insertBefore(elt, widget);
            }
            builder.measuredSomething = true;
          }
        }
        builder.pos += size;
      }

      // Outputs a number of spans to make up a line, taking highlighting
      // and marked text into account.
      function insertLineContent(line, builder, styles) {
        var spans = line.markedSpans,
            allText = line.text,
            at = 0;
        if (!spans) {
          for (var i = 1; i < styles.length; i += 2) builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i + 1], builder));
          return;
        }

        var len = allText.length,
            pos = 0,
            i = 1,
            text = "",
            style;
        var nextChange = 0,
            spanStyle,
            spanEndStyle,
            spanStartStyle,
            title,
            collapsed;
        for (;;) {
          if (nextChange == pos) {
            // Update current marker set
            spanStyle = spanEndStyle = spanStartStyle = title = "";
            collapsed = null;nextChange = Infinity;
            var foundBookmarks = [];
            for (var j = 0; j < spans.length; ++j) {
              var sp = spans[j],
                  m = sp.marker;
              if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
                if (sp.to != null && nextChange > sp.to) {
                  nextChange = sp.to;spanEndStyle = "";
                }
                if (m.className) spanStyle += " " + m.className;
                if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
                if (m.endStyle && sp.to == nextChange) spanEndStyle += " " + m.endStyle;
                if (m.title && !title) title = m.title;
                if (m.collapsed && (!collapsed || collapsed.marker.size < m.size)) collapsed = sp;
              } else if (sp.from > pos && nextChange > sp.from) {
                nextChange = sp.from;
              }
              if (m.type == "bookmark" && sp.from == pos && m.replacedWith) foundBookmarks.push(m);
            }
            if (collapsed && (collapsed.from || 0) == pos) {
              buildCollapsedSpan(builder, (collapsed.to == null ? len : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
              if (collapsed.to == null) return collapsed.marker.find();
            }
            if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j) buildCollapsedSpan(builder, 0, foundBookmarks[j]);
          }
          if (pos >= len) break;

          var upto = Math.min(len, nextChange);
          while (true) {
            if (text) {
              var end = pos + text.length;
              if (!collapsed) {
                var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title);
              }
              if (end >= upto) {
                text = text.slice(upto - pos);pos = upto;break;
              }
              pos = end;
              spanStartStyle = "";
            }
            text = allText.slice(at, at = styles[i++]);
            style = interpretTokenStyle(styles[i++], builder);
          }
        }
      }

      // DOCUMENT DATA STRUCTURE

      function updateDoc(doc, change, markedSpans, selAfter, estimateHeight) {
        function spansFor(n) {
          return markedSpans ? markedSpans[n] : null;
        }
        function update(line, text, spans) {
          updateLine(line, text, spans, estimateHeight);
          signalLater(line, "change", line, change);
        }

        var from = change.from,
            to = change.to,
            text = change.text;
        var firstLine = getLine(doc, from.line),
            lastLine = getLine(doc, to.line);
        var lastText = lst(text),
            lastSpans = spansFor(text.length - 1),
            nlines = to.line - from.line;

        // First adjust the line structure
        if (from.ch == 0 && to.ch == 0 && lastText == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore)) {
          // This is a whole-line replace. Treated specially to make
          // sure line objects move the way they are supposed to.
          for (var i = 0, e = text.length - 1, added = []; i < e; ++i) added.push(new Line(text[i], spansFor(i), estimateHeight));
          update(lastLine, lastLine.text, lastSpans);
          if (nlines) doc.remove(from.line, nlines);
          if (added.length) doc.insert(from.line, added);
        } else if (firstLine == lastLine) {
          if (text.length == 1) {
            update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
          } else {
            for (var added = [], i = 1, e = text.length - 1; i < e; ++i) added.push(new Line(text[i], spansFor(i), estimateHeight));
            added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
            doc.insert(from.line + 1, added);
          }
        } else if (text.length == 1) {
          update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
          doc.remove(from.line + 1, nlines);
        } else {
          update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
          update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
          for (var i = 1, e = text.length - 1, added = []; i < e; ++i) added.push(new Line(text[i], spansFor(i), estimateHeight));
          if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
          doc.insert(from.line + 1, added);
        }

        signalLater(doc, "change", doc, change);
        setSelection(doc, selAfter.anchor, selAfter.head, null, true);
      }

      function LeafChunk(lines) {
        this.lines = lines;
        this.parent = null;
        for (var i = 0, e = lines.length, height = 0; i < e; ++i) {
          lines[i].parent = this;
          height += lines[i].height;
        }
        this.height = height;
      }

      LeafChunk.prototype = {
        chunkSize: function () {
          return this.lines.length;
        },
        removeInner: function (at, n) {
          for (var i = at, e = at + n; i < e; ++i) {
            var line = this.lines[i];
            this.height -= line.height;
            cleanUpLine(line);
            signalLater(line, "delete");
          }
          this.lines.splice(at, n);
        },
        collapse: function (lines) {
          lines.splice.apply(lines, [lines.length, 0].concat(this.lines));
        },
        insertInner: function (at, lines, height) {
          this.height += height;
          this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
          for (var i = 0, e = lines.length; i < e; ++i) lines[i].parent = this;
        },
        iterN: function (at, n, op) {
          for (var e = at + n; at < e; ++at) if (op(this.lines[at])) return true;
        }
      };

      function BranchChunk(children) {
        this.children = children;
        var size = 0,
            height = 0;
        for (var i = 0, e = children.length; i < e; ++i) {
          var ch = children[i];
          size += ch.chunkSize();height += ch.height;
          ch.parent = this;
        }
        this.size = size;
        this.height = height;
        this.parent = null;
      }

      BranchChunk.prototype = {
        chunkSize: function () {
          return this.size;
        },
        removeInner: function (at, n) {
          this.size -= n;
          for (var i = 0; i < this.children.length; ++i) {
            var child = this.children[i],
                sz = child.chunkSize();
            if (at < sz) {
              var rm = Math.min(n, sz - at),
                  oldHeight = child.height;
              child.removeInner(at, rm);
              this.height -= oldHeight - child.height;
              if (sz == rm) {
                this.children.splice(i--, 1);child.parent = null;
              }
              if ((n -= rm) == 0) break;
              at = 0;
            } else at -= sz;
          }
          if (this.size - n < 25) {
            var lines = [];
            this.collapse(lines);
            this.children = [new LeafChunk(lines)];
            this.children[0].parent = this;
          }
        },
        collapse: function (lines) {
          for (var i = 0, e = this.children.length; i < e; ++i) this.children[i].collapse(lines);
        },
        insertInner: function (at, lines, height) {
          this.size += lines.length;
          this.height += height;
          for (var i = 0, e = this.children.length; i < e; ++i) {
            var child = this.children[i],
                sz = child.chunkSize();
            if (at <= sz) {
              child.insertInner(at, lines, height);
              if (child.lines && child.lines.length > 50) {
                while (child.lines.length > 50) {
                  var spilled = child.lines.splice(child.lines.length - 25, 25);
                  var newleaf = new LeafChunk(spilled);
                  child.height -= newleaf.height;
                  this.children.splice(i + 1, 0, newleaf);
                  newleaf.parent = this;
                }
                this.maybeSpill();
              }
              break;
            }
            at -= sz;
          }
        },
        maybeSpill: function () {
          if (this.children.length <= 10) return;
          var me = this;
          do {
            var spilled = me.children.splice(me.children.length - 5, 5);
            var sibling = new BranchChunk(spilled);
            if (!me.parent) {
              // Become the parent node
              var copy = new BranchChunk(me.children);
              copy.parent = me;
              me.children = [copy, sibling];
              me = copy;
            } else {
              me.size -= sibling.size;
              me.height -= sibling.height;
              var myIndex = indexOf(me.parent.children, me);
              me.parent.children.splice(myIndex + 1, 0, sibling);
            }
            sibling.parent = me.parent;
          } while (me.children.length > 10);
          me.parent.maybeSpill();
        },
        iterN: function (at, n, op) {
          for (var i = 0, e = this.children.length; i < e; ++i) {
            var child = this.children[i],
                sz = child.chunkSize();
            if (at < sz) {
              var used = Math.min(n, sz - at);
              if (child.iterN(at, used, op)) return true;
              if ((n -= used) == 0) break;
              at = 0;
            } else at -= sz;
          }
        }
      };

      var nextDocId = 0;
      var Doc = CodeMirror.Doc = function (text, mode, firstLine) {
        if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);
        if (firstLine == null) firstLine = 0;

        BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
        this.first = firstLine;
        this.scrollTop = this.scrollLeft = 0;
        this.cantEdit = false;
        this.history = makeHistory();
        this.cleanGeneration = 1;
        this.frontier = firstLine;
        var start = Pos(firstLine, 0);
        this.sel = { from: start, to: start, head: start, anchor: start, shift: false, extend: false, goalColumn: null };
        this.id = ++nextDocId;
        this.modeOption = mode;

        if (typeof text == "string") text = splitLines(text);
        updateDoc(this, { from: start, to: start, text: text }, null, { head: start, anchor: start });
      };

      Doc.prototype = createObj(BranchChunk.prototype, {
        constructor: Doc,
        iter: function (from, to, op) {
          if (op) this.iterN(from - this.first, to - from, op);else this.iterN(this.first, this.first + this.size, from);
        },

        insert: function (at, lines) {
          var height = 0;
          for (var i = 0, e = lines.length; i < e; ++i) height += lines[i].height;
          this.insertInner(at - this.first, lines, height);
        },
        remove: function (at, n) {
          this.removeInner(at - this.first, n);
        },

        getValue: function (lineSep) {
          var lines = getLines(this, this.first, this.first + this.size);
          if (lineSep === false) return lines;
          return lines.join(lineSep || "\n");
        },
        setValue: function (code) {
          var top = Pos(this.first, 0),
              last = this.first + this.size - 1;
          makeChange(this, { from: top, to: Pos(last, getLine(this, last).text.length),
            text: splitLines(code), origin: "setValue" }, { head: top, anchor: top }, true);
        },
        replaceRange: function (code, from, to, origin) {
          from = clipPos(this, from);
          to = to ? clipPos(this, to) : from;
          replaceRange(this, code, from, to, origin);
        },
        getRange: function (from, to, lineSep) {
          var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
          if (lineSep === false) return lines;
          return lines.join(lineSep || "\n");
        },

        getLine: function (line) {
          var l = this.getLineHandle(line);return l && l.text;
        },
        setLine: function (line, text) {
          if (isLine(this, line)) replaceRange(this, text, Pos(line, 0), clipPos(this, Pos(line)));
        },
        removeLine: function (line) {
          if (line) replaceRange(this, "", clipPos(this, Pos(line - 1)), clipPos(this, Pos(line)));else replaceRange(this, "", Pos(0, 0), clipPos(this, Pos(1, 0)));
        },

        getLineHandle: function (line) {
          if (isLine(this, line)) return getLine(this, line);
        },
        getLineNumber: function (line) {
          return lineNo(line);
        },

        getLineHandleVisualStart: function (line) {
          if (typeof line == "number") line = getLine(this, line);
          return visualLine(this, line);
        },

        lineCount: function () {
          return this.size;
        },
        firstLine: function () {
          return this.first;
        },
        lastLine: function () {
          return this.first + this.size - 1;
        },

        clipPos: function (pos) {
          return clipPos(this, pos);
        },

        getCursor: function (start) {
          var sel = this.sel,
              pos;
          if (start == null || start == "head") pos = sel.head;else if (start == "anchor") pos = sel.anchor;else if (start == "end" || start === false) pos = sel.to;else pos = sel.from;
          return copyPos(pos);
        },
        somethingSelected: function () {
          return !posEq(this.sel.head, this.sel.anchor);
        },

        setCursor: docOperation(function (line, ch, extend) {
          var pos = clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line);
          if (extend) extendSelection(this, pos);else setSelection(this, pos, pos);
        }),
        setSelection: docOperation(function (anchor, head, bias) {
          setSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), bias);
        }),
        extendSelection: docOperation(function (from, to, bias) {
          extendSelection(this, clipPos(this, from), to && clipPos(this, to), bias);
        }),

        getSelection: function (lineSep) {
          return this.getRange(this.sel.from, this.sel.to, lineSep);
        },
        replaceSelection: function (code, collapse, origin) {
          makeChange(this, { from: this.sel.from, to: this.sel.to, text: splitLines(code), origin: origin }, collapse || "around");
        },
        undo: docOperation(function () {
          makeChangeFromHistory(this, "undo");
        }),
        redo: docOperation(function () {
          makeChangeFromHistory(this, "redo");
        }),

        setExtending: function (val) {
          this.sel.extend = val;
        },

        historySize: function () {
          var hist = this.history;
          return { undo: hist.done.length, redo: hist.undone.length };
        },
        clearHistory: function () {
          this.history = makeHistory(this.history.maxGeneration);
        },

        markClean: function () {
          this.cleanGeneration = this.changeGeneration();
        },
        changeGeneration: function () {
          this.history.lastOp = this.history.lastOrigin = null;
          return this.history.generation;
        },
        isClean: function (gen) {
          return this.history.generation == (gen || this.cleanGeneration);
        },

        getHistory: function () {
          return { done: copyHistoryArray(this.history.done),
            undone: copyHistoryArray(this.history.undone) };
        },
        setHistory: function (histData) {
          var hist = this.history = makeHistory(this.history.maxGeneration);
          hist.done = histData.done.slice(0);
          hist.undone = histData.undone.slice(0);
        },

        markText: function (from, to, options) {
          return markText(this, clipPos(this, from), clipPos(this, to), options, "range");
        },
        setBookmark: function (pos, options) {
          var realOpts = { replacedWith: options && (options.nodeType == null ? options.widget : options),
            insertLeft: options && options.insertLeft };
          pos = clipPos(this, pos);
          return markText(this, pos, pos, realOpts, "bookmark");
        },
        findMarksAt: function (pos) {
          pos = clipPos(this, pos);
          var markers = [],
              spans = getLine(this, pos.line).markedSpans;
          if (spans) for (var i = 0; i < spans.length; ++i) {
            var span = spans[i];
            if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) markers.push(span.marker.parent || span.marker);
          }
          return markers;
        },
        getAllMarks: function () {
          var markers = [];
          this.iter(function (line) {
            var sps = line.markedSpans;
            if (sps) for (var i = 0; i < sps.length; ++i) if (sps[i].from != null) markers.push(sps[i].marker);
          });
          return markers;
        },

        posFromIndex: function (off) {
          var ch,
              lineNo = this.first;
          this.iter(function (line) {
            var sz = line.text.length + 1;
            if (sz > off) {
              ch = off;return true;
            }
            off -= sz;
            ++lineNo;
          });
          return clipPos(this, Pos(lineNo, ch));
        },
        indexFromPos: function (coords) {
          coords = clipPos(this, coords);
          var index = coords.ch;
          if (coords.line < this.first || coords.ch < 0) return 0;
          this.iter(this.first, coords.line, function (line) {
            index += line.text.length + 1;
          });
          return index;
        },

        copy: function (copyHistory) {
          var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
          doc.scrollTop = this.scrollTop;doc.scrollLeft = this.scrollLeft;
          doc.sel = { from: this.sel.from, to: this.sel.to, head: this.sel.head, anchor: this.sel.anchor,
            shift: this.sel.shift, extend: false, goalColumn: this.sel.goalColumn };
          if (copyHistory) {
            doc.history.undoDepth = this.history.undoDepth;
            doc.setHistory(this.getHistory());
          }
          return doc;
        },

        linkedDoc: function (options) {
          if (!options) options = {};
          var from = this.first,
              to = this.first + this.size;
          if (options.from != null && options.from > from) from = options.from;
          if (options.to != null && options.to < to) to = options.to;
          var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
          if (options.sharedHist) copy.history = this.history;
          (this.linked || (this.linked = [])).push({ doc: copy, sharedHist: options.sharedHist });
          copy.linked = [{ doc: this, isParent: true, sharedHist: options.sharedHist }];
          return copy;
        },
        unlinkDoc: function (other) {
          if (other instanceof CodeMirror) other = other.doc;
          if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
            var link = this.linked[i];
            if (link.doc != other) continue;
            this.linked.splice(i, 1);
            other.unlinkDoc(this);
            break;
          }
          // If the histories were shared, split them again
          if (other.history == this.history) {
            var splitIds = [other.id];
            linkedDocs(other, function (doc) {
              splitIds.push(doc.id);
            }, true);
            other.history = makeHistory();
            other.history.done = copyHistoryArray(this.history.done, splitIds);
            other.history.undone = copyHistoryArray(this.history.undone, splitIds);
          }
        },
        iterLinkedDocs: function (f) {
          linkedDocs(this, f);
        },

        getMode: function () {
          return this.mode;
        },
        getEditor: function () {
          return this.cm;
        }
      });

      Doc.prototype.eachLine = Doc.prototype.iter;

      // The Doc methods that should be available on CodeMirror instances
      var dontDelegate = "iter insert remove copy getEditor".split(" ");
      for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) CodeMirror.prototype[prop] = function (method) {
        return function () {
          return method.apply(this.doc, arguments);
        };
      }(Doc.prototype[prop]);

      eventMixin(Doc);

      function linkedDocs(doc, f, sharedHistOnly) {
        function propagate(doc, skip, sharedHist) {
          if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
            var rel = doc.linked[i];
            if (rel.doc == skip) continue;
            var shared = sharedHist && rel.sharedHist;
            if (sharedHistOnly && !shared) continue;
            f(rel.doc, shared);
            propagate(rel.doc, doc, shared);
          }
        }
        propagate(doc, null, true);
      }

      function attachDoc(cm, doc) {
        if (doc.cm) throw new Error("This document is already in use.");
        cm.doc = doc;
        doc.cm = cm;
        estimateLineHeights(cm);
        loadMode(cm);
        if (!cm.options.lineWrapping) computeMaxLength(cm);
        cm.options.mode = doc.modeOption;
        regChange(cm);
      }

      // LINE UTILITIES

      function getLine(chunk, n) {
        n -= chunk.first;
        while (!chunk.lines) {
          for (var i = 0;; ++i) {
            var child = chunk.children[i],
                sz = child.chunkSize();
            if (n < sz) {
              chunk = child;break;
            }
            n -= sz;
          }
        }
        return chunk.lines[n];
      }

      function getBetween(doc, start, end) {
        var out = [],
            n = start.line;
        doc.iter(start.line, end.line + 1, function (line) {
          var text = line.text;
          if (n == end.line) text = text.slice(0, end.ch);
          if (n == start.line) text = text.slice(start.ch);
          out.push(text);
          ++n;
        });
        return out;
      }
      function getLines(doc, from, to) {
        var out = [];
        doc.iter(from, to, function (line) {
          out.push(line.text);
        });
        return out;
      }

      function updateLineHeight(line, height) {
        var diff = height - line.height;
        for (var n = line; n; n = n.parent) n.height += diff;
      }

      function lineNo(line) {
        if (line.parent == null) return null;
        var cur = line.parent,
            no = indexOf(cur.lines, line);
        for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
          for (var i = 0;; ++i) {
            if (chunk.children[i] == cur) break;
            no += chunk.children[i].chunkSize();
          }
        }
        return no + cur.first;
      }

      function lineAtHeight(chunk, h) {
        var n = chunk.first;
        outer: do {
          for (var i = 0, e = chunk.children.length; i < e; ++i) {
            var child = chunk.children[i],
                ch = child.height;
            if (h < ch) {
              chunk = child;continue outer;
            }
            h -= ch;
            n += child.chunkSize();
          }
          return n;
        } while (!chunk.lines);
        for (var i = 0, e = chunk.lines.length; i < e; ++i) {
          var line = chunk.lines[i],
              lh = line.height;
          if (h < lh) break;
          h -= lh;
        }
        return n + i;
      }

      function heightAtLine(cm, lineObj) {
        lineObj = visualLine(cm.doc, lineObj);

        var h = 0,
            chunk = lineObj.parent;
        for (var i = 0; i < chunk.lines.length; ++i) {
          var line = chunk.lines[i];
          if (line == lineObj) break;else h += line.height;
        }
        for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
          for (var i = 0; i < p.children.length; ++i) {
            var cur = p.children[i];
            if (cur == chunk) break;else h += cur.height;
          }
        }
        return h;
      }

      function getOrder(line) {
        var order = line.order;
        if (order == null) order = line.order = bidiOrdering(line.text);
        return order;
      }

      // HISTORY

      function makeHistory(startGen) {
        return {
          // Arrays of history events. Doing something adds an event to
          // done and clears undo. Undoing moves events from done to
          // undone, redoing moves them in the other direction.
          done: [], undone: [], undoDepth: Infinity,
          // Used to track when changes can be merged into a single undo
          // event
          lastTime: 0, lastOp: null, lastOrigin: null,
          // Used by the isClean() method
          generation: startGen || 1, maxGeneration: startGen || 1
        };
      }

      function attachLocalSpans(doc, change, from, to) {
        var existing = change["spans_" + doc.id],
            n = 0;
        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
          if (line.markedSpans) (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
          ++n;
        });
      }

      function historyChangeFromChange(doc, change) {
        var from = { line: change.from.line, ch: change.from.ch };
        var histChange = { from: from, to: changeEnd(change), text: getBetween(doc, change.from, change.to) };
        attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        linkedDocs(doc, function (doc) {
          attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        }, true);
        return histChange;
      }

      function addToHistory(doc, change, selAfter, opId) {
        var hist = doc.history;
        hist.undone.length = 0;
        var time = +new Date(),
            cur = lst(hist.done);

        if (cur && (hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && doc.cm && hist.lastTime > time - doc.cm.options.historyEventDelay || change.origin.charAt(0) == "*"))) {
          // Merge this change into the last event
          var last = lst(cur.changes);
          if (posEq(change.from, change.to) && posEq(change.from, last.to)) {
            // Optimized case for simple insertion -- don't want to add
            // new changesets for every character typed
            last.to = changeEnd(change);
          } else {
            // Add new sub-event
            cur.changes.push(historyChangeFromChange(doc, change));
          }
          cur.anchorAfter = selAfter.anchor;cur.headAfter = selAfter.head;
        } else {
          // Can not be merged, start a new event.
          cur = { changes: [historyChangeFromChange(doc, change)],
            generation: hist.generation,
            anchorBefore: doc.sel.anchor, headBefore: doc.sel.head,
            anchorAfter: selAfter.anchor, headAfter: selAfter.head };
          hist.done.push(cur);
          hist.generation = ++hist.maxGeneration;
          while (hist.done.length > hist.undoDepth) hist.done.shift();
        }
        hist.lastTime = time;
        hist.lastOp = opId;
        hist.lastOrigin = change.origin;
      }

      function removeClearedSpans(spans) {
        if (!spans) return null;
        for (var i = 0, out; i < spans.length; ++i) {
          if (spans[i].marker.explicitlyCleared) {
            if (!out) out = spans.slice(0, i);
          } else if (out) out.push(spans[i]);
        }
        return !out ? spans : out.length ? out : null;
      }

      function getOldSpans(doc, change) {
        var found = change["spans_" + doc.id];
        if (!found) return null;
        for (var i = 0, nw = []; i < change.text.length; ++i) nw.push(removeClearedSpans(found[i]));
        return nw;
      }

      // Used both to provide a JSON-safe object in .getHistory, and, when
      // detaching a document, to split the history in two
      function copyHistoryArray(events, newGroup) {
        for (var i = 0, copy = []; i < events.length; ++i) {
          var event = events[i],
              changes = event.changes,
              newChanges = [];
          copy.push({ changes: newChanges, anchorBefore: event.anchorBefore, headBefore: event.headBefore,
            anchorAfter: event.anchorAfter, headAfter: event.headAfter });
          for (var j = 0; j < changes.length; ++j) {
            var change = changes[j],
                m;
            newChanges.push({ from: change.from, to: change.to, text: change.text });
            if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
              if (indexOf(newGroup, Number(m[1])) > -1) {
                lst(newChanges)[prop] = change[prop];
                delete change[prop];
              }
            }
          }
        }
        return copy;
      }

      // Rebasing/resetting history to deal with externally-sourced changes

      function rebaseHistSel(pos, from, to, diff) {
        if (to < pos.line) {
          pos.line += diff;
        } else if (from < pos.line) {
          pos.line = from;
          pos.ch = 0;
        }
      }

      // Tries to rebase an array of history events given a change in the
      // document. If the change touches the same lines as the event, the
      // event, and everything 'behind' it, is discarded. If the change is
      // before the event, the event's positions are updated. Uses a
      // copy-on-write scheme for the positions, to avoid having to
      // reallocate them all on every rebase, but also avoid problems with
      // shared position objects being unsafely updated.
      function rebaseHistArray(array, from, to, diff) {
        for (var i = 0; i < array.length; ++i) {
          var sub = array[i],
              ok = true;
          for (var j = 0; j < sub.changes.length; ++j) {
            var cur = sub.changes[j];
            if (!sub.copied) {
              cur.from = copyPos(cur.from);cur.to = copyPos(cur.to);
            }
            if (to < cur.from.line) {
              cur.from.line += diff;
              cur.to.line += diff;
            } else if (from <= cur.to.line) {
              ok = false;
              break;
            }
          }
          if (!sub.copied) {
            sub.anchorBefore = copyPos(sub.anchorBefore);sub.headBefore = copyPos(sub.headBefore);
            sub.anchorAfter = copyPos(sub.anchorAfter);sub.readAfter = copyPos(sub.headAfter);
            sub.copied = true;
          }
          if (!ok) {
            array.splice(0, i + 1);
            i = 0;
          } else {
            rebaseHistSel(sub.anchorBefore);rebaseHistSel(sub.headBefore);
            rebaseHistSel(sub.anchorAfter);rebaseHistSel(sub.headAfter);
          }
        }
      }

      function rebaseHist(hist, change) {
        var from = change.from.line,
            to = change.to.line,
            diff = change.text.length - (to - from) - 1;
        rebaseHistArray(hist.done, from, to, diff);
        rebaseHistArray(hist.undone, from, to, diff);
      }

      // EVENT OPERATORS

      function stopMethod() {
        e_stop(this);
      }
      // Ensure an event has a stop method.
      function addStop(event) {
        if (!event.stop) event.stop = stopMethod;
        return event;
      }

      function e_preventDefault(e) {
        if (e.preventDefault) e.preventDefault();else e.returnValue = false;
      }
      function e_stopPropagation(e) {
        if (e.stopPropagation) e.stopPropagation();else e.cancelBubble = true;
      }
      function e_defaultPrevented(e) {
        return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
      }
      function e_stop(e) {
        e_preventDefault(e);e_stopPropagation(e);
      }
      CodeMirror.e_stop = e_stop;
      CodeMirror.e_preventDefault = e_preventDefault;
      CodeMirror.e_stopPropagation = e_stopPropagation;

      function e_target(e) {
        return e.target || e.srcElement;
      }
      function e_button(e) {
        var b = e.which;
        if (b == null) {
          if (e.button & 1) b = 1;else if (e.button & 2) b = 3;else if (e.button & 4) b = 2;
        }
        if (mac && e.ctrlKey && b == 1) b = 3;
        return b;
      }

      // EVENT HANDLING

      function on(emitter, type, f) {
        if (emitter.addEventListener) emitter.addEventListener(type, f, false);else if (emitter.attachEvent) emitter.attachEvent("on" + type, f);else {
          var map = emitter._handlers || (emitter._handlers = {});
          var arr = map[type] || (map[type] = []);
          arr.push(f);
        }
      }

      function off(emitter, type, f) {
        if (emitter.removeEventListener) emitter.removeEventListener(type, f, false);else if (emitter.detachEvent) emitter.detachEvent("on" + type, f);else {
          var arr = emitter._handlers && emitter._handlers[type];
          if (!arr) return;
          for (var i = 0; i < arr.length; ++i) if (arr[i] == f) {
            arr.splice(i, 1);break;
          }
        }
      }

      function signal(emitter, type /*, values...*/) {
        var arr = emitter._handlers && emitter._handlers[type];
        if (!arr) return;
        var args = Array.prototype.slice.call(arguments, 2);
        for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);
      }

      var delayedCallbacks,
          delayedCallbackDepth = 0;
      function signalLater(emitter, type /*, values...*/) {
        var arr = emitter._handlers && emitter._handlers[type];
        if (!arr) return;
        var args = Array.prototype.slice.call(arguments, 2);
        if (!delayedCallbacks) {
          ++delayedCallbackDepth;
          delayedCallbacks = [];
          setTimeout(fireDelayed, 0);
        }
        function bnd(f) {
          return function () {
            f.apply(null, args);
          };
        };
        for (var i = 0; i < arr.length; ++i) delayedCallbacks.push(bnd(arr[i]));
      }

      function signalDOMEvent(cm, e, override) {
        signal(cm, override || e.type, cm, e);
        return e_defaultPrevented(e) || e.codemirrorIgnore;
      }

      function fireDelayed() {
        --delayedCallbackDepth;
        var delayed = delayedCallbacks;
        delayedCallbacks = null;
        for (var i = 0; i < delayed.length; ++i) delayed[i]();
      }

      function hasHandler(emitter, type) {
        var arr = emitter._handlers && emitter._handlers[type];
        return arr && arr.length > 0;
      }

      CodeMirror.on = on;CodeMirror.off = off;CodeMirror.signal = signal;

      function eventMixin(ctor) {
        ctor.prototype.on = function (type, f) {
          on(this, type, f);
        };
        ctor.prototype.off = function (type, f) {
          off(this, type, f);
        };
      }

      // MISC UTILITIES

      // Number of pixels added to scroller and sizer to hide scrollbar
      var scrollerCutOff = 30;

      // Returned or thrown by various protocols to signal 'I'm not
      // handling this'.
      var Pass = CodeMirror.Pass = { toString: function () {
          return "CodeMirror.Pass";
        } };

      function Delayed() {
        this.id = null;
      }
      Delayed.prototype = { set: function (ms, f) {
          clearTimeout(this.id);this.id = setTimeout(f, ms);
        } };

      // Counts the column offset in a string, taking tabs into account.
      // Used mostly to find indentation.
      function countColumn(string, end, tabSize, startIndex, startValue) {
        if (end == null) {
          end = string.search(/[^\s\u00a0]/);
          if (end == -1) end = string.length;
        }
        for (var i = startIndex || 0, n = startValue || 0; i < end; ++i) {
          if (string.charAt(i) == "\t") n += tabSize - n % tabSize;else ++n;
        }
        return n;
      }
      CodeMirror.countColumn = countColumn;

      var spaceStrs = [""];
      function spaceStr(n) {
        while (spaceStrs.length <= n) spaceStrs.push(lst(spaceStrs) + " ");
        return spaceStrs[n];
      }

      function lst(arr) {
        return arr[arr.length - 1];
      }

      function selectInput(node) {
        if (ios) {
          // Mobile Safari apparently has a bug where select() is broken.
          node.selectionStart = 0;
          node.selectionEnd = node.value.length;
        } else {
          // Suppress mysterious IE10 errors
          try {
            node.select();
          } catch (_e) {}
        }
      }

      function indexOf(collection, elt) {
        if (collection.indexOf) return collection.indexOf(elt);
        for (var i = 0, e = collection.length; i < e; ++i) if (collection[i] == elt) return i;
        return -1;
      }

      function createObj(base, props) {
        function Obj() {}
        Obj.prototype = base;
        var inst = new Obj();
        if (props) copyObj(props, inst);
        return inst;
      }

      function copyObj(obj, target) {
        if (!target) target = {};
        for (var prop in obj) if (obj.hasOwnProperty(prop)) target[prop] = obj[prop];
        return target;
      }

      function emptyArray(size) {
        for (var a = [], i = 0; i < size; ++i) a.push(undefined);
        return a;
      }

      function bind(f) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
          return f.apply(null, args);
        };
      }

      var nonASCIISingleCaseWordChar = /[\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
      function isWordChar(ch) {
        return (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
        );
      }

      function isEmpty(obj) {
        for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;
        return true;
      }

      var isExtendingChar = /[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\uA66F\u1DC0–\u1DFF\u20D0–\u20FF\uA670-\uA672\uA674-\uA67D\uA69F\udc00-\udfff\uFE20–\uFE2F]/;

      // DOM UTILITIES

      function elt(tag, content, className, style) {
        var e = document.createElement(tag);
        if (className) e.className = className;
        if (style) e.style.cssText = style;
        if (typeof content == "string") setTextContent(e, content);else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
        return e;
      }

      function removeChildren(e) {
        for (var count = e.childNodes.length; count > 0; --count) e.removeChild(e.firstChild);
        return e;
      }

      function removeChildrenAndAdd(parent, e) {
        return removeChildren(parent).appendChild(e);
      }

      function setTextContent(e, str) {
        if (ie_lt9) {
          e.innerHTML = "";
          e.appendChild(document.createTextNode(str));
        } else e.textContent = str;
      }

      function getRect(node) {
        return node.getBoundingClientRect();
      }
      CodeMirror.replaceGetRect = function (f) {
        getRect = f;
      };

      // FEATURE DETECTION

      // Detect drag-and-drop
      var dragAndDrop = function () {
        // There is *some* kind of drag-and-drop support in IE6-8, but I
        // couldn't get it to work yet.
        if (ie_lt9) return false;
        var div = elt('div');
        return "draggable" in div || "dragDrop" in div;
      }();

      // For a reason I have yet to figure out, some browsers disallow
      // word wrapping between certain characters *only* if a new inline
      // element is started between them. This makes it hard to reliably
      // measure the position of things, since that requires inserting an
      // extra span. This terribly fragile set of tests matches the
      // character combinations that suffer from this phenomenon on the
      // various browsers.
      function spanAffectsWrapping() {
        return false;
      }
      if (gecko) // Only for "$'"
        spanAffectsWrapping = function (str, i) {
          return str.charCodeAt(i - 1) == 36 && str.charCodeAt(i) == 39;
        };else if (safari && !/Version\/([6-9]|\d\d)\b/.test(navigator.userAgent)) spanAffectsWrapping = function (str, i) {
        return (/\-[^ \-?]|\?[^ !\'\"\),.\-\/:;\?\]\}]/.test(str.slice(i - 1, i + 1))
        );
      };else if (webkit && /Chrome\/(?:29|[3-9]\d|\d\d\d)\./.test(navigator.userAgent)) spanAffectsWrapping = function (str, i) {
        var code = str.charCodeAt(i - 1);
        return code >= 8208 && code <= 8212;
      };else if (webkit) spanAffectsWrapping = function (str, i) {
        if (i > 1 && str.charCodeAt(i - 1) == 45) {
          if (/\w/.test(str.charAt(i - 2)) && /[^\-?\.]/.test(str.charAt(i))) return true;
          if (i > 2 && /[\d\.,]/.test(str.charAt(i - 2)) && /[\d\.,]/.test(str.charAt(i))) return false;
        }
        return (/[~!#%&*)=+}\]\\|\"\.>,:;][({[<]|-[^\-?\.\u2010-\u201f\u2026]|\?[\w~`@#$%\^&*(_=+{[|><]|…[\w~`@#$%\^&*(_=+{[><]/.test(str.slice(i - 1, i + 1))
        );
      };

      var knownScrollbarWidth;
      function scrollbarWidth(measure) {
        if (knownScrollbarWidth != null) return knownScrollbarWidth;
        var test = elt("div", null, null, "width: 50px; height: 50px; overflow-x: scroll");
        removeChildrenAndAdd(measure, test);
        if (test.offsetWidth) knownScrollbarWidth = test.offsetHeight - test.clientHeight;
        return knownScrollbarWidth || 0;
      }

      var zwspSupported;
      function zeroWidthElement(measure) {
        if (zwspSupported == null) {
          var test = elt("span", "\u200b");
          removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
          if (measure.firstChild.offsetHeight != 0) zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8;
        }
        if (zwspSupported) return elt("span", "\u200b");else return elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
      }

      // See if "".split is the broken IE version, if so, provide an
      // alternative way to split lines.
      var splitLines = "\n\nb".split(/\n/).length != 3 ? function (string) {
        var pos = 0,
            result = [],
            l = string.length;
        while (pos <= l) {
          var nl = string.indexOf("\n", pos);
          if (nl == -1) nl = string.length;
          var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
          var rt = line.indexOf("\r");
          if (rt != -1) {
            result.push(line.slice(0, rt));
            pos += rt + 1;
          } else {
            result.push(line);
            pos = nl + 1;
          }
        }
        return result;
      } : function (string) {
        return string.split(/\r\n?|\n/);
      };
      CodeMirror.splitLines = splitLines;

      var hasSelection = window.getSelection ? function (te) {
        try {
          return te.selectionStart != te.selectionEnd;
        } catch (e) {
          return false;
        }
      } : function (te) {
        try {
          var range = te.ownerDocument.selection.createRange();
        } catch (e) {}
        if (!range || range.parentElement() != te) return false;
        return range.compareEndPoints("StartToEnd", range) != 0;
      };

      var hasCopyEvent = function () {
        var e = elt("div");
        if ("oncopy" in e) return true;
        e.setAttribute("oncopy", "return;");
        return typeof e.oncopy == 'function';
      }();

      // KEY NAMING

      var keyNames = { 3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
        19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
        36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
        46: "Delete", 59: ";", 91: "Mod", 92: "Mod", 93: "Mod", 109: "-", 107: "=", 127: "Delete",
        186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
        221: "]", 222: "'", 63276: "PageUp", 63277: "PageDown", 63275: "End", 63273: "Home",
        63234: "Left", 63232: "Up", 63235: "Right", 63233: "Down", 63302: "Insert", 63272: "Delete" };
      CodeMirror.keyNames = keyNames;
      (function () {
        // Number keys
        for (var i = 0; i < 10; i++) keyNames[i + 48] = String(i);
        // Alphabetic keys
        for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
        // Function keys
        for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
      })();

      // BIDI HELPERS

      function iterateBidiSections(order, from, to, f) {
        if (!order) return f(from, to, "ltr");
        var found = false;
        for (var i = 0; i < order.length; ++i) {
          var part = order[i];
          if (part.from < to && part.to > from || from == to && part.to == from) {
            f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
            found = true;
          }
        }
        if (!found) f(from, to, "ltr");
      }

      function bidiLeft(part) {
        return part.level % 2 ? part.to : part.from;
      }
      function bidiRight(part) {
        return part.level % 2 ? part.from : part.to;
      }

      function lineLeft(line) {
        var order = getOrder(line);return order ? bidiLeft(order[0]) : 0;
      }
      function lineRight(line) {
        var order = getOrder(line);
        if (!order) return line.text.length;
        return bidiRight(lst(order));
      }

      function lineStart(cm, lineN) {
        var line = getLine(cm.doc, lineN);
        var visual = visualLine(cm.doc, line);
        if (visual != line) lineN = lineNo(visual);
        var order = getOrder(visual);
        var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
        return Pos(lineN, ch);
      }
      function lineEnd(cm, lineN) {
        var merged, line;
        while (merged = collapsedSpanAtEnd(line = getLine(cm.doc, lineN))) lineN = merged.find().to.line;
        var order = getOrder(line);
        var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
        return Pos(lineN, ch);
      }

      function compareBidiLevel(order, a, b) {
        var linedir = order[0].level;
        if (a == linedir) return true;
        if (b == linedir) return false;
        return a < b;
      }
      var bidiOther;
      function getBidiPartAt(order, pos) {
        for (var i = 0, found; i < order.length; ++i) {
          var cur = order[i];
          if (cur.from < pos && cur.to > pos) {
            bidiOther = null;return i;
          }
          if (cur.from == pos || cur.to == pos) {
            if (found == null) {
              found = i;
            } else if (compareBidiLevel(order, cur.level, order[found].level)) {
              bidiOther = found;
              return i;
            } else {
              bidiOther = i;
              return found;
            }
          }
        }
        bidiOther = null;
        return found;
      }

      function moveInLine(line, pos, dir, byUnit) {
        if (!byUnit) return pos + dir;
        do pos += dir; while (pos > 0 && isExtendingChar.test(line.text.charAt(pos)));
        return pos;
      }

      // This is somewhat involved. It is needed in order to move
      // 'visually' through bi-directional text -- i.e., pressing left
      // should make the cursor go left, even when in RTL text. The
      // tricky part is the 'jumps', where RTL and LTR text touch each
      // other. This often requires the cursor offset to move more than
      // one unit, in order to visually move one unit.
      function moveVisually(line, start, dir, byUnit) {
        var bidi = getOrder(line);
        if (!bidi) return moveLogically(line, start, dir, byUnit);
        var pos = getBidiPartAt(bidi, start),
            part = bidi[pos];
        var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);

        for (;;) {
          if (target > part.from && target < part.to) return target;
          if (target == part.from || target == part.to) {
            if (getBidiPartAt(bidi, target) == pos) return target;
            part = bidi[pos += dir];
            return dir > 0 == part.level % 2 ? part.to : part.from;
          } else {
            part = bidi[pos += dir];
            if (!part) return null;
            if (dir > 0 == part.level % 2) target = moveInLine(line, part.to, -1, byUnit);else target = moveInLine(line, part.from, 1, byUnit);
          }
        }
      }

      function moveLogically(line, start, dir, byUnit) {
        var target = start + dir;
        if (byUnit) while (target > 0 && isExtendingChar.test(line.text.charAt(target))) target += dir;
        return target < 0 || target > line.text.length ? null : target;
      }

      // Bidirectional ordering algorithm
      // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
      // that this (partially) implements.

      // One-char codes used for character types:
      // L (L):   Left-to-Right
      // R (R):   Right-to-Left
      // r (AL):  Right-to-Left Arabic
      // 1 (EN):  European Number
      // + (ES):  European Number Separator
      // % (ET):  European Number Terminator
      // n (AN):  Arabic Number
      // , (CS):  Common Number Separator
      // m (NSM): Non-Spacing Mark
      // b (BN):  Boundary Neutral
      // s (B):   Paragraph Separator
      // t (S):   Segment Separator
      // w (WS):  Whitespace
      // N (ON):  Other Neutrals

      // Returns null if characters are ordered as they appear
      // (left-to-right), or an array of sections ({from, to, level}
      // objects) in the order in which they occur visually.
      var bidiOrdering = function () {
        // Character types for codepoints 0 to 0xff
        var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL";
        // Character types for codepoints 0x600 to 0x6ff
        var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr";
        function charType(code) {
          if (code <= 0xff) return lowTypes.charAt(code);else if (0x590 <= code && code <= 0x5f4) return "R";else if (0x600 <= code && code <= 0x6ff) return arabicTypes.charAt(code - 0x600);else if (0x700 <= code && code <= 0x8ac) return "r";else return "L";
        }

        var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
        var isNeutral = /[stwN]/,
            isStrong = /[LRr]/,
            countsAsLeft = /[Lb1n]/,
            countsAsNum = /[1n]/;
        // Browsers seem to always treat the boundaries of block elements as being L.
        var outerType = "L";

        return function (str) {
          if (!bidiRE.test(str)) return false;
          var len = str.length,
              types = [];
          for (var i = 0, type; i < len; ++i) types.push(type = charType(str.charCodeAt(i)));

          // W1. Examine each non-spacing mark (NSM) in the level run, and
          // change the type of the NSM to the type of the previous
          // character. If the NSM is at the start of the level run, it will
          // get the type of sor.
          for (var i = 0, prev = outerType; i < len; ++i) {
            var type = types[i];
            if (type == "m") types[i] = prev;else prev = type;
          }

          // W2. Search backwards from each instance of a European number
          // until the first strong type (R, L, AL, or sor) is found. If an
          // AL is found, change the type of the European number to Arabic
          // number.
          // W3. Change all ALs to R.
          for (var i = 0, cur = outerType; i < len; ++i) {
            var type = types[i];
            if (type == "1" && cur == "r") types[i] = "n";else if (isStrong.test(type)) {
              cur = type;if (type == "r") types[i] = "R";
            }
          }

          // W4. A single European separator between two European numbers
          // changes to a European number. A single common separator between
          // two numbers of the same type changes to that type.
          for (var i = 1, prev = types[0]; i < len - 1; ++i) {
            var type = types[i];
            if (type == "+" && prev == "1" && types[i + 1] == "1") types[i] = "1";else if (type == "," && prev == types[i + 1] && (prev == "1" || prev == "n")) types[i] = prev;
            prev = type;
          }

          // W5. A sequence of European terminators adjacent to European
          // numbers changes to all European numbers.
          // W6. Otherwise, separators and terminators change to Other
          // Neutral.
          for (var i = 0; i < len; ++i) {
            var type = types[i];
            if (type == ",") types[i] = "N";else if (type == "%") {
              for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
              var replace = i && types[i - 1] == "!" || end < len - 1 && types[end] == "1" ? "1" : "N";
              for (var j = i; j < end; ++j) types[j] = replace;
              i = end - 1;
            }
          }

          // W7. Search backwards from each instance of a European number
          // until the first strong type (R, L, or sor) is found. If an L is
          // found, then change the type of the European number to L.
          for (var i = 0, cur = outerType; i < len; ++i) {
            var type = types[i];
            if (cur == "L" && type == "1") types[i] = "L";else if (isStrong.test(type)) cur = type;
          }

          // N1. A sequence of neutrals takes the direction of the
          // surrounding strong text if the text on both sides has the same
          // direction. European and Arabic numbers act as if they were R in
          // terms of their influence on neutrals. Start-of-level-run (sor)
          // and end-of-level-run (eor) are used at level run boundaries.
          // N2. Any remaining neutrals take the embedding direction.
          for (var i = 0; i < len; ++i) {
            if (isNeutral.test(types[i])) {
              for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
              var before = (i ? types[i - 1] : outerType) == "L";
              var after = (end < len - 1 ? types[end] : outerType) == "L";
              var replace = before || after ? "L" : "R";
              for (var j = i; j < end; ++j) types[j] = replace;
              i = end - 1;
            }
          }

          // Here we depart from the documented algorithm, in order to avoid
          // building up an actual levels array. Since there are only three
          // levels (0, 1, 2) in an implementation that doesn't take
          // explicit embedding into account, we can build up the order on
          // the fly, without following the level-based algorithm.
          var order = [],
              m;
          for (var i = 0; i < len;) {
            if (countsAsLeft.test(types[i])) {
              var start = i;
              for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
              order.push({ from: start, to: i, level: 0 });
            } else {
              var pos = i,
                  at = order.length;
              for (++i; i < len && types[i] != "L"; ++i) {}
              for (var j = pos; j < i;) {
                if (countsAsNum.test(types[j])) {
                  if (pos < j) order.splice(at, 0, { from: pos, to: j, level: 1 });
                  var nstart = j;
                  for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
                  order.splice(at, 0, { from: nstart, to: j, level: 2 });
                  pos = j;
                } else ++j;
              }
              if (pos < i) order.splice(at, 0, { from: pos, to: i, level: 1 });
            }
          }
          if (order[0].level == 1 && (m = str.match(/^\s+/))) {
            order[0].from = m[0].length;
            order.unshift({ from: 0, to: m[0].length, level: 0 });
          }
          if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
            lst(order).to -= m[0].length;
            order.push({ from: len - m[0].length, to: len, level: 0 });
          }
          if (order[0].level != lst(order).level) order.push({ from: len, to: len, level: order[0].level });

          return order;
        };
      }();

      // THE END

      CodeMirror.version = "3.20.0";

      return CodeMirror;
    }();
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic("83", ["80"], false, function ($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);

  (function ($__global) {
    // ============== Formatting extensions ============================
    (function () {
      // Define extensions for a few modes
      CodeMirror.extendMode("css", {
        commentStart: "/*",
        commentEnd: "*/",
        wordWrapChars: [";", "\\{", "\\}"],
        autoFormatLineBreaks: function (text) {
          return text.replace(new RegExp("(;|\\{|\\})([^\r\n])", "g"), "$1\n$2");
        }
      });

      function jsNonBreakableBlocks(text) {
        var nonBreakableRegexes = [/for\s*?\((.*?)\)/, /\"(.*?)(\"|$)/, /\'(.*?)(\'|$)/, /\/\*(.*?)(\*\/|$)/, /\/\/.*/];
        var nonBreakableBlocks = [];
        for (var i = 0; i < nonBreakableRegexes.length; i++) {
          var curPos = 0;
          while (curPos < text.length) {
            var m = text.substr(curPos).match(nonBreakableRegexes[i]);
            if (m != null) {
              nonBreakableBlocks.push({
                start: curPos + m.index,
                end: curPos + m.index + m[0].length
              });
              curPos += m.index + Math.max(1, m[0].length);
            } else {
              // No more matches
              break;
            }
          }
        }
        nonBreakableBlocks.sort(function (a, b) {
          return a.start - b.start;
        });

        return nonBreakableBlocks;
      }

      CodeMirror.extendMode("javascript", {
        commentStart: "/*",
        commentEnd: "*/",
        wordWrapChars: [";", "\\{", "\\}"],

        autoFormatLineBreaks: function (text) {
          var curPos = 0;
          var split = this.jsonMode ? function (str) {
            return str.replace(/([,{])/g, "$1\n").replace(/}/g, "\n}");
          } : function (str) {
            return str.replace(/(;|\{|\})([^\r\n;])/g, "$1\n$2");
          };
          var nonBreakableBlocks = jsNonBreakableBlocks(text),
              res = "";
          if (nonBreakableBlocks != null) {
            for (var i = 0; i < nonBreakableBlocks.length; i++) {
              if (nonBreakableBlocks[i].start > curPos) {
                // Break lines till the block
                res += split(text.substring(curPos, nonBreakableBlocks[i].start));
                curPos = nonBreakableBlocks[i].start;
              }
              if (nonBreakableBlocks[i].start <= curPos && nonBreakableBlocks[i].end >= curPos) {
                // Skip non-breakable block
                res += text.substring(curPos, nonBreakableBlocks[i].end);
                curPos = nonBreakableBlocks[i].end;
              }
            }
            if (curPos < text.length) res += split(text.substr(curPos));
          } else {
            res = split(text);
          }
          return res.replace(/^\n*|\n*$/, "");
        }
      });

      CodeMirror.extendMode("xml", {
        commentStart: "<!--",
        commentEnd: "-->",
        wordWrapChars: [">"],

        autoFormatLineBreaks: function (text) {
          var lines = text.split("\n");
          var reProcessedPortion = new RegExp("(^\\s*?<|^[^<]*?)(.+)(>\\s*?$|[^>]*?$)");
          var reOpenBrackets = new RegExp("<", "g");
          var reCloseBrackets = new RegExp("(>)([^\r\n])", "g");
          for (var i = 0; i < lines.length; i++) {
            var mToProcess = lines[i].match(reProcessedPortion);
            if (mToProcess != null && mToProcess.length > 3) {
              // The line starts with whitespaces and ends with whitespaces
              lines[i] = mToProcess[1] + mToProcess[2].replace(reOpenBrackets, "\n$&").replace(reCloseBrackets, "$1\n$2") + mToProcess[3];
              continue;
            }
          }
          return lines.join("\n");
        }
      });

      function localModeAt(cm, pos) {
        return CodeMirror.innerMode(cm.getMode(), cm.getTokenAt(pos).state).mode;
      }

      function enumerateModesBetween(cm, line, start, end) {
        var outer = cm.getMode(),
            text = cm.getLine(line);
        if (end == null) end = text.length;
        if (!outer.innerMode) return [{ from: start, to: end, mode: outer }];
        var state = cm.getTokenAt({ line: line, ch: start }).state;
        var mode = CodeMirror.innerMode(outer, state).mode;
        var found = [],
            stream = new CodeMirror.StringStream(text);
        stream.pos = stream.start = start;
        for (;;) {
          outer.token(stream, state);
          var curMode = CodeMirror.innerMode(outer, state).mode;
          if (curMode != mode) {
            var cut = stream.start;
            // Crappy heuristic to deal with the fact that a change in
            // mode can occur both at the end and the start of a token,
            // and we don't know which it was.
            if (mode.name == "xml" && text.charAt(stream.pos - 1) == ">") cut = stream.pos;
            found.push({ from: start, to: cut, mode: mode });
            start = cut;
            mode = curMode;
          }
          if (stream.pos >= end) break;
          stream.start = stream.pos;
        }
        if (start < end) found.push({ from: start, to: end, mode: mode });
        return found;
      }

      // Comment/uncomment the specified range
      CodeMirror.defineExtension("commentRange", function (isComment, from, to) {
        var curMode = localModeAt(this, from),
            cm = this;
        this.operation(function () {
          if (isComment) {
            // Comment range
            cm.replaceRange(curMode.commentEnd, to);
            cm.replaceRange(curMode.commentStart, from);
            if (from.line == to.line && from.ch == to.ch) // An empty comment inserted - put cursor inside
              cm.setCursor(from.line, from.ch + curMode.commentStart.length);
          } else {
            // Uncomment range
            var selText = cm.getRange(from, to);
            var startIndex = selText.indexOf(curMode.commentStart);
            var endIndex = selText.lastIndexOf(curMode.commentEnd);
            if (startIndex > -1 && endIndex > -1 && endIndex > startIndex) {
              // Take string till comment start
              selText = selText.substr(0, startIndex)
              // From comment start till comment end
              + selText.substring(startIndex + curMode.commentStart.length, endIndex)
              // From comment end till string end
              + selText.substr(endIndex + curMode.commentEnd.length);
            }
            cm.replaceRange(selText, from, to);
          }
        });
      });

      // Applies automatic mode-aware indentation to the specified range
      CodeMirror.defineExtension("autoIndentRange", function (from, to) {
        var cmInstance = this;
        this.operation(function () {
          for (var i = from.line; i <= to.line; i++) {
            cmInstance.indentLine(i, "smart");
          }
        });
      });

      // Applies automatic formatting to the specified range
      CodeMirror.defineExtension("autoFormatRange", function (from, to) {
        var cm = this;
        cm.operation(function () {
          for (var cur = from.line, end = to.line; cur <= end; ++cur) {
            var f = { line: cur, ch: cur == from.line ? from.ch : 0 };
            var t = { line: cur, ch: cur == end ? to.ch : null };
            var modes = enumerateModesBetween(cm, cur, f.ch, t.ch),
                mangled = "";
            var text = cm.getRange(f, t);
            for (var i = 0; i < modes.length; ++i) {
              var part = modes.length > 1 ? text.slice(modes[i].from, modes[i].to) : text;
              if (mangled) mangled += "\n";
              if (modes[i].mode.autoFormatLineBreaks) {
                mangled += modes[i].mode.autoFormatLineBreaks(part);
              } else mangled += text;
            }
            if (mangled != text) {
              for (var count = 0, pos = mangled.indexOf("\n"); pos != -1; pos = mangled.indexOf("\n", pos + 1), ++count) {}
              cm.replaceRange(mangled, f, t);
              cur += count;
              end += count;
            }
          }
          for (var cur = from.line + 1; cur <= end; ++cur) cm.indentLine(cur, "smart");
          cm.setSelection(from, cm.getCursor(false));
        });
      });
    })();
  })(this);

  return _retrieveGlobal();
});
$__System.registerDynamic('84', ['28'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /**
     * Super simple wysiwyg editor v0.8.10
     * https://summernote.org
     *
     * Copyright 2013- Alan Hong. and other contributors
     * summernote may be freely distributed under the MIT license.
     *
     * Date: 2018-02-20T00:34Z
     */
    (function (global, factory) {
        typeof exports === 'object' && typeof module !== 'undefined' ? factory($__require('28')) : typeof undefined === 'function' && define.amd ? define(['jquery'], factory) : factory(global.jQuery);
    })(this, function ($$1) {
        'use strict';

        $$1 = $$1 && $$1.hasOwnProperty('default') ? $$1['default'] : $$1;

        var Renderer = /** @class */function () {
            function Renderer(markup, children, options, callback) {
                this.markup = markup;
                this.children = children;
                this.options = options;
                this.callback = callback;
            }
            Renderer.prototype.render = function ($parent) {
                var $node = $$1(this.markup);
                if (this.options && this.options.contents) {
                    $node.html(this.options.contents);
                }
                if (this.options && this.options.className) {
                    $node.addClass(this.options.className);
                }
                if (this.options && this.options.data) {
                    $$1.each(this.options.data, function (k, v) {
                        $node.attr('data-' + k, v);
                    });
                }
                if (this.options && this.options.click) {
                    $node.on('click', this.options.click);
                }
                if (this.children) {
                    var $container_1 = $node.find('.note-children-container');
                    this.children.forEach(function (child) {
                        child.render($container_1.length ? $container_1 : $node);
                    });
                }
                if (this.callback) {
                    this.callback($node, this.options);
                }
                if (this.options && this.options.callback) {
                    this.options.callback($node);
                }
                if ($parent) {
                    $parent.append($node);
                }
                return $node;
            };
            return Renderer;
        }();
        var renderer = {
            create: function (markup, callback) {
                return function () {
                    var options = typeof arguments[1] === 'object' ? arguments[1] : arguments[0];
                    var children = $$1.isArray(arguments[0]) ? arguments[0] : [];
                    if (options && options.children) {
                        children = options.children;
                    }
                    return new Renderer(markup, children, options, callback);
                };
            }
        };

        var editor = renderer.create('<div class="note-editor note-frame panel"/>');
        var toolbar = renderer.create('<div class="note-toolbar-wrapper panel-default"><div class="note-toolbar panel-heading" role="toolbar"></div></div>');
        var editingArea = renderer.create('<div class="note-editing-area"/>');
        var codable = renderer.create('<textarea class="note-codable" role="textbox" aria-multiline="true"/>');
        var editable = renderer.create('<div class="note-editable" contentEditable="true" role="textbox" aria-multiline="true"/>');
        var statusbar = renderer.create(['<output class="note-status-output" aria-live="polite"/>', '<div class="note-statusbar" role="status">', '  <div class="note-resizebar" role="seperator" aria-orientation="horizontal" aria-label="Resize">', '    <div class="note-icon-bar"/>', '    <div class="note-icon-bar"/>', '    <div class="note-icon-bar"/>', '  </div>', '</div>'].join(''));
        var airEditor = renderer.create('<div class="note-editor"/>');
        var airEditable = renderer.create(['  <output class="note-status-output" aria-live="polite"/>', '<div class="note-editable" contentEditable="true" role="textbox" aria-multiline="true"/>'].join(''));
        var buttonGroup = renderer.create('<div class="note-btn-group btn-group">');
        var dropdown = renderer.create('<ul class="dropdown-menu" role="list">', function ($node, options) {
            var markup = $$1.isArray(options.items) ? options.items.map(function (item) {
                var value = typeof item === 'string' ? item : item.value || '';
                var content = options.template ? options.template(item) : item;
                var option = typeof item === 'object' ? item.option : undefined;
                var dataValue = 'data-value="' + value + '"';
                var dataOption = option !== undefined ? ' data-option="' + option + '"' : '';
                return '<li role="listitem" aria-label="' + item + '"><a href="#" ' + (dataValue + dataOption) + '>' + content + '</a></li>';
            }).join('') : options.items;
            $node.html(markup).attr({ 'aria-label': options.title });
        });
        var dropdownButtonContents = function (contents, options) {
            return contents + ' ' + icon(options.icons.caret, 'span');
        };
        var dropdownCheck = renderer.create('<ul class="dropdown-menu note-check" role="list">', function ($node, options) {
            var markup = $$1.isArray(options.items) ? options.items.map(function (item) {
                var value = typeof item === 'string' ? item : item.value || '';
                var content = options.template ? options.template(item) : item;
                return '<li role="listitem" aria-label="' + item + '"><a href="#" data-value="' + value + '">' + icon(options.checkClassName) + ' ' + content + '</a></li>';
            }).join('') : options.items;
            $node.html(markup).attr({ 'aria-label': options.title });
        });
        var palette = renderer.create('<div class="note-color-palette"/>', function ($node, options) {
            var contents = [];
            for (var row = 0, rowSize = options.colors.length; row < rowSize; row++) {
                var eventName = options.eventName;
                var colors = options.colors[row];
                var colorsName = options.colorsName[row];
                var buttons = [];
                for (var col = 0, colSize = colors.length; col < colSize; col++) {
                    var color = colors[col];
                    var colorName = colorsName[col];
                    buttons.push(['<button type="button" class="note-color-btn"', 'style="background-color:', color, '" ', 'data-event="', eventName, '" ', 'data-value="', color, '" ', 'title="', colorName, '" ', 'aria-label="', colorName, '" ', 'data-toggle="button" tabindex="-1"></button>'].join(''));
                }
                contents.push('<div class="note-color-row">' + buttons.join('') + '</div>');
            }
            $node.html(contents.join(''));
            if (options.tooltip) {
                $node.find('.note-color-btn').tooltip({
                    container: options.container,
                    trigger: 'hover',
                    placement: 'bottom'
                });
            }
        });
        var dialog = renderer.create('<div class="modal" aria-hidden="false" tabindex="-1" role="dialog"/>', function ($node, options) {
            if (options.fade) {
                $node.addClass('fade');
            }
            $node.attr({
                'aria-label': options.title
            });
            $node.html(['<div class="modal-dialog">', '  <div class="modal-content">', options.title ? '    <div class="modal-header">' + '      <button type="button" class="close" data-dismiss="modal" aria-label="Close" aria-hidden="true">&times;</button>' + '      <h4 class="modal-title">' + options.title + '</h4>' + '    </div>' : '', '    <div class="modal-body">' + options.body + '</div>', options.footer ? '    <div class="modal-footer">' + options.footer + '</div>' : '', '  </div>', '</div>'].join(''));
        });
        var popover = renderer.create(['<div class="note-popover popover in">', '  <div class="arrow"/>', '  <div class="popover-content note-children-container"/>', '</div>'].join(''), function ($node, options) {
            var direction = typeof options.direction !== 'undefined' ? options.direction : 'bottom';
            $node.addClass(direction);
            if (options.hideArrow) {
                $node.find('.arrow').hide();
            }
        });
        var checkbox = renderer.create('<div class="checkbox"></div>', function ($node, options) {
            $node.html([' <label' + (options.id ? ' for="' + options.id + '"' : '') + '>', ' <input role="checkbox" type="checkbox"' + (options.id ? ' id="' + options.id + '"' : ''), options.checked ? ' checked' : '', ' aria-checked="' + (options.checked ? 'true' : 'false') + '"/>', options.text ? options.text : '', '</label>'].join(''));
        });
        var icon = function (iconClassName, tagName) {
            tagName = tagName || 'i';
            return '<' + tagName + ' class="' + iconClassName + '"/>';
        };
        var ui = {
            editor: editor,
            toolbar: toolbar,
            editingArea: editingArea,
            codable: codable,
            editable: editable,
            statusbar: statusbar,
            airEditor: airEditor,
            airEditable: airEditable,
            buttonGroup: buttonGroup,
            dropdown: dropdown,
            dropdownButtonContents: dropdownButtonContents,
            dropdownCheck: dropdownCheck,
            palette: palette,
            dialog: dialog,
            popover: popover,
            checkbox: checkbox,
            icon: icon,
            options: {},
            button: function ($node, options) {
                return renderer.create('<button type="button" class="note-btn btn btn-default btn-sm" role="button" tabindex="-1">', function ($node, options) {
                    if (options && options.tooltip) {
                        $node.attr({
                            title: options.tooltip,
                            'aria-label': options.tooltip
                        }).tooltip({
                            container: options.container,
                            trigger: 'hover',
                            placement: 'bottom'
                        });
                    }
                })($node, options);
            },
            toggleBtn: function ($btn, isEnable) {
                $btn.toggleClass('disabled', !isEnable);
                $btn.attr('disabled', !isEnable);
            },
            toggleBtnActive: function ($btn, isActive) {
                $btn.toggleClass('active', isActive);
            },
            onDialogShown: function ($dialog, handler) {
                $dialog.one('shown.bs.modal', handler);
            },
            onDialogHidden: function ($dialog, handler) {
                $dialog.one('hidden.bs.modal', handler);
            },
            showDialog: function ($dialog) {
                $dialog.modal('show');
            },
            hideDialog: function ($dialog) {
                $dialog.modal('hide');
            },
            createLayout: function ($note, options) {
                var $editor = (options.airMode ? ui.airEditor([ui.editingArea([ui.airEditable()])]) : ui.editor([ui.toolbar(), ui.editingArea([ui.codable(), ui.editable()]), ui.statusbar()])).render();
                $editor.insertAfter($note);
                return {
                    note: $note,
                    editor: $editor,
                    toolbar: $editor.find('.note-toolbar'),
                    editingArea: $editor.find('.note-editing-area'),
                    editable: $editor.find('.note-editable'),
                    codable: $editor.find('.note-codable'),
                    statusbar: $editor.find('.note-statusbar')
                };
            },
            removeLayout: function ($note, layoutInfo) {
                $note.html(layoutInfo.editable.html());
                layoutInfo.editor.remove();
                $note.show();
            }
        };

        /**
         * @class core.func
         *
         * func utils (for high-order func's arg)
         *
         * @singleton
         * @alternateClassName func
         */
        function eq(itemA) {
            return function (itemB) {
                return itemA === itemB;
            };
        }
        function eq2(itemA, itemB) {
            return itemA === itemB;
        }
        function peq2(propName) {
            return function (itemA, itemB) {
                return itemA[propName] === itemB[propName];
            };
        }
        function ok() {
            return true;
        }
        function fail() {
            return false;
        }
        function not(f) {
            return function () {
                return !f.apply(f, arguments);
            };
        }
        function and(fA, fB) {
            return function (item) {
                return fA(item) && fB(item);
            };
        }
        function self(a) {
            return a;
        }
        function invoke(obj, method) {
            return function () {
                return obj[method].apply(obj, arguments);
            };
        }
        var idCounter = 0;
        /**
         * generate a globally-unique id
         *
         * @param {String} [prefix]
         */
        function uniqueId(prefix) {
            var id = ++idCounter + '';
            return prefix ? prefix + id : id;
        }
        /**
         * returns bnd (bounds) from rect
         *
         * - IE Compatibility Issue: http://goo.gl/sRLOAo
         * - Scroll Issue: http://goo.gl/sNjUc
         *
         * @param {Rect} rect
         * @return {Object} bounds
         * @return {Number} bounds.top
         * @return {Number} bounds.left
         * @return {Number} bounds.width
         * @return {Number} bounds.height
         */
        function rect2bnd(rect) {
            var $document = $(document);
            return {
                top: rect.top + $document.scrollTop(),
                left: rect.left + $document.scrollLeft(),
                width: rect.right - rect.left,
                height: rect.bottom - rect.top
            };
        }
        /**
         * returns a copy of the object where the keys have become the values and the values the keys.
         * @param {Object} obj
         * @return {Object}
         */
        function invertObject(obj) {
            var inverted = {};
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    inverted[obj[key]] = key;
                }
            }
            return inverted;
        }
        /**
         * @param {String} namespace
         * @param {String} [prefix]
         * @return {String}
         */
        function namespaceToCamel(namespace, prefix) {
            prefix = prefix || '';
            return prefix + namespace.split('.').map(function (name) {
                return name.substring(0, 1).toUpperCase() + name.substring(1);
            }).join('');
        }
        /**
         * Returns a function, that, as long as it continues to be invoked, will not
         * be triggered. The function will be called after it stops being called for
         * N milliseconds. If `immediate` is passed, trigger the function on the
         * leading edge, instead of the trailing.
         * @param {Function} func
         * @param {Number} wait
         * @param {Boolean} immediate
         * @return {Function}
         */
        function debounce(func, wait, immediate) {
            var _this = this;
            var timeout;
            return function () {
                var context = _this;
                var args = arguments;
                var later = function () {
                    timeout = null;
                    if (!immediate) {
                        func.apply(context, args);
                    }
                };
                var callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) {
                    func.apply(context, args);
                }
            };
        }
        var func = {
            eq: eq,
            eq2: eq2,
            peq2: peq2,
            ok: ok,
            fail: fail,
            self: self,
            not: not,
            and: and,
            invoke: invoke,
            uniqueId: uniqueId,
            rect2bnd: rect2bnd,
            invertObject: invertObject,
            namespaceToCamel: namespaceToCamel,
            debounce: debounce
        };

        /**
         * returns the first item of an array.
         *
         * @param {Array} array
         */
        function head(array) {
            return array[0];
        }
        /**
         * returns the last item of an array.
         *
         * @param {Array} array
         */
        function last(array) {
            return array[array.length - 1];
        }
        /**
         * returns everything but the last entry of the array.
         *
         * @param {Array} array
         */
        function initial(array) {
            return array.slice(0, array.length - 1);
        }
        /**
         * returns the rest of the items in an array.
         *
         * @param {Array} array
         */
        function tail(array) {
            return array.slice(1);
        }
        /**
         * returns item of array
         */
        function find(array, pred) {
            for (var idx = 0, len = array.length; idx < len; idx++) {
                var item = array[idx];
                if (pred(item)) {
                    return item;
                }
            }
        }
        /**
         * returns true if all of the values in the array pass the predicate truth test.
         */
        function all(array, pred) {
            for (var idx = 0, len = array.length; idx < len; idx++) {
                if (!pred(array[idx])) {
                    return false;
                }
            }
            return true;
        }
        /**
         * returns index of item
         */
        function indexOf(array, item) {
            return $$1.inArray(item, array);
        }
        /**
         * returns true if the value is present in the list.
         */
        function contains(array, item) {
            return indexOf(array, item) !== -1;
        }
        /**
         * get sum from a list
         *
         * @param {Array} array - array
         * @param {Function} fn - iterator
         */
        function sum(array, fn) {
            fn = fn || func.self;
            return array.reduce(function (memo, v) {
                return memo + fn(v);
            }, 0);
        }
        /**
         * returns a copy of the collection with array type.
         * @param {Collection} collection - collection eg) node.childNodes, ...
         */
        function from(collection) {
            var result = [];
            var length = collection.length;
            var idx = -1;
            while (++idx < length) {
                result[idx] = collection[idx];
            }
            return result;
        }
        /**
         * returns whether list is empty or not
         */
        function isEmpty$1(array) {
            return !array || !array.length;
        }
        /**
         * cluster elements by predicate function.
         *
         * @param {Array} array - array
         * @param {Function} fn - predicate function for cluster rule
         * @param {Array[]}
         */
        function clusterBy(array, fn) {
            if (!array.length) {
                return [];
            }
            var aTail = tail(array);
            return aTail.reduce(function (memo, v) {
                var aLast = last(memo);
                if (fn(last(aLast), v)) {
                    aLast[aLast.length] = v;
                } else {
                    memo[memo.length] = [v];
                }
                return memo;
            }, [[head(array)]]);
        }
        /**
         * returns a copy of the array with all false values removed
         *
         * @param {Array} array - array
         * @param {Function} fn - predicate function for cluster rule
         */
        function compact(array) {
            var aResult = [];
            for (var idx = 0, len = array.length; idx < len; idx++) {
                if (array[idx]) {
                    aResult.push(array[idx]);
                }
            }
            return aResult;
        }
        /**
         * produces a duplicate-free version of the array
         *
         * @param {Array} array
         */
        function unique(array) {
            var results = [];
            for (var idx = 0, len = array.length; idx < len; idx++) {
                if (!contains(results, array[idx])) {
                    results.push(array[idx]);
                }
            }
            return results;
        }
        /**
         * returns next item.
         * @param {Array} array
         */
        function next(array, item) {
            var idx = indexOf(array, item);
            if (idx === -1) {
                return null;
            }
            return array[idx + 1];
        }
        /**
         * returns prev item.
         * @param {Array} array
         */
        function prev(array, item) {
            var idx = indexOf(array, item);
            if (idx === -1) {
                return null;
            }
            return array[idx - 1];
        }
        /**
         * @class core.list
         *
         * list utils
         *
         * @singleton
         * @alternateClassName list
         */
        var lists = {
            head: head,
            last: last,
            initial: initial,
            tail: tail,
            prev: prev,
            next: next,
            find: find,
            contains: contains,
            all: all,
            sum: sum,
            from: from,
            isEmpty: isEmpty$1,
            clusterBy: clusterBy,
            compact: compact,
            unique: unique
        };

        var isSupportAmd = typeof undefined === 'function' && define.amd; // eslint-disable-line
        /**
         * returns whether font is installed or not.
         *
         * @param {String} fontName
         * @return {Boolean}
         */
        function isFontInstalled(fontName) {
            var testFontName = fontName === 'Comic Sans MS' ? 'Courier New' : 'Comic Sans MS';
            var $tester = $$1('<div>').css({
                position: 'absolute',
                left: '-9999px',
                top: '-9999px',
                fontSize: '200px'
            }).text('mmmmmmmmmwwwwwww').appendTo(document.body);
            var originalWidth = $tester.css('fontFamily', testFontName).width();
            var width = $tester.css('fontFamily', fontName + ',' + testFontName).width();
            $tester.remove();
            return originalWidth !== width;
        }
        var userAgent = navigator.userAgent;
        var isMSIE = /MSIE|Trident/i.test(userAgent);
        var browserVersion;
        if (isMSIE) {
            var matches = /MSIE (\d+[.]\d+)/.exec(userAgent);
            if (matches) {
                browserVersion = parseFloat(matches[1]);
            }
            matches = /Trident\/.*rv:([0-9]{1,}[.0-9]{0,})/.exec(userAgent);
            if (matches) {
                browserVersion = parseFloat(matches[1]);
            }
        }
        var isEdge = /Edge\/\d+/.test(userAgent);
        var hasCodeMirror = !!window.CodeMirror;
        if (!hasCodeMirror && isSupportAmd) {
            // Webpack
            if (typeof __webpack_require__ === 'function') {
                try {
                    // If CodeMirror can't be resolved, `require.resolve` will throw an
                    // exception and `hasCodeMirror` won't be set to `true`.
                    $__require.resolve('codemirror');
                    hasCodeMirror = true;
                } catch (e) {
                    // do nothing
                }
            } else if (typeof $__require !== 'undefined') {
                // Browserify
                if (typeof $__require.resolve !== 'undefined') {
                    try {
                        // If CodeMirror can't be resolved, `require.resolve` will throw an
                        // exception and `hasCodeMirror` won't be set to `true`.
                        $__require.resolve('codemirror');
                        hasCodeMirror = true;
                    } catch (e) {}
                    // do nothing

                    // Almond/Require
                } else if (typeof $__require.specified !== 'undefined') {
                    hasCodeMirror = $__require.specified('codemirror');
                }
            }
        }
        var isSupportTouch = 'ontouchstart' in window || navigator.MaxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
        // [workaround] IE doesn't have input events for contentEditable
        // - see: https://goo.gl/4bfIvA
        var inputEventName = isMSIE || isEdge ? 'DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted' : 'input';
        /**
         * @class core.env
         *
         * Object which check platform and agent
         *
         * @singleton
         * @alternateClassName env
         */
        var env = {
            isMac: navigator.appVersion.indexOf('Mac') > -1,
            isMSIE: isMSIE,
            isEdge: isEdge,
            isFF: !isEdge && /firefox/i.test(userAgent),
            isPhantom: /PhantomJS/i.test(userAgent),
            isWebkit: !isEdge && /webkit/i.test(userAgent),
            isChrome: !isEdge && /chrome/i.test(userAgent),
            isSafari: !isEdge && /safari/i.test(userAgent),
            browserVersion: browserVersion,
            jqueryVersion: parseFloat($$1.fn.jquery),
            isSupportAmd: isSupportAmd,
            isSupportTouch: isSupportTouch,
            hasCodeMirror: hasCodeMirror,
            isFontInstalled: isFontInstalled,
            isW3CRangeSupport: !!document.createRange,
            inputEventName: inputEventName
        };

        var NBSP_CHAR = String.fromCharCode(160);
        var ZERO_WIDTH_NBSP_CHAR = '\ufeff';
        /**
         * @method isEditable
         *
         * returns whether node is `note-editable` or not.
         *
         * @param {Node} node
         * @return {Boolean}
         */
        function isEditable(node) {
            return node && $$1(node).hasClass('note-editable');
        }
        /**
         * @method isControlSizing
         *
         * returns whether node is `note-control-sizing` or not.
         *
         * @param {Node} node
         * @return {Boolean}
         */
        function isControlSizing(node) {
            return node && $$1(node).hasClass('note-control-sizing');
        }
        /**
         * @method makePredByNodeName
         *
         * returns predicate which judge whether nodeName is same
         *
         * @param {String} nodeName
         * @return {Function}
         */
        function makePredByNodeName(nodeName) {
            nodeName = nodeName.toUpperCase();
            return function (node) {
                return node && node.nodeName.toUpperCase() === nodeName;
            };
        }
        /**
         * @method isText
         *
         *
         *
         * @param {Node} node
         * @return {Boolean} true if node's type is text(3)
         */
        function isText(node) {
            return node && node.nodeType === 3;
        }
        /**
         * @method isElement
         *
         *
         *
         * @param {Node} node
         * @return {Boolean} true if node's type is element(1)
         */
        function isElement(node) {
            return node && node.nodeType === 1;
        }
        /**
         * ex) br, col, embed, hr, img, input, ...
         * @see http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
         */
        function isVoid(node) {
            return node && /^BR|^IMG|^HR|^IFRAME|^BUTTON|^INPUT/.test(node.nodeName.toUpperCase());
        }
        function isPara(node) {
            if (isEditable(node)) {
                return false;
            }
            // Chrome(v31.0), FF(v25.0.1) use DIV for paragraph
            return node && /^DIV|^P|^LI|^H[1-7]/.test(node.nodeName.toUpperCase());
        }
        function isHeading(node) {
            return node && /^H[1-7]/.test(node.nodeName.toUpperCase());
        }
        var isPre = makePredByNodeName('PRE');
        var isLi = makePredByNodeName('LI');
        function isPurePara(node) {
            return isPara(node) && !isLi(node);
        }
        var isTable = makePredByNodeName('TABLE');
        var isData = makePredByNodeName('DATA');
        function isInline(node) {
            return !isBodyContainer(node) && !isList(node) && !isHr(node) && !isPara(node) && !isTable(node) && !isBlockquote(node) && !isData(node);
        }
        function isList(node) {
            return node && /^UL|^OL/.test(node.nodeName.toUpperCase());
        }
        var isHr = makePredByNodeName('HR');
        function isCell(node) {
            return node && /^TD|^TH/.test(node.nodeName.toUpperCase());
        }
        var isBlockquote = makePredByNodeName('BLOCKQUOTE');
        function isBodyContainer(node) {
            return isCell(node) || isBlockquote(node) || isEditable(node);
        }
        var isAnchor = makePredByNodeName('A');
        function isParaInline(node) {
            return isInline(node) && !!ancestor(node, isPara);
        }
        function isBodyInline(node) {
            return isInline(node) && !ancestor(node, isPara);
        }
        var isBody = makePredByNodeName('BODY');
        /**
         * returns whether nodeB is closest sibling of nodeA
         *
         * @param {Node} nodeA
         * @param {Node} nodeB
         * @return {Boolean}
         */
        function isClosestSibling(nodeA, nodeB) {
            return nodeA.nextSibling === nodeB || nodeA.previousSibling === nodeB;
        }
        /**
         * returns array of closest siblings with node
         *
         * @param {Node} node
         * @param {function} [pred] - predicate function
         * @return {Node[]}
         */
        function withClosestSiblings(node, pred) {
            pred = pred || func.ok;
            var siblings = [];
            if (node.previousSibling && pred(node.previousSibling)) {
                siblings.push(node.previousSibling);
            }
            siblings.push(node);
            if (node.nextSibling && pred(node.nextSibling)) {
                siblings.push(node.nextSibling);
            }
            return siblings;
        }
        /**
         * blank HTML for cursor position
         * - [workaround] old IE only works with &nbsp;
         * - [workaround] IE11 and other browser works with bogus br
         */
        var blankHTML = env.isMSIE && env.browserVersion < 11 ? '&nbsp;' : '<br>';
        /**
         * @method nodeLength
         *
         * returns #text's text size or element's childNodes size
         *
         * @param {Node} node
         */
        function nodeLength(node) {
            if (isText(node)) {
                return node.nodeValue.length;
            }
            if (node) {
                return node.childNodes.length;
            }
            return 0;
        }
        /**
         * returns whether node is empty or not.
         *
         * @param {Node} node
         * @return {Boolean}
         */
        function isEmpty(node) {
            var len = nodeLength(node);
            if (len === 0) {
                return true;
            } else if (!isText(node) && len === 1 && node.innerHTML === blankHTML) {
                // ex) <p><br></p>, <span><br></span>
                return true;
            } else if (lists.all(node.childNodes, isText) && node.innerHTML === '') {
                // ex) <p></p>, <span></span>
                return true;
            }
            return false;
        }
        /**
         * padding blankHTML if node is empty (for cursor position)
         */
        function paddingBlankHTML(node) {
            if (!isVoid(node) && !nodeLength(node)) {
                node.innerHTML = blankHTML;
            }
        }
        /**
         * find nearest ancestor predicate hit
         *
         * @param {Node} node
         * @param {Function} pred - predicate function
         */
        function ancestor(node, pred) {
            while (node) {
                if (pred(node)) {
                    return node;
                }
                if (isEditable(node)) {
                    break;
                }
                node = node.parentNode;
            }
            return null;
        }
        /**
         * find nearest ancestor only single child blood line and predicate hit
         *
         * @param {Node} node
         * @param {Function} pred - predicate function
         */
        function singleChildAncestor(node, pred) {
            node = node.parentNode;
            while (node) {
                if (nodeLength(node) !== 1) {
                    break;
                }
                if (pred(node)) {
                    return node;
                }
                if (isEditable(node)) {
                    break;
                }
                node = node.parentNode;
            }
            return null;
        }
        /**
         * returns new array of ancestor nodes (until predicate hit).
         *
         * @param {Node} node
         * @param {Function} [optional] pred - predicate function
         */
        function listAncestor(node, pred) {
            pred = pred || func.fail;
            var ancestors = [];
            ancestor(node, function (el) {
                if (!isEditable(el)) {
                    ancestors.push(el);
                }
                return pred(el);
            });
            return ancestors;
        }
        /**
         * find farthest ancestor predicate hit
         */
        function lastAncestor(node, pred) {
            var ancestors = listAncestor(node);
            return lists.last(ancestors.filter(pred));
        }
        /**
         * returns common ancestor node between two nodes.
         *
         * @param {Node} nodeA
         * @param {Node} nodeB
         */
        function commonAncestor(nodeA, nodeB) {
            var ancestors = listAncestor(nodeA);
            for (var n = nodeB; n; n = n.parentNode) {
                if ($$1.inArray(n, ancestors) > -1) {
                    return n;
                }
            }
            return null; // difference document area
        }
        /**
         * listing all previous siblings (until predicate hit).
         *
         * @param {Node} node
         * @param {Function} [optional] pred - predicate function
         */
        function listPrev(node, pred) {
            pred = pred || func.fail;
            var nodes = [];
            while (node) {
                if (pred(node)) {
                    break;
                }
                nodes.push(node);
                node = node.previousSibling;
            }
            return nodes;
        }
        /**
         * listing next siblings (until predicate hit).
         *
         * @param {Node} node
         * @param {Function} [pred] - predicate function
         */
        function listNext(node, pred) {
            pred = pred || func.fail;
            var nodes = [];
            while (node) {
                if (pred(node)) {
                    break;
                }
                nodes.push(node);
                node = node.nextSibling;
            }
            return nodes;
        }
        /**
         * listing descendant nodes
         *
         * @param {Node} node
         * @param {Function} [pred] - predicate function
         */
        function listDescendant(node, pred) {
            var descendants = [];
            pred = pred || func.ok;
            // start DFS(depth first search) with node
            (function fnWalk(current) {
                if (node !== current && pred(current)) {
                    descendants.push(current);
                }
                for (var idx = 0, len = current.childNodes.length; idx < len; idx++) {
                    fnWalk(current.childNodes[idx]);
                }
            })(node);
            return descendants;
        }
        /**
         * wrap node with new tag.
         *
         * @param {Node} node
         * @param {Node} tagName of wrapper
         * @return {Node} - wrapper
         */
        function wrap(node, wrapperName) {
            var parent = node.parentNode;
            var wrapper = $$1('<' + wrapperName + '>')[0];
            parent.insertBefore(wrapper, node);
            wrapper.appendChild(node);
            return wrapper;
        }
        /**
         * insert node after preceding
         *
         * @param {Node} node
         * @param {Node} preceding - predicate function
         */
        function insertAfter(node, preceding) {
            var next = preceding.nextSibling;
            var parent = preceding.parentNode;
            if (next) {
                parent.insertBefore(node, next);
            } else {
                parent.appendChild(node);
            }
            return node;
        }
        /**
         * append elements.
         *
         * @param {Node} node
         * @param {Collection} aChild
         */
        function appendChildNodes(node, aChild) {
            $$1.each(aChild, function (idx, child) {
                node.appendChild(child);
            });
            return node;
        }
        /**
         * returns whether boundaryPoint is left edge or not.
         *
         * @param {BoundaryPoint} point
         * @return {Boolean}
         */
        function isLeftEdgePoint(point) {
            return point.offset === 0;
        }
        /**
         * returns whether boundaryPoint is right edge or not.
         *
         * @param {BoundaryPoint} point
         * @return {Boolean}
         */
        function isRightEdgePoint(point) {
            return point.offset === nodeLength(point.node);
        }
        /**
         * returns whether boundaryPoint is edge or not.
         *
         * @param {BoundaryPoint} point
         * @return {Boolean}
         */
        function isEdgePoint(point) {
            return isLeftEdgePoint(point) || isRightEdgePoint(point);
        }
        /**
         * returns whether node is left edge of ancestor or not.
         *
         * @param {Node} node
         * @param {Node} ancestor
         * @return {Boolean}
         */
        function isLeftEdgeOf(node, ancestor) {
            while (node && node !== ancestor) {
                if (position(node) !== 0) {
                    return false;
                }
                node = node.parentNode;
            }
            return true;
        }
        /**
         * returns whether node is right edge of ancestor or not.
         *
         * @param {Node} node
         * @param {Node} ancestor
         * @return {Boolean}
         */
        function isRightEdgeOf(node, ancestor) {
            if (!ancestor) {
                return false;
            }
            while (node && node !== ancestor) {
                if (position(node) !== nodeLength(node.parentNode) - 1) {
                    return false;
                }
                node = node.parentNode;
            }
            return true;
        }
        /**
         * returns whether point is left edge of ancestor or not.
         * @param {BoundaryPoint} point
         * @param {Node} ancestor
         * @return {Boolean}
         */
        function isLeftEdgePointOf(point, ancestor) {
            return isLeftEdgePoint(point) && isLeftEdgeOf(point.node, ancestor);
        }
        /**
         * returns whether point is right edge of ancestor or not.
         * @param {BoundaryPoint} point
         * @param {Node} ancestor
         * @return {Boolean}
         */
        function isRightEdgePointOf(point, ancestor) {
            return isRightEdgePoint(point) && isRightEdgeOf(point.node, ancestor);
        }
        /**
         * returns offset from parent.
         *
         * @param {Node} node
         */
        function position(node) {
            var offset = 0;
            while (node = node.previousSibling) {
                offset += 1;
            }
            return offset;
        }
        function hasChildren(node) {
            return !!(node && node.childNodes && node.childNodes.length);
        }
        /**
         * returns previous boundaryPoint
         *
         * @param {BoundaryPoint} point
         * @param {Boolean} isSkipInnerOffset
         * @return {BoundaryPoint}
         */
        function prevPoint(point, isSkipInnerOffset) {
            var node;
            var offset;
            if (point.offset === 0) {
                if (isEditable(point.node)) {
                    return null;
                }
                node = point.node.parentNode;
                offset = position(point.node);
            } else if (hasChildren(point.node)) {
                node = point.node.childNodes[point.offset - 1];
                offset = nodeLength(node);
            } else {
                node = point.node;
                offset = isSkipInnerOffset ? 0 : point.offset - 1;
            }
            return {
                node: node,
                offset: offset
            };
        }
        /**
         * returns next boundaryPoint
         *
         * @param {BoundaryPoint} point
         * @param {Boolean} isSkipInnerOffset
         * @return {BoundaryPoint}
         */
        function nextPoint(point, isSkipInnerOffset) {
            var node, offset;
            if (nodeLength(point.node) === point.offset) {
                if (isEditable(point.node)) {
                    return null;
                }
                node = point.node.parentNode;
                offset = position(point.node) + 1;
            } else if (hasChildren(point.node)) {
                node = point.node.childNodes[point.offset];
                offset = 0;
            } else {
                node = point.node;
                offset = isSkipInnerOffset ? nodeLength(point.node) : point.offset + 1;
            }
            return {
                node: node,
                offset: offset
            };
        }
        /**
         * returns whether pointA and pointB is same or not.
         *
         * @param {BoundaryPoint} pointA
         * @param {BoundaryPoint} pointB
         * @return {Boolean}
         */
        function isSamePoint(pointA, pointB) {
            return pointA.node === pointB.node && pointA.offset === pointB.offset;
        }
        /**
         * returns whether point is visible (can set cursor) or not.
         *
         * @param {BoundaryPoint} point
         * @return {Boolean}
         */
        function isVisiblePoint(point) {
            if (isText(point.node) || !hasChildren(point.node) || isEmpty(point.node)) {
                return true;
            }
            var leftNode = point.node.childNodes[point.offset - 1];
            var rightNode = point.node.childNodes[point.offset];
            if ((!leftNode || isVoid(leftNode)) && (!rightNode || isVoid(rightNode))) {
                return true;
            }
            return false;
        }
        /**
         * @method prevPointUtil
         *
         * @param {BoundaryPoint} point
         * @param {Function} pred
         * @return {BoundaryPoint}
         */
        function prevPointUntil(point, pred) {
            while (point) {
                if (pred(point)) {
                    return point;
                }
                point = prevPoint(point);
            }
            return null;
        }
        /**
         * @method nextPointUntil
         *
         * @param {BoundaryPoint} point
         * @param {Function} pred
         * @return {BoundaryPoint}
         */
        function nextPointUntil(point, pred) {
            while (point) {
                if (pred(point)) {
                    return point;
                }
                point = nextPoint(point);
            }
            return null;
        }
        /**
         * returns whether point has character or not.
         *
         * @param {Point} point
         * @return {Boolean}
         */
        function isCharPoint(point) {
            if (!isText(point.node)) {
                return false;
            }
            var ch = point.node.nodeValue.charAt(point.offset - 1);
            return ch && ch !== ' ' && ch !== NBSP_CHAR;
        }
        /**
         * @method walkPoint
         *
         * @param {BoundaryPoint} startPoint
         * @param {BoundaryPoint} endPoint
         * @param {Function} handler
         * @param {Boolean} isSkipInnerOffset
         */
        function walkPoint(startPoint, endPoint, handler, isSkipInnerOffset) {
            var point = startPoint;
            while (point) {
                handler(point);
                if (isSamePoint(point, endPoint)) {
                    break;
                }
                var isSkipOffset = isSkipInnerOffset && startPoint.node !== point.node && endPoint.node !== point.node;
                point = nextPoint(point, isSkipOffset);
            }
        }
        /**
         * @method makeOffsetPath
         *
         * return offsetPath(array of offset) from ancestor
         *
         * @param {Node} ancestor - ancestor node
         * @param {Node} node
         */
        function makeOffsetPath(ancestor, node) {
            var ancestors = listAncestor(node, func.eq(ancestor));
            return ancestors.map(position).reverse();
        }
        /**
         * @method fromOffsetPath
         *
         * return element from offsetPath(array of offset)
         *
         * @param {Node} ancestor - ancestor node
         * @param {array} offsets - offsetPath
         */
        function fromOffsetPath(ancestor, offsets) {
            var current = ancestor;
            for (var i = 0, len = offsets.length; i < len; i++) {
                if (current.childNodes.length <= offsets[i]) {
                    current = current.childNodes[current.childNodes.length - 1];
                } else {
                    current = current.childNodes[offsets[i]];
                }
            }
            return current;
        }
        /**
         * @method splitNode
         *
         * split element or #text
         *
         * @param {BoundaryPoint} point
         * @param {Object} [options]
         * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false
         * @param {Boolean} [options.isNotSplitEdgePoint] - default: false
         * @return {Node} right node of boundaryPoint
         */
        function splitNode(point, options) {
            var isSkipPaddingBlankHTML = options && options.isSkipPaddingBlankHTML;
            var isNotSplitEdgePoint = options && options.isNotSplitEdgePoint;
            // edge case
            if (isEdgePoint(point) && (isText(point.node) || isNotSplitEdgePoint)) {
                if (isLeftEdgePoint(point)) {
                    return point.node;
                } else if (isRightEdgePoint(point)) {
                    return point.node.nextSibling;
                }
            }
            // split #text
            if (isText(point.node)) {
                return point.node.splitText(point.offset);
            } else {
                var childNode = point.node.childNodes[point.offset];
                var clone = insertAfter(point.node.cloneNode(false), point.node);
                appendChildNodes(clone, listNext(childNode));
                if (!isSkipPaddingBlankHTML) {
                    paddingBlankHTML(point.node);
                    paddingBlankHTML(clone);
                }
                return clone;
            }
        }
        /**
         * @method splitTree
         *
         * split tree by point
         *
         * @param {Node} root - split root
         * @param {BoundaryPoint} point
         * @param {Object} [options]
         * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false
         * @param {Boolean} [options.isNotSplitEdgePoint] - default: false
         * @return {Node} right node of boundaryPoint
         */
        function splitTree(root, point, options) {
            // ex) [#text, <span>, <p>]
            var ancestors = listAncestor(point.node, func.eq(root));
            if (!ancestors.length) {
                return null;
            } else if (ancestors.length === 1) {
                return splitNode(point, options);
            }
            return ancestors.reduce(function (node, parent) {
                if (node === point.node) {
                    node = splitNode(point, options);
                }
                return splitNode({
                    node: parent,
                    offset: node ? position(node) : nodeLength(parent)
                }, options);
            });
        }
        /**
         * split point
         *
         * @param {Point} point
         * @param {Boolean} isInline
         * @return {Object}
         */
        function splitPoint(point, isInline) {
            // find splitRoot, container
            //  - inline: splitRoot is a child of paragraph
            //  - block: splitRoot is a child of bodyContainer
            var pred = isInline ? isPara : isBodyContainer;
            var ancestors = listAncestor(point.node, pred);
            var topAncestor = lists.last(ancestors) || point.node;
            var splitRoot, container;
            if (pred(topAncestor)) {
                splitRoot = ancestors[ancestors.length - 2];
                container = topAncestor;
            } else {
                splitRoot = topAncestor;
                container = splitRoot.parentNode;
            }
            // if splitRoot is exists, split with splitTree
            var pivot = splitRoot && splitTree(splitRoot, point, {
                isSkipPaddingBlankHTML: isInline,
                isNotSplitEdgePoint: isInline
            });
            // if container is point.node, find pivot with point.offset
            if (!pivot && container === point.node) {
                pivot = point.node.childNodes[point.offset];
            }
            return {
                rightNode: pivot,
                container: container
            };
        }
        function create(nodeName) {
            return document.createElement(nodeName);
        }
        function createText(text) {
            return document.createTextNode(text);
        }
        /**
         * @method remove
         *
         * remove node, (isRemoveChild: remove child or not)
         *
         * @param {Node} node
         * @param {Boolean} isRemoveChild
         */
        function remove(node, isRemoveChild) {
            if (!node || !node.parentNode) {
                return;
            }
            if (node.removeNode) {
                return node.removeNode(isRemoveChild);
            }
            var parent = node.parentNode;
            if (!isRemoveChild) {
                var nodes = [];
                for (var i = 0, len = node.childNodes.length; i < len; i++) {
                    nodes.push(node.childNodes[i]);
                }
                for (var i = 0, len = nodes.length; i < len; i++) {
                    parent.insertBefore(nodes[i], node);
                }
            }
            parent.removeChild(node);
        }
        /**
         * @method removeWhile
         *
         * @param {Node} node
         * @param {Function} pred
         */
        function removeWhile(node, pred) {
            while (node) {
                if (isEditable(node) || !pred(node)) {
                    break;
                }
                var parent = node.parentNode;
                remove(node);
                node = parent;
            }
        }
        /**
         * @method replace
         *
         * replace node with provided nodeName
         *
         * @param {Node} node
         * @param {String} nodeName
         * @return {Node} - new node
         */
        function replace(node, nodeName) {
            if (node.nodeName.toUpperCase() === nodeName.toUpperCase()) {
                return node;
            }
            var newNode = create(nodeName);
            if (node.style.cssText) {
                newNode.style.cssText = node.style.cssText;
            }
            appendChildNodes(newNode, lists.from(node.childNodes));
            insertAfter(newNode, node);
            remove(node);
            return newNode;
        }
        var isTextarea = makePredByNodeName('TEXTAREA');
        /**
         * @param {jQuery} $node
         * @param {Boolean} [stripLinebreaks] - default: false
         */
        function value($node, stripLinebreaks) {
            var val = isTextarea($node[0]) ? $node.val() : $node.html();
            if (stripLinebreaks) {
                return val.replace(/[\n\r]/g, '');
            }
            return val;
        }
        /**
         * @method html
         *
         * get the HTML contents of node
         *
         * @param {jQuery} $node
         * @param {Boolean} [isNewlineOnBlock]
         */
        function html($node, isNewlineOnBlock) {
            var markup = value($node);
            if (isNewlineOnBlock) {
                var regexTag = /<(\/?)(\b(?!!)[^>\s]*)(.*?)(\s*\/?>)/g;
                markup = markup.replace(regexTag, function (match, endSlash, name) {
                    name = name.toUpperCase();
                    var isEndOfInlineContainer = /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(name) && !!endSlash;
                    var isBlockNode = /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(name);
                    return match + (isEndOfInlineContainer || isBlockNode ? '\n' : '');
                });
                markup = $$1.trim(markup);
            }
            return markup;
        }
        function posFromPlaceholder(placeholder) {
            var $placeholder = $$1(placeholder);
            var pos = $placeholder.offset();
            var height = $placeholder.outerHeight(true); // include margin
            return {
                left: pos.left,
                top: pos.top + height
            };
        }
        function attachEvents($node, events) {
            Object.keys(events).forEach(function (key) {
                $node.on(key, events[key]);
            });
        }
        function detachEvents($node, events) {
            Object.keys(events).forEach(function (key) {
                $node.off(key, events[key]);
            });
        }
        /**
         * @method isCustomStyleTag
         *
         * assert if a node contains a "note-styletag" class,
         * which implies that's a custom-made style tag node
         *
         * @param {Node} an HTML DOM node
         */
        function isCustomStyleTag(node) {
            return node && !isText(node) && lists.contains(node.classList, 'note-styletag');
        }
        var dom = {
            /** @property {String} NBSP_CHAR */
            NBSP_CHAR: NBSP_CHAR,
            /** @property {String} ZERO_WIDTH_NBSP_CHAR */
            ZERO_WIDTH_NBSP_CHAR: ZERO_WIDTH_NBSP_CHAR,
            /** @property {String} blank */
            blank: blankHTML,
            /** @property {String} emptyPara */
            emptyPara: "<p>" + blankHTML + "</p>",
            makePredByNodeName: makePredByNodeName,
            isEditable: isEditable,
            isControlSizing: isControlSizing,
            isText: isText,
            isElement: isElement,
            isVoid: isVoid,
            isPara: isPara,
            isPurePara: isPurePara,
            isHeading: isHeading,
            isInline: isInline,
            isBlock: func.not(isInline),
            isBodyInline: isBodyInline,
            isBody: isBody,
            isParaInline: isParaInline,
            isPre: isPre,
            isList: isList,
            isTable: isTable,
            isData: isData,
            isCell: isCell,
            isBlockquote: isBlockquote,
            isBodyContainer: isBodyContainer,
            isAnchor: isAnchor,
            isDiv: makePredByNodeName('DIV'),
            isLi: isLi,
            isBR: makePredByNodeName('BR'),
            isSpan: makePredByNodeName('SPAN'),
            isB: makePredByNodeName('B'),
            isU: makePredByNodeName('U'),
            isS: makePredByNodeName('S'),
            isI: makePredByNodeName('I'),
            isImg: makePredByNodeName('IMG'),
            isTextarea: isTextarea,
            isEmpty: isEmpty,
            isEmptyAnchor: func.and(isAnchor, isEmpty),
            isClosestSibling: isClosestSibling,
            withClosestSiblings: withClosestSiblings,
            nodeLength: nodeLength,
            isLeftEdgePoint: isLeftEdgePoint,
            isRightEdgePoint: isRightEdgePoint,
            isEdgePoint: isEdgePoint,
            isLeftEdgeOf: isLeftEdgeOf,
            isRightEdgeOf: isRightEdgeOf,
            isLeftEdgePointOf: isLeftEdgePointOf,
            isRightEdgePointOf: isRightEdgePointOf,
            prevPoint: prevPoint,
            nextPoint: nextPoint,
            isSamePoint: isSamePoint,
            isVisiblePoint: isVisiblePoint,
            prevPointUntil: prevPointUntil,
            nextPointUntil: nextPointUntil,
            isCharPoint: isCharPoint,
            walkPoint: walkPoint,
            ancestor: ancestor,
            singleChildAncestor: singleChildAncestor,
            listAncestor: listAncestor,
            lastAncestor: lastAncestor,
            listNext: listNext,
            listPrev: listPrev,
            listDescendant: listDescendant,
            commonAncestor: commonAncestor,
            wrap: wrap,
            insertAfter: insertAfter,
            appendChildNodes: appendChildNodes,
            position: position,
            hasChildren: hasChildren,
            makeOffsetPath: makeOffsetPath,
            fromOffsetPath: fromOffsetPath,
            splitTree: splitTree,
            splitPoint: splitPoint,
            create: create,
            createText: createText,
            remove: remove,
            removeWhile: removeWhile,
            replace: replace,
            html: html,
            value: value,
            posFromPlaceholder: posFromPlaceholder,
            attachEvents: attachEvents,
            detachEvents: detachEvents,
            isCustomStyleTag: isCustomStyleTag
        };

        $$1.summernote = $$1.summernote || {
            lang: {}
        };
        $$1.extend($$1.summernote.lang, {
            'en-US': {
                font: {
                    bold: 'Bold',
                    italic: 'Italic',
                    underline: 'Underline',
                    clear: 'Remove Font Style',
                    height: 'Line Height',
                    name: 'Font Family',
                    strikethrough: 'Strikethrough',
                    subscript: 'Subscript',
                    superscript: 'Superscript',
                    size: 'Font Size'
                },
                image: {
                    image: 'Picture',
                    insert: 'Insert Image',
                    resizeFull: 'Resize Full',
                    resizeHalf: 'Resize Half',
                    resizeQuarter: 'Resize Quarter',
                    floatLeft: 'Float Left',
                    floatRight: 'Float Right',
                    floatNone: 'Float None',
                    shapeRounded: 'Shape: Rounded',
                    shapeCircle: 'Shape: Circle',
                    shapeThumbnail: 'Shape: Thumbnail',
                    shapeNone: 'Shape: None',
                    dragImageHere: 'Drag image or text here',
                    dropImage: 'Drop image or Text',
                    selectFromFiles: 'Select from files',
                    maximumFileSize: 'Maximum file size',
                    maximumFileSizeError: 'Maximum file size exceeded.',
                    url: 'Image URL',
                    remove: 'Remove Image',
                    original: 'Original'
                },
                video: {
                    video: 'Video',
                    videoLink: 'Video Link',
                    insert: 'Insert Video',
                    url: 'Video URL',
                    providers: '(YouTube, Vimeo, Vine, Instagram, DailyMotion or Youku)'
                },
                link: {
                    link: 'Link',
                    insert: 'Insert Link',
                    unlink: 'Unlink',
                    edit: 'Edit',
                    textToDisplay: 'Text to display',
                    url: 'To what URL should this link go?',
                    openInNewWindow: 'Open in new window'
                },
                table: {
                    table: 'Table',
                    addRowAbove: 'Add row above',
                    addRowBelow: 'Add row below',
                    addColLeft: 'Add column left',
                    addColRight: 'Add column right',
                    delRow: 'Delete row',
                    delCol: 'Delete column',
                    delTable: 'Delete table'
                },
                hr: {
                    insert: 'Insert Horizontal Rule'
                },
                style: {
                    style: 'Style',
                    p: 'Normal',
                    blockquote: 'Quote',
                    pre: 'Code',
                    h1: 'Header 1',
                    h2: 'Header 2',
                    h3: 'Header 3',
                    h4: 'Header 4',
                    h5: 'Header 5',
                    h6: 'Header 6'
                },
                lists: {
                    unordered: 'Unordered list',
                    ordered: 'Ordered list'
                },
                options: {
                    help: 'Help',
                    fullscreen: 'Full Screen',
                    codeview: 'Code View'
                },
                paragraph: {
                    paragraph: 'Paragraph',
                    outdent: 'Outdent',
                    indent: 'Indent',
                    left: 'Align left',
                    center: 'Align center',
                    right: 'Align right',
                    justify: 'Justify full'
                },
                color: {
                    recent: 'Recent Color',
                    more: 'More Color',
                    background: 'Background Color',
                    foreground: 'Foreground Color',
                    transparent: 'Transparent',
                    setTransparent: 'Set transparent',
                    reset: 'Reset',
                    resetToDefault: 'Reset to default'
                },
                shortcut: {
                    shortcuts: 'Keyboard shortcuts',
                    close: 'Close',
                    textFormatting: 'Text formatting',
                    action: 'Action',
                    paragraphFormatting: 'Paragraph formatting',
                    documentStyle: 'Document Style',
                    extraKeys: 'Extra keys'
                },
                help: {
                    'insertParagraph': 'Insert Paragraph',
                    'undo': 'Undoes the last command',
                    'redo': 'Redoes the last command',
                    'tab': 'Tab',
                    'untab': 'Untab',
                    'bold': 'Set a bold style',
                    'italic': 'Set a italic style',
                    'underline': 'Set a underline style',
                    'strikethrough': 'Set a strikethrough style',
                    'removeFormat': 'Clean a style',
                    'justifyLeft': 'Set left align',
                    'justifyCenter': 'Set center align',
                    'justifyRight': 'Set right align',
                    'justifyFull': 'Set full align',
                    'insertUnorderedList': 'Toggle unordered list',
                    'insertOrderedList': 'Toggle ordered list',
                    'outdent': 'Outdent on current paragraph',
                    'indent': 'Indent on current paragraph',
                    'formatPara': 'Change current block\'s format as a paragraph(P tag)',
                    'formatH1': 'Change current block\'s format as H1',
                    'formatH2': 'Change current block\'s format as H2',
                    'formatH3': 'Change current block\'s format as H3',
                    'formatH4': 'Change current block\'s format as H4',
                    'formatH5': 'Change current block\'s format as H5',
                    'formatH6': 'Change current block\'s format as H6',
                    'insertHorizontalRule': 'Insert horizontal rule',
                    'linkDialog.show': 'Show Link Dialog'
                },
                history: {
                    undo: 'Undo',
                    redo: 'Redo'
                },
                specialChar: {
                    specialChar: 'SPECIAL CHARACTERS',
                    select: 'Select Special characters'
                }
            }
        });

        var KEY_MAP = {
            'BACKSPACE': 8,
            'TAB': 9,
            'ENTER': 13,
            'SPACE': 32,
            'DELETE': 46,
            // Arrow
            'LEFT': 37,
            'UP': 38,
            'RIGHT': 39,
            'DOWN': 40,
            // Number: 0-9
            'NUM0': 48,
            'NUM1': 49,
            'NUM2': 50,
            'NUM3': 51,
            'NUM4': 52,
            'NUM5': 53,
            'NUM6': 54,
            'NUM7': 55,
            'NUM8': 56,
            // Alphabet: a-z
            'B': 66,
            'E': 69,
            'I': 73,
            'J': 74,
            'K': 75,
            'L': 76,
            'R': 82,
            'S': 83,
            'U': 85,
            'V': 86,
            'Y': 89,
            'Z': 90,
            'SLASH': 191,
            'LEFTBRACKET': 219,
            'BACKSLASH': 220,
            'RIGHTBRACKET': 221
        };
        /**
         * @class core.key
         *
         * Object for keycodes.
         *
         * @singleton
         * @alternateClassName key
         */
        var key = {
            /**
             * @method isEdit
             *
             * @param {Number} keyCode
             * @return {Boolean}
             */
            isEdit: function (keyCode) {
                return lists.contains([KEY_MAP.BACKSPACE, KEY_MAP.TAB, KEY_MAP.ENTER, KEY_MAP.SPACE, KEY_MAP.DELETE], keyCode);
            },
            /**
             * @method isMove
             *
             * @param {Number} keyCode
             * @return {Boolean}
             */
            isMove: function (keyCode) {
                return lists.contains([KEY_MAP.LEFT, KEY_MAP.UP, KEY_MAP.RIGHT, KEY_MAP.DOWN], keyCode);
            },
            /**
             * @property {Object} nameFromCode
             * @property {String} nameFromCode.8 "BACKSPACE"
             */
            nameFromCode: func.invertObject(KEY_MAP),
            code: KEY_MAP
        };

        /**
         * return boundaryPoint from TextRange, inspired by Andy Na's HuskyRange.js
         *
         * @param {TextRange} textRange
         * @param {Boolean} isStart
         * @return {BoundaryPoint}
         *
         * @see http://msdn.microsoft.com/en-us/library/ie/ms535872(v=vs.85).aspx
         */
        function textRangeToPoint(textRange, isStart) {
            var container = textRange.parentElement();
            var offset;
            var tester = document.body.createTextRange();
            var prevContainer;
            var childNodes = lists.from(container.childNodes);
            for (offset = 0; offset < childNodes.length; offset++) {
                if (dom.isText(childNodes[offset])) {
                    continue;
                }
                tester.moveToElementText(childNodes[offset]);
                if (tester.compareEndPoints('StartToStart', textRange) >= 0) {
                    break;
                }
                prevContainer = childNodes[offset];
            }
            if (offset !== 0 && dom.isText(childNodes[offset - 1])) {
                var textRangeStart = document.body.createTextRange();
                var curTextNode = null;
                textRangeStart.moveToElementText(prevContainer || container);
                textRangeStart.collapse(!prevContainer);
                curTextNode = prevContainer ? prevContainer.nextSibling : container.firstChild;
                var pointTester = textRange.duplicate();
                pointTester.setEndPoint('StartToStart', textRangeStart);
                var textCount = pointTester.text.replace(/[\r\n]/g, '').length;
                while (textCount > curTextNode.nodeValue.length && curTextNode.nextSibling) {
                    textCount -= curTextNode.nodeValue.length;
                    curTextNode = curTextNode.nextSibling;
                }
                // [workaround] enforce IE to re-reference curTextNode, hack
                var dummy = curTextNode.nodeValue; // eslint-disable-line
                if (isStart && curTextNode.nextSibling && dom.isText(curTextNode.nextSibling) && textCount === curTextNode.nodeValue.length) {
                    textCount -= curTextNode.nodeValue.length;
                    curTextNode = curTextNode.nextSibling;
                }
                container = curTextNode;
                offset = textCount;
            }
            return {
                cont: container,
                offset: offset
            };
        }
        /**
         * return TextRange from boundary point (inspired by google closure-library)
         * @param {BoundaryPoint} point
         * @return {TextRange}
         */
        function pointToTextRange(point) {
            var textRangeInfo = function (container, offset) {
                var node, isCollapseToStart;
                if (dom.isText(container)) {
                    var prevTextNodes = dom.listPrev(container, func.not(dom.isText));
                    var prevContainer = lists.last(prevTextNodes).previousSibling;
                    node = prevContainer || container.parentNode;
                    offset += lists.sum(lists.tail(prevTextNodes), dom.nodeLength);
                    isCollapseToStart = !prevContainer;
                } else {
                    node = container.childNodes[offset] || container;
                    if (dom.isText(node)) {
                        return textRangeInfo(node, 0);
                    }
                    offset = 0;
                    isCollapseToStart = false;
                }
                return {
                    node: node,
                    collapseToStart: isCollapseToStart,
                    offset: offset
                };
            };
            var textRange = document.body.createTextRange();
            var info = textRangeInfo(point.node, point.offset);
            textRange.moveToElementText(info.node);
            textRange.collapse(info.collapseToStart);
            textRange.moveStart('character', info.offset);
            return textRange;
        }
        /**
           * Wrapped Range
           *
           * @constructor
           * @param {Node} sc - start container
           * @param {Number} so - start offset
           * @param {Node} ec - end container
           * @param {Number} eo - end offset
           */
        var WrappedRange = /** @class */function () {
            function WrappedRange(sc, so, ec, eo) {
                this.sc = sc;
                this.so = so;
                this.ec = ec;
                this.eo = eo;
                // isOnEditable: judge whether range is on editable or not
                this.isOnEditable = this.makeIsOn(dom.isEditable);
                // isOnList: judge whether range is on list node or not
                this.isOnList = this.makeIsOn(dom.isList);
                // isOnAnchor: judge whether range is on anchor node or not
                this.isOnAnchor = this.makeIsOn(dom.isAnchor);
                // isOnCell: judge whether range is on cell node or not
                this.isOnCell = this.makeIsOn(dom.isCell);
                // isOnData: judge whether range is on data node or not
                this.isOnData = this.makeIsOn(dom.isData);
            }
            // nativeRange: get nativeRange from sc, so, ec, eo
            WrappedRange.prototype.nativeRange = function () {
                if (env.isW3CRangeSupport) {
                    var w3cRange = document.createRange();
                    w3cRange.setStart(this.sc, this.so);
                    w3cRange.setEnd(this.ec, this.eo);
                    return w3cRange;
                } else {
                    var textRange = pointToTextRange({
                        node: this.sc,
                        offset: this.so
                    });
                    textRange.setEndPoint('EndToEnd', pointToTextRange({
                        node: this.ec,
                        offset: this.eo
                    }));
                    return textRange;
                }
            };
            WrappedRange.prototype.getPoints = function () {
                return {
                    sc: this.sc,
                    so: this.so,
                    ec: this.ec,
                    eo: this.eo
                };
            };
            WrappedRange.prototype.getStartPoint = function () {
                return {
                    node: this.sc,
                    offset: this.so
                };
            };
            WrappedRange.prototype.getEndPoint = function () {
                return {
                    node: this.ec,
                    offset: this.eo
                };
            };
            /**
             * select update visible range
             */
            WrappedRange.prototype.select = function () {
                var nativeRng = this.nativeRange();
                if (env.isW3CRangeSupport) {
                    var selection = document.getSelection();
                    if (selection.rangeCount > 0) {
                        selection.removeAllRanges();
                    }
                    selection.addRange(nativeRng);
                } else {
                    nativeRng.select();
                }
                return this;
            };
            /**
             * Moves the scrollbar to start container(sc) of current range
             *
             * @return {WrappedRange}
             */
            WrappedRange.prototype.scrollIntoView = function (container) {
                var height = $$1(container).height();
                if (container.scrollTop + height < this.sc.offsetTop) {
                    container.scrollTop += Math.abs(container.scrollTop + height - this.sc.offsetTop);
                }
                return this;
            };
            /**
             * @return {WrappedRange}
             */
            WrappedRange.prototype.normalize = function () {
                /**
                 * @param {BoundaryPoint} point
                 * @param {Boolean} isLeftToRight
                 * @return {BoundaryPoint}
                 */
                var getVisiblePoint = function (point, isLeftToRight) {
                    if (dom.isVisiblePoint(point) && !dom.isEdgePoint(point) || dom.isVisiblePoint(point) && dom.isRightEdgePoint(point) && !isLeftToRight || dom.isVisiblePoint(point) && dom.isLeftEdgePoint(point) && isLeftToRight || dom.isVisiblePoint(point) && dom.isBlock(point.node) && dom.isEmpty(point.node)) {
                        return point;
                    }
                    // point on block's edge
                    var block = dom.ancestor(point.node, dom.isBlock);
                    if ((dom.isLeftEdgePointOf(point, block) || dom.isVoid(dom.prevPoint(point).node)) && !isLeftToRight || (dom.isRightEdgePointOf(point, block) || dom.isVoid(dom.nextPoint(point).node)) && isLeftToRight) {
                        // returns point already on visible point
                        if (dom.isVisiblePoint(point)) {
                            return point;
                        }
                        // reverse direction
                        isLeftToRight = !isLeftToRight;
                    }
                    var nextPoint = isLeftToRight ? dom.nextPointUntil(dom.nextPoint(point), dom.isVisiblePoint) : dom.prevPointUntil(dom.prevPoint(point), dom.isVisiblePoint);
                    return nextPoint || point;
                };
                var endPoint = getVisiblePoint(this.getEndPoint(), false);
                var startPoint = this.isCollapsed() ? endPoint : getVisiblePoint(this.getStartPoint(), true);
                return new WrappedRange(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset);
            };
            /**
             * returns matched nodes on range
             *
             * @param {Function} [pred] - predicate function
             * @param {Object} [options]
             * @param {Boolean} [options.includeAncestor]
             * @param {Boolean} [options.fullyContains]
             * @return {Node[]}
             */
            WrappedRange.prototype.nodes = function (pred, options) {
                pred = pred || func.ok;
                var includeAncestor = options && options.includeAncestor;
                var fullyContains = options && options.fullyContains;
                // TODO compare points and sort
                var startPoint = this.getStartPoint();
                var endPoint = this.getEndPoint();
                var nodes = [];
                var leftEdgeNodes = [];
                dom.walkPoint(startPoint, endPoint, function (point) {
                    if (dom.isEditable(point.node)) {
                        return;
                    }
                    var node;
                    if (fullyContains) {
                        if (dom.isLeftEdgePoint(point)) {
                            leftEdgeNodes.push(point.node);
                        }
                        if (dom.isRightEdgePoint(point) && lists.contains(leftEdgeNodes, point.node)) {
                            node = point.node;
                        }
                    } else if (includeAncestor) {
                        node = dom.ancestor(point.node, pred);
                    } else {
                        node = point.node;
                    }
                    if (node && pred(node)) {
                        nodes.push(node);
                    }
                }, true);
                return lists.unique(nodes);
            };
            /**
             * returns commonAncestor of range
             * @return {Element} - commonAncestor
             */
            WrappedRange.prototype.commonAncestor = function () {
                return dom.commonAncestor(this.sc, this.ec);
            };
            /**
             * returns expanded range by pred
             *
             * @param {Function} pred - predicate function
             * @return {WrappedRange}
             */
            WrappedRange.prototype.expand = function (pred) {
                var startAncestor = dom.ancestor(this.sc, pred);
                var endAncestor = dom.ancestor(this.ec, pred);
                if (!startAncestor && !endAncestor) {
                    return new WrappedRange(this.sc, this.so, this.ec, this.eo);
                }
                var boundaryPoints = this.getPoints();
                if (startAncestor) {
                    boundaryPoints.sc = startAncestor;
                    boundaryPoints.so = 0;
                }
                if (endAncestor) {
                    boundaryPoints.ec = endAncestor;
                    boundaryPoints.eo = dom.nodeLength(endAncestor);
                }
                return new WrappedRange(boundaryPoints.sc, boundaryPoints.so, boundaryPoints.ec, boundaryPoints.eo);
            };
            /**
             * @param {Boolean} isCollapseToStart
             * @return {WrappedRange}
             */
            WrappedRange.prototype.collapse = function (isCollapseToStart) {
                if (isCollapseToStart) {
                    return new WrappedRange(this.sc, this.so, this.sc, this.so);
                } else {
                    return new WrappedRange(this.ec, this.eo, this.ec, this.eo);
                }
            };
            /**
             * splitText on range
             */
            WrappedRange.prototype.splitText = function () {
                var isSameContainer = this.sc === this.ec;
                var boundaryPoints = this.getPoints();
                if (dom.isText(this.ec) && !dom.isEdgePoint(this.getEndPoint())) {
                    this.ec.splitText(this.eo);
                }
                if (dom.isText(this.sc) && !dom.isEdgePoint(this.getStartPoint())) {
                    boundaryPoints.sc = this.sc.splitText(this.so);
                    boundaryPoints.so = 0;
                    if (isSameContainer) {
                        boundaryPoints.ec = boundaryPoints.sc;
                        boundaryPoints.eo = this.eo - this.so;
                    }
                }
                return new WrappedRange(boundaryPoints.sc, boundaryPoints.so, boundaryPoints.ec, boundaryPoints.eo);
            };
            /**
             * delete contents on range
             * @return {WrappedRange}
             */
            WrappedRange.prototype.deleteContents = function () {
                if (this.isCollapsed()) {
                    return this;
                }
                var rng = this.splitText();
                var nodes = rng.nodes(null, {
                    fullyContains: true
                });
                // find new cursor point
                var point = dom.prevPointUntil(rng.getStartPoint(), function (point) {
                    return !lists.contains(nodes, point.node);
                });
                var emptyParents = [];
                $$1.each(nodes, function (idx, node) {
                    // find empty parents
                    var parent = node.parentNode;
                    if (point.node !== parent && dom.nodeLength(parent) === 1) {
                        emptyParents.push(parent);
                    }
                    dom.remove(node, false);
                });
                // remove empty parents
                $$1.each(emptyParents, function (idx, node) {
                    dom.remove(node, false);
                });
                return new WrappedRange(point.node, point.offset, point.node, point.offset).normalize();
            };
            /**
             * makeIsOn: return isOn(pred) function
             */
            WrappedRange.prototype.makeIsOn = function (pred) {
                return function () {
                    var ancestor = dom.ancestor(this.sc, pred);
                    return !!ancestor && ancestor === dom.ancestor(this.ec, pred);
                };
            };
            /**
             * @param {Function} pred
             * @return {Boolean}
             */
            WrappedRange.prototype.isLeftEdgeOf = function (pred) {
                if (!dom.isLeftEdgePoint(this.getStartPoint())) {
                    return false;
                }
                var node = dom.ancestor(this.sc, pred);
                return node && dom.isLeftEdgeOf(this.sc, node);
            };
            /**
             * returns whether range was collapsed or not
             */
            WrappedRange.prototype.isCollapsed = function () {
                return this.sc === this.ec && this.so === this.eo;
            };
            /**
             * wrap inline nodes which children of body with paragraph
             *
             * @return {WrappedRange}
             */
            WrappedRange.prototype.wrapBodyInlineWithPara = function () {
                if (dom.isBodyContainer(this.sc) && dom.isEmpty(this.sc)) {
                    this.sc.innerHTML = dom.emptyPara;
                    return new WrappedRange(this.sc.firstChild, 0, this.sc.firstChild, 0);
                }
                /**
                 * [workaround] firefox often create range on not visible point. so normalize here.
                 *  - firefox: |<p>text</p>|
                 *  - chrome: <p>|text|</p>
                 */
                var rng = this.normalize();
                if (dom.isParaInline(this.sc) || dom.isPara(this.sc)) {
                    return rng;
                }
                // find inline top ancestor
                var topAncestor;
                if (dom.isInline(rng.sc)) {
                    var ancestors = dom.listAncestor(rng.sc, func.not(dom.isInline));
                    topAncestor = lists.last(ancestors);
                    if (!dom.isInline(topAncestor)) {
                        topAncestor = ancestors[ancestors.length - 2] || rng.sc.childNodes[rng.so];
                    }
                } else {
                    topAncestor = rng.sc.childNodes[rng.so > 0 ? rng.so - 1 : 0];
                }
                // siblings not in paragraph
                var inlineSiblings = dom.listPrev(topAncestor, dom.isParaInline).reverse();
                inlineSiblings = inlineSiblings.concat(dom.listNext(topAncestor.nextSibling, dom.isParaInline));
                // wrap with paragraph
                if (inlineSiblings.length) {
                    var para = dom.wrap(lists.head(inlineSiblings), 'p');
                    dom.appendChildNodes(para, lists.tail(inlineSiblings));
                }
                return this.normalize();
            };
            /**
             * insert node at current cursor
             *
             * @param {Node} node
             * @return {Node}
             */
            WrappedRange.prototype.insertNode = function (node) {
                var rng = this.wrapBodyInlineWithPara().deleteContents();
                var info = dom.splitPoint(rng.getStartPoint(), dom.isInline(node));
                if (info.rightNode) {
                    info.rightNode.parentNode.insertBefore(node, info.rightNode);
                } else {
                    info.container.appendChild(node);
                }
                return node;
            };
            /**
             * insert html at current cursor
             */
            WrappedRange.prototype.pasteHTML = function (markup) {
                var contentsContainer = $$1('<div></div>').html(markup)[0];
                var childNodes = lists.from(contentsContainer.childNodes);
                var rng = this.wrapBodyInlineWithPara().deleteContents();
                return childNodes.reverse().map(function (childNode) {
                    return rng.insertNode(childNode);
                }).reverse();
            };
            /**
             * returns text in range
             *
             * @return {String}
             */
            WrappedRange.prototype.toString = function () {
                var nativeRng = this.nativeRange();
                return env.isW3CRangeSupport ? nativeRng.toString() : nativeRng.text;
            };
            /**
             * returns range for word before cursor
             *
             * @param {Boolean} [findAfter] - find after cursor, default: false
             * @return {WrappedRange}
             */
            WrappedRange.prototype.getWordRange = function (findAfter) {
                var endPoint = this.getEndPoint();
                if (!dom.isCharPoint(endPoint)) {
                    return this;
                }
                var startPoint = dom.prevPointUntil(endPoint, function (point) {
                    return !dom.isCharPoint(point);
                });
                if (findAfter) {
                    endPoint = dom.nextPointUntil(endPoint, function (point) {
                        return !dom.isCharPoint(point);
                    });
                }
                return new WrappedRange(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset);
            };
            /**
             * create offsetPath bookmark
             *
             * @param {Node} editable
             */
            WrappedRange.prototype.bookmark = function (editable) {
                return {
                    s: {
                        path: dom.makeOffsetPath(editable, this.sc),
                        offset: this.so
                    },
                    e: {
                        path: dom.makeOffsetPath(editable, this.ec),
                        offset: this.eo
                    }
                };
            };
            /**
             * create offsetPath bookmark base on paragraph
             *
             * @param {Node[]} paras
             */
            WrappedRange.prototype.paraBookmark = function (paras) {
                return {
                    s: {
                        path: lists.tail(dom.makeOffsetPath(lists.head(paras), this.sc)),
                        offset: this.so
                    },
                    e: {
                        path: lists.tail(dom.makeOffsetPath(lists.last(paras), this.ec)),
                        offset: this.eo
                    }
                };
            };
            /**
             * getClientRects
             * @return {Rect[]}
             */
            WrappedRange.prototype.getClientRects = function () {
                var nativeRng = this.nativeRange();
                return nativeRng.getClientRects();
            };
            return WrappedRange;
        }();
        /**
         * Data structure
         *  * BoundaryPoint: a point of dom tree
         *  * BoundaryPoints: two boundaryPoints corresponding to the start and the end of the Range
         *
         * See to http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Position
         */
        var range = {
            /**
             * create Range Object From arguments or Browser Selection
             *
             * @param {Node} sc - start container
             * @param {Number} so - start offset
             * @param {Node} ec - end container
             * @param {Number} eo - end offset
             * @return {WrappedRange}
             */
            create: function (sc, so, ec, eo) {
                if (arguments.length === 4) {
                    return new WrappedRange(sc, so, ec, eo);
                } else if (arguments.length === 2) {
                    ec = sc;
                    eo = so;
                    return new WrappedRange(sc, so, ec, eo);
                } else {
                    var wrappedRange = this.createFromSelection();
                    if (!wrappedRange && arguments.length === 1) {
                        wrappedRange = this.createFromNode(arguments[0]);
                        return wrappedRange.collapse(dom.emptyPara === arguments[0].innerHTML);
                    }
                    return wrappedRange;
                }
            },
            createFromSelection: function () {
                var sc, so, ec, eo;
                if (env.isW3CRangeSupport) {
                    var selection = document.getSelection();
                    if (!selection || selection.rangeCount === 0) {
                        return null;
                    } else if (dom.isBody(selection.anchorNode)) {
                        // Firefox: returns entire body as range on initialization.
                        // We won't never need it.
                        return null;
                    }
                    var nativeRng = selection.getRangeAt(0);
                    sc = nativeRng.startContainer;
                    so = nativeRng.startOffset;
                    ec = nativeRng.endContainer;
                    eo = nativeRng.endOffset;
                } else {
                    var textRange = document.selection.createRange();
                    var textRangeEnd = textRange.duplicate();
                    textRangeEnd.collapse(false);
                    var textRangeStart = textRange;
                    textRangeStart.collapse(true);
                    var startPoint = textRangeToPoint(textRangeStart, true);
                    var endPoint = textRangeToPoint(textRangeEnd, false);
                    // same visible point case: range was collapsed.
                    if (dom.isText(startPoint.node) && dom.isLeftEdgePoint(startPoint) && dom.isTextNode(endPoint.node) && dom.isRightEdgePoint(endPoint) && endPoint.node.nextSibling === startPoint.node) {
                        startPoint = endPoint;
                    }
                    sc = startPoint.cont;
                    so = startPoint.offset;
                    ec = endPoint.cont;
                    eo = endPoint.offset;
                }
                return new WrappedRange(sc, so, ec, eo);
            },
            /**
             * @method
             *
             * create WrappedRange from node
             *
             * @param {Node} node
             * @return {WrappedRange}
             */
            createFromNode: function (node) {
                var sc = node;
                var so = 0;
                var ec = node;
                var eo = dom.nodeLength(ec);
                // browsers can't target a picture or void node
                if (dom.isVoid(sc)) {
                    so = dom.listPrev(sc).length - 1;
                    sc = sc.parentNode;
                }
                if (dom.isBR(ec)) {
                    eo = dom.listPrev(ec).length - 1;
                    ec = ec.parentNode;
                } else if (dom.isVoid(ec)) {
                    eo = dom.listPrev(ec).length;
                    ec = ec.parentNode;
                }
                return this.create(sc, so, ec, eo);
            },
            /**
             * create WrappedRange from node after position
             *
             * @param {Node} node
             * @return {WrappedRange}
             */
            createFromNodeBefore: function (node) {
                return this.createFromNode(node).collapse(true);
            },
            /**
             * create WrappedRange from node after position
             *
             * @param {Node} node
             * @return {WrappedRange}
             */
            createFromNodeAfter: function (node) {
                return this.createFromNode(node).collapse();
            },
            /**
             * @method
             *
             * create WrappedRange from bookmark
             *
             * @param {Node} editable
             * @param {Object} bookmark
             * @return {WrappedRange}
             */
            createFromBookmark: function (editable, bookmark) {
                var sc = dom.fromOffsetPath(editable, bookmark.s.path);
                var so = bookmark.s.offset;
                var ec = dom.fromOffsetPath(editable, bookmark.e.path);
                var eo = bookmark.e.offset;
                return new WrappedRange(sc, so, ec, eo);
            },
            /**
             * @method
             *
             * create WrappedRange from paraBookmark
             *
             * @param {Object} bookmark
             * @param {Node[]} paras
             * @return {WrappedRange}
             */
            createFromParaBookmark: function (bookmark, paras) {
                var so = bookmark.s.offset;
                var eo = bookmark.e.offset;
                var sc = dom.fromOffsetPath(lists.head(paras), bookmark.s.path);
                var ec = dom.fromOffsetPath(lists.last(paras), bookmark.e.path);
                return new WrappedRange(sc, so, ec, eo);
            }
        };

        /**
         * @method readFileAsDataURL
         *
         * read contents of file as representing URL
         *
         * @param {File} file
         * @return {Promise} - then: dataUrl
         */
        function readFileAsDataURL(file) {
            return $$1.Deferred(function (deferred) {
                $$1.extend(new FileReader(), {
                    onload: function (e) {
                        var dataURL = e.target.result;
                        deferred.resolve(dataURL);
                    },
                    onerror: function (err) {
                        deferred.reject(err);
                    }
                }).readAsDataURL(file);
            }).promise();
        }
        /**
         * @method createImage
         *
         * create `<image>` from url string
         *
         * @param {String} url
         * @return {Promise} - then: $image
         */
        function createImage(url) {
            return $$1.Deferred(function (deferred) {
                var $img = $$1('<img>');
                $img.one('load', function () {
                    $img.off('error abort');
                    deferred.resolve($img);
                }).one('error abort', function () {
                    $img.off('load').detach();
                    deferred.reject($img);
                }).css({
                    display: 'none'
                }).appendTo(document.body).attr('src', url);
            }).promise();
        }

        var History = /** @class */function () {
            function History($editable) {
                this.stack = [];
                this.stackOffset = -1;
                this.$editable = $editable;
                this.editable = $editable[0];
            }
            History.prototype.makeSnapshot = function () {
                var rng = range.create(this.editable);
                var emptyBookmark = { s: { path: [], offset: 0 }, e: { path: [], offset: 0 } };
                return {
                    contents: this.$editable.html(),
                    bookmark: rng ? rng.bookmark(this.editable) : emptyBookmark
                };
            };
            History.prototype.applySnapshot = function (snapshot) {
                if (snapshot.contents !== null) {
                    this.$editable.html(snapshot.contents);
                }
                if (snapshot.bookmark !== null) {
                    range.createFromBookmark(this.editable, snapshot.bookmark).select();
                }
            };
            /**
            * @method rewind
            * Rewinds the history stack back to the first snapshot taken.
            * Leaves the stack intact, so that "Redo" can still be used.
            */
            History.prototype.rewind = function () {
                // Create snap shot if not yet recorded
                if (this.$editable.html() !== this.stack[this.stackOffset].contents) {
                    this.recordUndo();
                }
                // Return to the first available snapshot.
                this.stackOffset = 0;
                // Apply that snapshot.
                this.applySnapshot(this.stack[this.stackOffset]);
            };
            /**
            * @method reset
            * Resets the history stack completely; reverting to an empty editor.
            */
            History.prototype.reset = function () {
                // Clear the stack.
                this.stack = [];
                // Restore stackOffset to its original value.
                this.stackOffset = -1;
                // Clear the editable area.
                this.$editable.html('');
                // Record our first snapshot (of nothing).
                this.recordUndo();
            };
            /**
             * undo
             */
            History.prototype.undo = function () {
                // Create snap shot if not yet recorded
                if (this.$editable.html() !== this.stack[this.stackOffset].contents) {
                    this.recordUndo();
                }
                if (this.stackOffset > 0) {
                    this.stackOffset--;
                    this.applySnapshot(this.stack[this.stackOffset]);
                }
            };
            /**
             * redo
             */
            History.prototype.redo = function () {
                if (this.stack.length - 1 > this.stackOffset) {
                    this.stackOffset++;
                    this.applySnapshot(this.stack[this.stackOffset]);
                }
            };
            /**
             * recorded undo
             */
            History.prototype.recordUndo = function () {
                this.stackOffset++;
                // Wash out stack after stackOffset
                if (this.stack.length > this.stackOffset) {
                    this.stack = this.stack.slice(0, this.stackOffset);
                }
                // Create new snapshot and push it to the end
                this.stack.push(this.makeSnapshot());
            };
            return History;
        }();

        var Style = /** @class */function () {
            function Style() {}
            /**
             * @method jQueryCSS
             *
             * [workaround] for old jQuery
             * passing an array of style properties to .css()
             * will result in an object of property-value pairs.
             * (compability with version < 1.9)
             *
             * @private
             * @param  {jQuery} $obj
             * @param  {Array} propertyNames - An array of one or more CSS properties.
             * @return {Object}
             */
            Style.prototype.jQueryCSS = function ($obj, propertyNames) {
                if (env.jqueryVersion < 1.9) {
                    var result_1 = {};
                    $$1.each(propertyNames, function (idx, propertyName) {
                        result_1[propertyName] = $obj.css(propertyName);
                    });
                    return result_1;
                }
                return $obj.css(propertyNames);
            };
            /**
             * returns style object from node
             *
             * @param {jQuery} $node
             * @return {Object}
             */
            Style.prototype.fromNode = function ($node) {
                var properties = ['font-family', 'font-size', 'text-align', 'list-style-type', 'line-height'];
                var styleInfo = this.jQueryCSS($node, properties) || {};
                styleInfo['font-size'] = parseInt(styleInfo['font-size'], 10);
                return styleInfo;
            };
            /**
             * paragraph level style
             *
             * @param {WrappedRange} rng
             * @param {Object} styleInfo
             */
            Style.prototype.stylePara = function (rng, styleInfo) {
                $$1.each(rng.nodes(dom.isPara, {
                    includeAncestor: true
                }), function (idx, para) {
                    $$1(para).css(styleInfo);
                });
            };
            /**
             * insert and returns styleNodes on range.
             *
             * @param {WrappedRange} rng
             * @param {Object} [options] - options for styleNodes
             * @param {String} [options.nodeName] - default: `SPAN`
             * @param {Boolean} [options.expandClosestSibling] - default: `false`
             * @param {Boolean} [options.onlyPartialContains] - default: `false`
             * @return {Node[]}
             */
            Style.prototype.styleNodes = function (rng, options) {
                rng = rng.splitText();
                var nodeName = options && options.nodeName || 'SPAN';
                var expandClosestSibling = !!(options && options.expandClosestSibling);
                var onlyPartialContains = !!(options && options.onlyPartialContains);
                if (rng.isCollapsed()) {
                    return [rng.insertNode(dom.create(nodeName))];
                }
                var pred = dom.makePredByNodeName(nodeName);
                var nodes = rng.nodes(dom.isText, {
                    fullyContains: true
                }).map(function (text) {
                    return dom.singleChildAncestor(text, pred) || dom.wrap(text, nodeName);
                });
                if (expandClosestSibling) {
                    if (onlyPartialContains) {
                        var nodesInRange_1 = rng.nodes();
                        // compose with partial contains predication
                        pred = func.and(pred, function (node) {
                            return lists.contains(nodesInRange_1, node);
                        });
                    }
                    return nodes.map(function (node) {
                        var siblings = dom.withClosestSiblings(node, pred);
                        var head = lists.head(siblings);
                        var tails = lists.tail(siblings);
                        $$1.each(tails, function (idx, elem) {
                            dom.appendChildNodes(head, elem.childNodes);
                            dom.remove(elem);
                        });
                        return lists.head(siblings);
                    });
                } else {
                    return nodes;
                }
            };
            /**
             * get current style on cursor
             *
             * @param {WrappedRange} rng
             * @return {Object} - object contains style properties.
             */
            Style.prototype.current = function (rng) {
                var $cont = $$1(!dom.isElement(rng.sc) ? rng.sc.parentNode : rng.sc);
                var styleInfo = this.fromNode($cont);
                // document.queryCommandState for toggle state
                // [workaround] prevent Firefox nsresult: "0x80004005 (NS_ERROR_FAILURE)"
                try {
                    styleInfo = $$1.extend(styleInfo, {
                        'font-bold': document.queryCommandState('bold') ? 'bold' : 'normal',
                        'font-italic': document.queryCommandState('italic') ? 'italic' : 'normal',
                        'font-underline': document.queryCommandState('underline') ? 'underline' : 'normal',
                        'font-subscript': document.queryCommandState('subscript') ? 'subscript' : 'normal',
                        'font-superscript': document.queryCommandState('superscript') ? 'superscript' : 'normal',
                        'font-strikethrough': document.queryCommandState('strikethrough') ? 'strikethrough' : 'normal',
                        'font-family': document.queryCommandValue('fontname') || styleInfo['font-family']
                    });
                } catch (e) {}
                // list-style-type to list-style(unordered, ordered)
                if (!rng.isOnList()) {
                    styleInfo['list-style'] = 'none';
                } else {
                    var orderedTypes = ['circle', 'disc', 'disc-leading-zero', 'square'];
                    var isUnordered = $$1.inArray(styleInfo['list-style-type'], orderedTypes) > -1;
                    styleInfo['list-style'] = isUnordered ? 'unordered' : 'ordered';
                }
                var para = dom.ancestor(rng.sc, dom.isPara);
                if (para && para.style['line-height']) {
                    styleInfo['line-height'] = para.style.lineHeight;
                } else {
                    var lineHeight = parseInt(styleInfo['line-height'], 10) / parseInt(styleInfo['font-size'], 10);
                    styleInfo['line-height'] = lineHeight.toFixed(1);
                }
                styleInfo.anchor = rng.isOnAnchor() && dom.ancestor(rng.sc, dom.isAnchor);
                styleInfo.ancestors = dom.listAncestor(rng.sc, dom.isEditable);
                styleInfo.range = rng;
                return styleInfo;
            };
            return Style;
        }();

        var Bullet = /** @class */function () {
            function Bullet() {}
            /**
             * toggle ordered list
             */
            Bullet.prototype.insertOrderedList = function (editable) {
                this.toggleList('OL', editable);
            };
            /**
             * toggle unordered list
             */
            Bullet.prototype.insertUnorderedList = function (editable) {
                this.toggleList('UL', editable);
            };
            /**
             * indent
             */
            Bullet.prototype.indent = function (editable) {
                var _this = this;
                var rng = range.create(editable).wrapBodyInlineWithPara();
                var paras = rng.nodes(dom.isPara, { includeAncestor: true });
                var clustereds = lists.clusterBy(paras, func.peq2('parentNode'));
                $$1.each(clustereds, function (idx, paras) {
                    var head = lists.head(paras);
                    if (dom.isLi(head)) {
                        _this.wrapList(paras, head.parentNode.nodeName);
                    } else {
                        $$1.each(paras, function (idx, para) {
                            $$1(para).css('marginLeft', function (idx, val) {
                                return (parseInt(val, 10) || 0) + 25;
                            });
                        });
                    }
                });
                rng.select();
            };
            /**
             * outdent
             */
            Bullet.prototype.outdent = function (editable) {
                var _this = this;
                var rng = range.create(editable).wrapBodyInlineWithPara();
                var paras = rng.nodes(dom.isPara, { includeAncestor: true });
                var clustereds = lists.clusterBy(paras, func.peq2('parentNode'));
                $$1.each(clustereds, function (idx, paras) {
                    var head = lists.head(paras);
                    if (dom.isLi(head)) {
                        _this.releaseList([paras]);
                    } else {
                        $$1.each(paras, function (idx, para) {
                            $$1(para).css('marginLeft', function (idx, val) {
                                val = parseInt(val, 10) || 0;
                                return val > 25 ? val - 25 : '';
                            });
                        });
                    }
                });
                rng.select();
            };
            /**
             * toggle list
             *
             * @param {String} listName - OL or UL
             */
            Bullet.prototype.toggleList = function (listName, editable) {
                var _this = this;
                var rng = range.create(editable).wrapBodyInlineWithPara();
                var paras = rng.nodes(dom.isPara, { includeAncestor: true });
                var bookmark = rng.paraBookmark(paras);
                var clustereds = lists.clusterBy(paras, func.peq2('parentNode'));
                // paragraph to list
                if (lists.find(paras, dom.isPurePara)) {
                    var wrappedParas_1 = [];
                    $$1.each(clustereds, function (idx, paras) {
                        wrappedParas_1 = wrappedParas_1.concat(_this.wrapList(paras, listName));
                    });
                    paras = wrappedParas_1;
                    // list to paragraph or change list style
                } else {
                    var diffLists = rng.nodes(dom.isList, {
                        includeAncestor: true
                    }).filter(function (listNode) {
                        return !$$1.nodeName(listNode, listName);
                    });
                    if (diffLists.length) {
                        $$1.each(diffLists, function (idx, listNode) {
                            dom.replace(listNode, listName);
                        });
                    } else {
                        paras = this.releaseList(clustereds, true);
                    }
                }
                range.createFromParaBookmark(bookmark, paras).select();
            };
            /**
             * @param {Node[]} paras
             * @param {String} listName
             * @return {Node[]}
             */
            Bullet.prototype.wrapList = function (paras, listName) {
                var head = lists.head(paras);
                var last = lists.last(paras);
                var prevList = dom.isList(head.previousSibling) && head.previousSibling;
                var nextList = dom.isList(last.nextSibling) && last.nextSibling;
                var listNode = prevList || dom.insertAfter(dom.create(listName || 'UL'), last);
                // P to LI
                paras = paras.map(function (para) {
                    return dom.isPurePara(para) ? dom.replace(para, 'LI') : para;
                });
                // append to list(<ul>, <ol>)
                dom.appendChildNodes(listNode, paras);
                if (nextList) {
                    dom.appendChildNodes(listNode, lists.from(nextList.childNodes));
                    dom.remove(nextList);
                }
                return paras;
            };
            /**
             * @method releaseList
             *
             * @param {Array[]} clustereds
             * @param {Boolean} isEscapseToBody
             * @return {Node[]}
             */
            Bullet.prototype.releaseList = function (clustereds, isEscapseToBody) {
                var releasedParas = [];
                $$1.each(clustereds, function (idx, paras) {
                    var head = lists.head(paras);
                    var last = lists.last(paras);
                    var headList = isEscapseToBody ? dom.lastAncestor(head, dom.isList) : head.parentNode;
                    var lastList = headList.childNodes.length > 1 ? dom.splitTree(headList, {
                        node: last.parentNode,
                        offset: dom.position(last) + 1
                    }, {
                        isSkipPaddingBlankHTML: true
                    }) : null;
                    var middleList = dom.splitTree(headList, {
                        node: head.parentNode,
                        offset: dom.position(head)
                    }, {
                        isSkipPaddingBlankHTML: true
                    });
                    paras = isEscapseToBody ? dom.listDescendant(middleList, dom.isLi) : lists.from(middleList.childNodes).filter(dom.isLi);
                    // LI to P
                    if (isEscapseToBody || !dom.isList(headList.parentNode)) {
                        paras = paras.map(function (para) {
                            return dom.replace(para, 'P');
                        });
                    }
                    $$1.each(lists.from(paras).reverse(), function (idx, para) {
                        dom.insertAfter(para, headList);
                    });
                    // remove empty lists
                    var rootLists = lists.compact([headList, middleList, lastList]);
                    $$1.each(rootLists, function (idx, rootList) {
                        var listNodes = [rootList].concat(dom.listDescendant(rootList, dom.isList));
                        $$1.each(listNodes.reverse(), function (idx, listNode) {
                            if (!dom.nodeLength(listNode)) {
                                dom.remove(listNode, true);
                            }
                        });
                    });
                    releasedParas = releasedParas.concat(paras);
                });
                return releasedParas;
            };
            return Bullet;
        }();

        /**
         * @class editing.Typing
         *
         * Typing
         *
         */
        var Typing = /** @class */function () {
            function Typing() {
                // a Bullet instance to toggle lists off
                this.bullet = new Bullet();
            }
            /**
             * insert tab
             *
             * @param {WrappedRange} rng
             * @param {Number} tabsize
             */
            Typing.prototype.insertTab = function (rng, tabsize) {
                var tab = dom.createText(new Array(tabsize + 1).join(dom.NBSP_CHAR));
                rng = rng.deleteContents();
                rng.insertNode(tab, true);
                rng = range.create(tab, tabsize);
                rng.select();
            };
            /**
             * insert paragraph
             */
            Typing.prototype.insertParagraph = function (editable) {
                var rng = range.create(editable);
                // deleteContents on range.
                rng = rng.deleteContents();
                // Wrap range if it needs to be wrapped by paragraph
                rng = rng.wrapBodyInlineWithPara();
                // finding paragraph
                var splitRoot = dom.ancestor(rng.sc, dom.isPara);
                var nextPara;
                // on paragraph: split paragraph
                if (splitRoot) {
                    // if it is an empty line with li
                    if (dom.isEmpty(splitRoot) && dom.isLi(splitRoot)) {
                        // toogle UL/OL and escape
                        this.bullet.toggleList(splitRoot.parentNode.nodeName);
                        return;
                        // if it is an empty line with para on blockquote
                    } else if (dom.isEmpty(splitRoot) && dom.isPara(splitRoot) && dom.isBlockquote(splitRoot.parentNode)) {
                        // escape blockquote
                        dom.insertAfter(splitRoot, splitRoot.parentNode);
                        nextPara = splitRoot;
                        // if new line has content (not a line break)
                    } else {
                        nextPara = dom.splitTree(splitRoot, rng.getStartPoint());
                        var emptyAnchors = dom.listDescendant(splitRoot, dom.isEmptyAnchor);
                        emptyAnchors = emptyAnchors.concat(dom.listDescendant(nextPara, dom.isEmptyAnchor));
                        $$1.each(emptyAnchors, function (idx, anchor) {
                            dom.remove(anchor);
                        });
                        // replace empty heading, pre or custom-made styleTag with P tag
                        if ((dom.isHeading(nextPara) || dom.isPre(nextPara) || dom.isCustomStyleTag(nextPara)) && dom.isEmpty(nextPara)) {
                            nextPara = dom.replace(nextPara, 'p');
                        }
                    }
                    // no paragraph: insert empty paragraph
                } else {
                    var next = rng.sc.childNodes[rng.so];
                    nextPara = $$1(dom.emptyPara)[0];
                    if (next) {
                        rng.sc.insertBefore(nextPara, next);
                    } else {
                        rng.sc.appendChild(nextPara);
                    }
                }
                range.create(nextPara, 0).normalize().select().scrollIntoView(editable);
            };
            return Typing;
        }();

        /**
         * @class Create a virtual table to create what actions to do in change.
         * @param {object} startPoint Cell selected to apply change.
         * @param {enum} where  Where change will be applied Row or Col. Use enum: TableResultAction.where
         * @param {enum} action Action to be applied. Use enum: TableResultAction.requestAction
         * @param {object} domTable Dom element of table to make changes.
         */
        var TableResultAction = function (startPoint, where, action, domTable) {
            var _startPoint = { 'colPos': 0, 'rowPos': 0 };
            var _virtualTable = [];
            var _actionCellList = [];
            /// ///////////////////////////////////////////
            // Private functions
            /// ///////////////////////////////////////////
            /**
             * Set the startPoint of action.
             */
            function setStartPoint() {
                if (!startPoint || !startPoint.tagName || startPoint.tagName.toLowerCase() !== 'td' && startPoint.tagName.toLowerCase() !== 'th') {
                    console.error('Impossible to identify start Cell point.', startPoint);
                    return;
                }
                _startPoint.colPos = startPoint.cellIndex;
                if (!startPoint.parentElement || !startPoint.parentElement.tagName || startPoint.parentElement.tagName.toLowerCase() !== 'tr') {
                    console.error('Impossible to identify start Row point.', startPoint);
                    return;
                }
                _startPoint.rowPos = startPoint.parentElement.rowIndex;
            }
            /**
             * Define virtual table position info object.
             *
             * @param {int} rowIndex Index position in line of virtual table.
             * @param {int} cellIndex Index position in column of virtual table.
             * @param {object} baseRow Row affected by this position.
             * @param {object} baseCell Cell affected by this position.
             * @param {bool} isSpan Inform if it is an span cell/row.
             */
            function setVirtualTablePosition(rowIndex, cellIndex, baseRow, baseCell, isRowSpan, isColSpan, isVirtualCell) {
                var objPosition = {
                    'baseRow': baseRow,
                    'baseCell': baseCell,
                    'isRowSpan': isRowSpan,
                    'isColSpan': isColSpan,
                    'isVirtual': isVirtualCell
                };
                if (!_virtualTable[rowIndex]) {
                    _virtualTable[rowIndex] = [];
                }
                _virtualTable[rowIndex][cellIndex] = objPosition;
            }
            /**
             * Create action cell object.
             *
             * @param {object} virtualTableCellObj Object of specific position on virtual table.
             * @param {enum} resultAction Action to be applied in that item.
             */
            function getActionCell(virtualTableCellObj, resultAction, virtualRowPosition, virtualColPosition) {
                return {
                    'baseCell': virtualTableCellObj.baseCell,
                    'action': resultAction,
                    'virtualTable': {
                        'rowIndex': virtualRowPosition,
                        'cellIndex': virtualColPosition
                    }
                };
            }
            /**
             * Recover free index of row to append Cell.
             *
             * @param {int} rowIndex Index of row to find free space.
             * @param {int} cellIndex Index of cell to find free space in table.
             */
            function recoverCellIndex(rowIndex, cellIndex) {
                if (!_virtualTable[rowIndex]) {
                    return cellIndex;
                }
                if (!_virtualTable[rowIndex][cellIndex]) {
                    return cellIndex;
                }
                var newCellIndex = cellIndex;
                while (_virtualTable[rowIndex][newCellIndex]) {
                    newCellIndex++;
                    if (!_virtualTable[rowIndex][newCellIndex]) {
                        return newCellIndex;
                    }
                }
            }
            /**
             * Recover info about row and cell and add information to virtual table.
             *
             * @param {object} row Row to recover information.
             * @param {object} cell Cell to recover information.
             */
            function addCellInfoToVirtual(row, cell) {
                var cellIndex = recoverCellIndex(row.rowIndex, cell.cellIndex);
                var cellHasColspan = cell.colSpan > 1;
                var cellHasRowspan = cell.rowSpan > 1;
                var isThisSelectedCell = row.rowIndex === _startPoint.rowPos && cell.cellIndex === _startPoint.colPos;
                setVirtualTablePosition(row.rowIndex, cellIndex, row, cell, cellHasRowspan, cellHasColspan, false);
                // Add span rows to virtual Table.
                var rowspanNumber = cell.attributes.rowSpan ? parseInt(cell.attributes.rowSpan.value, 10) : 0;
                if (rowspanNumber > 1) {
                    for (var rp = 1; rp < rowspanNumber; rp++) {
                        var rowspanIndex = row.rowIndex + rp;
                        adjustStartPoint(rowspanIndex, cellIndex, cell, isThisSelectedCell);
                        setVirtualTablePosition(rowspanIndex, cellIndex, row, cell, true, cellHasColspan, true);
                    }
                }
                // Add span cols to virtual table.
                var colspanNumber = cell.attributes.colSpan ? parseInt(cell.attributes.colSpan.value, 10) : 0;
                if (colspanNumber > 1) {
                    for (var cp = 1; cp < colspanNumber; cp++) {
                        var cellspanIndex = recoverCellIndex(row.rowIndex, cellIndex + cp);
                        adjustStartPoint(row.rowIndex, cellspanIndex, cell, isThisSelectedCell);
                        setVirtualTablePosition(row.rowIndex, cellspanIndex, row, cell, cellHasRowspan, true, true);
                    }
                }
            }
            /**
             * Process validation and adjust of start point if needed
             *
             * @param {int} rowIndex
             * @param {int} cellIndex
             * @param {object} cell
             * @param {bool} isSelectedCell
             */
            function adjustStartPoint(rowIndex, cellIndex, cell, isSelectedCell) {
                if (rowIndex === _startPoint.rowPos && _startPoint.colPos >= cell.cellIndex && cell.cellIndex <= cellIndex && !isSelectedCell) {
                    _startPoint.colPos++;
                }
            }
            /**
             * Create virtual table of cells with all cells, including span cells.
             */
            function createVirtualTable() {
                var rows = domTable.rows;
                for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
                    var cells = rows[rowIndex].cells;
                    for (var cellIndex = 0; cellIndex < cells.length; cellIndex++) {
                        addCellInfoToVirtual(rows[rowIndex], cells[cellIndex]);
                    }
                }
            }
            /**
             * Get action to be applied on the cell.
             *
             * @param {object} cell virtual table cell to apply action
             */
            function getDeleteResultActionToCell(cell) {
                switch (where) {
                    case TableResultAction.where.Column:
                        if (cell.isColSpan) {
                            return TableResultAction.resultAction.SubtractSpanCount;
                        }
                        break;
                    case TableResultAction.where.Row:
                        if (!cell.isVirtual && cell.isRowSpan) {
                            return TableResultAction.resultAction.AddCell;
                        } else if (cell.isRowSpan) {
                            return TableResultAction.resultAction.SubtractSpanCount;
                        }
                        break;
                }
                return TableResultAction.resultAction.RemoveCell;
            }
            /**
             * Get action to be applied on the cell.
             *
             * @param {object} cell virtual table cell to apply action
             */
            function getAddResultActionToCell(cell) {
                switch (where) {
                    case TableResultAction.where.Column:
                        if (cell.isColSpan) {
                            return TableResultAction.resultAction.SumSpanCount;
                        } else if (cell.isRowSpan && cell.isVirtual) {
                            return TableResultAction.resultAction.Ignore;
                        }
                        break;
                    case TableResultAction.where.Row:
                        if (cell.isRowSpan) {
                            return TableResultAction.resultAction.SumSpanCount;
                        } else if (cell.isColSpan && cell.isVirtual) {
                            return TableResultAction.resultAction.Ignore;
                        }
                        break;
                }
                return TableResultAction.resultAction.AddCell;
            }
            function init() {
                setStartPoint();
                createVirtualTable();
            }
            /// ///////////////////////////////////////////
            // Public functions
            /// ///////////////////////////////////////////
            /**
             * Recover array os what to do in table.
             */
            this.getActionList = function () {
                var fixedRow = where === TableResultAction.where.Row ? _startPoint.rowPos : -1;
                var fixedCol = where === TableResultAction.where.Column ? _startPoint.colPos : -1;
                var actualPosition = 0;
                var canContinue = true;
                while (canContinue) {
                    var rowPosition = fixedRow >= 0 ? fixedRow : actualPosition;
                    var colPosition = fixedCol >= 0 ? fixedCol : actualPosition;
                    var row = _virtualTable[rowPosition];
                    if (!row) {
                        canContinue = false;
                        return _actionCellList;
                    }
                    var cell = row[colPosition];
                    if (!cell) {
                        canContinue = false;
                        return _actionCellList;
                    }
                    // Define action to be applied in this cell
                    var resultAction = TableResultAction.resultAction.Ignore;
                    switch (action) {
                        case TableResultAction.requestAction.Add:
                            resultAction = getAddResultActionToCell(cell);
                            break;
                        case TableResultAction.requestAction.Delete:
                            resultAction = getDeleteResultActionToCell(cell);
                            break;
                    }
                    _actionCellList.push(getActionCell(cell, resultAction, rowPosition, colPosition));
                    actualPosition++;
                }
                return _actionCellList;
            };
            init();
        };
        /**
        *
        * Where action occours enum.
        */
        TableResultAction.where = { 'Row': 0, 'Column': 1 };
        /**
        *
        * Requested action to apply enum.
        */
        TableResultAction.requestAction = { 'Add': 0, 'Delete': 1 };
        /**
        *
        * Result action to be executed enum.
        */
        TableResultAction.resultAction = { 'Ignore': 0, 'SubtractSpanCount': 1, 'RemoveCell': 2, 'AddCell': 3, 'SumSpanCount': 4 };
        /**
         *
         * @class editing.Table
         *
         * Table
         *
         */
        var Table = /** @class */function () {
            function Table() {}
            /**
             * handle tab key
             *
             * @param {WrappedRange} rng
             * @param {Boolean} isShift
             */
            Table.prototype.tab = function (rng, isShift) {
                var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
                var table = dom.ancestor(cell, dom.isTable);
                var cells = dom.listDescendant(table, dom.isCell);
                var nextCell = lists[isShift ? 'prev' : 'next'](cells, cell);
                if (nextCell) {
                    range.create(nextCell, 0).select();
                }
            };
            /**
             * Add a new row
             *
             * @param {WrappedRange} rng
             * @param {String} position (top/bottom)
             * @return {Node}
             */
            Table.prototype.addRow = function (rng, position) {
                var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
                var currentTr = $$1(cell).closest('tr');
                var trAttributes = this.recoverAttributes(currentTr);
                var html = $$1('<tr' + trAttributes + '></tr>');
                var vTable = new TableResultAction(cell, TableResultAction.where.Row, TableResultAction.requestAction.Add, $$1(currentTr).closest('table')[0]);
                var actions = vTable.getActionList();
                for (var idCell = 0; idCell < actions.length; idCell++) {
                    var currentCell = actions[idCell];
                    var tdAttributes = this.recoverAttributes(currentCell.baseCell);
                    switch (currentCell.action) {
                        case TableResultAction.resultAction.AddCell:
                            html.append('<td' + tdAttributes + '>' + dom.blank + '</td>');
                            break;
                        case TableResultAction.resultAction.SumSpanCount:
                            if (position === 'top') {
                                var baseCellTr = currentCell.baseCell.parent;
                                var isTopFromRowSpan = (!baseCellTr ? 0 : currentCell.baseCell.closest('tr').rowIndex) <= currentTr[0].rowIndex;
                                if (isTopFromRowSpan) {
                                    var newTd = $$1('<div></div>').append($$1('<td' + tdAttributes + '>' + dom.blank + '</td>').removeAttr('rowspan')).html();
                                    html.append(newTd);
                                    break;
                                }
                            }
                            var rowspanNumber = parseInt(currentCell.baseCell.rowSpan, 10);
                            rowspanNumber++;
                            currentCell.baseCell.setAttribute('rowSpan', rowspanNumber);
                            break;
                    }
                }
                if (position === 'top') {
                    currentTr.before(html);
                } else {
                    var cellHasRowspan = cell.rowSpan > 1;
                    if (cellHasRowspan) {
                        var lastTrIndex = currentTr[0].rowIndex + (cell.rowSpan - 2);
                        $$1($$1(currentTr).parent().find('tr')[lastTrIndex]).after($$1(html));
                        return;
                    }
                    currentTr.after(html);
                }
            };
            /**
             * Add a new col
             *
             * @param {WrappedRange} rng
             * @param {String} position (left/right)
             * @return {Node}
             */
            Table.prototype.addCol = function (rng, position) {
                var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
                var row = $$1(cell).closest('tr');
                var rowsGroup = $$1(row).siblings();
                rowsGroup.push(row);
                var vTable = new TableResultAction(cell, TableResultAction.where.Column, TableResultAction.requestAction.Add, $$1(row).closest('table')[0]);
                var actions = vTable.getActionList();
                for (var actionIndex = 0; actionIndex < actions.length; actionIndex++) {
                    var currentCell = actions[actionIndex];
                    var tdAttributes = this.recoverAttributes(currentCell.baseCell);
                    switch (currentCell.action) {
                        case TableResultAction.resultAction.AddCell:
                            if (position === 'right') {
                                $$1(currentCell.baseCell).after('<td' + tdAttributes + '>' + dom.blank + '</td>');
                            } else {
                                $$1(currentCell.baseCell).before('<td' + tdAttributes + '>' + dom.blank + '</td>');
                            }
                            break;
                        case TableResultAction.resultAction.SumSpanCount:
                            if (position === 'right') {
                                var colspanNumber = parseInt(currentCell.baseCell.colSpan, 10);
                                colspanNumber++;
                                currentCell.baseCell.setAttribute('colSpan', colspanNumber);
                            } else {
                                $$1(currentCell.baseCell).before('<td' + tdAttributes + '>' + dom.blank + '</td>');
                            }
                            break;
                    }
                }
            };
            /*
            * Copy attributes from element.
            *
            * @param {object} Element to recover attributes.
            * @return {string} Copied string elements.
            */
            Table.prototype.recoverAttributes = function (el) {
                var resultStr = '';
                if (!el) {
                    return resultStr;
                }
                var attrList = el.attributes || [];
                for (var i = 0; i < attrList.length; i++) {
                    if (attrList[i].name.toLowerCase() === 'id') {
                        continue;
                    }
                    if (attrList[i].specified) {
                        resultStr += ' ' + attrList[i].name + '=\'' + attrList[i].value + '\'';
                    }
                }
                return resultStr;
            };
            /**
             * Delete current row
             *
             * @param {WrappedRange} rng
             * @return {Node}
             */
            Table.prototype.deleteRow = function (rng) {
                var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
                var row = $$1(cell).closest('tr');
                var cellPos = row.children('td, th').index($$1(cell));
                var rowPos = row[0].rowIndex;
                var vTable = new TableResultAction(cell, TableResultAction.where.Row, TableResultAction.requestAction.Delete, $$1(row).closest('table')[0]);
                var actions = vTable.getActionList();
                for (var actionIndex = 0; actionIndex < actions.length; actionIndex++) {
                    if (!actions[actionIndex]) {
                        continue;
                    }
                    var baseCell = actions[actionIndex].baseCell;
                    var virtualPosition = actions[actionIndex].virtualTable;
                    var hasRowspan = baseCell.rowSpan && baseCell.rowSpan > 1;
                    var rowspanNumber = hasRowspan ? parseInt(baseCell.rowSpan, 10) : 0;
                    switch (actions[actionIndex].action) {
                        case TableResultAction.resultAction.Ignore:
                            continue;
                        case TableResultAction.resultAction.AddCell:
                            var nextRow = row.next('tr')[0];
                            if (!nextRow) {
                                continue;
                            }
                            var cloneRow = row[0].cells[cellPos];
                            if (hasRowspan) {
                                if (rowspanNumber > 2) {
                                    rowspanNumber--;
                                    nextRow.insertBefore(cloneRow, nextRow.cells[cellPos]);
                                    nextRow.cells[cellPos].setAttribute('rowSpan', rowspanNumber);
                                    nextRow.cells[cellPos].innerHTML = '';
                                } else if (rowspanNumber === 2) {
                                    nextRow.insertBefore(cloneRow, nextRow.cells[cellPos]);
                                    nextRow.cells[cellPos].removeAttribute('rowSpan');
                                    nextRow.cells[cellPos].innerHTML = '';
                                }
                            }
                            continue;
                        case TableResultAction.resultAction.SubtractSpanCount:
                            if (hasRowspan) {
                                if (rowspanNumber > 2) {
                                    rowspanNumber--;
                                    baseCell.setAttribute('rowSpan', rowspanNumber);
                                    if (virtualPosition.rowIndex !== rowPos && baseCell.cellIndex === cellPos) {
                                        baseCell.innerHTML = '';
                                    }
                                } else if (rowspanNumber === 2) {
                                    baseCell.removeAttribute('rowSpan');
                                    if (virtualPosition.rowIndex !== rowPos && baseCell.cellIndex === cellPos) {
                                        baseCell.innerHTML = '';
                                    }
                                }
                            }
                            continue;
                        case TableResultAction.resultAction.RemoveCell:
                            // Do not need remove cell because row will be deleted.
                            continue;
                    }
                }
                row.remove();
            };
            /**
             * Delete current col
             *
             * @param {WrappedRange} rng
             * @return {Node}
             */
            Table.prototype.deleteCol = function (rng) {
                var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
                var row = $$1(cell).closest('tr');
                var cellPos = row.children('td, th').index($$1(cell));
                var vTable = new TableResultAction(cell, TableResultAction.where.Column, TableResultAction.requestAction.Delete, $$1(row).closest('table')[0]);
                var actions = vTable.getActionList();
                for (var actionIndex = 0; actionIndex < actions.length; actionIndex++) {
                    if (!actions[actionIndex]) {
                        continue;
                    }
                    switch (actions[actionIndex].action) {
                        case TableResultAction.resultAction.Ignore:
                            continue;
                        case TableResultAction.resultAction.SubtractSpanCount:
                            var baseCell = actions[actionIndex].baseCell;
                            var hasColspan = baseCell.colSpan && baseCell.colSpan > 1;
                            if (hasColspan) {
                                var colspanNumber = baseCell.colSpan ? parseInt(baseCell.colSpan, 10) : 0;
                                if (colspanNumber > 2) {
                                    colspanNumber--;
                                    baseCell.setAttribute('colSpan', colspanNumber);
                                    if (baseCell.cellIndex === cellPos) {
                                        baseCell.innerHTML = '';
                                    }
                                } else if (colspanNumber === 2) {
                                    baseCell.removeAttribute('colSpan');
                                    if (baseCell.cellIndex === cellPos) {
                                        baseCell.innerHTML = '';
                                    }
                                }
                            }
                            continue;
                        case TableResultAction.resultAction.RemoveCell:
                            dom.remove(actions[actionIndex].baseCell, true);
                            continue;
                    }
                }
            };
            /**
             * create empty table element
             *
             * @param {Number} rowCount
             * @param {Number} colCount
             * @return {Node}
             */
            Table.prototype.createTable = function (colCount, rowCount, options) {
                var tds = [];
                var tdHTML;
                for (var idxCol = 0; idxCol < colCount; idxCol++) {
                    tds.push('<td>' + dom.blank + '</td>');
                }
                tdHTML = tds.join('');
                var trs = [];
                var trHTML;
                for (var idxRow = 0; idxRow < rowCount; idxRow++) {
                    trs.push('<tr>' + tdHTML + '</tr>');
                }
                trHTML = trs.join('');
                var $table = $$1('<table>' + trHTML + '</table>');
                if (options && options.tableClassName) {
                    $table.addClass(options.tableClassName);
                }
                return $table[0];
            };
            /**
             * Delete current table
             *
             * @param {WrappedRange} rng
             * @return {Node}
             */
            Table.prototype.deleteTable = function (rng) {
                var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
                $$1(cell).closest('table').remove();
            };
            return Table;
        }();

        var KEY_BOGUS = 'bogus';
        /**
         * @class Editor
         */
        var Editor = /** @class */function () {
            function Editor(context) {
                var _this = this;
                this.context = context;
                this.$note = context.layoutInfo.note;
                this.$editor = context.layoutInfo.editor;
                this.$editable = context.layoutInfo.editable;
                this.options = context.options;
                this.lang = this.options.langInfo;
                this.editable = this.$editable[0];
                this.lastRange = null;
                this.style = new Style();
                this.table = new Table();
                this.typing = new Typing();
                this.bullet = new Bullet();
                this.history = new History(this.$editable);
                this.context.memo('help.undo', this.lang.help.undo);
                this.context.memo('help.redo', this.lang.help.redo);
                this.context.memo('help.tab', this.lang.help.tab);
                this.context.memo('help.untab', this.lang.help.untab);
                this.context.memo('help.insertParagraph', this.lang.help.insertParagraph);
                this.context.memo('help.insertOrderedList', this.lang.help.insertOrderedList);
                this.context.memo('help.insertUnorderedList', this.lang.help.insertUnorderedList);
                this.context.memo('help.indent', this.lang.help.indent);
                this.context.memo('help.outdent', this.lang.help.outdent);
                this.context.memo('help.formatPara', this.lang.help.formatPara);
                this.context.memo('help.insertHorizontalRule', this.lang.help.insertHorizontalRule);
                this.context.memo('help.fontName', this.lang.help.fontName);
                // native commands(with execCommand), generate function for execCommand
                var commands = ['bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript', 'justifyLeft', 'justifyCenter', 'justifyRight', 'justifyFull', 'formatBlock', 'removeFormat', 'backColor'];
                for (var idx = 0, len = commands.length; idx < len; idx++) {
                    this[commands[idx]] = function (sCmd) {
                        return function (value) {
                            _this.beforeCommand();
                            document.execCommand(sCmd, false, value);
                            _this.afterCommand(true);
                        };
                    }(commands[idx]);
                    this.context.memo('help.' + commands[idx], this.lang.help[commands[idx]]);
                }
                this.fontName = this.wrapCommand(function (value) {
                    return _this.fontStyling('font-family', "\'" + value + "\'");
                });
                this.fontSize = this.wrapCommand(function (value) {
                    return _this.fontStyling('font-size', value + 'px');
                });
                for (var idx = 1; idx <= 6; idx++) {
                    this['formatH' + idx] = function (idx) {
                        return function () {
                            _this.formatBlock('H' + idx);
                        };
                    }(idx);
                    this.context.memo('help.formatH' + idx, this.lang.help['formatH' + idx]);
                }

                this.insertParagraph = this.wrapCommand(function () {
                    _this.typing.insertParagraph(_this.editable);
                });
                this.insertOrderedList = this.wrapCommand(function () {
                    _this.bullet.insertOrderedList(_this.editable);
                });
                this.insertUnorderedList = this.wrapCommand(function () {
                    _this.bullet.insertUnorderedList(_this.editable);
                });
                this.indent = this.wrapCommand(function () {
                    _this.bullet.indent(_this.editable);
                });
                this.outdent = this.wrapCommand(function () {
                    _this.bullet.outdent(_this.editable);
                });
                /**
                 * insertNode
                 * insert node
                 * @param {Node} node
                 */
                this.insertNode = this.wrapCommand(function (node) {
                    if (_this.isLimited($$1(node).text().length)) {
                        return;
                    }
                    var rng = _this.createRange();
                    rng.insertNode(node);
                    range.createFromNodeAfter(node).select();
                });
                /**
                 * insert text
                 * @param {String} text
                 */
                this.insertText = this.wrapCommand(function (text) {
                    if (_this.isLimited(text.length)) {
                        return;
                    }
                    var rng = _this.createRange();
                    var textNode = rng.insertNode(dom.createText(text));
                    range.create(textNode, dom.nodeLength(textNode)).select();
                });
                /**
                 * paste HTML
                 * @param {String} markup
                 */
                this.pasteHTML = this.wrapCommand(function (markup) {
                    if (_this.isLimited(markup.length)) {
                        return;
                    }
                    var contents = _this.createRange().pasteHTML(markup);
                    range.createFromNodeAfter(lists.last(contents)).select();
                });
                /**
                 * formatBlock
                 *
                 * @param {String} tagName
                 */
                this.formatBlock = this.wrapCommand(function (tagName, $target) {
                    var onApplyCustomStyle = _this.options.callbacks.onApplyCustomStyle;
                    if (onApplyCustomStyle) {
                        onApplyCustomStyle.call(_this, $target, _this.context, _this.onFormatBlock);
                    } else {
                        _this.onFormatBlock(tagName, $target);
                    }
                });
                /**
                 * insert horizontal rule
                 */
                this.insertHorizontalRule = this.wrapCommand(function () {
                    var hrNode = _this.createRange().insertNode(dom.create('HR'));
                    if (hrNode.nextSibling) {
                        range.create(hrNode.nextSibling, 0).normalize().select();
                    }
                });
                /**
                 * lineHeight
                 * @param {String} value
                 */
                this.lineHeight = this.wrapCommand(function (value) {
                    _this.style.stylePara(_this.createRange(), {
                        lineHeight: value
                    });
                });
                /**
                 * create link (command)
                 *
                 * @param {Object} linkInfo
                 */
                this.createLink = this.wrapCommand(function (linkInfo) {
                    var linkUrl = linkInfo.url;
                    var linkText = linkInfo.text;
                    var isNewWindow = linkInfo.isNewWindow;
                    var rng = linkInfo.range || _this.createRange();
                    var isTextChanged = rng.toString() !== linkText;
                    // handle spaced urls from input
                    if (typeof linkUrl === 'string') {
                        linkUrl = linkUrl.trim();
                    }
                    if (_this.options.onCreateLink) {
                        linkUrl = _this.options.onCreateLink(linkUrl);
                    } else {
                        // if url doesn't match an URL schema, set http:// as default
                        linkUrl = /^[A-Za-z][A-Za-z0-9+-.]*\:[\/\/]?/.test(linkUrl) ? linkUrl : 'http://' + linkUrl;
                    }
                    var anchors = [];
                    if (isTextChanged) {
                        rng = rng.deleteContents();
                        var anchor = rng.insertNode($$1('<A>' + linkText + '</A>')[0]);
                        anchors.push(anchor);
                    } else {
                        anchors = _this.style.styleNodes(rng, {
                            nodeName: 'A',
                            expandClosestSibling: true,
                            onlyPartialContains: true
                        });
                    }
                    $$1.each(anchors, function (idx, anchor) {
                        $$1(anchor).attr('href', linkUrl);
                        if (isNewWindow) {
                            $$1(anchor).attr('target', '_blank');
                        } else {
                            $$1(anchor).removeAttr('target');
                        }
                    });
                    var startRange = range.createFromNodeBefore(lists.head(anchors));
                    var startPoint = startRange.getStartPoint();
                    var endRange = range.createFromNodeAfter(lists.last(anchors));
                    var endPoint = endRange.getEndPoint();
                    range.create(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset).select();
                });
                /**
                 * setting color
                 *
                 * @param {Object} sObjColor  color code
                 * @param {String} sObjColor.foreColor foreground color
                 * @param {String} sObjColor.backColor background color
                 */
                this.color = this.wrapCommand(function (colorInfo) {
                    var foreColor = colorInfo.foreColor;
                    var backColor = colorInfo.backColor;
                    if (foreColor) {
                        document.execCommand('foreColor', false, foreColor);
                    }
                    if (backColor) {
                        document.execCommand('backColor', false, backColor);
                    }
                });
                /**
                 * Set foreground color
                 *
                 * @param {String} colorCode foreground color code
                 */
                this.foreColor = this.wrapCommand(function (colorInfo) {
                    document.execCommand('styleWithCSS', false, true);
                    document.execCommand('foreColor', false, colorInfo);
                });
                /**
                 * insert Table
                 *
                 * @param {String} dimension of table (ex : "5x5")
                 */
                this.insertTable = this.wrapCommand(function (dim) {
                    var dimension = dim.split('x');
                    var rng = _this.createRange().deleteContents();
                    rng.insertNode(_this.table.createTable(dimension[0], dimension[1], _this.options));
                });
                /**
                 * remove media object and Figure Elements if media object is img with Figure.
                 */
                this.removeMedia = this.wrapCommand(function () {
                    var $target = $$1(_this.restoreTarget()).parent();
                    if ($target.parent('figure').length) {
                        $target.parent('figure').remove();
                    } else {
                        $target = $$1(_this.restoreTarget()).detach();
                    }
                    _this.context.triggerEvent('media.delete', $target, _this.$editable);
                });
                /**
                 * float me
                 *
                 * @param {String} value
                 */
                this.floatMe = this.wrapCommand(function (value) {
                    var $target = $$1(_this.restoreTarget());
                    $target.toggleClass('note-float-left', value === 'left');
                    $target.toggleClass('note-float-right', value === 'right');
                    $target.css('float', value);
                });
                /**
                 * resize overlay element
                 * @param {String} value
                 */
                this.resize = this.wrapCommand(function (value) {
                    var $target = $$1(_this.restoreTarget());
                    $target.css({
                        width: value * 100 + '%',
                        height: ''
                    });
                });
            }
            Editor.prototype.initialize = function () {
                var _this = this;
                // bind custom events
                this.$editable.on('keydown', function (event) {
                    if (event.keyCode === key.code.ENTER) {
                        _this.context.triggerEvent('enter', event);
                    }
                    _this.context.triggerEvent('keydown', event);
                    if (!event.isDefaultPrevented()) {
                        if (_this.options.shortcuts) {
                            _this.handleKeyMap(event);
                        } else {
                            _this.preventDefaultEditableShortCuts(event);
                        }
                    }
                    if (_this.isLimited(1, event)) {
                        return false;
                    }
                }).on('keyup', function (event) {
                    _this.context.triggerEvent('keyup', event);
                }).on('focus', function (event) {
                    _this.context.triggerEvent('focus', event);
                }).on('blur', function (event) {
                    _this.context.triggerEvent('blur', event);
                }).on('mousedown', function (event) {
                    _this.context.triggerEvent('mousedown', event);
                }).on('mouseup', function (event) {
                    _this.context.triggerEvent('mouseup', event);
                }).on('scroll', function (event) {
                    _this.context.triggerEvent('scroll', event);
                }).on('paste', function (event) {
                    _this.context.triggerEvent('paste', event);
                });
                // init content before set event
                this.$editable.html(dom.html(this.$note) || dom.emptyPara);
                this.$editable.on(env.inputEventName, func.debounce(function () {
                    _this.context.triggerEvent('change', _this.$editable.html());
                }, 100));
                this.$editor.on('focusin', function (event) {
                    _this.context.triggerEvent('focusin', event);
                }).on('focusout', function (event) {
                    _this.context.triggerEvent('focusout', event);
                });
                if (!this.options.airMode) {
                    if (this.options.width) {
                        this.$editor.outerWidth(this.options.width);
                    }
                    if (this.options.height) {
                        this.$editable.outerHeight(this.options.height);
                    }
                    if (this.options.maxHeight) {
                        this.$editable.css('max-height', this.options.maxHeight);
                    }
                    if (this.options.minHeight) {
                        this.$editable.css('min-height', this.options.minHeight);
                    }
                }
                this.history.recordUndo();
            };
            Editor.prototype.destroy = function () {
                this.$editable.off();
            };
            Editor.prototype.handleKeyMap = function (event) {
                var keyMap = this.options.keyMap[env.isMac ? 'mac' : 'pc'];
                var keys = [];
                if (event.metaKey) {
                    keys.push('CMD');
                }
                if (event.ctrlKey && !event.altKey) {
                    keys.push('CTRL');
                }
                if (event.shiftKey) {
                    keys.push('SHIFT');
                }
                var keyName = key.nameFromCode[event.keyCode];
                if (keyName) {
                    keys.push(keyName);
                }
                var eventName = keyMap[keys.join('+')];
                if (eventName) {
                    if (this.context.invoke(eventName) !== false) {
                        event.preventDefault();
                    }
                } else if (key.isEdit(event.keyCode)) {
                    this.afterCommand();
                }
            };
            Editor.prototype.preventDefaultEditableShortCuts = function (event) {
                // B(Bold, 66) / I(Italic, 73) / U(Underline, 85)
                if ((event.ctrlKey || event.metaKey) && lists.contains([66, 73, 85], event.keyCode)) {
                    event.preventDefault();
                }
            };
            Editor.prototype.isLimited = function (pad, event) {
                pad = pad || 0;
                if (typeof event !== 'undefined') {
                    if (key.isMove(event.keyCode) || event.ctrlKey || event.metaKey || lists.contains([key.code.BACKSPACE, key.code.DELETE], event.keyCode)) {
                        return false;
                    }
                }
                if (this.options.maxTextLength > 0) {
                    if (this.$editable.text().length + pad >= this.options.maxTextLength) {
                        return true;
                    }
                }
                return false;
            };
            /**
             * create range
             * @return {WrappedRange}
             */
            Editor.prototype.createRange = function () {
                this.focus();
                return range.create(this.editable);
            };
            /**
             * saveRange
             *
             * save current range
             *
             * @param {Boolean} [thenCollapse=false]
             */
            Editor.prototype.saveRange = function (thenCollapse) {
                this.lastRange = this.createRange();
                if (thenCollapse) {
                    this.lastRange.collapse().select();
                }
            };
            /**
             * restoreRange
             *
             * restore lately range
             */
            Editor.prototype.restoreRange = function () {
                if (this.lastRange) {
                    this.lastRange.select();
                    this.focus();
                }
            };
            Editor.prototype.saveTarget = function (node) {
                this.$editable.data('target', node);
            };
            Editor.prototype.clearTarget = function () {
                this.$editable.removeData('target');
            };
            Editor.prototype.restoreTarget = function () {
                return this.$editable.data('target');
            };
            /**
             * currentStyle
             *
             * current style
             * @return {Object|Boolean} unfocus
             */
            Editor.prototype.currentStyle = function () {
                var rng = range.create();
                if (rng) {
                    rng = rng.normalize();
                }
                return rng ? this.style.current(rng) : this.style.fromNode(this.$editable);
            };
            /**
             * style from node
             *
             * @param {jQuery} $node
             * @return {Object}
             */
            Editor.prototype.styleFromNode = function ($node) {
                return this.style.fromNode($node);
            };
            /**
             * undo
             */
            Editor.prototype.undo = function () {
                this.context.triggerEvent('before.command', this.$editable.html());
                this.history.undo();
                this.context.triggerEvent('change', this.$editable.html());
            };
            /**
             * redo
             */
            Editor.prototype.redo = function () {
                this.context.triggerEvent('before.command', this.$editable.html());
                this.history.redo();
                this.context.triggerEvent('change', this.$editable.html());
            };
            /**
             * before command
             */
            Editor.prototype.beforeCommand = function () {
                this.context.triggerEvent('before.command', this.$editable.html());
                // keep focus on editable before command execution
                this.focus();
            };
            /**
             * after command
             * @param {Boolean} isPreventTrigger
             */
            Editor.prototype.afterCommand = function (isPreventTrigger) {
                this.normalizeContent();
                this.history.recordUndo();
                if (!isPreventTrigger) {
                    this.context.triggerEvent('change', this.$editable.html());
                }
            };
            /**
             * handle tab key
             */
            Editor.prototype.tab = function () {
                var rng = this.createRange();
                if (rng.isCollapsed() && rng.isOnCell()) {
                    this.table.tab(rng);
                } else {
                    if (this.options.tabSize === 0) {
                        return false;
                    }
                    if (!this.isLimited(this.options.tabSize)) {
                        this.beforeCommand();
                        this.typing.insertTab(rng, this.options.tabSize);
                        this.afterCommand();
                    }
                }
            };
            /**
             * handle shift+tab key
             */
            Editor.prototype.untab = function () {
                var rng = this.createRange();
                if (rng.isCollapsed() && rng.isOnCell()) {
                    this.table.tab(rng, true);
                } else {
                    if (this.options.tabSize === 0) {
                        return false;
                    }
                }
            };
            /**
             * run given function between beforeCommand and afterCommand
             */
            Editor.prototype.wrapCommand = function (fn) {
                var _this = this;
                return function () {
                    _this.beforeCommand();
                    fn.apply(_this, arguments);
                    _this.afterCommand();
                };
            };
            /**
             * insert image
             *
             * @param {String} src
             * @param {String|Function} param
             * @return {Promise}
             */
            Editor.prototype.insertImage = function (src, param) {
                var _this = this;
                return createImage(src, param).then(function ($image) {
                    _this.beforeCommand();
                    if (typeof param === 'function') {
                        param($image);
                    } else {
                        if (typeof param === 'string') {
                            $image.attr('data-filename', param);
                        }
                        $image.css('width', Math.min(_this.$editable.width(), $image.width()));
                    }
                    $image.show();
                    range.create(_this.editable).insertNode($image[0]);
                    range.createFromNodeAfter($image[0]).select();
                    _this.afterCommand();
                }).fail(function (e) {
                    _this.context.triggerEvent('image.upload.error', e);
                });
            };
            /**
             * insertImages
             * @param {File[]} files
             */
            Editor.prototype.insertImages = function (files) {
                var _this = this;
                $$1.each(files, function (idx, file) {
                    var filename = file.name;
                    if (_this.options.maximumImageFileSize && _this.options.maximumImageFileSize < file.size) {
                        _this.context.triggerEvent('image.upload.error', _this.lang.image.maximumFileSizeError);
                    } else {
                        readFileAsDataURL(file).then(function (dataURL) {
                            return _this.insertImage(dataURL, filename);
                        }).fail(function () {
                            _this.context.triggerEvent('image.upload.error');
                        });
                    }
                });
            };
            /**
             * insertImagesOrCallback
             * @param {File[]} files
             */
            Editor.prototype.insertImagesOrCallback = function (files) {
                var callbacks = this.options.callbacks;
                // If onImageUpload this.options setted
                if (callbacks.onImageUpload) {
                    this.context.triggerEvent('image.upload', files);
                    // else insert Image as dataURL
                } else {
                    this.insertImages(files);
                }
            };
            /**
             * return selected plain text
             * @return {String} text
             */
            Editor.prototype.getSelectedText = function () {
                var rng = this.createRange();
                // if range on anchor, expand range with anchor
                if (rng.isOnAnchor()) {
                    rng = range.createFromNode(dom.ancestor(rng.sc, dom.isAnchor));
                }
                return rng.toString();
            };
            Editor.prototype.onFormatBlock = function (tagName, $target) {
                // [workaround] for MSIE, IE need `<`
                tagName = env.isMSIE ? '<' + tagName + '>' : tagName;
                document.execCommand('FormatBlock', false, tagName);
                // support custom class
                if ($target && $target.length) {
                    var className = $target[0].className || '';
                    if (className) {
                        var currentRange = this.createRange();
                        var $parent = $$1([currentRange.sc, currentRange.ec]).closest(tagName);
                        $parent.addClass(className);
                    }
                }
            };
            Editor.prototype.formatPara = function () {
                this.formatBlock('P');
            };
            Editor.prototype.fontStyling = function (target, value) {
                var rng = this.createRange();
                if (rng) {
                    var spans = this.style.styleNodes(rng);
                    $$1(spans).css(target, value);
                    // [workaround] added styled bogus span for style
                    //  - also bogus character needed for cursor position
                    if (rng.isCollapsed()) {
                        var firstSpan = lists.head(spans);
                        if (firstSpan && !dom.nodeLength(firstSpan)) {
                            firstSpan.innerHTML = dom.ZERO_WIDTH_NBSP_CHAR;
                            range.createFromNodeAfter(firstSpan.firstChild).select();
                            this.$editable.data(KEY_BOGUS, firstSpan);
                        }
                    }
                }
            };
            /**
             * unlink
             *
             * @type command
             */
            Editor.prototype.unlink = function () {
                var rng = this.createRange();
                if (rng.isOnAnchor()) {
                    var anchor = dom.ancestor(rng.sc, dom.isAnchor);
                    rng = range.createFromNode(anchor);
                    rng.select();
                    this.beforeCommand();
                    document.execCommand('unlink');
                    this.afterCommand();
                }
            };
            /**
             * returns link info
             *
             * @return {Object}
             * @return {WrappedRange} return.range
             * @return {String} return.text
             * @return {Boolean} [return.isNewWindow=true]
             * @return {String} [return.url=""]
             */
            Editor.prototype.getLinkInfo = function () {
                var rng = this.createRange().expand(dom.isAnchor);
                // Get the first anchor on range(for edit).
                var $anchor = $$1(lists.head(rng.nodes(dom.isAnchor)));
                var linkInfo = {
                    range: rng,
                    text: rng.toString(),
                    url: $anchor.length ? $anchor.attr('href') : ''
                };
                // Define isNewWindow when anchor exists.
                if ($anchor.length) {
                    linkInfo.isNewWindow = $anchor.attr('target') === '_blank';
                }
                return linkInfo;
            };
            Editor.prototype.addRow = function (position) {
                var rng = this.createRange(this.$editable);
                if (rng.isCollapsed() && rng.isOnCell()) {
                    this.beforeCommand();
                    this.table.addRow(rng, position);
                    this.afterCommand();
                }
            };
            Editor.prototype.addCol = function (position) {
                var rng = this.createRange(this.$editable);
                if (rng.isCollapsed() && rng.isOnCell()) {
                    this.beforeCommand();
                    this.table.addCol(rng, position);
                    this.afterCommand();
                }
            };
            Editor.prototype.deleteRow = function () {
                var rng = this.createRange(this.$editable);
                if (rng.isCollapsed() && rng.isOnCell()) {
                    this.beforeCommand();
                    this.table.deleteRow(rng);
                    this.afterCommand();
                }
            };
            Editor.prototype.deleteCol = function () {
                var rng = this.createRange(this.$editable);
                if (rng.isCollapsed() && rng.isOnCell()) {
                    this.beforeCommand();
                    this.table.deleteCol(rng);
                    this.afterCommand();
                }
            };
            Editor.prototype.deleteTable = function () {
                var rng = this.createRange(this.$editable);
                if (rng.isCollapsed() && rng.isOnCell()) {
                    this.beforeCommand();
                    this.table.deleteTable(rng);
                    this.afterCommand();
                }
            };
            /**
             * @param {Position} pos
             * @param {jQuery} $target - target element
             * @param {Boolean} [bKeepRatio] - keep ratio
             */
            Editor.prototype.resizeTo = function (pos, $target, bKeepRatio) {
                var imageSize;
                if (bKeepRatio) {
                    var newRatio = pos.y / pos.x;
                    var ratio = $target.data('ratio');
                    imageSize = {
                        width: ratio > newRatio ? pos.x : pos.y / ratio,
                        height: ratio > newRatio ? pos.x * ratio : pos.y
                    };
                } else {
                    imageSize = {
                        width: pos.x,
                        height: pos.y
                    };
                }
                $target.css(imageSize);
            };
            /**
             * returns whether editable area has focus or not.
             */
            Editor.prototype.hasFocus = function () {
                return this.$editable.is(':focus');
            };
            /**
             * set focus
             */
            Editor.prototype.focus = function () {
                // [workaround] Screen will move when page is scolled in IE.
                //  - do focus when not focused
                if (!this.hasFocus()) {
                    this.$editable.focus();
                }
            };
            /**
             * returns whether contents is empty or not.
             * @return {Boolean}
             */
            Editor.prototype.isEmpty = function () {
                return dom.isEmpty(this.$editable[0]) || dom.emptyPara === this.$editable.html();
            };
            /**
             * Removes all contents and restores the editable instance to an _emptyPara_.
             */
            Editor.prototype.empty = function () {
                this.context.invoke('code', dom.emptyPara);
            };
            /**
             * normalize content
             */
            Editor.prototype.normalizeContent = function () {
                this.$editable[0].normalize();
            };
            return Editor;
        }();

        var Clipboard = /** @class */function () {
            function Clipboard(context) {
                this.context = context;
                this.$editable = context.layoutInfo.editable;
            }
            Clipboard.prototype.initialize = function () {
                this.$editable.on('paste', this.pasteByEvent.bind(this));
            };
            /**
             * paste by clipboard event
             *
             * @param {Event} event
             */
            Clipboard.prototype.pasteByEvent = function (event) {
                var clipboardData = event.originalEvent.clipboardData;
                if (clipboardData && clipboardData.items && clipboardData.items.length) {
                    var item = lists.head(clipboardData.items);
                    if (item.kind === 'file' && item.type.indexOf('image/') !== -1) {
                        this.context.invoke('editor.insertImagesOrCallback', [item.getAsFile()]);
                    }
                    this.context.invoke('editor.afterCommand');
                }
            };
            return Clipboard;
        }();

        var Dropzone = /** @class */function () {
            function Dropzone(context) {
                this.context = context;
                this.$eventListener = $$1(document);
                this.$editor = context.layoutInfo.editor;
                this.$editable = context.layoutInfo.editable;
                this.options = context.options;
                this.lang = this.options.langInfo;
                this.documentEventHandlers = {};
                this.$dropzone = $$1(['<div class="note-dropzone">', '  <div class="note-dropzone-message"/>', '</div>'].join('')).prependTo(this.$editor);
            }
            /**
             * attach Drag and Drop Events
             */
            Dropzone.prototype.initialize = function () {
                if (this.options.disableDragAndDrop) {
                    // prevent default drop event
                    this.documentEventHandlers.onDrop = function (e) {
                        e.preventDefault();
                    };
                    // do not consider outside of dropzone
                    this.$eventListener = this.$dropzone;
                    this.$eventListener.on('drop', this.documentEventHandlers.onDrop);
                } else {
                    this.attachDragAndDropEvent();
                }
            };
            /**
             * attach Drag and Drop Events
             */
            Dropzone.prototype.attachDragAndDropEvent = function () {
                var _this = this;
                var collection = $$1();
                var $dropzoneMessage = this.$dropzone.find('.note-dropzone-message');
                this.documentEventHandlers.onDragenter = function (e) {
                    var isCodeview = _this.context.invoke('codeview.isActivated');
                    var hasEditorSize = _this.$editor.width() > 0 && _this.$editor.height() > 0;
                    if (!isCodeview && !collection.length && hasEditorSize) {
                        _this.$editor.addClass('dragover');
                        _this.$dropzone.width(_this.$editor.width());
                        _this.$dropzone.height(_this.$editor.height());
                        $dropzoneMessage.text(_this.lang.image.dragImageHere);
                    }
                    collection = collection.add(e.target);
                };
                this.documentEventHandlers.onDragleave = function (e) {
                    collection = collection.not(e.target);
                    if (!collection.length) {
                        _this.$editor.removeClass('dragover');
                    }
                };
                this.documentEventHandlers.onDrop = function () {
                    collection = $$1();
                    _this.$editor.removeClass('dragover');
                };
                // show dropzone on dragenter when dragging a object to document
                // -but only if the editor is visible, i.e. has a positive width and height
                this.$eventListener.on('dragenter', this.documentEventHandlers.onDragenter).on('dragleave', this.documentEventHandlers.onDragleave).on('drop', this.documentEventHandlers.onDrop);
                // change dropzone's message on hover.
                this.$dropzone.on('dragenter', function () {
                    _this.$dropzone.addClass('hover');
                    $dropzoneMessage.text(_this.lang.image.dropImage);
                }).on('dragleave', function () {
                    _this.$dropzone.removeClass('hover');
                    $dropzoneMessage.text(_this.lang.image.dragImageHere);
                });
                // attach dropImage
                this.$dropzone.on('drop', function (event) {
                    var dataTransfer = event.originalEvent.dataTransfer;
                    // stop the browser from opening the dropped content
                    event.preventDefault();
                    if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
                        _this.$editable.focus();
                        _this.context.invoke('editor.insertImagesOrCallback', dataTransfer.files);
                    } else {
                        $$1.each(dataTransfer.types, function (idx, type) {
                            var content = dataTransfer.getData(type);
                            if (type.toLowerCase().indexOf('text') > -1) {
                                _this.context.invoke('editor.pasteHTML', content);
                            } else {
                                $$1(content).each(function (idx, item) {
                                    _this.context.invoke('editor.insertNode', item);
                                });
                            }
                        });
                    }
                }).on('dragover', false); // prevent default dragover event
            };
            Dropzone.prototype.destroy = function () {
                var _this = this;
                Object.keys(this.documentEventHandlers).forEach(function (key) {
                    _this.$eventListener.off(key.substr(2).toLowerCase(), _this.documentEventHandlers[key]);
                });
                this.documentEventHandlers = {};
            };
            return Dropzone;
        }();

        var CodeMirror;
        if (env.hasCodeMirror) {
            if (env.isSupportAmd) {
                $__require(['codemirror'], function (cm) {
                    CodeMirror = cm;
                });
            } else {
                CodeMirror = window.CodeMirror;
            }
        }
        /**
         * @class Codeview
         */
        var CodeView = /** @class */function () {
            function CodeView(context) {
                this.context = context;
                this.$editor = context.layoutInfo.editor;
                this.$editable = context.layoutInfo.editable;
                this.$codable = context.layoutInfo.codable;
                this.options = context.options;
            }
            CodeView.prototype.sync = function () {
                var isCodeview = this.isActivated();
                if (isCodeview && env.hasCodeMirror) {
                    this.$codable.data('cmEditor').save();
                }
            };
            /**
             * @return {Boolean}
             */
            CodeView.prototype.isActivated = function () {
                return this.$editor.hasClass('codeview');
            };
            /**
             * toggle codeview
             */
            CodeView.prototype.toggle = function () {
                if (this.isActivated()) {
                    this.deactivate();
                } else {
                    this.activate();
                }
                this.context.triggerEvent('codeview.toggled');
            };
            /**
             * activate code view
             */
            CodeView.prototype.activate = function () {
                var _this = this;
                this.$codable.val(dom.html(this.$editable, this.options.prettifyHtml));
                this.$codable.height(this.$editable.height());
                this.context.invoke('toolbar.updateCodeview', true);
                this.$editor.addClass('codeview');
                this.$codable.focus();
                // activate CodeMirror as codable
                if (env.hasCodeMirror) {
                    var cmEditor_1 = CodeMirror.fromTextArea(this.$codable[0], this.options.codemirror);
                    // CodeMirror TernServer
                    if (this.options.codemirror.tern) {
                        var server_1 = new CodeMirror.TernServer(this.options.codemirror.tern);
                        cmEditor_1.ternServer = server_1;
                        cmEditor_1.on('cursorActivity', function (cm) {
                            server_1.updateArgHints(cm);
                        });
                    }
                    cmEditor_1.on('blur', function (event) {
                        _this.context.triggerEvent('blur.codeview', cmEditor_1.getValue(), event);
                    });
                    // CodeMirror hasn't Padding.
                    cmEditor_1.setSize(null, this.$editable.outerHeight());
                    this.$codable.data('cmEditor', cmEditor_1);
                } else {
                    this.$codable.on('blur', function (event) {
                        _this.context.triggerEvent('blur.codeview', _this.$codable.val(), event);
                    });
                }
            };
            /**
             * deactivate code view
             */
            CodeView.prototype.deactivate = function () {
                // deactivate CodeMirror as codable
                if (env.hasCodeMirror) {
                    var cmEditor = this.$codable.data('cmEditor');
                    this.$codable.val(cmEditor.getValue());
                    cmEditor.toTextArea();
                }
                var value = dom.value(this.$codable, this.options.prettifyHtml) || dom.emptyPara;
                var isChange = this.$editable.html() !== value;
                this.$editable.html(value);
                this.$editable.height(this.options.height ? this.$codable.height() : 'auto');
                this.$editor.removeClass('codeview');
                if (isChange) {
                    this.context.triggerEvent('change', this.$editable.html(), this.$editable);
                }
                this.$editable.focus();
                this.context.invoke('toolbar.updateCodeview', false);
            };
            CodeView.prototype.destroy = function () {
                if (this.isActivated()) {
                    this.deactivate();
                }
            };
            return CodeView;
        }();

        var EDITABLE_PADDING = 24;
        var Statusbar = /** @class */function () {
            function Statusbar(context) {
                this.$document = $$1(document);
                this.$statusbar = context.layoutInfo.statusbar;
                this.$editable = context.layoutInfo.editable;
                this.options = context.options;
            }
            Statusbar.prototype.initialize = function () {
                var _this = this;
                if (this.options.airMode || this.options.disableResizeEditor) {
                    this.destroy();
                    return;
                }
                this.$statusbar.on('mousedown', function (event) {
                    event.preventDefault();
                    event.stopPropagation();
                    var editableTop = _this.$editable.offset().top - _this.$document.scrollTop();
                    var onMouseMove = function (event) {
                        var height = event.clientY - (editableTop + EDITABLE_PADDING);
                        height = _this.options.minheight > 0 ? Math.max(height, _this.options.minheight) : height;
                        height = _this.options.maxHeight > 0 ? Math.min(height, _this.options.maxHeight) : height;
                        _this.$editable.height(height);
                    };
                    _this.$document.on('mousemove', onMouseMove).one('mouseup', function () {
                        _this.$document.off('mousemove', onMouseMove);
                    });
                });
            };
            Statusbar.prototype.destroy = function () {
                this.$statusbar.off();
                this.$statusbar.addClass('locked');
            };
            return Statusbar;
        }();

        var Fullscreen = /** @class */function () {
            function Fullscreen(context) {
                var _this = this;
                this.context = context;
                this.$editor = context.layoutInfo.editor;
                this.$toolbar = context.layoutInfo.toolbar;
                this.$editable = context.layoutInfo.editable;
                this.$codable = context.layoutInfo.codable;
                this.$window = $$1(window);
                this.$scrollbar = $$1('html, body');
                this.onResize = function () {
                    _this.resizeTo({
                        h: _this.$window.height() - _this.$toolbar.outerHeight()
                    });
                };
            }
            Fullscreen.prototype.resizeTo = function (size) {
                this.$editable.css('height', size.h);
                this.$codable.css('height', size.h);
                if (this.$codable.data('cmeditor')) {
                    this.$codable.data('cmeditor').setsize(null, size.h);
                }
            };
            /**
             * toggle fullscreen
             */
            Fullscreen.prototype.toggle = function () {
                this.$editor.toggleClass('fullscreen');
                if (this.isFullscreen()) {
                    this.$editable.data('orgHeight', this.$editable.css('height'));
                    this.$window.on('resize', this.onResize).trigger('resize');
                    this.$scrollbar.css('overflow', 'hidden');
                } else {
                    this.$window.off('resize', this.onResize);
                    this.resizeTo({ h: this.$editable.data('orgHeight') });
                    this.$scrollbar.css('overflow', 'visible');
                }
                this.context.invoke('toolbar.updateFullscreen', this.isFullscreen());
            };
            Fullscreen.prototype.isFullscreen = function () {
                return this.$editor.hasClass('fullscreen');
            };
            return Fullscreen;
        }();

        var Handle = /** @class */function () {
            function Handle(context) {
                var _this = this;
                this.context = context;
                this.$document = $$1(document);
                this.$editingArea = context.layoutInfo.editingArea;
                this.options = context.options;
                this.lang = this.options.langInfo;
                this.events = {
                    'summernote.mousedown': function (we, e) {
                        if (_this.update(e.target)) {
                            e.preventDefault();
                        }
                    },
                    'summernote.keyup summernote.scroll summernote.change summernote.dialog.shown': function () {
                        _this.update();
                    },
                    'summernote.disable': function () {
                        _this.hide();
                    },
                    'summernote.codeview.toggled': function () {
                        _this.update();
                    }
                };
            }
            Handle.prototype.initialize = function () {
                var _this = this;
                this.$handle = $$1(['<div class="note-handle">', '<div class="note-control-selection">', '<div class="note-control-selection-bg"></div>', '<div class="note-control-holder note-control-nw"></div>', '<div class="note-control-holder note-control-ne"></div>', '<div class="note-control-holder note-control-sw"></div>', '<div class="', this.options.disableResizeImage ? 'note-control-holder' : 'note-control-sizing', ' note-control-se"></div>', this.options.disableResizeImage ? '' : '<div class="note-control-selection-info"></div>', '</div>', '</div>'].join('')).prependTo(this.$editingArea);
                this.$handle.on('mousedown', function (event) {
                    if (dom.isControlSizing(event.target)) {
                        event.preventDefault();
                        event.stopPropagation();
                        var $target_1 = _this.$handle.find('.note-control-selection').data('target');
                        var posStart_1 = $target_1.offset();
                        var scrollTop_1 = _this.$document.scrollTop();
                        var onMouseMove_1 = function (event) {
                            _this.context.invoke('editor.resizeTo', {
                                x: event.clientX - posStart_1.left,
                                y: event.clientY - (posStart_1.top - scrollTop_1)
                            }, $target_1, !event.shiftKey);
                            _this.update($target_1[0]);
                        };
                        _this.$document.on('mousemove', onMouseMove_1).one('mouseup', function (e) {
                            e.preventDefault();
                            _this.$document.off('mousemove', onMouseMove_1);
                            _this.context.invoke('editor.afterCommand');
                        });
                        if (!$target_1.data('ratio')) {
                            $target_1.data('ratio', $target_1.height() / $target_1.width());
                        }
                    }
                });
                // Listen for scrolling on the handle overlay.
                this.$handle.on('wheel', function (e) {
                    e.preventDefault();
                    _this.update();
                });
            };
            Handle.prototype.destroy = function () {
                this.$handle.remove();
            };
            Handle.prototype.update = function (target) {
                if (this.context.isDisabled()) {
                    return false;
                }
                var isImage = dom.isImg(target);
                var $selection = this.$handle.find('.note-control-selection');
                this.context.invoke('imagePopover.update', target);
                if (isImage) {
                    var $image = $$1(target);
                    var position = $image.position();
                    var pos = {
                        left: position.left + parseInt($image.css('marginLeft'), 10),
                        top: position.top + parseInt($image.css('marginTop'), 10)
                    };
                    // exclude margin
                    var imageSize = {
                        w: $image.outerWidth(false),
                        h: $image.outerHeight(false)
                    };
                    $selection.css({
                        display: 'block',
                        left: pos.left,
                        top: pos.top,
                        width: imageSize.w,
                        height: imageSize.h
                    }).data('target', $image); // save current image element.
                    var origImageObj = new Image();
                    origImageObj.src = $image.attr('src');
                    var sizingText = imageSize.w + 'x' + imageSize.h + ' (' + this.lang.image.original + ': ' + origImageObj.width + 'x' + origImageObj.height + ')';
                    $selection.find('.note-control-selection-info').text(sizingText);
                    this.context.invoke('editor.saveTarget', target);
                } else {
                    this.hide();
                }
                return isImage;
            };
            /**
             * hide
             *
             * @param {jQuery} $handle
             */
            Handle.prototype.hide = function () {
                this.context.invoke('editor.clearTarget');
                this.$handle.children().hide();
            };
            return Handle;
        }();

        var defaultScheme = 'http://';
        var linkPattern = /^([A-Za-z][A-Za-z0-9+-.]*\:[\/\/]?|mailto:[A-Z0-9._%+-]+@)?(www\.)?(.+)$/i;
        var AutoLink = /** @class */function () {
            function AutoLink(context) {
                var _this = this;
                this.context = context;
                this.events = {
                    'summernote.keyup': function (we, e) {
                        if (!e.isDefaultPrevented()) {
                            _this.handleKeyup(e);
                        }
                    },
                    'summernote.keydown': function (we, e) {
                        _this.handleKeydown(e);
                    }
                };
            }
            AutoLink.prototype.initialize = function () {
                this.lastWordRange = null;
            };
            AutoLink.prototype.destroy = function () {
                this.lastWordRange = null;
            };
            AutoLink.prototype.replace = function () {
                if (!this.lastWordRange) {
                    return;
                }
                var keyword = this.lastWordRange.toString();
                var match = keyword.match(linkPattern);
                if (match && (match[1] || match[2])) {
                    var link = match[1] ? keyword : defaultScheme + keyword;
                    var node = $$1('<a />').html(keyword).attr('href', link)[0];
                    this.lastWordRange.insertNode(node);
                    this.lastWordRange = null;
                    this.context.invoke('editor.focus');
                }
            };
            AutoLink.prototype.handleKeydown = function (e) {
                if (lists.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {
                    var wordRange = this.context.invoke('editor.createRange').getWordRange();
                    this.lastWordRange = wordRange;
                }
            };
            AutoLink.prototype.handleKeyup = function (e) {
                if (lists.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {
                    this.replace();
                }
            };
            return AutoLink;
        }();

        /**
         * textarea auto sync.
         */
        var AutoSync = /** @class */function () {
            function AutoSync(context) {
                var _this = this;
                this.$note = context.layoutInfo.note;
                this.events = {
                    'summernote.change': function () {
                        _this.$note.val(context.invoke('code'));
                    }
                };
            }
            AutoSync.prototype.shouldInitialize = function () {
                return dom.isTextarea(this.$note[0]);
            };
            return AutoSync;
        }();

        var Placeholder = /** @class */function () {
            function Placeholder(context) {
                var _this = this;
                this.context = context;
                this.$editingArea = context.layoutInfo.editingArea;
                this.options = context.options;
                this.events = {
                    'summernote.init summernote.change': function () {
                        _this.update();
                    },
                    'summernote.codeview.toggled': function () {
                        _this.update();
                    }
                };
            }
            Placeholder.prototype.shouldInitialize = function () {
                return !!this.options.placeholder;
            };
            Placeholder.prototype.initialize = function () {
                var _this = this;
                this.$placeholder = $$1('<div class="note-placeholder">');
                this.$placeholder.on('click', function () {
                    _this.context.invoke('focus');
                }).text(this.options.placeholder).prependTo(this.$editingArea);
                this.update();
            };
            Placeholder.prototype.destroy = function () {
                this.$placeholder.remove();
            };
            Placeholder.prototype.update = function () {
                var isShow = !this.context.invoke('codeview.isActivated') && this.context.invoke('editor.isEmpty');
                this.$placeholder.toggle(isShow);
            };
            return Placeholder;
        }();

        var Buttons = /** @class */function () {
            function Buttons(context) {
                this.ui = $$1.summernote.ui;
                this.context = context;
                this.$toolbar = context.layoutInfo.toolbar;
                this.options = context.options;
                this.lang = this.options.langInfo;
                this.invertedKeyMap = func.invertObject(this.options.keyMap[env.isMac ? 'mac' : 'pc']);
            }
            Buttons.prototype.representShortcut = function (editorMethod) {
                var shortcut = this.invertedKeyMap[editorMethod];
                if (!this.options.shortcuts || !shortcut) {
                    return '';
                }
                if (env.isMac) {
                    shortcut = shortcut.replace('CMD', '⌘').replace('SHIFT', '⇧');
                }
                shortcut = shortcut.replace('BACKSLASH', '\\').replace('SLASH', '/').replace('LEFTBRACKET', '[').replace('RIGHTBRACKET', ']');
                return ' (' + shortcut + ')';
            };
            Buttons.prototype.button = function (o) {
                if (!this.options.tooltip && o.tooltip) {
                    delete o.tooltip;
                }
                o.container = this.options.container;
                return this.ui.button(o);
            };
            Buttons.prototype.initialize = function () {
                this.addToolbarButtons();
                this.addImagePopoverButtons();
                this.addLinkPopoverButtons();
                this.addTablePopoverButtons();
                this.fontInstalledMap = {};
            };
            Buttons.prototype.destroy = function () {
                delete this.fontInstalledMap;
            };
            Buttons.prototype.isFontInstalled = function (name) {
                if (!this.fontInstalledMap.hasOwnProperty(name)) {
                    this.fontInstalledMap[name] = env.isFontInstalled(name) || lists.contains(this.options.fontNamesIgnoreCheck, name);
                }
                return this.fontInstalledMap[name];
            };
            Buttons.prototype.isFontDeservedToAdd = function (name) {
                var genericFamilies = ['sans-serif', 'serif', 'monospace', 'cursive', 'fantasy'];
                name = name.toLowerCase();
                return name !== '' && this.isFontInstalled(name) && $$1.inArray(name, genericFamilies) === -1;
            };
            Buttons.prototype.addToolbarButtons = function () {
                var _this = this;
                this.context.memo('button.style', function () {
                    return _this.ui.buttonGroup([_this.button({
                        className: 'dropdown-toggle',
                        contents: _this.ui.dropdownButtonContents(_this.ui.icon(_this.options.icons.magic), _this.options),
                        tooltip: _this.lang.style.style,
                        data: {
                            toggle: 'dropdown'
                        }
                    }), _this.ui.dropdown({
                        className: 'dropdown-style',
                        items: _this.options.styleTags,
                        title: _this.lang.style.style,
                        template: function (item) {
                            if (typeof item === 'string') {
                                item = { tag: item, title: _this.lang.style.hasOwnProperty(item) ? _this.lang.style[item] : item };
                            }
                            var tag = item.tag;
                            var title = item.title;
                            var style = item.style ? ' style="' + item.style + '" ' : '';
                            var className = item.className ? ' class="' + item.className + '"' : '';
                            return '<' + tag + style + className + '>' + title + '</' + tag + '>';
                        },
                        click: _this.context.createInvokeHandler('editor.formatBlock')
                    })]).render();
                });
                var _loop_1 = function (styleIdx, styleLen) {
                    var item = this_1.options.styleTags[styleIdx];
                    this_1.context.memo('button.style.' + item, function () {
                        return _this.button({
                            className: 'note-btn-style-' + item,
                            contents: '<div data-value="' + item + '">' + item.toUpperCase() + '</div>',
                            tooltip: _this.lang.style[item],
                            click: _this.context.createInvokeHandler('editor.formatBlock')
                        }).render();
                    });
                };
                var this_1 = this;
                for (var styleIdx = 0, styleLen = this.options.styleTags.length; styleIdx < styleLen; styleIdx++) {
                    _loop_1(styleIdx, styleLen);
                }
                this.context.memo('button.bold', function () {
                    return _this.button({
                        className: 'note-btn-bold',
                        contents: _this.ui.icon(_this.options.icons.bold),
                        tooltip: _this.lang.font.bold + _this.representShortcut('bold'),
                        click: _this.context.createInvokeHandlerAndUpdateState('editor.bold')
                    }).render();
                });
                this.context.memo('button.italic', function () {
                    return _this.button({
                        className: 'note-btn-italic',
                        contents: _this.ui.icon(_this.options.icons.italic),
                        tooltip: _this.lang.font.italic + _this.representShortcut('italic'),
                        click: _this.context.createInvokeHandlerAndUpdateState('editor.italic')
                    }).render();
                });
                this.context.memo('button.underline', function () {
                    return _this.button({
                        className: 'note-btn-underline',
                        contents: _this.ui.icon(_this.options.icons.underline),
                        tooltip: _this.lang.font.underline + _this.representShortcut('underline'),
                        click: _this.context.createInvokeHandlerAndUpdateState('editor.underline')
                    }).render();
                });
                this.context.memo('button.clear', function () {
                    return _this.button({
                        contents: _this.ui.icon(_this.options.icons.eraser),
                        tooltip: _this.lang.font.clear + _this.representShortcut('removeFormat'),
                        click: _this.context.createInvokeHandler('editor.removeFormat')
                    }).render();
                });
                this.context.memo('button.strikethrough', function () {
                    return _this.button({
                        className: 'note-btn-strikethrough',
                        contents: _this.ui.icon(_this.options.icons.strikethrough),
                        tooltip: _this.lang.font.strikethrough + _this.representShortcut('strikethrough'),
                        click: _this.context.createInvokeHandlerAndUpdateState('editor.strikethrough')
                    }).render();
                });
                this.context.memo('button.superscript', function () {
                    return _this.button({
                        className: 'note-btn-superscript',
                        contents: _this.ui.icon(_this.options.icons.superscript),
                        tooltip: _this.lang.font.superscript,
                        click: _this.context.createInvokeHandlerAndUpdateState('editor.superscript')
                    }).render();
                });
                this.context.memo('button.subscript', function () {
                    return _this.button({
                        className: 'note-btn-subscript',
                        contents: _this.ui.icon(_this.options.icons.subscript),
                        tooltip: _this.lang.font.subscript,
                        click: _this.context.createInvokeHandlerAndUpdateState('editor.subscript')
                    }).render();
                });
                this.context.memo('button.fontname', function () {
                    var styleInfo = _this.context.invoke('editor.currentStyle');
                    // Add 'default' fonts into the fontnames array if not exist
                    $$1.each(styleInfo['font-family'].split(','), function (idx, fontname) {
                        fontname = fontname.trim().replace(/['"]+/g, '');
                        if (_this.isFontDeservedToAdd(fontname)) {
                            if ($$1.inArray(fontname, _this.options.fontNames) === -1) {
                                _this.options.fontNames.push(fontname);
                            }
                        }
                    });
                    return _this.ui.buttonGroup([_this.button({
                        className: 'dropdown-toggle',
                        contents: _this.ui.dropdownButtonContents('<span class="note-current-fontname"/>', _this.options),
                        tooltip: _this.lang.font.name,
                        data: {
                            toggle: 'dropdown'
                        }
                    }), _this.ui.dropdownCheck({
                        className: 'dropdown-fontname',
                        checkClassName: _this.options.icons.menuCheck,
                        items: _this.options.fontNames.filter(_this.isFontInstalled.bind(_this)),
                        title: _this.lang.font.name,
                        template: function (item) {
                            return '<span style="font-family: \'' + item + '\'">' + item + '</span>';
                        },
                        click: _this.context.createInvokeHandlerAndUpdateState('editor.fontName')
                    })]).render();
                });
                this.context.memo('button.fontsize', function () {
                    return _this.ui.buttonGroup([_this.button({
                        className: 'dropdown-toggle',
                        contents: _this.ui.dropdownButtonContents('<span class="note-current-fontsize"/>', _this.options),
                        tooltip: _this.lang.font.size,
                        data: {
                            toggle: 'dropdown'
                        }
                    }), _this.ui.dropdownCheck({
                        className: 'dropdown-fontsize',
                        checkClassName: _this.options.icons.menuCheck,
                        items: _this.options.fontSizes,
                        title: _this.lang.font.size,
                        click: _this.context.createInvokeHandlerAndUpdateState('editor.fontSize')
                    })]).render();
                });
                this.context.memo('button.color', function () {
                    return _this.ui.buttonGroup({
                        className: 'note-color',
                        children: [_this.button({
                            className: 'note-current-color-button',
                            contents: _this.ui.icon(_this.options.icons.font + ' note-recent-color'),
                            tooltip: _this.lang.color.recent,
                            click: function (e) {
                                var $button = $$1(e.currentTarget);
                                _this.context.invoke('editor.color', {
                                    backColor: $button.attr('data-backColor'),
                                    foreColor: $button.attr('data-foreColor')
                                });
                            },
                            callback: function ($button) {
                                var $recentColor = $button.find('.note-recent-color');
                                $recentColor.css('background-color', '#FFFF00');
                                $button.attr('data-backColor', '#FFFF00');
                            }
                        }), _this.button({
                            className: 'dropdown-toggle',
                            contents: _this.ui.dropdownButtonContents('', _this.options),
                            tooltip: _this.lang.color.more,
                            data: {
                                toggle: 'dropdown'
                            }
                        }), _this.ui.dropdown({
                            items: ['<div class="note-palette">', '  <div class="note-palette-title">' + _this.lang.color.background + '</div>', '  <div>', '    <button type="button" class="note-color-reset btn btn-light" data-event="backColor" data-value="inherit">', _this.lang.color.transparent, '    </button>', '  </div>', '  <div class="note-holder" data-event="backColor"/>', '</div>', '<div class="note-palette">', '  <div class="note-palette-title">' + _this.lang.color.foreground + '</div>', '  <div>', '    <button type="button" class="note-color-reset btn btn-light" data-event="removeFormat" data-value="foreColor">', _this.lang.color.resetToDefault, '    </button>', '  </div>', '  <div class="note-holder" data-event="foreColor"/>', '</div>'].join(''),
                            callback: function ($dropdown) {
                                $dropdown.find('.note-holder').each(function (idx, item) {
                                    var $holder = $$1(item);
                                    $holder.append(_this.ui.palette({
                                        colors: _this.options.colors,
                                        colorsName: _this.options.colorsName,
                                        eventName: $holder.data('event'),
                                        container: _this.options.container,
                                        tooltip: _this.options.tooltip
                                    }).render());
                                });
                            },
                            click: function (event) {
                                var $button = $$1(event.target);
                                var eventName = $button.data('event');
                                var value = $button.data('value');
                                if (eventName && value) {
                                    var key = eventName === 'backColor' ? 'background-color' : 'color';
                                    var $color = $button.closest('.note-color').find('.note-recent-color');
                                    var $currentButton = $button.closest('.note-color').find('.note-current-color-button');
                                    $color.css(key, value);
                                    $currentButton.attr('data-' + eventName, value);
                                    _this.context.invoke('editor.' + eventName, value);
                                }
                            }
                        })]
                    }).render();
                });
                this.context.memo('button.ul', function () {
                    return _this.button({
                        contents: _this.ui.icon(_this.options.icons.unorderedlist),
                        tooltip: _this.lang.lists.unordered + _this.representShortcut('insertUnorderedList'),
                        click: _this.context.createInvokeHandler('editor.insertUnorderedList')
                    }).render();
                });
                this.context.memo('button.ol', function () {
                    return _this.button({
                        contents: _this.ui.icon(_this.options.icons.orderedlist),
                        tooltip: _this.lang.lists.ordered + _this.representShortcut('insertOrderedList'),
                        click: _this.context.createInvokeHandler('editor.insertOrderedList')
                    }).render();
                });
                var justifyLeft = this.button({
                    contents: this.ui.icon(this.options.icons.alignLeft),
                    tooltip: this.lang.paragraph.left + this.representShortcut('justifyLeft'),
                    click: this.context.createInvokeHandler('editor.justifyLeft')
                });
                var justifyCenter = this.button({
                    contents: this.ui.icon(this.options.icons.alignCenter),
                    tooltip: this.lang.paragraph.center + this.representShortcut('justifyCenter'),
                    click: this.context.createInvokeHandler('editor.justifyCenter')
                });
                var justifyRight = this.button({
                    contents: this.ui.icon(this.options.icons.alignRight),
                    tooltip: this.lang.paragraph.right + this.representShortcut('justifyRight'),
                    click: this.context.createInvokeHandler('editor.justifyRight')
                });
                var justifyFull = this.button({
                    contents: this.ui.icon(this.options.icons.alignJustify),
                    tooltip: this.lang.paragraph.justify + this.representShortcut('justifyFull'),
                    click: this.context.createInvokeHandler('editor.justifyFull')
                });
                var outdent = this.button({
                    contents: this.ui.icon(this.options.icons.outdent),
                    tooltip: this.lang.paragraph.outdent + this.representShortcut('outdent'),
                    click: this.context.createInvokeHandler('editor.outdent')
                });
                var indent = this.button({
                    contents: this.ui.icon(this.options.icons.indent),
                    tooltip: this.lang.paragraph.indent + this.representShortcut('indent'),
                    click: this.context.createInvokeHandler('editor.indent')
                });
                this.context.memo('button.justifyLeft', func.invoke(justifyLeft, 'render'));
                this.context.memo('button.justifyCenter', func.invoke(justifyCenter, 'render'));
                this.context.memo('button.justifyRight', func.invoke(justifyRight, 'render'));
                this.context.memo('button.justifyFull', func.invoke(justifyFull, 'render'));
                this.context.memo('button.outdent', func.invoke(outdent, 'render'));
                this.context.memo('button.indent', func.invoke(indent, 'render'));
                this.context.memo('button.paragraph', function () {
                    return _this.ui.buttonGroup([_this.button({
                        className: 'dropdown-toggle',
                        contents: _this.ui.dropdownButtonContents(_this.ui.icon(_this.options.icons.alignLeft), _this.options),
                        tooltip: _this.lang.paragraph.paragraph,
                        data: {
                            toggle: 'dropdown'
                        }
                    }), _this.ui.dropdown([_this.ui.buttonGroup({
                        className: 'note-align',
                        children: [justifyLeft, justifyCenter, justifyRight, justifyFull]
                    }), _this.ui.buttonGroup({
                        className: 'note-list',
                        children: [outdent, indent]
                    })])]).render();
                });
                this.context.memo('button.height', function () {
                    return _this.ui.buttonGroup([_this.button({
                        className: 'dropdown-toggle',
                        contents: _this.ui.dropdownButtonContents(_this.ui.icon(_this.options.icons.textHeight), _this.options),
                        tooltip: _this.lang.font.height,
                        data: {
                            toggle: 'dropdown'
                        }
                    }), _this.ui.dropdownCheck({
                        items: _this.options.lineHeights,
                        checkClassName: _this.options.icons.menuCheck,
                        className: 'dropdown-line-height',
                        title: _this.lang.font.height,
                        click: _this.context.createInvokeHandler('editor.lineHeight')
                    })]).render();
                });
                this.context.memo('button.table', function () {
                    return _this.ui.buttonGroup([_this.button({
                        className: 'dropdown-toggle',
                        contents: _this.ui.dropdownButtonContents(_this.ui.icon(_this.options.icons.table), _this.options),
                        tooltip: _this.lang.table.table,
                        data: {
                            toggle: 'dropdown'
                        }
                    }), _this.ui.dropdown({
                        title: _this.lang.table.table,
                        className: 'note-table',
                        items: ['<div class="note-dimension-picker">', '  <div class="note-dimension-picker-mousecatcher" data-event="insertTable" data-value="1x1"/>', '  <div class="note-dimension-picker-highlighted"/>', '  <div class="note-dimension-picker-unhighlighted"/>', '</div>', '<div class="note-dimension-display">1 x 1</div>'].join('')
                    })], {
                        callback: function ($node) {
                            var $catcher = $node.find('.note-dimension-picker-mousecatcher');
                            $catcher.css({
                                width: _this.options.insertTableMaxSize.col + 'em',
                                height: _this.options.insertTableMaxSize.row + 'em'
                            }).mousedown(_this.context.createInvokeHandler('editor.insertTable')).on('mousemove', _this.tableMoveHandler.bind(_this));
                        }
                    }).render();
                });
                this.context.memo('button.link', function () {
                    return _this.button({
                        contents: _this.ui.icon(_this.options.icons.link),
                        tooltip: _this.lang.link.link + _this.representShortcut('linkDialog.show'),
                        click: _this.context.createInvokeHandler('linkDialog.show')
                    }).render();
                });
                this.context.memo('button.picture', function () {
                    return _this.button({
                        contents: _this.ui.icon(_this.options.icons.picture),
                        tooltip: _this.lang.image.image,
                        click: _this.context.createInvokeHandler('imageDialog.show')
                    }).render();
                });
                this.context.memo('button.video', function () {
                    return _this.button({
                        contents: _this.ui.icon(_this.options.icons.video),
                        tooltip: _this.lang.video.video,
                        click: _this.context.createInvokeHandler('videoDialog.show')
                    }).render();
                });
                this.context.memo('button.hr', function () {
                    return _this.button({
                        contents: _this.ui.icon(_this.options.icons.minus),
                        tooltip: _this.lang.hr.insert + _this.representShortcut('insertHorizontalRule'),
                        click: _this.context.createInvokeHandler('editor.insertHorizontalRule')
                    }).render();
                });
                this.context.memo('button.fullscreen', function () {
                    return _this.button({
                        className: 'btn-fullscreen',
                        contents: _this.ui.icon(_this.options.icons.arrowsAlt),
                        tooltip: _this.lang.options.fullscreen,
                        click: _this.context.createInvokeHandler('fullscreen.toggle')
                    }).render();
                });
                this.context.memo('button.codeview', function () {
                    return _this.button({
                        className: 'btn-codeview',
                        contents: _this.ui.icon(_this.options.icons.code),
                        tooltip: _this.lang.options.codeview,
                        click: _this.context.createInvokeHandler('codeview.toggle')
                    }).render();
                });
                this.context.memo('button.redo', function () {
                    return _this.button({
                        contents: _this.ui.icon(_this.options.icons.redo),
                        tooltip: _this.lang.history.redo + _this.representShortcut('redo'),
                        click: _this.context.createInvokeHandler('editor.redo')
                    }).render();
                });
                this.context.memo('button.undo', function () {
                    return _this.button({
                        contents: _this.ui.icon(_this.options.icons.undo),
                        tooltip: _this.lang.history.undo + _this.representShortcut('undo'),
                        click: _this.context.createInvokeHandler('editor.undo')
                    }).render();
                });
                this.context.memo('button.help', function () {
                    return _this.button({
                        contents: _this.ui.icon(_this.options.icons.question),
                        tooltip: _this.lang.options.help,
                        click: _this.context.createInvokeHandler('helpDialog.show')
                    }).render();
                });
            };
            /**
             * image : [
             *   ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],
             *   ['float', ['floatLeft', 'floatRight', 'floatNone' ]],
             *   ['remove', ['removeMedia']]
             * ],
             */
            Buttons.prototype.addImagePopoverButtons = function () {
                var _this = this;
                // Image Size Buttons
                this.context.memo('button.imageSize100', function () {
                    return _this.button({
                        contents: '<span class="note-fontsize-10">100%</span>',
                        tooltip: _this.lang.image.resizeFull,
                        click: _this.context.createInvokeHandler('editor.resize', '1')
                    }).render();
                });
                this.context.memo('button.imageSize50', function () {
                    return _this.button({
                        contents: '<span class="note-fontsize-10">50%</span>',
                        tooltip: _this.lang.image.resizeHalf,
                        click: _this.context.createInvokeHandler('editor.resize', '0.5')
                    }).render();
                });
                this.context.memo('button.imageSize25', function () {
                    return _this.button({
                        contents: '<span class="note-fontsize-10">25%</span>',
                        tooltip: _this.lang.image.resizeQuarter,
                        click: _this.context.createInvokeHandler('editor.resize', '0.25')
                    }).render();
                });
                // Float Buttons
                this.context.memo('button.floatLeft', function () {
                    return _this.button({
                        contents: _this.ui.icon(_this.options.icons.alignLeft),
                        tooltip: _this.lang.image.floatLeft,
                        click: _this.context.createInvokeHandler('editor.floatMe', 'left')
                    }).render();
                });
                this.context.memo('button.floatRight', function () {
                    return _this.button({
                        contents: _this.ui.icon(_this.options.icons.alignRight),
                        tooltip: _this.lang.image.floatRight,
                        click: _this.context.createInvokeHandler('editor.floatMe', 'right')
                    }).render();
                });
                this.context.memo('button.floatNone', function () {
                    return _this.button({
                        contents: _this.ui.icon(_this.options.icons.alignJustify),
                        tooltip: _this.lang.image.floatNone,
                        click: _this.context.createInvokeHandler('editor.floatMe', 'none')
                    }).render();
                });
                // Remove Buttons
                this.context.memo('button.removeMedia', function () {
                    return _this.button({
                        contents: _this.ui.icon(_this.options.icons.trash),
                        tooltip: _this.lang.image.remove,
                        click: _this.context.createInvokeHandler('editor.removeMedia')
                    }).render();
                });
            };
            Buttons.prototype.addLinkPopoverButtons = function () {
                var _this = this;
                this.context.memo('button.linkDialogShow', function () {
                    return _this.button({
                        contents: _this.ui.icon(_this.options.icons.link),
                        tooltip: _this.lang.link.edit,
                        click: _this.context.createInvokeHandler('linkDialog.show')
                    }).render();
                });
                this.context.memo('button.unlink', function () {
                    return _this.button({
                        contents: _this.ui.icon(_this.options.icons.unlink),
                        tooltip: _this.lang.link.unlink,
                        click: _this.context.createInvokeHandler('editor.unlink')
                    }).render();
                });
            };
            /**
             * table : [
             *  ['add', ['addRowDown', 'addRowUp', 'addColLeft', 'addColRight']],
             *  ['delete', ['deleteRow', 'deleteCol', 'deleteTable']]
             * ],
             */
            Buttons.prototype.addTablePopoverButtons = function () {
                var _this = this;
                this.context.memo('button.addRowUp', function () {
                    return _this.button({
                        className: 'btn-md',
                        contents: _this.ui.icon(_this.options.icons.rowAbove),
                        tooltip: _this.lang.table.addRowAbove,
                        click: _this.context.createInvokeHandler('editor.addRow', 'top')
                    }).render();
                });
                this.context.memo('button.addRowDown', function () {
                    return _this.button({
                        className: 'btn-md',
                        contents: _this.ui.icon(_this.options.icons.rowBelow),
                        tooltip: _this.lang.table.addRowBelow,
                        click: _this.context.createInvokeHandler('editor.addRow', 'bottom')
                    }).render();
                });
                this.context.memo('button.addColLeft', function () {
                    return _this.button({
                        className: 'btn-md',
                        contents: _this.ui.icon(_this.options.icons.colBefore),
                        tooltip: _this.lang.table.addColLeft,
                        click: _this.context.createInvokeHandler('editor.addCol', 'left')
                    }).render();
                });
                this.context.memo('button.addColRight', function () {
                    return _this.button({
                        className: 'btn-md',
                        contents: _this.ui.icon(_this.options.icons.colAfter),
                        tooltip: _this.lang.table.addColRight,
                        click: _this.context.createInvokeHandler('editor.addCol', 'right')
                    }).render();
                });
                this.context.memo('button.deleteRow', function () {
                    return _this.button({
                        className: 'btn-md',
                        contents: _this.ui.icon(_this.options.icons.rowRemove),
                        tooltip: _this.lang.table.delRow,
                        click: _this.context.createInvokeHandler('editor.deleteRow')
                    }).render();
                });
                this.context.memo('button.deleteCol', function () {
                    return _this.button({
                        className: 'btn-md',
                        contents: _this.ui.icon(_this.options.icons.colRemove),
                        tooltip: _this.lang.table.delCol,
                        click: _this.context.createInvokeHandler('editor.deleteCol')
                    }).render();
                });
                this.context.memo('button.deleteTable', function () {
                    return _this.button({
                        className: 'btn-md',
                        contents: _this.ui.icon(_this.options.icons.trash),
                        tooltip: _this.lang.table.delTable,
                        click: _this.context.createInvokeHandler('editor.deleteTable')
                    }).render();
                });
            };
            Buttons.prototype.build = function ($container, groups) {
                for (var groupIdx = 0, groupLen = groups.length; groupIdx < groupLen; groupIdx++) {
                    var group = groups[groupIdx];
                    var groupName = $$1.isArray(group) ? group[0] : group;
                    var buttons = $$1.isArray(group) ? group.length === 1 ? [group[0]] : group[1] : [group];
                    var $group = this.ui.buttonGroup({
                        className: 'note-' + groupName
                    }).render();
                    for (var idx = 0, len = buttons.length; idx < len; idx++) {
                        var btn = this.context.memo('button.' + buttons[idx]);
                        if (btn) {
                            $group.append(typeof btn === 'function' ? btn(this.context) : btn);
                        }
                    }
                    $group.appendTo($container);
                }
            };
            /**
             * @param {jQuery} [$container]
             */
            Buttons.prototype.updateCurrentStyle = function ($container) {
                var _this = this;
                var $cont = $container || this.$toolbar;
                var styleInfo = this.context.invoke('editor.currentStyle');
                this.updateBtnStates($cont, {
                    '.note-btn-bold': function () {
                        return styleInfo['font-bold'] === 'bold';
                    },
                    '.note-btn-italic': function () {
                        return styleInfo['font-italic'] === 'italic';
                    },
                    '.note-btn-underline': function () {
                        return styleInfo['font-underline'] === 'underline';
                    },
                    '.note-btn-subscript': function () {
                        return styleInfo['font-subscript'] === 'subscript';
                    },
                    '.note-btn-superscript': function () {
                        return styleInfo['font-superscript'] === 'superscript';
                    },
                    '.note-btn-strikethrough': function () {
                        return styleInfo['font-strikethrough'] === 'strikethrough';
                    }
                });
                if (styleInfo['font-family']) {
                    var fontNames = styleInfo['font-family'].split(',').map(function (name) {
                        return name.replace(/[\'\"]/g, '').replace(/\s+$/, '').replace(/^\s+/, '');
                    });
                    var fontName_1 = lists.find(fontNames, this.isFontInstalled.bind(this));
                    $cont.find('.dropdown-fontname a').each(function (idx, item) {
                        var $item = $$1(item);
                        // always compare string to avoid creating another func.
                        var isChecked = $item.data('value') + '' === fontName_1 + '';
                        $item.toggleClass('checked', isChecked);
                    });
                    $cont.find('.note-current-fontname').text(fontName_1).css('font-family', fontName_1);
                }
                if (styleInfo['font-size']) {
                    var fontSize_1 = styleInfo['font-size'];
                    $cont.find('.dropdown-fontsize a').each(function (idx, item) {
                        var $item = $$1(item);
                        // always compare with string to avoid creating another func.
                        var isChecked = $item.data('value') + '' === fontSize_1 + '';
                        $item.toggleClass('checked', isChecked);
                    });
                    $cont.find('.note-current-fontsize').text(fontSize_1);
                }
                if (styleInfo['line-height']) {
                    var lineHeight_1 = styleInfo['line-height'];
                    $cont.find('.dropdown-line-height li a').each(function (idx, item) {
                        // always compare with string to avoid creating another func.
                        var isChecked = $$1(item).data('value') + '' === lineHeight_1 + '';
                        _this.className = isChecked ? 'checked' : '';
                    });
                }
            };
            Buttons.prototype.updateBtnStates = function ($container, infos) {
                var _this = this;
                $$1.each(infos, function (selector, pred) {
                    _this.ui.toggleBtnActive($container.find(selector), pred());
                });
            };
            Buttons.prototype.tableMoveHandler = function (event) {
                var PX_PER_EM = 18;
                var $picker = $$1(event.target.parentNode); // target is mousecatcher
                var $dimensionDisplay = $picker.next();
                var $catcher = $picker.find('.note-dimension-picker-mousecatcher');
                var $highlighted = $picker.find('.note-dimension-picker-highlighted');
                var $unhighlighted = $picker.find('.note-dimension-picker-unhighlighted');
                var posOffset;
                // HTML5 with jQuery - e.offsetX is undefined in Firefox
                if (event.offsetX === undefined) {
                    var posCatcher = $$1(event.target).offset();
                    posOffset = {
                        x: event.pageX - posCatcher.left,
                        y: event.pageY - posCatcher.top
                    };
                } else {
                    posOffset = {
                        x: event.offsetX,
                        y: event.offsetY
                    };
                }
                var dim = {
                    c: Math.ceil(posOffset.x / PX_PER_EM) || 1,
                    r: Math.ceil(posOffset.y / PX_PER_EM) || 1
                };
                $highlighted.css({ width: dim.c + 'em', height: dim.r + 'em' });
                $catcher.data('value', dim.c + 'x' + dim.r);
                if (dim.c > 3 && dim.c < this.options.insertTableMaxSize.col) {
                    $unhighlighted.css({ width: dim.c + 1 + 'em' });
                }
                if (dim.r > 3 && dim.r < this.options.insertTableMaxSize.row) {
                    $unhighlighted.css({ height: dim.r + 1 + 'em' });
                }
                $dimensionDisplay.html(dim.c + ' x ' + dim.r);
            };
            return Buttons;
        }();

        var Toolbar = /** @class */function () {
            function Toolbar(context) {
                this.context = context;
                this.$window = $$1(window);
                this.$document = $$1(document);
                this.ui = $$1.summernote.ui;
                this.$note = context.layoutInfo.note;
                this.$editor = context.layoutInfo.editor;
                this.$toolbar = context.layoutInfo.toolbar;
                this.options = context.options;
                this.followScroll = this.followScroll.bind(this);
            }
            Toolbar.prototype.shouldInitialize = function () {
                return !this.options.airMode;
            };
            Toolbar.prototype.initialize = function () {
                var _this = this;
                this.options.toolbar = this.options.toolbar || [];
                if (!this.options.toolbar.length) {
                    this.$toolbar.hide();
                } else {
                    this.context.invoke('buttons.build', this.$toolbar, this.options.toolbar);
                }
                if (this.options.toolbarContainer) {
                    this.$toolbar.appendTo(this.options.toolbarContainer);
                }
                this.changeContainer(false);
                this.$note.on('summernote.keyup summernote.mouseup summernote.change', function () {
                    _this.context.invoke('buttons.updateCurrentStyle');
                });
                this.context.invoke('buttons.updateCurrentStyle');
                if (this.options.followingToolbar) {
                    this.$window.on('scroll resize', this.followScroll);
                }
            };
            Toolbar.prototype.destroy = function () {
                this.$toolbar.children().remove();
                if (this.options.followingToolbar) {
                    this.$window.off('scroll resize', this.followScroll);
                }
            };
            Toolbar.prototype.followScroll = function () {
                if (this.$editor.hasClass('fullscreen')) {
                    return false;
                }
                var $toolbarWrapper = this.$toolbar.parent('.note-toolbar-wrapper');
                var editorHeight = this.$editor.outerHeight();
                var editorWidth = this.$editor.width();
                var toolbarHeight = this.$toolbar.height();
                $toolbarWrapper.css({
                    height: toolbarHeight
                });
                // check if the web app is currently using another static bar
                var otherBarHeight = 0;
                if (this.options.otherStaticBar) {
                    otherBarHeight = $$1(this.options.otherStaticBar).outerHeight();
                }
                var currentOffset = this.$document.scrollTop();
                var editorOffsetTop = this.$editor.offset().top;
                var editorOffsetBottom = editorOffsetTop + editorHeight;
                var activateOffset = editorOffsetTop - otherBarHeight;
                var deactivateOffsetBottom = editorOffsetBottom - otherBarHeight - toolbarHeight;
                if (currentOffset > activateOffset && currentOffset < deactivateOffsetBottom) {
                    this.$toolbar.css({
                        position: 'fixed',
                        top: otherBarHeight,
                        width: editorWidth
                    });
                } else {
                    this.$toolbar.css({
                        position: 'relative',
                        top: 0,
                        width: '100%'
                    });
                }
            };
            Toolbar.prototype.changeContainer = function (isFullscreen) {
                if (isFullscreen) {
                    this.$toolbar.prependTo(this.$editor);
                } else {
                    if (this.options.toolbarContainer) {
                        this.$toolbar.appendTo(this.options.toolbarContainer);
                    }
                }
            };
            Toolbar.prototype.updateFullscreen = function (isFullscreen) {
                this.ui.toggleBtnActive(this.$toolbar.find('.btn-fullscreen'), isFullscreen);
                this.changeContainer(isFullscreen);
            };
            Toolbar.prototype.updateCodeview = function (isCodeview) {
                this.ui.toggleBtnActive(this.$toolbar.find('.btn-codeview'), isCodeview);
                if (isCodeview) {
                    this.deactivate();
                } else {
                    this.activate();
                }
            };
            Toolbar.prototype.activate = function (isIncludeCodeview) {
                var $btn = this.$toolbar.find('button');
                if (!isIncludeCodeview) {
                    $btn = $btn.not('.btn-codeview');
                }
                this.ui.toggleBtn($btn, true);
            };
            Toolbar.prototype.deactivate = function (isIncludeCodeview) {
                var $btn = this.$toolbar.find('button');
                if (!isIncludeCodeview) {
                    $btn = $btn.not('.btn-codeview');
                }
                this.ui.toggleBtn($btn, false);
            };
            return Toolbar;
        }();

        var LinkDialog = /** @class */function () {
            function LinkDialog(context) {
                this.context = context;
                this.ui = $$1.summernote.ui;
                this.$body = $$1(document.body);
                this.$editor = context.layoutInfo.editor;
                this.options = context.options;
                this.lang = this.options.langInfo;
                context.memo('help.linkDialog.show', this.options.langInfo.help['linkDialog.show']);
            }
            LinkDialog.prototype.initialize = function () {
                var $container = this.options.dialogsInBody ? this.$body : this.$editor;
                var body = ['<div class="form-group note-form-group">', "<label class=\"note-form-label\">" + this.lang.link.textToDisplay + "</label>", '<input class="note-link-text form-control note-form-control  note-input" type="text" />', '</div>', '<div class="form-group note-form-group">', "<label class=\"note-form-label\">" + this.lang.link.url + "</label>", '<input class="note-link-url form-control note-form-control note-input" type="text" value="http://" />', '</div>', !this.options.disableLinkTarget ? $$1('<div/>').append(this.ui.checkbox({
                    id: 'sn-checkbox-open-in-new-window',
                    text: this.lang.link.openInNewWindow,
                    checked: true
                }).render()).html() : ''].join('');
                var buttonClass = 'btn btn-primary note-btn note-btn-primary note-link-btn';
                var footer = "<button type=\"submit\" href=\"#\" class=\"" + buttonClass + "\" disabled>" + this.lang.link.insert + "</button>";
                this.$dialog = this.ui.dialog({
                    className: 'link-dialog',
                    title: this.lang.link.insert,
                    fade: this.options.dialogsFade,
                    body: body,
                    footer: footer
                }).render().appendTo($container);
            };
            LinkDialog.prototype.destroy = function () {
                this.ui.hideDialog(this.$dialog);
                this.$dialog.remove();
            };
            LinkDialog.prototype.bindEnterKey = function ($input, $btn) {
                $input.on('keypress', function (event) {
                    if (event.keyCode === key.code.ENTER) {
                        event.preventDefault();
                        $btn.trigger('click');
                    }
                });
            };
            /**
             * toggle update button
             */
            LinkDialog.prototype.toggleLinkBtn = function ($linkBtn, $linkText, $linkUrl) {
                this.ui.toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());
            };
            /**
             * Show link dialog and set event handlers on dialog controls.
             *
             * @param {Object} linkInfo
             * @return {Promise}
             */
            LinkDialog.prototype.showLinkDialog = function (linkInfo) {
                var _this = this;
                return $$1.Deferred(function (deferred) {
                    var $linkText = _this.$dialog.find('.note-link-text');
                    var $linkUrl = _this.$dialog.find('.note-link-url');
                    var $linkBtn = _this.$dialog.find('.note-link-btn');
                    var $openInNewWindow = _this.$dialog.find('input[type=checkbox]');
                    _this.ui.onDialogShown(_this.$dialog, function () {
                        _this.context.triggerEvent('dialog.shown');
                        // if no url was given, copy text to url
                        if (!linkInfo.url) {
                            linkInfo.url = linkInfo.text;
                        }
                        $linkText.val(linkInfo.text);
                        var handleLinkTextUpdate = function () {
                            _this.toggleLinkBtn($linkBtn, $linkText, $linkUrl);
                            // if linktext was modified by keyup,
                            // stop cloning text from linkUrl
                            linkInfo.text = $linkText.val();
                        };
                        $linkText.on('input', handleLinkTextUpdate).on('paste', function () {
                            setTimeout(handleLinkTextUpdate, 0);
                        });
                        var handleLinkUrlUpdate = function () {
                            _this.toggleLinkBtn($linkBtn, $linkText, $linkUrl);
                            // display same link on `Text to display` input
                            // when create a new link
                            if (!linkInfo.text) {
                                $linkText.val($linkUrl.val());
                            }
                        };
                        $linkUrl.on('input', handleLinkUrlUpdate).on('paste', function () {
                            setTimeout(handleLinkUrlUpdate, 0);
                        }).val(linkInfo.url);
                        if (!env.isSupportTouch) {
                            $linkUrl.trigger('focus');
                        }
                        _this.toggleLinkBtn($linkBtn, $linkText, $linkUrl);
                        _this.bindEnterKey($linkUrl, $linkBtn);
                        _this.bindEnterKey($linkText, $linkBtn);
                        var isChecked = linkInfo.isNewWindow !== undefined ? linkInfo.isNewWindow : _this.context.options.linkTargetBlank;
                        $openInNewWindow.prop('checked', isChecked);
                        $linkBtn.one('click', function (event) {
                            event.preventDefault();
                            deferred.resolve({
                                range: linkInfo.range,
                                url: $linkUrl.val(),
                                text: $linkText.val(),
                                isNewWindow: $openInNewWindow.is(':checked')
                            });
                            _this.ui.hideDialog(_this.$dialog);
                        });
                    });
                    _this.ui.onDialogHidden(_this.$dialog, function () {
                        // detach events
                        $linkText.off('input paste keypress');
                        $linkUrl.off('input paste keypress');
                        $linkBtn.off('click');
                        if (deferred.state() === 'pending') {
                            deferred.reject();
                        }
                    });
                    _this.ui.showDialog(_this.$dialog);
                }).promise();
            };
            /**
             * @param {Object} layoutInfo
             */
            LinkDialog.prototype.show = function () {
                var _this = this;
                var linkInfo = this.context.invoke('editor.getLinkInfo');
                this.context.invoke('editor.saveRange');
                this.showLinkDialog(linkInfo).then(function (linkInfo) {
                    _this.context.invoke('editor.restoreRange');
                    _this.context.invoke('editor.createLink', linkInfo);
                }).fail(function () {
                    _this.context.invoke('editor.restoreRange');
                });
            };
            return LinkDialog;
        }();

        var LinkPopover = /** @class */function () {
            function LinkPopover(context) {
                var _this = this;
                this.context = context;
                this.ui = $$1.summernote.ui;
                this.options = context.options;
                this.events = {
                    'summernote.keyup summernote.mouseup summernote.change summernote.scroll': function () {
                        _this.update();
                    },
                    'summernote.disable summernote.dialog.shown': function () {
                        _this.hide();
                    }
                };
            }
            LinkPopover.prototype.shouldInitialize = function () {
                return !lists.isEmpty(this.options.popover.link);
            };
            LinkPopover.prototype.initialize = function () {
                this.$popover = this.ui.popover({
                    className: 'note-link-popover',
                    callback: function ($node) {
                        var $content = $node.find('.popover-content,.note-popover-content');
                        $content.prepend('<span><a target="_blank"></a>&nbsp;</span>');
                    }
                }).render().appendTo(this.options.container);
                var $content = this.$popover.find('.popover-content,.note-popover-content');
                this.context.invoke('buttons.build', $content, this.options.popover.link);
            };
            LinkPopover.prototype.destroy = function () {
                this.$popover.remove();
            };
            LinkPopover.prototype.update = function () {
                // Prevent focusing on editable when invoke('code') is executed
                if (!this.context.invoke('editor.hasFocus')) {
                    this.hide();
                    return;
                }
                var rng = this.context.invoke('editor.createRange');
                if (rng.isCollapsed() && rng.isOnAnchor()) {
                    var anchor = dom.ancestor(rng.sc, dom.isAnchor);
                    var href = $$1(anchor).attr('href');
                    this.$popover.find('a').attr('href', href).html(href);
                    var pos = dom.posFromPlaceholder(anchor);
                    this.$popover.css({
                        display: 'block',
                        left: pos.left,
                        top: pos.top
                    });
                } else {
                    this.hide();
                }
            };
            LinkPopover.prototype.hide = function () {
                this.$popover.hide();
            };
            return LinkPopover;
        }();

        var ImageDialog = /** @class */function () {
            function ImageDialog(context) {
                this.context = context;
                this.ui = $$1.summernote.ui;
                this.$body = $$1(document.body);
                this.$editor = context.layoutInfo.editor;
                this.options = context.options;
                this.lang = this.options.langInfo;
            }
            ImageDialog.prototype.initialize = function () {
                var $container = this.options.dialogsInBody ? this.$body : this.$editor;
                var imageLimitation = '';
                if (this.options.maximumImageFileSize) {
                    var unit = Math.floor(Math.log(this.options.maximumImageFileSize) / Math.log(1024));
                    var readableSize = (this.options.maximumImageFileSize / Math.pow(1024, unit)).toFixed(2) * 1 + ' ' + ' KMGTP'[unit] + 'B';
                    imageLimitation = "<small>" + (this.lang.image.maximumFileSize + ' : ' + readableSize) + "</small>";
                }
                var body = ['<div class="form-group note-form-group note-group-select-from-files">', '<label class="note-form-label">' + this.lang.image.selectFromFiles + '</label>', '<input class="note-image-input note-form-control note-input" ', ' type="file" name="files" accept="image/*" multiple="multiple" />', imageLimitation, '</div>', '<div class="form-group note-group-image-url" style="overflow:auto;">', '<label class="note-form-label">' + this.lang.image.url + '</label>', '<input class="note-image-url form-control note-form-control note-input ', ' col-md-12" type="text" />', '</div>'].join('');
                var buttonClass = 'btn btn-primary note-btn note-btn-primary note-image-btn';
                var footer = "<button type=\"submit\" href=\"#\" class=\"" + buttonClass + "\" disabled>" + this.lang.image.insert + "</button>";
                this.$dialog = this.ui.dialog({
                    title: this.lang.image.insert,
                    fade: this.options.dialogsFade,
                    body: body,
                    footer: footer
                }).render().appendTo($container);
            };
            ImageDialog.prototype.destroy = function () {
                this.ui.hideDialog(this.$dialog);
                this.$dialog.remove();
            };
            ImageDialog.prototype.bindEnterKey = function ($input, $btn) {
                $input.on('keypress', function (event) {
                    if (event.keyCode === key.code.ENTER) {
                        event.preventDefault();
                        $btn.trigger('click');
                    }
                });
            };
            ImageDialog.prototype.show = function () {
                var _this = this;
                this.context.invoke('editor.saveRange');
                this.showImageDialog().then(function (data) {
                    // [workaround] hide dialog before restore range for IE range focus
                    _this.ui.hideDialog(_this.$dialog);
                    _this.context.invoke('editor.restoreRange');
                    if (typeof data === 'string') {
                        _this.context.invoke('editor.insertImage', data);
                    } else {
                        _this.context.invoke('editor.insertImagesOrCallback', data);
                    }
                }).fail(function () {
                    _this.context.invoke('editor.restoreRange');
                });
            };
            /**
             * show image dialog
             *
             * @param {jQuery} $dialog
             * @return {Promise}
             */
            ImageDialog.prototype.showImageDialog = function () {
                var _this = this;
                return $$1.Deferred(function (deferred) {
                    var $imageInput = _this.$dialog.find('.note-image-input');
                    var $imageUrl = _this.$dialog.find('.note-image-url');
                    var $imageBtn = _this.$dialog.find('.note-image-btn');
                    _this.ui.onDialogShown(_this.$dialog, function () {
                        _this.context.triggerEvent('dialog.shown');
                        // Cloning imageInput to clear element.
                        $imageInput.replaceWith($imageInput.clone().on('change', function (event) {
                            deferred.resolve(event.target.files || event.target.value);
                        }).val(''));
                        $imageBtn.click(function (event) {
                            event.preventDefault();
                            deferred.resolve($imageUrl.val());
                        });
                        $imageUrl.on('keyup paste', function () {
                            var url = $imageUrl.val();
                            _this.ui.toggleBtn($imageBtn, url);
                        }).val('');
                        if (!env.isSupportTouch) {
                            $imageUrl.trigger('focus');
                        }
                        _this.bindEnterKey($imageUrl, $imageBtn);
                    });
                    _this.ui.onDialogHidden(_this.$dialog, function () {
                        $imageInput.off('change');
                        $imageUrl.off('keyup paste keypress');
                        $imageBtn.off('click');
                        if (deferred.state() === 'pending') {
                            deferred.reject();
                        }
                    });
                    _this.ui.showDialog(_this.$dialog);
                });
            };
            return ImageDialog;
        }();

        /**
         * Image popover module
         *  mouse events that show/hide popover will be handled by Handle.js.
         *  Handle.js will receive the events and invoke 'imagePopover.update'.
         */
        var ImagePopover = /** @class */function () {
            function ImagePopover(context) {
                var _this = this;
                this.context = context;
                this.ui = $$1.summernote.ui;
                this.editable = context.layoutInfo.editable[0];
                this.options = context.options;
                this.events = {
                    'summernote.disable': function () {
                        _this.hide();
                    }
                };
            }
            ImagePopover.prototype.shouldInitialize = function () {
                return !lists.isEmpty(this.options.popover.image);
            };
            ImagePopover.prototype.initialize = function () {
                this.$popover = this.ui.popover({
                    className: 'note-image-popover'
                }).render().appendTo(this.options.container);
                var $content = this.$popover.find('.popover-content,.note-popover-content');
                this.context.invoke('buttons.build', $content, this.options.popover.image);
            };
            ImagePopover.prototype.destroy = function () {
                this.$popover.remove();
            };
            ImagePopover.prototype.update = function (target) {
                if (dom.isImg(target)) {
                    var pos = dom.posFromPlaceholder(target);
                    var posEditor = dom.posFromPlaceholder(this.editable);
                    this.$popover.css({
                        display: 'block',
                        left: this.options.popatmouse ? event.pageX - 20 : pos.left,
                        top: this.options.popatmouse ? event.pageY : Math.min(pos.top, posEditor.top)
                    });
                } else {
                    this.hide();
                }
            };
            ImagePopover.prototype.hide = function () {
                this.$popover.hide();
            };
            return ImagePopover;
        }();

        var TablePopover = /** @class */function () {
            function TablePopover(context) {
                var _this = this;
                this.context = context;
                this.ui = $$1.summernote.ui;
                this.options = context.options;
                this.events = {
                    'summernote.mousedown': function (we, e) {
                        _this.update(e.target);
                    },
                    'summernote.keyup summernote.scroll summernote.change': function () {
                        _this.update();
                    },
                    'summernote.disable': function () {
                        _this.hide();
                    }
                };
            }
            TablePopover.prototype.shouldInitialize = function () {
                return !lists.isEmpty(this.options.popover.table);
            };
            TablePopover.prototype.initialize = function () {
                this.$popover = this.ui.popover({
                    className: 'note-table-popover'
                }).render().appendTo(this.options.container);
                var $content = this.$popover.find('.popover-content,.note-popover-content');
                this.context.invoke('buttons.build', $content, this.options.popover.table);
                // [workaround] Disable Firefox's default table editor
                if (env.isFF) {
                    document.execCommand('enableInlineTableEditing', false, false);
                }
            };
            TablePopover.prototype.destroy = function () {
                this.$popover.remove();
            };
            TablePopover.prototype.update = function (target) {
                if (this.context.isDisabled()) {
                    return false;
                }
                var isCell = dom.isCell(target);
                if (isCell) {
                    var pos = dom.posFromPlaceholder(target);
                    this.$popover.css({
                        display: 'block',
                        left: pos.left,
                        top: pos.top
                    });
                } else {
                    this.hide();
                }
                return isCell;
            };
            TablePopover.prototype.hide = function () {
                this.$popover.hide();
            };
            return TablePopover;
        }();

        var VideoDialog = /** @class */function () {
            function VideoDialog(context) {
                this.context = context;
                this.ui = $$1.summernote.ui;
                this.$body = $$1(document.body);
                this.$editor = context.layoutInfo.editor;
                this.options = context.options;
                this.lang = this.options.langInfo;
            }
            VideoDialog.prototype.initialize = function () {
                var $container = this.options.dialogsInBody ? this.$body : this.$editor;
                var body = ['<div class="form-group note-form-group row-fluid">', "<label class=\"note-form-label\">" + this.lang.video.url + " <small class=\"text-muted\">" + this.lang.video.providers + "</small></label>", '<input class="note-video-url form-control note-form-control note-input" type="text" />', '</div>'].join('');
                var buttonClass = 'btn btn-primary note-btn note-btn-primary note-video-btn';
                var footer = "<button type=\"submit\" href=\"#\" class=\"" + buttonClass + "\" disabled>" + this.lang.video.insert + "</button>";
                this.$dialog = this.ui.dialog({
                    title: this.lang.video.insert,
                    fade: this.options.dialogsFade,
                    body: body,
                    footer: footer
                }).render().appendTo($container);
            };
            VideoDialog.prototype.destroy = function () {
                this.ui.hideDialog(this.$dialog);
                this.$dialog.remove();
            };
            VideoDialog.prototype.bindEnterKey = function ($input, $btn) {
                $input.on('keypress', function (event) {
                    if (event.keyCode === key.code.ENTER) {
                        event.preventDefault();
                        $btn.trigger('click');
                    }
                });
            };
            VideoDialog.prototype.createVideoNode = function (url) {
                // video url patterns(youtube, instagram, vimeo, dailymotion, youku, mp4, ogg, webm)
                var ytRegExp = /^(?:https?:\/\/)?(?:www\.)?(?:youtu\.be\/|youtube\.com\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=))((\w|-){11})(?:\S+)?$/;
                var ytMatch = url.match(ytRegExp);
                var igRegExp = /(?:www\.|\/\/)instagram\.com\/p\/(.[a-zA-Z0-9_-]*)/;
                var igMatch = url.match(igRegExp);
                var vRegExp = /\/\/vine\.co\/v\/([a-zA-Z0-9]+)/;
                var vMatch = url.match(vRegExp);
                var vimRegExp = /\/\/(player\.)?vimeo\.com\/([a-z]*\/)*(\d+)[?]?.*/;
                var vimMatch = url.match(vimRegExp);
                var dmRegExp = /.+dailymotion.com\/(video|hub)\/([^_]+)[^#]*(#video=([^_&]+))?/;
                var dmMatch = url.match(dmRegExp);
                var youkuRegExp = /\/\/v\.youku\.com\/v_show\/id_(\w+)=*\.html/;
                var youkuMatch = url.match(youkuRegExp);
                var qqRegExp = /\/\/v\.qq\.com.*?vid=(.+)/;
                var qqMatch = url.match(qqRegExp);
                var qqRegExp2 = /\/\/v\.qq\.com\/x?\/?(page|cover).*?\/([^\/]+)\.html\??.*/;
                var qqMatch2 = url.match(qqRegExp2);
                var mp4RegExp = /^.+.(mp4|m4v)$/;
                var mp4Match = url.match(mp4RegExp);
                var oggRegExp = /^.+.(ogg|ogv)$/;
                var oggMatch = url.match(oggRegExp);
                var webmRegExp = /^.+.(webm)$/;
                var webmMatch = url.match(webmRegExp);
                var $video;
                if (ytMatch && ytMatch[1].length === 11) {
                    var youtubeId = ytMatch[1];
                    $video = $$1('<iframe>').attr('frameborder', 0).attr('src', '//www.youtube.com/embed/' + youtubeId).attr('width', '640').attr('height', '360');
                } else if (igMatch && igMatch[0].length) {
                    $video = $$1('<iframe>').attr('frameborder', 0).attr('src', 'https://instagram.com/p/' + igMatch[1] + '/embed/').attr('width', '612').attr('height', '710').attr('scrolling', 'no').attr('allowtransparency', 'true');
                } else if (vMatch && vMatch[0].length) {
                    $video = $$1('<iframe>').attr('frameborder', 0).attr('src', vMatch[0] + '/embed/simple').attr('width', '600').attr('height', '600').attr('class', 'vine-embed');
                } else if (vimMatch && vimMatch[3].length) {
                    $video = $$1('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>').attr('frameborder', 0).attr('src', '//player.vimeo.com/video/' + vimMatch[3]).attr('width', '640').attr('height', '360');
                } else if (dmMatch && dmMatch[2].length) {
                    $video = $$1('<iframe>').attr('frameborder', 0).attr('src', '//www.dailymotion.com/embed/video/' + dmMatch[2]).attr('width', '640').attr('height', '360');
                } else if (youkuMatch && youkuMatch[1].length) {
                    $video = $$1('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>').attr('frameborder', 0).attr('height', '498').attr('width', '510').attr('src', '//player.youku.com/embed/' + youkuMatch[1]);
                } else if (qqMatch && qqMatch[1].length || qqMatch2 && qqMatch2[2].length) {
                    var vid = qqMatch && qqMatch[1].length ? qqMatch[1] : qqMatch2[2];
                    $video = $$1('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>').attr('frameborder', 0).attr('height', '310').attr('width', '500').attr('src', 'http://v.qq.com/iframe/player.html?vid=' + vid + '&amp;auto=0');
                } else if (mp4Match || oggMatch || webmMatch) {
                    $video = $$1('<video controls>').attr('src', url).attr('width', '640').attr('height', '360');
                } else {
                    // this is not a known video link. Now what, Cat? Now what?
                    return false;
                }
                $video.addClass('note-video-clip');
                return $video[0];
            };
            VideoDialog.prototype.show = function () {
                var _this = this;
                var text = this.context.invoke('editor.getSelectedText');
                this.context.invoke('editor.saveRange');
                this.showVideoDialog(text).then(function (url) {
                    // [workaround] hide dialog before restore range for IE range focus
                    _this.ui.hideDialog(_this.$dialog);
                    _this.context.invoke('editor.restoreRange');
                    // build node
                    var $node = _this.createVideoNode(url);
                    if ($node) {
                        // insert video node
                        _this.context.invoke('editor.insertNode', $node);
                    }
                }).fail(function () {
                    _this.context.invoke('editor.restoreRange');
                });
            };
            /**
             * show image dialog
             *
             * @param {jQuery} $dialog
             * @return {Promise}
             */
            VideoDialog.prototype.showVideoDialog = function (text) {
                var _this = this;
                return $$1.Deferred(function (deferred) {
                    var $videoUrl = _this.$dialog.find('.note-video-url');
                    var $videoBtn = _this.$dialog.find('.note-video-btn');
                    _this.ui.onDialogShown(_this.$dialog, function () {
                        _this.context.triggerEvent('dialog.shown');
                        $videoUrl.val(text).on('input', function () {
                            _this.ui.toggleBtn($videoBtn, $videoUrl.val());
                        });
                        if (!env.isSupportTouch) {
                            $videoUrl.trigger('focus');
                        }
                        $videoBtn.click(function (event) {
                            event.preventDefault();
                            deferred.resolve($videoUrl.val());
                        });
                        _this.bindEnterKey($videoUrl, $videoBtn);
                    });
                    _this.ui.onDialogHidden(_this.$dialog, function () {
                        $videoUrl.off('input');
                        $videoBtn.off('click');
                        if (deferred.state() === 'pending') {
                            deferred.reject();
                        }
                    });
                    _this.ui.showDialog(_this.$dialog);
                });
            };
            return VideoDialog;
        }();

        var HelpDialog = /** @class */function () {
            function HelpDialog(context) {
                this.context = context;
                this.ui = $$1.summernote.ui;
                this.$body = $$1(document.body);
                this.$editor = context.layoutInfo.editor;
                this.options = context.options;
                this.lang = this.options.langInfo;
            }
            HelpDialog.prototype.initialize = function () {
                var $container = this.options.dialogsInBody ? this.$body : this.$editor;
                var body = ['<p class="text-center">', '<a href="http://summernote.org/" target="_blank">Summernote 0.8.10</a> · ', '<a href="https://github.com/summernote/summernote" target="_blank">Project</a> · ', '<a href="https://github.com/summernote/summernote/issues" target="_blank">Issues</a>', '</p>'].join('');
                this.$dialog = this.ui.dialog({
                    title: this.lang.options.help,
                    fade: this.options.dialogsFade,
                    body: this.createShortcutList(),
                    footer: body,
                    callback: function ($node) {
                        $node.find('.modal-body,.note-modal-body').css({
                            'max-height': 300,
                            'overflow': 'scroll'
                        });
                    }
                }).render().appendTo($container);
            };
            HelpDialog.prototype.destroy = function () {
                this.ui.hideDialog(this.$dialog);
                this.$dialog.remove();
            };
            HelpDialog.prototype.createShortcutList = function () {
                var _this = this;
                var keyMap = this.options.keyMap[env.isMac ? 'mac' : 'pc'];
                return Object.keys(keyMap).map(function (key) {
                    var command = keyMap[key];
                    var $row = $$1('<div><div class="help-list-item"/></div>');
                    $row.append($$1('<label><kbd>' + key + '</kdb></label>').css({
                        'width': 180,
                        'margin-right': 10
                    })).append($$1('<span/>').html(_this.context.memo('help.' + command) || command));
                    return $row.html();
                }).join('');
            };
            /**
             * show help dialog
             *
             * @return {Promise}
             */
            HelpDialog.prototype.showHelpDialog = function () {
                var _this = this;
                return $$1.Deferred(function (deferred) {
                    _this.ui.onDialogShown(_this.$dialog, function () {
                        _this.context.triggerEvent('dialog.shown');
                        deferred.resolve();
                    });
                    _this.ui.showDialog(_this.$dialog);
                }).promise();
            };
            HelpDialog.prototype.show = function () {
                var _this = this;
                this.context.invoke('editor.saveRange');
                this.showHelpDialog().then(function () {
                    _this.context.invoke('editor.restoreRange');
                });
            };
            return HelpDialog;
        }();

        var AIR_MODE_POPOVER_X_OFFSET = 20;
        var AirPopover = /** @class */function () {
            function AirPopover(context) {
                var _this = this;
                this.context = context;
                this.ui = $$1.summernote.ui;
                this.options = context.options;
                this.events = {
                    'summernote.keyup summernote.mouseup summernote.scroll': function () {
                        _this.update();
                    },
                    'summernote.disable summernote.change summernote.dialog.shown': function () {
                        _this.hide();
                    },
                    'summernote.focusout': function (we, e) {
                        // [workaround] Firefox doesn't support relatedTarget on focusout
                        //  - Ignore hide action on focus out in FF.
                        if (env.isFF) {
                            return;
                        }
                        if (!e.relatedTarget || !dom.ancestor(e.relatedTarget, func.eq(_this.$popover[0]))) {
                            _this.hide();
                        }
                    }
                };
            }
            AirPopover.prototype.shouldInitialize = function () {
                return this.options.airMode && !lists.isEmpty(this.options.popover.air);
            };
            AirPopover.prototype.initialize = function () {
                this.$popover = this.ui.popover({
                    className: 'note-air-popover'
                }).render().appendTo(this.options.container);
                var $content = this.$popover.find('.popover-content');
                this.context.invoke('buttons.build', $content, this.options.popover.air);
            };
            AirPopover.prototype.destroy = function () {
                this.$popover.remove();
            };
            AirPopover.prototype.update = function () {
                var styleInfo = this.context.invoke('editor.currentStyle');
                if (styleInfo.range && !styleInfo.range.isCollapsed()) {
                    var rect = lists.last(styleInfo.range.getClientRects());
                    if (rect) {
                        var bnd = func.rect2bnd(rect);
                        this.$popover.css({
                            display: 'block',
                            left: Math.max(bnd.left + bnd.width / 2, 0) - AIR_MODE_POPOVER_X_OFFSET,
                            top: bnd.top + bnd.height
                        });
                        this.context.invoke('buttons.updateCurrentStyle', this.$popover);
                    }
                } else {
                    this.hide();
                }
            };
            AirPopover.prototype.hide = function () {
                this.$popover.hide();
            };
            return AirPopover;
        }();

        var POPOVER_DIST = 5;
        var HintPopover = /** @class */function () {
            function HintPopover(context) {
                var _this = this;
                this.context = context;
                this.ui = $$1.summernote.ui;
                this.$editable = context.layoutInfo.editable;
                this.options = context.options;
                this.hint = this.options.hint || [];
                this.direction = this.options.hintDirection || 'bottom';
                this.hints = $$1.isArray(this.hint) ? this.hint : [this.hint];
                this.events = {
                    'summernote.keyup': function (we, e) {
                        if (!e.isDefaultPrevented()) {
                            _this.handleKeyup(e);
                        }
                    },
                    'summernote.keydown': function (we, e) {
                        _this.handleKeydown(e);
                    },
                    'summernote.disable summernote.dialog.shown': function () {
                        _this.hide();
                    }
                };
            }
            HintPopover.prototype.shouldInitialize = function () {
                return this.hints.length > 0;
            };
            HintPopover.prototype.initialize = function () {
                var _this = this;
                this.lastWordRange = null;
                this.$popover = this.ui.popover({
                    className: 'note-hint-popover',
                    hideArrow: true,
                    direction: ''
                }).render().appendTo(this.options.container);
                this.$popover.hide();
                this.$content = this.$popover.find('.popover-content,.note-popover-content');
                this.$content.on('click', '.note-hint-item', function () {
                    _this.$content.find('.active').removeClass('active');
                    $$1(_this).addClass('active');
                    _this.replace();
                });
            };
            HintPopover.prototype.destroy = function () {
                this.$popover.remove();
            };
            HintPopover.prototype.selectItem = function ($item) {
                this.$content.find('.active').removeClass('active');
                $item.addClass('active');
                this.$content[0].scrollTop = $item[0].offsetTop - this.$content.innerHeight() / 2;
            };
            HintPopover.prototype.moveDown = function () {
                var $current = this.$content.find('.note-hint-item.active');
                var $next = $current.next();
                if ($next.length) {
                    this.selectItem($next);
                } else {
                    var $nextGroup = $current.parent().next();
                    if (!$nextGroup.length) {
                        $nextGroup = this.$content.find('.note-hint-group').first();
                    }
                    this.selectItem($nextGroup.find('.note-hint-item').first());
                }
            };
            HintPopover.prototype.moveUp = function () {
                var $current = this.$content.find('.note-hint-item.active');
                var $prev = $current.prev();
                if ($prev.length) {
                    this.selectItem($prev);
                } else {
                    var $prevGroup = $current.parent().prev();
                    if (!$prevGroup.length) {
                        $prevGroup = this.$content.find('.note-hint-group').last();
                    }
                    this.selectItem($prevGroup.find('.note-hint-item').last());
                }
            };
            HintPopover.prototype.replace = function () {
                var $item = this.$content.find('.note-hint-item.active');
                if ($item.length) {
                    var node = this.nodeFromItem($item);
                    // XXX: consider to move codes to editor for recording redo/undo.
                    this.lastWordRange.insertNode(node);
                    range.createFromNode(node).collapse().select();
                    this.lastWordRange = null;
                    this.hide();
                    this.context.triggerEvent('change', this.$editable.html(), this.$editable[0]);
                    this.context.invoke('editor.focus');
                }
            };
            HintPopover.prototype.nodeFromItem = function ($item) {
                var hint = this.hints[$item.data('index')];
                var item = $item.data('item');
                var node = hint.content ? hint.content(item) : item;
                if (typeof node === 'string') {
                    node = dom.createText(node);
                }
                return node;
            };
            HintPopover.prototype.createItemTemplates = function (hintIdx, items) {
                var hint = this.hints[hintIdx];
                return items.map(function (item, idx) {
                    var $item = $$1('<div class="note-hint-item"/>');
                    $item.append(hint.template ? hint.template(item) : item + '');
                    $item.data({
                        'index': hintIdx,
                        'item': item
                    });
                    return $item;
                });
            };
            HintPopover.prototype.handleKeydown = function (e) {
                if (!this.$popover.is(':visible')) {
                    return;
                }
                if (e.keyCode === key.code.ENTER) {
                    e.preventDefault();
                    this.replace();
                } else if (e.keyCode === key.code.UP) {
                    e.preventDefault();
                    this.moveUp();
                } else if (e.keyCode === key.code.DOWN) {
                    e.preventDefault();
                    this.moveDown();
                }
            };
            HintPopover.prototype.searchKeyword = function (index, keyword, callback) {
                var hint = this.hints[index];
                if (hint && hint.match.test(keyword) && hint.search) {
                    var matches = hint.match.exec(keyword);
                    hint.search(matches[1], callback);
                } else {
                    callback();
                }
            };
            HintPopover.prototype.createGroup = function (idx, keyword) {
                var _this = this;
                var $group = $$1('<div class="note-hint-group note-hint-group-' + idx + '"/>');
                this.searchKeyword(idx, keyword, function (items) {
                    items = items || [];
                    if (items.length) {
                        $group.html(_this.createItemTemplates(idx, items));
                        _this.show();
                    }
                });
                return $group;
            };
            HintPopover.prototype.handleKeyup = function (e) {
                var _this = this;
                if (!lists.contains([key.code.ENTER, key.code.UP, key.code.DOWN], e.keyCode)) {
                    var wordRange = this.context.invoke('editor.createRange').getWordRange();
                    var keyword_1 = wordRange.toString();
                    if (this.hints.length && keyword_1) {
                        this.$content.empty();
                        var bnd = func.rect2bnd(lists.last(wordRange.getClientRects()));
                        if (bnd) {
                            this.$popover.hide();
                            this.lastWordRange = wordRange;
                            this.hints.forEach(function (hint, idx) {
                                if (hint.match.test(keyword_1)) {
                                    _this.createGroup(idx, keyword_1).appendTo(_this.$content);
                                }
                            });
                            // select first .note-hint-item
                            this.$content.find('.note-hint-item:first').addClass('active');
                            // set position for popover after group is created
                            if (this.direction === 'top') {
                                this.$popover.css({
                                    left: bnd.left,
                                    top: bnd.top - this.$popover.outerHeight() - POPOVER_DIST
                                });
                            } else {
                                this.$popover.css({
                                    left: bnd.left,
                                    top: bnd.top + bnd.height + POPOVER_DIST
                                });
                            }
                        }
                    } else {
                        this.hide();
                    }
                }
            };
            HintPopover.prototype.show = function () {
                this.$popover.show();
            };
            HintPopover.prototype.hide = function () {
                this.$popover.hide();
            };
            return HintPopover;
        }();

        var Context = /** @class */function () {
            /**
             * @param {jQuery} $note
             * @param {Object} options
             */
            function Context($note, options) {
                this.ui = $$1.summernote.ui;
                this.$note = $note;
                this.memos = {};
                this.modules = {};
                this.layoutInfo = {};
                this.options = options;
                this.initialize();
            }
            /**
             * create layout and initialize modules and other resources
             */
            Context.prototype.initialize = function () {
                this.layoutInfo = this.ui.createLayout(this.$note, this.options);
                this._initialize();
                this.$note.hide();
                return this;
            };
            /**
             * destroy modules and other resources and remove layout
             */
            Context.prototype.destroy = function () {
                this._destroy();
                this.$note.removeData('summernote');
                this.ui.removeLayout(this.$note, this.layoutInfo);
            };
            /**
             * destory modules and other resources and initialize it again
             */
            Context.prototype.reset = function () {
                var disabled = this.isDisabled();
                this.code(dom.emptyPara);
                this._destroy();
                this._initialize();
                if (disabled) {
                    this.disable();
                }
            };
            Context.prototype._initialize = function () {
                var _this = this;
                // add optional buttons
                var buttons = $$1.extend({}, this.options.buttons);
                Object.keys(buttons).forEach(function (key) {
                    _this.memo('button.' + key, buttons[key]);
                });
                var modules = $$1.extend({}, this.options.modules, $$1.summernote.plugins || {});
                // add and initialize modules
                Object.keys(modules).forEach(function (key) {
                    _this.module(key, modules[key], true);
                });
                Object.keys(this.modules).forEach(function (key) {
                    _this.initializeModule(key);
                });
            };
            Context.prototype._destroy = function () {
                var _this = this;
                // destroy modules with reversed order
                Object.keys(this.modules).reverse().forEach(function (key) {
                    _this.removeModule(key);
                });
                Object.keys(this.memos).forEach(function (key) {
                    _this.removeMemo(key);
                });
                // trigger custom onDestroy callback
                this.triggerEvent('destroy', this);
            };
            Context.prototype.code = function (html) {
                var isActivated = this.invoke('codeview.isActivated');
                if (html === undefined) {
                    this.invoke('codeview.sync');
                    return isActivated ? this.layoutInfo.codable.val() : this.layoutInfo.editable.html();
                } else {
                    if (isActivated) {
                        this.layoutInfo.codable.val(html);
                    } else {
                        this.layoutInfo.editable.html(html);
                    }
                    this.$note.val(html);
                    this.triggerEvent('change', html);
                }
            };
            Context.prototype.isDisabled = function () {
                return this.layoutInfo.editable.attr('contenteditable') === 'false';
            };
            Context.prototype.enable = function () {
                this.layoutInfo.editable.attr('contenteditable', true);
                this.invoke('toolbar.activate', true);
                this.triggerEvent('disable', false);
            };
            Context.prototype.disable = function () {
                // close codeview if codeview is opend
                if (this.invoke('codeview.isActivated')) {
                    this.invoke('codeview.deactivate');
                }
                this.layoutInfo.editable.attr('contenteditable', false);
                this.invoke('toolbar.deactivate', true);
                this.triggerEvent('disable', true);
            };
            Context.prototype.triggerEvent = function () {
                var namespace = lists.head(arguments);
                var args = lists.tail(lists.from(arguments));
                var callback = this.options.callbacks[func.namespaceToCamel(namespace, 'on')];
                if (callback) {
                    callback.apply(this.$note[0], args);
                }
                this.$note.trigger('summernote.' + namespace, args);
            };
            Context.prototype.initializeModule = function (key) {
                var module = this.modules[key];
                module.shouldInitialize = module.shouldInitialize || func.ok;
                if (!module.shouldInitialize()) {
                    return;
                }
                // initialize module
                if (module.initialize) {
                    module.initialize();
                }
                // attach events
                if (module.events) {
                    dom.attachEvents(this.$note, module.events);
                }
            };
            Context.prototype.module = function (key, ModuleClass, withoutIntialize) {
                if (arguments.length === 1) {
                    return this.modules[key];
                }
                this.modules[key] = new ModuleClass(this);
                if (!withoutIntialize) {
                    this.initializeModule(key);
                }
            };
            Context.prototype.removeModule = function (key) {
                var module = this.modules[key];
                if (module.shouldInitialize()) {
                    if (module.events) {
                        dom.detachEvents(this.$note, module.events);
                    }
                    if (module.destroy) {
                        module.destroy();
                    }
                }
                delete this.modules[key];
            };
            Context.prototype.memo = function (key, obj) {
                if (arguments.length === 1) {
                    return this.memos[key];
                }
                this.memos[key] = obj;
            };
            Context.prototype.removeMemo = function (key) {
                if (this.memos[key] && this.memos[key].destroy) {
                    this.memos[key].destroy();
                }
                delete this.memos[key];
            };
            /**
             * Some buttons need to change their visual style immediately once they get pressed
             */
            Context.prototype.createInvokeHandlerAndUpdateState = function (namespace, value) {
                var _this = this;
                return function (event) {
                    _this.createInvokeHandler(namespace, value)(event);
                    _this.invoke('buttons.updateCurrentStyle');
                };
            };
            Context.prototype.createInvokeHandler = function (namespace, value) {
                var _this = this;
                return function (event) {
                    event.preventDefault();
                    var $target = $$1(event.target);
                    _this.invoke(namespace, value || $target.closest('[data-value]').data('value'), $target);
                };
            };
            Context.prototype.invoke = function () {
                var namespace = lists.head(arguments);
                var args = lists.tail(lists.from(arguments));
                var splits = namespace.split('.');
                var hasSeparator = splits.length > 1;
                var moduleName = hasSeparator && lists.head(splits);
                var methodName = hasSeparator ? lists.last(splits) : lists.head(splits);
                var module = this.modules[moduleName || 'editor'];
                if (!moduleName && this[methodName]) {
                    return this[methodName].apply(this, args);
                } else if (module && module[methodName] && module.shouldInitialize()) {
                    return module[methodName].apply(module, args);
                }
            };
            return Context;
        }();

        $$1.fn.extend({
            /**
             * Summernote API
             *
             * @param {Object|String}
             * @return {this}
             */
            summernote: function () {
                var type = $$1.type(lists.head(arguments));
                var isExternalAPICalled = type === 'string';
                var hasInitOptions = type === 'object';
                var options = $$1.extend({}, $$1.summernote.options, hasInitOptions ? lists.head(arguments) : {});
                // Update options
                options.langInfo = $$1.extend(true, {}, $$1.summernote.lang['en-US'], $$1.summernote.lang[options.lang]);
                options.icons = $$1.extend(true, {}, $$1.summernote.options.icons, options.icons);
                options.tooltip = options.tooltip === 'auto' ? !env.isSupportTouch : options.tooltip;
                this.each(function (idx, note) {
                    var $note = $$1(note);
                    if (!$note.data('summernote')) {
                        var context = new Context($note, options);
                        $note.data('summernote', context);
                        $note.data('summernote').triggerEvent('init', context.layoutInfo);
                    }
                });
                var $note = this.first();
                if ($note.length) {
                    var context = $note.data('summernote');
                    if (isExternalAPICalled) {
                        return context.invoke.apply(context, lists.from(arguments));
                    } else if (options.focus) {
                        context.invoke('editor.focus');
                    }
                }
                return this;
            }
        });

        $$1.summernote = $$1.extend($$1.summernote, {
            version: '0.8.10',
            ui: ui,
            dom: dom,
            plugins: {},
            options: {
                modules: {
                    'editor': Editor,
                    'clipboard': Clipboard,
                    'dropzone': Dropzone,
                    'codeview': CodeView,
                    'statusbar': Statusbar,
                    'fullscreen': Fullscreen,
                    'handle': Handle,
                    // FIXME: HintPopover must be front of autolink
                    //  - Script error about range when Enter key is pressed on hint popover
                    'hintPopover': HintPopover,
                    'autoLink': AutoLink,
                    'autoSync': AutoSync,
                    'placeholder': Placeholder,
                    'buttons': Buttons,
                    'toolbar': Toolbar,
                    'linkDialog': LinkDialog,
                    'linkPopover': LinkPopover,
                    'imageDialog': ImageDialog,
                    'imagePopover': ImagePopover,
                    'tablePopover': TablePopover,
                    'videoDialog': VideoDialog,
                    'helpDialog': HelpDialog,
                    'airPopover': AirPopover
                },
                buttons: {},
                lang: 'en-US',
                followingToolbar: true,
                otherStaticBar: '',
                // toolbar
                toolbar: [['style', ['style']], ['font', ['bold', 'underline', 'clear']], ['fontname', ['fontname']], ['color', ['color']], ['para', ['ul', 'ol', 'paragraph']], ['table', ['table']], ['insert', ['link', 'picture', 'video']], ['view', ['fullscreen', 'codeview', 'help']]],
                // popover
                popatmouse: true,
                popover: {
                    image: [['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']], ['float', ['floatLeft', 'floatRight', 'floatNone']], ['remove', ['removeMedia']]],
                    link: [['link', ['linkDialogShow', 'unlink']]],
                    table: [['add', ['addRowDown', 'addRowUp', 'addColLeft', 'addColRight']], ['delete', ['deleteRow', 'deleteCol', 'deleteTable']]],
                    air: [['color', ['color']], ['font', ['bold', 'underline', 'clear']], ['para', ['ul', 'paragraph']], ['table', ['table']], ['insert', ['link', 'picture']]]
                },
                // air mode: inline editor
                airMode: false,
                width: null,
                height: null,
                linkTargetBlank: true,
                focus: false,
                tabSize: 4,
                styleWithSpan: true,
                shortcuts: true,
                textareaAutoSync: true,
                hintDirection: 'bottom',
                tooltip: 'auto',
                container: 'body',
                maxTextLength: 0,
                styleTags: ['p', 'blockquote', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
                fontNames: ['Arial', 'Arial Black', 'Comic Sans MS', 'Courier New', 'Helvetica Neue', 'Helvetica', 'Impact', 'Lucida Grande', 'Tahoma', 'Times New Roman', 'Verdana'],
                fontSizes: ['8', '9', '10', '11', '12', '14', '18', '24', '36'],
                // pallete colors(n x n)
                colors: [['#000000', '#424242', '#636363', '#9C9C94', '#CEC6CE', '#EFEFEF', '#F7F7F7', '#FFFFFF'], ['#FF0000', '#FF9C00', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#9C00FF', '#FF00FF'], ['#F7C6CE', '#FFE7CE', '#FFEFC6', '#D6EFD6', '#CEDEE7', '#CEE7F7', '#D6D6E7', '#E7D6DE'], ['#E79C9C', '#FFC69C', '#FFE79C', '#B5D6A5', '#A5C6CE', '#9CC6EF', '#B5A5D6', '#D6A5BD'], ['#E76363', '#F7AD6B', '#FFD663', '#94BD7B', '#73A5AD', '#6BADDE', '#8C7BC6', '#C67BA5'], ['#CE0000', '#E79439', '#EFC631', '#6BA54A', '#4A7B8C', '#3984C6', '#634AA5', '#A54A7B'], ['#9C0000', '#B56308', '#BD9400', '#397B21', '#104A5A', '#085294', '#311873', '#731842'], ['#630000', '#7B3900', '#846300', '#295218', '#083139', '#003163', '#21104A', '#4A1031']],
                // http://chir.ag/projects/name-that-color/
                colorsName: [['Black', 'Tundora', 'Dove Gray', 'Star Dust', 'Pale Slate', 'Gallery', 'Alabaster', 'White'], ['Red', 'Orange Peel', 'Yellow', 'Green', 'Cyan', 'Blue', 'Electric Violet', 'Magenta'], ['Azalea', 'Karry', 'Egg White', 'Zanah', 'Botticelli', 'Tropical Blue', 'Mischka', 'Twilight'], ['Tonys Pink', 'Peach Orange', 'Cream Brulee', 'Sprout', 'Casper', 'Perano', 'Cold Purple', 'Careys Pink'], ['Mandy', 'Rajah', 'Dandelion', 'Olivine', 'Gulf Stream', 'Viking', 'Blue Marguerite', 'Puce'], ['Guardsman Red', 'Fire Bush', 'Golden Dream', 'Chelsea Cucumber', 'Smalt Blue', 'Boston Blue', 'Butterfly Bush', 'Cadillac'], ['Sangria', 'Mai Tai', 'Buddha Gold', 'Forest Green', 'Eden', 'Venice Blue', 'Meteorite', 'Claret'], ['Rosewood', 'Cinnamon', 'Olive', 'Parsley', 'Tiber', 'Midnight Blue', 'Valentino', 'Loulou']],
                lineHeights: ['1.0', '1.2', '1.4', '1.5', '1.6', '1.8', '2.0', '3.0'],
                tableClassName: 'table table-bordered',
                insertTableMaxSize: {
                    col: 10,
                    row: 10
                },
                dialogsInBody: false,
                dialogsFade: false,
                maximumImageFileSize: null,
                callbacks: {
                    onInit: null,
                    onFocus: null,
                    onBlur: null,
                    onBlurCodeview: null,
                    onEnter: null,
                    onKeyup: null,
                    onKeydown: null,
                    onImageUpload: null,
                    onImageUploadError: null
                },
                codemirror: {
                    mode: 'text/html',
                    htmlMode: true,
                    lineNumbers: true
                },
                keyMap: {
                    pc: {
                        'ENTER': 'insertParagraph',
                        'CTRL+Z': 'undo',
                        'CTRL+Y': 'redo',
                        'TAB': 'tab',
                        'SHIFT+TAB': 'untab',
                        'CTRL+B': 'bold',
                        'CTRL+I': 'italic',
                        'CTRL+U': 'underline',
                        'CTRL+SHIFT+S': 'strikethrough',
                        'CTRL+BACKSLASH': 'removeFormat',
                        'CTRL+SHIFT+L': 'justifyLeft',
                        'CTRL+SHIFT+E': 'justifyCenter',
                        'CTRL+SHIFT+R': 'justifyRight',
                        'CTRL+SHIFT+J': 'justifyFull',
                        'CTRL+SHIFT+NUM7': 'insertUnorderedList',
                        'CTRL+SHIFT+NUM8': 'insertOrderedList',
                        'CTRL+LEFTBRACKET': 'outdent',
                        'CTRL+RIGHTBRACKET': 'indent',
                        'CTRL+NUM0': 'formatPara',
                        'CTRL+NUM1': 'formatH1',
                        'CTRL+NUM2': 'formatH2',
                        'CTRL+NUM3': 'formatH3',
                        'CTRL+NUM4': 'formatH4',
                        'CTRL+NUM5': 'formatH5',
                        'CTRL+NUM6': 'formatH6',
                        'CTRL+ENTER': 'insertHorizontalRule',
                        'CTRL+K': 'linkDialog.show'
                    },
                    mac: {
                        'ENTER': 'insertParagraph',
                        'CMD+Z': 'undo',
                        'CMD+SHIFT+Z': 'redo',
                        'TAB': 'tab',
                        'SHIFT+TAB': 'untab',
                        'CMD+B': 'bold',
                        'CMD+I': 'italic',
                        'CMD+U': 'underline',
                        'CMD+SHIFT+S': 'strikethrough',
                        'CMD+BACKSLASH': 'removeFormat',
                        'CMD+SHIFT+L': 'justifyLeft',
                        'CMD+SHIFT+E': 'justifyCenter',
                        'CMD+SHIFT+R': 'justifyRight',
                        'CMD+SHIFT+J': 'justifyFull',
                        'CMD+SHIFT+NUM7': 'insertUnorderedList',
                        'CMD+SHIFT+NUM8': 'insertOrderedList',
                        'CMD+LEFTBRACKET': 'outdent',
                        'CMD+RIGHTBRACKET': 'indent',
                        'CMD+NUM0': 'formatPara',
                        'CMD+NUM1': 'formatH1',
                        'CMD+NUM2': 'formatH2',
                        'CMD+NUM3': 'formatH3',
                        'CMD+NUM4': 'formatH4',
                        'CMD+NUM5': 'formatH5',
                        'CMD+NUM6': 'formatH6',
                        'CMD+ENTER': 'insertHorizontalRule',
                        'CMD+K': 'linkDialog.show'
                    }
                },
                icons: {
                    'align': 'note-icon-align',
                    'alignCenter': 'note-icon-align-center',
                    'alignJustify': 'note-icon-align-justify',
                    'alignLeft': 'note-icon-align-left',
                    'alignRight': 'note-icon-align-right',
                    'rowBelow': 'note-icon-row-below',
                    'colBefore': 'note-icon-col-before',
                    'colAfter': 'note-icon-col-after',
                    'rowAbove': 'note-icon-row-above',
                    'rowRemove': 'note-icon-row-remove',
                    'colRemove': 'note-icon-col-remove',
                    'indent': 'note-icon-align-indent',
                    'outdent': 'note-icon-align-outdent',
                    'arrowsAlt': 'note-icon-arrows-alt',
                    'bold': 'note-icon-bold',
                    'caret': 'note-icon-caret',
                    'circle': 'note-icon-circle',
                    'close': 'note-icon-close',
                    'code': 'note-icon-code',
                    'eraser': 'note-icon-eraser',
                    'font': 'note-icon-font',
                    'frame': 'note-icon-frame',
                    'italic': 'note-icon-italic',
                    'link': 'note-icon-link',
                    'unlink': 'note-icon-chain-broken',
                    'magic': 'note-icon-magic',
                    'menuCheck': 'note-icon-menu-check',
                    'minus': 'note-icon-minus',
                    'orderedlist': 'note-icon-orderedlist',
                    'pencil': 'note-icon-pencil',
                    'picture': 'note-icon-picture',
                    'question': 'note-icon-question',
                    'redo': 'note-icon-redo',
                    'square': 'note-icon-square',
                    'strikethrough': 'note-icon-strikethrough',
                    'subscript': 'note-icon-subscript',
                    'superscript': 'note-icon-superscript',
                    'table': 'note-icon-table',
                    'textHeight': 'note-icon-text-height',
                    'trash': 'note-icon-trash',
                    'underline': 'note-icon-underline',
                    'undo': 'note-icon-undo',
                    'unorderedlist': 'note-icon-unorderedlist',
                    'video': 'note-icon-video'
                }
            }
        });
    });
    
});
(function() {
var define = $__System.amdDefine;
define("85", ["84"], function(main) {
  return main;
});

})();
(function() {
var define = $__System.amdDefine;
(function(global, factory) {
  "use strict";
  if (typeof module === "object" && typeof module.exports === "object") {
    module.exports = global.document ? factory(global, true) : function(w) {
      if (!w.document) {
        throw new Error("jQuery requires a window with a document");
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
  "use strict";
  var arr = [];
  var document = window.document;
  var getProto = Object.getPrototypeOf;
  var slice = arr.slice;
  var concat = arr.concat;
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var fnToString = hasOwn.toString;
  var ObjectFunctionString = fnToString.call(Object);
  var support = {};
  var isFunction = function isFunction(obj) {
    return typeof obj === "function" && typeof obj.nodeType !== "number";
  };
  var isWindow = function isWindow(obj) {
    return obj != null && obj === obj.window;
  };
  var preservedScriptAttributes = {
    type: true,
    src: true,
    noModule: true
  };
  function DOMEval(code, doc, node) {
    doc = doc || document;
    var i,
        script = doc.createElement("script");
    script.text = code;
    if (node) {
      for (i in preservedScriptAttributes) {
        if (node[i]) {
          script[i] = node[i];
        }
      }
    }
    doc.head.appendChild(script).parentNode.removeChild(script);
  }
  function toType(obj) {
    if (obj == null) {
      return obj + "";
    }
    return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
  }
  var version = "3.3.1",
      jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
      },
      rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
  jQuery.fn = jQuery.prototype = {
    jquery: version,
    constructor: jQuery,
    length: 0,
    toArray: function() {
      return slice.call(this);
    },
    get: function(num) {
      if (num == null) {
        return slice.call(this);
      }
      return num < 0 ? this[num + this.length] : this[num];
    },
    pushStack: function(elems) {
      var ret = jQuery.merge(this.constructor(), elems);
      ret.prevObject = this;
      return ret;
    },
    each: function(callback) {
      return jQuery.each(this, callback);
    },
    map: function(callback) {
      return this.pushStack(jQuery.map(this, function(elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function() {
      return this.pushStack(slice.apply(this, arguments));
    },
    first: function() {
      return this.eq(0);
    },
    last: function() {
      return this.eq(-1);
    },
    eq: function(i) {
      var len = this.length,
          j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function() {
      return this.prevObject || this.constructor();
    },
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };
  jQuery.extend = jQuery.fn.extend = function() {
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[i] || {};
      i++;
    }
    if (typeof target !== "object" && !isFunction(target)) {
      target = {};
    }
    if (i === length) {
      target = this;
      i--;
    }
    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && Array.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            target[name] = jQuery.extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
  jQuery.extend({
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    isReady: true,
    error: function(msg) {
      throw new Error(msg);
    },
    noop: function() {},
    isPlainObject: function(obj) {
      var proto,
          Ctor;
      if (!obj || toString.call(obj) !== "[object Object]") {
        return false;
      }
      proto = getProto(obj);
      if (!proto) {
        return true;
      }
      Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
      return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
    },
    isEmptyObject: function(obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    globalEval: function(code) {
      DOMEval(code);
    },
    each: function(obj, callback) {
      var length,
          i = 0;
      if (isArrayLike(obj)) {
        length = obj.length;
        for (; i < length; i++) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      }
      return obj;
    },
    trim: function(text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    },
    makeArray: function(arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArrayLike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    merge: function(first, second) {
      var len = +second.length,
          j = 0,
          i = first.length;
      for (; j < len; j++) {
        first[i++] = second[j];
      }
      first.length = i;
      return first;
    },
    grep: function(elems, callback, invert) {
      var callbackInverse,
          matches = [],
          i = 0,
          length = elems.length,
          callbackExpect = !invert;
      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);
        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }
      return matches;
    },
    map: function(elems, callback, arg) {
      var length,
          value,
          i = 0,
          ret = [];
      if (isArrayLike(elems)) {
        length = elems.length;
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      }
      return concat.apply([], ret);
    },
    guid: 1,
    support: support
  });
  if (typeof Symbol === "function") {
    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
  }
  jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });
  function isArrayLike(obj) {
    var length = !!obj && "length" in obj && obj.length,
        type = toType(obj);
    if (isFunction(obj) || isWindow(obj)) {
      return false;
    }
    return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
  }
  var Sizzle = (function(window) {
    var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        sortOrder = function(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        },
        hasOwn = ({}).hasOwnProperty,
        arr = [],
        pop = arr.pop,
        push_native = arr.push,
        push = arr.push,
        slice = arr.slice,
        indexOf = function(list, elem) {
          var i = 0,
              len = list.length;
          for (; i < len; i++) {
            if (list[i] === elem) {
              return i;
            }
          }
          return -1;
        },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        whitespace = "[\\x20\\t\\r\\n\\f]",
        identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
        pseudos = ":(" + identifier + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)",
        rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
          "ID": new RegExp("^#(" + identifier + ")"),
          "CLASS": new RegExp("^\\.(" + identifier + ")"),
          "TAG": new RegExp("^(" + identifier + "|[*])"),
          "ATTR": new RegExp("^" + attributes),
          "PSEUDO": new RegExp("^" + pseudos),
          "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
          "bool": new RegExp("^(?:" + booleans + ")$", "i"),
          "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        },
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
        funescape = function(_, escaped, escapedWhitespace) {
          var high = "0x" + escaped - 0x10000;
          return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
        },
        rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
        fcssescape = function(ch, asCodePoint) {
          if (asCodePoint) {
            if (ch === "\0") {
              return "\uFFFD";
            }
            return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
          }
          return "\\" + ch;
        },
        unloadHandler = function() {
          setDocument();
        },
        disabledAncestor = addCombinator(function(elem) {
          return elem.disabled === true && ("form" in elem || "label" in elem);
        }, {
          dir: "parentNode",
          next: "legend"
        });
    try {
      push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {apply: arr.length ? function(target, els) {
          push_native.apply(target, slice.call(els));
        } : function(target, els) {
          var j = target.length,
              i = 0;
          while ((target[j++] = els[i++])) {}
          target.length = j - 1;
        }};
    }
    function Sizzle(selector, context, results, seed) {
      var m,
          i,
          elem,
          nid,
          match,
          groups,
          newSelector,
          newContext = context && context.ownerDocument,
          nodeType = context ? context.nodeType : 9;
      results = results || [];
      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      }
      if (!seed) {
        if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
          setDocument(context);
        }
        context = context || document;
        if (documentIsHTML) {
          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
            if ((m = match[1])) {
              if (nodeType === 9) {
                if ((elem = context.getElementById(m))) {
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                }
              } else {
                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              }
            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results;
            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          }
          if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
            if (nodeType !== 1) {
              newContext = context;
              newSelector = selector;
            } else if (context.nodeName.toLowerCase() !== "object") {
              if ((nid = context.getAttribute("id"))) {
                nid = nid.replace(rcssescape, fcssescape);
              } else {
                context.setAttribute("id", (nid = expando));
              }
              groups = tokenize(selector);
              i = groups.length;
              while (i--) {
                groups[i] = "#" + nid + " " + toSelector(groups[i]);
              }
              newSelector = groups.join(",");
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
            }
            if (newSelector) {
              try {
                push.apply(results, newContext.querySelectorAll(newSelector));
                return results;
              } catch (qsaError) {} finally {
                if (nid === expando) {
                  context.removeAttribute("id");
                }
              }
            }
          }
        }
      }
      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key + " ") > Expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return (cache[key + " "] = value);
      }
      return cache;
    }
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    function assert(fn) {
      var el = document.createElement("fieldset");
      try {
        return !!fn(el);
      } catch (e) {
        return false;
      } finally {
        if (el.parentNode) {
          el.parentNode.removeChild(el);
        }
        el = null;
      }
    }
    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
          i = arr.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    function siblingCheck(a, b) {
      var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
      if (diff) {
        return diff;
      }
      if (cur) {
        while ((cur = cur.nextSibling)) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }
    function createDisabledPseudo(disabled) {
      return function(elem) {
        if ("form" in elem) {
          if (elem.parentNode && elem.disabled === false) {
            if ("label" in elem) {
              if ("label" in elem.parentNode) {
                return elem.parentNode.disabled === disabled;
              } else {
                return elem.disabled === disabled;
              }
            }
            return elem.isDisabled === disabled || elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;
          }
          return elem.disabled === disabled;
        } else if ("label" in elem) {
          return elem.disabled === disabled;
        }
        return false;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function(argument) {
        argument = +argument;
        return markFunction(function(seed, matches) {
          var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length;
          while (i--) {
            if (seed[(j = matchIndexes[i])]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    }
    support = Sizzle.support = {};
    isXML = Sizzle.isXML = function(elem) {
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== "HTML" : false;
    };
    setDocument = Sizzle.setDocument = function(node) {
      var hasCompare,
          subWindow,
          doc = node ? node.ownerDocument || node : preferredDoc;
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      document = doc;
      docElem = document.documentElement;
      documentIsHTML = !isXML(document);
      if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
        if (subWindow.addEventListener) {
          subWindow.addEventListener("unload", unloadHandler, false);
        } else if (subWindow.attachEvent) {
          subWindow.attachEvent("onunload", unloadHandler);
        }
      }
      support.attributes = assert(function(el) {
        el.className = "i";
        return !el.getAttribute("className");
      });
      support.getElementsByTagName = assert(function(el) {
        el.appendChild(document.createComment(""));
        return !el.getElementsByTagName("*").length;
      });
      support.getElementsByClassName = rnative.test(document.getElementsByClassName);
      support.getById = assert(function(el) {
        docElem.appendChild(el).id = expando;
        return !document.getElementsByName || !document.getElementsByName(expando).length;
      });
      if (support.getById) {
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            return elem.getAttribute("id") === attrId;
          };
        };
        Expr.find["ID"] = function(id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var elem = context.getElementById(id);
            return elem ? [elem] : [];
          }
        };
      } else {
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        };
        Expr.find["ID"] = function(id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var node,
                i,
                elems,
                elem = context.getElementById(id);
            if (elem) {
              node = elem.getAttributeNode("id");
              if (node && node.value === id) {
                return [elem];
              }
              elems = context.getElementsByName(id);
              i = 0;
              while ((elem = elems[i++])) {
                node = elem.getAttributeNode("id");
                if (node && node.value === id) {
                  return [elem];
                }
              }
            }
            return [];
          }
        };
      }
      Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
        if (typeof context.getElementsByTagName !== "undefined") {
          return context.getElementsByTagName(tag);
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function(tag, context) {
        var elem,
            tmp = [],
            i = 0,
            results = context.getElementsByTagName(tag);
        if (tag === "*") {
          while ((elem = results[i++])) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
        if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      rbuggyMatches = [];
      rbuggyQSA = [];
      if ((support.qsa = rnative.test(document.querySelectorAll))) {
        assert(function(el) {
          docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
          if (el.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          }
          if (!el.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          }
          if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          }
          if (!el.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          }
          if (!el.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          }
        });
        assert(function(el) {
          el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>";
          var input = document.createElement("input");
          input.setAttribute("type", "hidden");
          el.appendChild(input).setAttribute("name", "D");
          if (el.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          }
          if (el.querySelectorAll(":enabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
          docElem.appendChild(el).disabled = true;
          if (el.querySelectorAll(":disabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
          el.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }
      if ((support.matchesSelector = rnative.test((matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)))) {
        assert(function(el) {
          support.disconnectedMatch = matches.call(el, "*");
          matches.call(el, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      hasCompare = rnative.test(docElem.compareDocumentPosition);
      contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function(a, b) {
        if (b) {
          while ((b = b.parentNode)) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      sortOrder = hasCompare ? function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if (compare) {
          return compare;
        }
        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
        if (compare & 1 || (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
          if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
            return -1;
          }
          if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
            return 1;
          }
          return sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        }
        return compare & 4 ? -1 : 1;
      } : function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [a],
            bp = [b];
        if (!aup || !bup) {
          return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        cur = a;
        while ((cur = cur.parentNode)) {
          ap.unshift(cur);
        }
        cur = b;
        while ((cur = cur.parentNode)) {
          bp.unshift(cur);
        }
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return document;
    };
    Sizzle.matches = function(expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function(elem, expr) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, "='$1']");
      if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {}
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function(context, elem) {
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function(elem, name) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()],
          val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };
    Sizzle.escape = function(sel) {
      return (sel + "").replace(rcssescape, fcssescape);
    };
    Sizzle.error = function(msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    Sizzle.uniqueSort = function(results) {
      var elem,
          duplicates = [],
          j = 0,
          i = 0;
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while ((elem = results[i++])) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      sortInput = null;
      return results;
    };
    getText = Sizzle.getText = function(elem) {
      var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;
      if (!nodeType) {
        while ((node = elem[i++])) {
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      return ret;
    };
    Expr = Sizzle.selectors = {
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": {dir: "parentNode"},
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": {dir: "previousSibling"}
      },
      preFilter: {
        "ATTR": function(match) {
          match[1] = match[1].replace(runescape, funescape);
          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }
          return match.slice(0, 4);
        },
        "CHILD": function(match) {
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === "nth") {
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +((match[7] + match[8]) || match[3] === "odd");
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        "PSEUDO": function(match) {
          var excess,
              unquoted = !match[6] && match[2];
          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          }
          if (match[3]) {
            match[2] = match[4] || match[5] || "";
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          return match.slice(0, 3);
        }
      },
      filter: {
        "TAG": function(nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function() {
            return true;
          } : function(elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        "CLASS": function(className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function(name, operator, check) {
          return function(elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === "!=";
            }
            if (!operator) {
              return true;
            }
            result += "";
            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
          };
        },
        "CHILD": function(type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";
          return first === 1 && last === 0 ? function(elem) {
            return !!elem.parentNode;
          } : function(elem, context, xml) {
            var cache,
                uniqueCache,
                outerCache,
                node,
                nodeIndex,
                start,
                dir = simple !== forward ? "nextSibling" : "previousSibling",
                parent = elem.parentNode,
                name = ofType && elem.nodeName.toLowerCase(),
                useCache = !xml && !ofType,
                diff = false;
            if (parent) {
              if (simple) {
                while (dir) {
                  node = elem;
                  while ((node = node[dir])) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  }
                  start = dir = type === "only" && !start && "nextSibling";
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              if (forward && useCache) {
                node = parent;
                outerCache = node[expando] || (node[expando] = {});
                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache = uniqueCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    uniqueCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                }
              } else {
                if (useCache) {
                  node = elem;
                  outerCache = node[expando] || (node[expando] = {});
                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex;
                }
                if (diff === false) {
                  while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                      if (useCache) {
                        outerCache = node[expando] || (node[expando] = {});
                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        uniqueCache[type] = [dirruns, diff];
                      }
                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }
              }
              diff -= last;
              return diff === first || (diff % first === 0 && diff / first >= 0);
            }
          };
        },
        "PSEUDO": function(pseudo, argument) {
          var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
          if (fn[expando]) {
            return fn(argument);
          }
          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
              var idx,
                  matched = fn(seed, argument),
                  i = matched.length;
              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function(elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        "not": markFunction(function(selector) {
          var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
            var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length;
            while (i--) {
              if ((elem = unmatched[i])) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function(elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            input[0] = null;
            return !results.pop();
          };
        }),
        "has": markFunction(function(selector) {
          return function(elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function(text) {
          text = text.replace(runescape, funescape);
          return function(elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        "lang": markFunction(function(lang) {
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function(elem) {
            var elemLang;
            do {
              if ((elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        "target": function(elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        "root": function(elem) {
          return elem === docElem;
        },
        "focus": function(elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        "enabled": createDisabledPseudo(false),
        "disabled": createDisabledPseudo(true),
        "checked": function(elem) {
          var nodeName = elem.nodeName.toLowerCase();
          return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
        },
        "selected": function(elem) {
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        "empty": function(elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }
          return true;
        },
        "parent": function(elem) {
          return !Expr.pseudos["empty"](elem);
        },
        "header": function(elem) {
          return rheader.test(elem.nodeName);
        },
        "input": function(elem) {
          return rinputs.test(elem.nodeName);
        },
        "button": function(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },
        "text": function(elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        "first": createPositionalPseudo(function() {
          return [0];
        }),
        "last": createPositionalPseudo(function(matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function(matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function(matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"];
    for (i in {
      radio: true,
      checkbox: true,
      file: true,
      password: true,
      image: true
    }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in {
      submit: true,
      reset: true
    }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    function setFilters() {}
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    tokenize = Sizzle.tokenize = function(selector, parseOnly) {
      var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[selector + " "];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push((tokens = []));
        }
        matched = false;
        if ((match = rcombinators.exec(soFar))) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type: match[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        }
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
    };
    function toSelector(tokens) {
      var i = 0,
          len = tokens.length,
          selector = "";
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
          skip = combinator.next,
          key = skip || dir,
          checkNonElements = base && key === "parentNode",
          doneName = done++;
      return combinator.first ? function(elem, context, xml) {
        while ((elem = elem[dir])) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
        return false;
      } : function(elem, context, xml) {
        var oldCache,
            uniqueCache,
            outerCache,
            newCache = [dirruns, doneName];
        if (xml) {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
              if (skip && skip === elem.nodeName.toLowerCase()) {
                elem = elem[dir] || elem;
              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                return (newCache[2] = oldCache[2]);
              } else {
                uniqueCache[key] = newCache;
                if ((newCache[2] = matcher(elem, context, xml))) {
                  return true;
                }
              }
            }
          }
        }
        return false;
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function(elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function multipleContexts(selector, contexts, results) {
      var i = 0,
          len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;
      for (; i < len; i++) {
        if ((elem = unmatched[i])) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function(seed, results, context, xml) {
        var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
            matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          i = temp.length;
          while (i--) {
            if ((elem = temp[i])) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if ((elem = matcherOut[i])) {
                  temp.push((matcherIn[i] = elem));
                }
              }
              postFinder(null, (matcherOut = []), temp, xml);
            }
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true),
          matchAnyContext = addCombinator(function(elem) {
            return indexOf(checkContext, elem) > -1;
          }, implicitRelative, true),
          matchers = [function(elem, context, xml) {
            var ret = (!leadingRelative && (xml || context !== outermostContext)) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
      for (; i < len; i++) {
        if ((matcher = Expr.relative[tokens[i].type])) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          if (matcher[expando]) {
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({value: tokens[i - 2].type === " " ? "*" : ""})).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens((tokens = tokens.slice(j))), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function(seed, context, xml, results, outermost) {
            var elem,
                j,
                matcher,
                matchedCount = 0,
                i = "0",
                unmatched = seed && [],
                setMatched = [],
                contextBackup = outermostContext,
                elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                len = elems.length;
            if (outermost) {
              outermostContext = context === document || context || outermost;
            }
            for (; i !== len && (elem = elems[i]) != null; i++) {
              if (byElement && elem) {
                j = 0;
                if (!context && elem.ownerDocument !== document) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while ((matcher = elementMatchers[j++])) {
                  if (matcher(elem, context || document, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if ((elem = !matcher && elem)) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i;
            if (bySet && i !== matchedCount) {
              j = 0;
              while ((matcher = setMatchers[j++])) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i--) {
                    if (!(unmatched[i] || setMatched[i])) {
                      setMatched[i] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && (matchedCount + setMatchers.length) > 1) {
                Sizzle.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function(selector, match) {
      var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];
      if (!cached) {
        if (!match) {
          match = tokenize(selector);
        }
        i = match.length;
        while (i--) {
          cached = matcherFromTokens(match[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
        cached.selector = selector;
      }
      return cached;
    };
    select = Sizzle.select = function(selector, context, results, seed) {
      var i,
          tokens,
          token,
          type,
          find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize((selector = compiled.selector || selector));
      results = results || [];
      if (match.length === 1) {
        tokens = match[0] = match[0].slice(0);
        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
          if (!context) {
            return results;
          } else if (compiled) {
            context = context.parentNode;
          }
          selector = selector.slice(tokens.shift().value.length);
        }
        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
        while (i--) {
          token = tokens[i];
          if (Expr.relative[(type = token.type)]) {
            break;
          }
          if ((find = Expr.find[type])) {
            if ((seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);
              if (!selector) {
                push.apply(results, seed);
                return results;
              }
              break;
            }
          }
        }
      }
      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    };
    support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
    support.detectDuplicates = !!hasDuplicate;
    setDocument();
    support.sortDetached = assert(function(el) {
      return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
    });
    if (!assert(function(el) {
      el.innerHTML = "<a href='#'></a>";
      return el.firstChild.getAttribute("href") === "#";
    })) {
      addHandle("type|href|height|width", function(elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    }
    if (!support.attributes || !assert(function(el) {
      el.innerHTML = "<input/>";
      el.firstChild.setAttribute("value", "");
      return el.firstChild.getAttribute("value") === "";
    })) {
      addHandle("value", function(elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    }
    if (!assert(function(el) {
      return el.getAttribute("disabled") == null;
    })) {
      addHandle(booleans, function(elem, name, isXML) {
        var val;
        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }
    return Sizzle;
  })(window);
  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  jQuery.escapeSelector = Sizzle.escape;
  var dir = function(elem, dir, until) {
    var matched = [],
        truncate = until !== undefined;
    while ((elem = elem[dir]) && elem.nodeType !== 9) {
      if (elem.nodeType === 1) {
        if (truncate && jQuery(elem).is(until)) {
          break;
        }
        matched.push(elem);
      }
    }
    return matched;
  };
  var siblings = function(n, elem) {
    var matched = [];
    for (; n; n = n.nextSibling) {
      if (n.nodeType === 1 && n !== elem) {
        matched.push(n);
      }
    }
    return matched;
  };
  var rneedsContext = jQuery.expr.match.needsContext;
  function nodeName(elem, name) {
    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
  }
  ;
  var rsingleTag = (/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i);
  function winnow(elements, qualifier, not) {
    if (isFunction(qualifier)) {
      return jQuery.grep(elements, function(elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function(elem) {
        return (elem === qualifier) !== not;
      });
    }
    if (typeof qualifier !== "string") {
      return jQuery.grep(elements, function(elem) {
        return (indexOf.call(qualifier, elem) > -1) !== not;
      });
    }
    return jQuery.filter(qualifier, elements, not);
  }
  jQuery.filter = function(expr, elems, not) {
    var elem = elems[0];
    if (not) {
      expr = ":not(" + expr + ")";
    }
    if (elems.length === 1 && elem.nodeType === 1) {
      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
    }
    return jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
      return elem.nodeType === 1;
    }));
  };
  jQuery.fn.extend({
    find: function(selector) {
      var i,
          ret,
          len = this.length,
          self = this;
      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function() {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      ret = this.pushStack([]);
      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      return len > 1 ? jQuery.uniqueSort(ret) : ret;
    },
    filter: function(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function(selector) {
      return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  });
  var rootjQuery,
      rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
      init = jQuery.fn.init = function(selector, context, root) {
        var match,
            elem;
        if (!selector) {
          return this;
        }
        root = root || rootjQuery;
        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            match = [null, selector, null];
          } else {
            match = rquickExpr.exec(selector);
          }
          if (match && (match[1] || !context)) {
            if (match[1]) {
              context = context instanceof jQuery ? context[0] : context;
              jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
              if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                for (match in context) {
                  if (isFunction(this[match])) {
                    this[match](context[match]);
                  } else {
                    this.attr(match, context[match]);
                  }
                }
              }
              return this;
            } else {
              elem = document.getElementById(match[2]);
              if (elem) {
                this[0] = elem;
                this.length = 1;
              }
              return this;
            }
          } else if (!context || context.jquery) {
            return (context || root).find(selector);
          } else {
            return this.constructor(context).find(selector);
          }
        } else if (selector.nodeType) {
          this[0] = selector;
          this.length = 1;
          return this;
        } else if (isFunction(selector)) {
          return root.ready !== undefined ? root.ready(selector) : selector(jQuery);
        }
        return jQuery.makeArray(selector, this);
      };
  init.prototype = jQuery.fn;
  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
      guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
  jQuery.fn.extend({
    has: function(target) {
      var targets = jQuery(target, this),
          l = targets.length;
      return this.filter(function() {
        var i = 0;
        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function(selectors, context) {
      var cur,
          i = 0,
          l = this.length,
          matched = [],
          targets = typeof selectors !== "string" && jQuery(selectors);
      if (!rneedsContext.test(selectors)) {
        for (; i < l; i++) {
          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
              matched.push(cur);
              break;
            }
          }
        }
      }
      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
    },
    index: function(elem) {
      if (!elem) {
        return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
      }
      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      }
      return indexOf.call(this, elem.jquery ? elem[0] : elem);
    },
    add: function(selector, context) {
      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function(selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });
  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}
    return cur;
  }
  jQuery.each({
    parent: function(elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function(elem) {
      return dir(elem, "parentNode");
    },
    parentsUntil: function(elem, i, until) {
      return dir(elem, "parentNode", until);
    },
    next: function(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function(elem) {
      return dir(elem, "nextSibling");
    },
    prevAll: function(elem) {
      return dir(elem, "previousSibling");
    },
    nextUntil: function(elem, i, until) {
      return dir(elem, "nextSibling", until);
    },
    prevUntil: function(elem, i, until) {
      return dir(elem, "previousSibling", until);
    },
    siblings: function(elem) {
      return siblings((elem.parentNode || {}).firstChild, elem);
    },
    children: function(elem) {
      return siblings(elem.firstChild);
    },
    contents: function(elem) {
      if (nodeName(elem, "iframe")) {
        return elem.contentDocument;
      }
      if (nodeName(elem, "template")) {
        elem = elem.content || elem;
      }
      return jQuery.merge([], elem.childNodes);
    }
  }, function(name, fn) {
    jQuery.fn[name] = function(until, selector) {
      var matched = jQuery.map(this, fn, until);
      if (name.slice(-5) !== "Until") {
        selector = until;
      }
      if (selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }
      if (this.length > 1) {
        if (!guaranteedUnique[name]) {
          jQuery.uniqueSort(matched);
        }
        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }
      return this.pushStack(matched);
    };
  });
  var rnothtmlwhite = (/[^\x20\t\r\n\f]+/g);
  function createOptions(options) {
    var object = {};
    jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
      object[flag] = true;
    });
    return object;
  }
  jQuery.Callbacks = function(options) {
    options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
    var firing,
        memory,
        fired,
        locked,
        list = [],
        queue = [],
        firingIndex = -1,
        fire = function() {
          locked = locked || options.once;
          fired = firing = true;
          for (; queue.length; firingIndex = -1) {
            memory = queue.shift();
            while (++firingIndex < list.length) {
              if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                firingIndex = list.length;
                memory = false;
              }
            }
          }
          if (!options.memory) {
            memory = false;
          }
          firing = false;
          if (locked) {
            if (memory) {
              list = [];
            } else {
              list = "";
            }
          }
        },
        self = {
          add: function() {
            if (list) {
              if (memory && !firing) {
                firingIndex = list.length - 1;
                queue.push(memory);
              }
              (function add(args) {
                jQuery.each(args, function(_, arg) {
                  if (isFunction(arg)) {
                    if (!options.unique || !self.has(arg)) {
                      list.push(arg);
                    }
                  } else if (arg && arg.length && toType(arg) !== "string") {
                    add(arg);
                  }
                });
              })(arguments);
              if (memory && !firing) {
                fire();
              }
            }
            return this;
          },
          remove: function() {
            jQuery.each(arguments, function(_, arg) {
              var index;
              while ((index = jQuery.inArray(arg, list, index)) > -1) {
                list.splice(index, 1);
                if (index <= firingIndex) {
                  firingIndex--;
                }
              }
            });
            return this;
          },
          has: function(fn) {
            return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
          },
          empty: function() {
            if (list) {
              list = [];
            }
            return this;
          },
          disable: function() {
            locked = queue = [];
            list = memory = "";
            return this;
          },
          disabled: function() {
            return !list;
          },
          lock: function() {
            locked = queue = [];
            if (!memory && !firing) {
              list = memory = "";
            }
            return this;
          },
          locked: function() {
            return !!locked;
          },
          fireWith: function(context, args) {
            if (!locked) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              queue.push(args);
              if (!firing) {
                fire();
              }
            }
            return this;
          },
          fire: function() {
            self.fireWith(this, arguments);
            return this;
          },
          fired: function() {
            return !!fired;
          }
        };
    return self;
  };
  function Identity(v) {
    return v;
  }
  function Thrower(ex) {
    throw ex;
  }
  function adoptValue(value, resolve, reject, noValue) {
    var method;
    try {
      if (value && isFunction((method = value.promise))) {
        method.call(value).done(resolve).fail(reject);
      } else if (value && isFunction((method = value.then))) {
        method.call(value, resolve, reject);
      } else {
        resolve.apply(undefined, [value].slice(noValue));
      }
    } catch (value) {
      reject.apply(undefined, [value]);
    }
  }
  jQuery.extend({
    Deferred: function(func) {
      var tuples = [["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
          state = "pending",
          promise = {
            state: function() {
              return state;
            },
            always: function() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            "catch": function(fn) {
              return promise.then(null, fn);
            },
            pipe: function() {
              var fns = arguments;
              return jQuery.Deferred(function(newDefer) {
                jQuery.each(tuples, function(i, tuple) {
                  var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                  deferred[tuple[1]](function() {
                    var returned = fn && fn.apply(this, arguments);
                    if (returned && isFunction(returned.promise)) {
                      returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                    } else {
                      newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            then: function(onFulfilled, onRejected, onProgress) {
              var maxDepth = 0;
              function resolve(depth, deferred, handler, special) {
                return function() {
                  var that = this,
                      args = arguments,
                      mightThrow = function() {
                        var returned,
                            then;
                        if (depth < maxDepth) {
                          return;
                        }
                        returned = handler.apply(that, args);
                        if (returned === deferred.promise()) {
                          throw new TypeError("Thenable self-resolution");
                        }
                        then = returned && (typeof returned === "object" || typeof returned === "function") && returned.then;
                        if (isFunction(then)) {
                          if (special) {
                            then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special));
                          } else {
                            maxDepth++;
                            then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                          }
                        } else {
                          if (handler !== Identity) {
                            that = undefined;
                            args = [returned];
                          }
                          (special || deferred.resolveWith)(that, args);
                        }
                      },
                      process = special ? mightThrow : function() {
                        try {
                          mightThrow();
                        } catch (e) {
                          if (jQuery.Deferred.exceptionHook) {
                            jQuery.Deferred.exceptionHook(e, process.stackTrace);
                          }
                          if (depth + 1 >= maxDepth) {
                            if (handler !== Thrower) {
                              that = undefined;
                              args = [e];
                            }
                            deferred.rejectWith(that, args);
                          }
                        }
                      };
                  if (depth) {
                    process();
                  } else {
                    if (jQuery.Deferred.getStackHook) {
                      process.stackTrace = jQuery.Deferred.getStackHook();
                    }
                    window.setTimeout(process);
                  }
                };
              }
              return jQuery.Deferred(function(newDefer) {
                tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));
                tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity));
                tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
              }).promise();
            },
            promise: function(obj) {
              return obj != null ? jQuery.extend(obj, promise) : promise;
            }
          },
          deferred = {};
      jQuery.each(tuples, function(i, tuple) {
        var list = tuple[2],
            stateString = tuple[5];
        promise[tuple[1]] = list.add;
        if (stateString) {
          list.add(function() {
            state = stateString;
          }, tuples[3 - i][2].disable, tuples[3 - i][3].disable, tuples[0][2].lock, tuples[0][3].lock);
        }
        list.add(tuple[3].fire);
        deferred[tuple[0]] = function() {
          deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
          return this;
        };
        deferred[tuple[0] + "With"] = list.fireWith;
      });
      promise.promise(deferred);
      if (func) {
        func.call(deferred, deferred);
      }
      return deferred;
    },
    when: function(singleValue) {
      var remaining = arguments.length,
          i = remaining,
          resolveContexts = Array(i),
          resolveValues = slice.call(arguments),
          master = jQuery.Deferred(),
          updateFunc = function(i) {
            return function(value) {
              resolveContexts[i] = this;
              resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
              if (!(--remaining)) {
                master.resolveWith(resolveContexts, resolveValues);
              }
            };
          };
      if (remaining <= 1) {
        adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining);
        if (master.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
          return master.then();
        }
      }
      while (i--) {
        adoptValue(resolveValues[i], updateFunc(i), master.reject);
      }
      return master.promise();
    }
  });
  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
  jQuery.Deferred.exceptionHook = function(error, stack) {
    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
      window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
    }
  };
  jQuery.readyException = function(error) {
    window.setTimeout(function() {
      throw error;
    });
  };
  var readyList = jQuery.Deferred();
  jQuery.fn.ready = function(fn) {
    readyList.then(fn).catch(function(error) {
      jQuery.readyException(error);
    });
    return this;
  };
  jQuery.extend({
    isReady: false,
    readyWait: 1,
    ready: function(wait) {
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }
      jQuery.isReady = true;
      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      }
      readyList.resolveWith(document, [jQuery]);
    }
  });
  jQuery.ready.then = readyList.then;
  function completed() {
    document.removeEventListener("DOMContentLoaded", completed);
    window.removeEventListener("load", completed);
    jQuery.ready();
  }
  if (document.readyState === "complete" || (document.readyState !== "loading" && !document.documentElement.doScroll)) {
    window.setTimeout(jQuery.ready);
  } else {
    document.addEventListener("DOMContentLoaded", completed);
    window.addEventListener("load", completed);
  }
  var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
        len = elems.length,
        bulk = key == null;
    if (toType(key) === "object") {
      chainable = true;
      for (i in key) {
        access(elems, fn, i, key[i], true, emptyGet, raw);
      }
    } else if (value !== undefined) {
      chainable = true;
      if (!isFunction(value)) {
        raw = true;
      }
      if (bulk) {
        if (raw) {
          fn.call(elems, value);
          fn = null;
        } else {
          bulk = fn;
          fn = function(elem, key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }
      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }
    if (chainable) {
      return elems;
    }
    if (bulk) {
      return fn.call(elems);
    }
    return len ? fn(elems[0], key) : emptyGet;
  };
  var rmsPrefix = /^-ms-/,
      rdashAlpha = /-([a-z])/g;
  function fcamelCase(all, letter) {
    return letter.toUpperCase();
  }
  function camelCase(string) {
    return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
  }
  var acceptData = function(owner) {
    return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
  };
  function Data() {
    this.expando = jQuery.expando + Data.uid++;
  }
  Data.uid = 1;
  Data.prototype = {
    cache: function(owner) {
      var value = owner[this.expando];
      if (!value) {
        value = {};
        if (acceptData(owner)) {
          if (owner.nodeType) {
            owner[this.expando] = value;
          } else {
            Object.defineProperty(owner, this.expando, {
              value: value,
              configurable: true
            });
          }
        }
      }
      return value;
    },
    set: function(owner, data, value) {
      var prop,
          cache = this.cache(owner);
      if (typeof data === "string") {
        cache[camelCase(data)] = value;
      } else {
        for (prop in data) {
          cache[camelCase(prop)] = data[prop];
        }
      }
      return cache;
    },
    get: function(owner, key) {
      return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][camelCase(key)];
    },
    access: function(owner, key, value) {
      if (key === undefined || ((key && typeof key === "string") && value === undefined)) {
        return this.get(owner, key);
      }
      this.set(owner, key, value);
      return value !== undefined ? value : key;
    },
    remove: function(owner, key) {
      var i,
          cache = owner[this.expando];
      if (cache === undefined) {
        return;
      }
      if (key !== undefined) {
        if (Array.isArray(key)) {
          key = key.map(camelCase);
        } else {
          key = camelCase(key);
          key = key in cache ? [key] : (key.match(rnothtmlwhite) || []);
        }
        i = key.length;
        while (i--) {
          delete cache[key[i]];
        }
      }
      if (key === undefined || jQuery.isEmptyObject(cache)) {
        if (owner.nodeType) {
          owner[this.expando] = undefined;
        } else {
          delete owner[this.expando];
        }
      }
    },
    hasData: function(owner) {
      var cache = owner[this.expando];
      return cache !== undefined && !jQuery.isEmptyObject(cache);
    }
  };
  var dataPriv = new Data();
  var dataUser = new Data();
  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /[A-Z]/g;
  function getData(data) {
    if (data === "true") {
      return true;
    }
    if (data === "false") {
      return false;
    }
    if (data === "null") {
      return null;
    }
    if (data === +data + "") {
      return +data;
    }
    if (rbrace.test(data)) {
      return JSON.parse(data);
    }
    return data;
  }
  function dataAttr(elem, key, data) {
    var name;
    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === "string") {
        try {
          data = getData(data);
        } catch (e) {}
        dataUser.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  jQuery.extend({
    hasData: function(elem) {
      return dataUser.hasData(elem) || dataPriv.hasData(elem);
    },
    data: function(elem, name, data) {
      return dataUser.access(elem, name, data);
    },
    removeData: function(elem, name) {
      dataUser.remove(elem, name);
    },
    _data: function(elem, name, data) {
      return dataPriv.access(elem, name, data);
    },
    _removeData: function(elem, name) {
      dataPriv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function(key, value) {
      var i,
          name,
          data,
          elem = this[0],
          attrs = elem && elem.attributes;
      if (key === undefined) {
        if (this.length) {
          data = dataUser.get(elem);
          if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
            i = attrs.length;
            while (i--) {
              if (attrs[i]) {
                name = attrs[i].name;
                if (name.indexOf("data-") === 0) {
                  name = camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }
            dataPriv.set(elem, "hasDataAttrs", true);
          }
        }
        return data;
      }
      if (typeof key === "object") {
        return this.each(function() {
          dataUser.set(this, key);
        });
      }
      return access(this, function(value) {
        var data;
        if (elem && value === undefined) {
          data = dataUser.get(elem, key);
          if (data !== undefined) {
            return data;
          }
          data = dataAttr(elem, key);
          if (data !== undefined) {
            return data;
          }
          return;
        }
        this.each(function() {
          dataUser.set(this, key, value);
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function(key) {
      return this.each(function() {
        dataUser.remove(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function(elem, type, data) {
      var queue;
      if (elem) {
        type = (type || "fx") + "queue";
        queue = dataPriv.get(elem, type);
        if (data) {
          if (!queue || Array.isArray(data)) {
            queue = dataPriv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function(elem, type) {
      type = type || "fx";
      var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function() {
            jQuery.dequeue(elem, type);
          };
      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        if (type === "fx") {
          queue.unshift("inprogress");
        }
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function(elem, type) {
      var key = type + "queueHooks";
      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {empty: jQuery.Callbacks("once memory").add(function() {
          dataPriv.remove(elem, [type + "queue", key]);
        })});
    }
  });
  jQuery.fn.extend({
    queue: function(type, data) {
      var setter = 2;
      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }
      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined ? this : this.each(function() {
        var queue = jQuery.queue(this, type, data);
        jQuery._queueHooks(this, type);
        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function(type) {
      return this.each(function() {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function(type) {
      return this.queue(type || "fx", []);
    },
    promise: function(type, obj) {
      var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function() {
            if (!(--count)) {
              defer.resolveWith(elements, [elements]);
            }
          };
      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }
      type = type || "fx";
      while (i--) {
        tmp = dataPriv.get(elements[i], type + "queueHooks");
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
  var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
  var cssExpand = ["Top", "Right", "Bottom", "Left"];
  var isHiddenWithinTree = function(elem, el) {
    elem = el || elem;
    return elem.style.display === "none" || elem.style.display === "" && jQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, "display") === "none";
  };
  var swap = function(elem, options, callback, args) {
    var ret,
        name,
        old = {};
    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }
    ret = callback.apply(elem, args || []);
    for (name in options) {
      elem.style[name] = old[name];
    }
    return ret;
  };
  function adjustCSS(elem, prop, valueParts, tween) {
    var adjusted,
        scale,
        maxIterations = 20,
        currentValue = tween ? function() {
          return tween.cur();
        } : function() {
          return jQuery.css(elem, prop, "");
        },
        initial = currentValue(),
        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
        initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
    if (initialInUnit && initialInUnit[3] !== unit) {
      initial = initial / 2;
      unit = unit || initialInUnit[3];
      initialInUnit = +initial || 1;
      while (maxIterations--) {
        jQuery.style(elem, prop, initialInUnit + unit);
        if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
          maxIterations = 0;
        }
        initialInUnit = initialInUnit / scale;
      }
      initialInUnit = initialInUnit * 2;
      jQuery.style(elem, prop, initialInUnit + unit);
      valueParts = valueParts || [];
    }
    if (valueParts) {
      initialInUnit = +initialInUnit || +initial || 0;
      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
      if (tween) {
        tween.unit = unit;
        tween.start = initialInUnit;
        tween.end = adjusted;
      }
    }
    return adjusted;
  }
  var defaultDisplayMap = {};
  function getDefaultDisplay(elem) {
    var temp,
        doc = elem.ownerDocument,
        nodeName = elem.nodeName,
        display = defaultDisplayMap[nodeName];
    if (display) {
      return display;
    }
    temp = doc.body.appendChild(doc.createElement(nodeName));
    display = jQuery.css(temp, "display");
    temp.parentNode.removeChild(temp);
    if (display === "none") {
      display = "block";
    }
    defaultDisplayMap[nodeName] = display;
    return display;
  }
  function showHide(elements, show) {
    var display,
        elem,
        values = [],
        index = 0,
        length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      display = elem.style.display;
      if (show) {
        if (display === "none") {
          values[index] = dataPriv.get(elem, "display") || null;
          if (!values[index]) {
            elem.style.display = "";
          }
        }
        if (elem.style.display === "" && isHiddenWithinTree(elem)) {
          values[index] = getDefaultDisplay(elem);
        }
      } else {
        if (display !== "none") {
          values[index] = "none";
          dataPriv.set(elem, "display", display);
        }
      }
    }
    for (index = 0; index < length; index++) {
      if (values[index] != null) {
        elements[index].style.display = values[index];
      }
    }
    return elements;
  }
  jQuery.fn.extend({
    show: function() {
      return showHide(this, true);
    },
    hide: function() {
      return showHide(this);
    },
    toggle: function(state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }
      return this.each(function() {
        if (isHiddenWithinTree(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  var rcheckableType = (/^(?:checkbox|radio)$/i);
  var rtagName = (/<([a-z][^\/\0>\x20\t\r\n\f]+)/i);
  var rscriptType = (/^$|^module$|\/(?:java|ecma)script/i);
  var wrapMap = {
    option: [1, "<select multiple='multiple'>", "</select>"],
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""]
  };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  function getAll(context, tag) {
    var ret;
    if (typeof context.getElementsByTagName !== "undefined") {
      ret = context.getElementsByTagName(tag || "*");
    } else if (typeof context.querySelectorAll !== "undefined") {
      ret = context.querySelectorAll(tag || "*");
    } else {
      ret = [];
    }
    if (tag === undefined || tag && nodeName(context, tag)) {
      return jQuery.merge([context], ret);
    }
    return ret;
  }
  function setGlobalEval(elems, refElements) {
    var i = 0,
        l = elems.length;
    for (; i < l; i++) {
      dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
  }
  var rhtml = /<|&#?\w+;/;
  function buildFragment(elems, context, scripts, selection, ignored) {
    var elem,
        tmp,
        tag,
        wrap,
        contains,
        j,
        fragment = context.createDocumentFragment(),
        nodes = [],
        i = 0,
        l = elems.length;
    for (; i < l; i++) {
      elem = elems[i];
      if (elem || elem === 0) {
        if (toType(elem) === "object") {
          jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
        } else if (!rhtml.test(elem)) {
          nodes.push(context.createTextNode(elem));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
          j = wrap[0];
          while (j--) {
            tmp = tmp.lastChild;
          }
          jQuery.merge(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
      }
    }
    fragment.textContent = "";
    i = 0;
    while ((elem = nodes[i++])) {
      if (selection && jQuery.inArray(elem, selection) > -1) {
        if (ignored) {
          ignored.push(elem);
        }
        continue;
      }
      contains = jQuery.contains(elem.ownerDocument, elem);
      tmp = getAll(fragment.appendChild(elem), "script");
      if (contains) {
        setGlobalEval(tmp);
      }
      if (scripts) {
        j = 0;
        while ((elem = tmp[j++])) {
          if (rscriptType.test(elem.type || "")) {
            scripts.push(elem);
          }
        }
      }
    }
    return fragment;
  }
  (function() {
    var fragment = document.createDocumentFragment(),
        div = fragment.appendChild(document.createElement("div")),
        input = document.createElement("input");
    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input);
    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
  })();
  var documentElement = document.documentElement;
  var rkeyEvent = /^key/,
      rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
      rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }
  function on(elem, types, selector, data, fn, one) {
    var origFn,
        type;
    if (typeof types === "object") {
      if (typeof selector !== "string") {
        data = data || selector;
        selector = undefined;
      }
      for (type in types) {
        on(elem, type, selector, data, types[type], one);
      }
      return elem;
    }
    if (data == null && fn == null) {
      fn = selector;
      data = selector = undefined;
    } else if (fn == null) {
      if (typeof selector === "string") {
        fn = data;
        data = undefined;
      } else {
        fn = data;
        data = selector;
        selector = undefined;
      }
    }
    if (fn === false) {
      fn = returnFalse;
    } else if (!fn) {
      return elem;
    }
    if (one === 1) {
      origFn = fn;
      fn = function(event) {
        jQuery().off(event);
        return origFn.apply(this, arguments);
      };
      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
    }
    return elem.each(function() {
      jQuery.event.add(this, types, fn, data, selector);
    });
  }
  jQuery.event = {
    global: {},
    add: function(elem, types, handler, data, selector) {
      var handleObjIn,
          eventHandle,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.get(elem);
      if (!elemData) {
        return;
      }
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      if (selector) {
        jQuery.find.matchesSelector(documentElement, selector);
      }
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function(e) {
          return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      }
      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        special = jQuery.event.special[type] || {};
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn);
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        jQuery.event.global[type] = true;
      }
    },
    remove: function(elem, types, handler, selector, mappedTypes) {
      var j,
          origCount,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return;
      }
      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      if (jQuery.isEmptyObject(events)) {
        dataPriv.remove(elem, "handle events");
      }
    },
    dispatch: function(nativeEvent) {
      var event = jQuery.event.fix(nativeEvent);
      var i,
          j,
          ret,
          matched,
          handleObj,
          handlerQueue,
          args = new Array(arguments.length),
          handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
          special = jQuery.event.special[event.type] || {};
      args[0] = event;
      for (i = 1; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      event.delegateTarget = this;
      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      }
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function(event, handlers) {
      var i,
          handleObj,
          sel,
          matchedHandlers,
          matchedSelectors,
          handlerQueue = [],
          delegateCount = handlers.delegateCount,
          cur = event.target;
      if (delegateCount && cur.nodeType && !(event.type === "click" && event.button >= 1)) {
        for (; cur !== this; cur = cur.parentNode || this) {
          if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
            matchedHandlers = [];
            matchedSelectors = {};
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];
              sel = handleObj.selector + " ";
              if (matchedSelectors[sel] === undefined) {
                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matchedSelectors[sel]) {
                matchedHandlers.push(handleObj);
              }
            }
            if (matchedHandlers.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matchedHandlers
              });
            }
          }
        }
      }
      cur = this;
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: cur,
          handlers: handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    addProp: function(name, hook) {
      Object.defineProperty(jQuery.Event.prototype, name, {
        enumerable: true,
        configurable: true,
        get: isFunction(hook) ? function() {
          if (this.originalEvent) {
            return hook(this.originalEvent);
          }
        } : function() {
          if (this.originalEvent) {
            return this.originalEvent[name];
          }
        },
        set: function(value) {
          Object.defineProperty(this, name, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
          });
        }
      });
    },
    fix: function(originalEvent) {
      return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
    },
    special: {
      load: {noBubble: true},
      focus: {
        trigger: function() {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function() {
          if (this.type === "checkbox" && this.click && nodeName(this, "input")) {
            this.click();
            return false;
          }
        },
        _default: function(event) {
          return nodeName(event.target, "a");
        }
      },
      beforeunload: {postDispatch: function(event) {
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }}
    }
  };
  jQuery.removeEvent = function(elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle);
    }
  };
  jQuery.Event = function(src, props) {
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
      this.target = (src.target && src.target.nodeType === 3) ? src.target.parentNode : src.target;
      this.currentTarget = src.currentTarget;
      this.relatedTarget = src.relatedTarget;
    } else {
      this.type = src;
    }
    if (props) {
      jQuery.extend(this, props);
    }
    this.timeStamp = src && src.timeStamp || Date.now();
    this[jQuery.expando] = true;
  };
  jQuery.Event.prototype = {
    constructor: jQuery.Event,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    isSimulated: false,
    preventDefault: function() {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e && !this.isSimulated) {
        e.preventDefault();
      }
    },
    stopPropagation: function() {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e && !this.isSimulated) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function() {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;
      if (e && !this.isSimulated) {
        e.stopImmediatePropagation();
      }
      this.stopPropagation();
    }
  };
  jQuery.each({
    altKey: true,
    bubbles: true,
    cancelable: true,
    changedTouches: true,
    ctrlKey: true,
    detail: true,
    eventPhase: true,
    metaKey: true,
    pageX: true,
    pageY: true,
    shiftKey: true,
    view: true,
    "char": true,
    charCode: true,
    key: true,
    keyCode: true,
    button: true,
    buttons: true,
    clientX: true,
    clientY: true,
    offsetX: true,
    offsetY: true,
    pointerId: true,
    pointerType: true,
    screenX: true,
    screenY: true,
    targetTouches: true,
    toElement: true,
    touches: true,
    which: function(event) {
      var button = event.button;
      if (event.which == null && rkeyEvent.test(event.type)) {
        return event.charCode != null ? event.charCode : event.keyCode;
      }
      if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
        if (button & 1) {
          return 1;
        }
        if (button & 2) {
          return 3;
        }
        if (button & 4) {
          return 2;
        }
        return 0;
      }
      return event.which;
    }
  }, jQuery.event.addProp);
  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function(orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function(event) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj;
        if (!related || (related !== target && !jQuery.contains(target, related))) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  jQuery.fn.extend({
    on: function(types, selector, data, fn) {
      return on(this, types, selector, data, fn);
    },
    one: function(types, selector, data, fn) {
      return on(this, types, selector, data, fn, 1);
    },
    off: function(types, selector, fn) {
      var handleObj,
          type;
      if (types && types.preventDefault && types.handleObj) {
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }
      if (typeof types === "object") {
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === "function") {
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function() {
        jQuery.event.remove(this, types, fn, selector);
      });
    }
  });
  var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
      rnoInnerhtml = /<script|<style|<link/i,
      rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
  function manipulationTarget(elem, content) {
    if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
      return jQuery(elem).children("tbody")[0] || elem;
    }
    return elem;
  }
  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    if ((elem.type || "").slice(0, 5) === "true/") {
      elem.type = elem.type.slice(5);
    } else {
      elem.removeAttribute("type");
    }
    return elem;
  }
  function cloneCopyEvent(src, dest) {
    var i,
        l,
        type,
        pdataOld,
        pdataCur,
        udataOld,
        udataCur,
        events;
    if (dest.nodeType !== 1) {
      return;
    }
    if (dataPriv.hasData(src)) {
      pdataOld = dataPriv.access(src);
      pdataCur = dataPriv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }
    if (dataUser.hasData(src)) {
      udataOld = dataUser.access(src);
      udataCur = jQuery.extend({}, udataOld);
      dataUser.set(dest, udataCur);
    }
  }
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();
    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked;
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }
  function domManip(collection, args, callback, ignored) {
    args = concat.apply([], args);
    var fragment,
        first,
        scripts,
        hasScripts,
        node,
        doc,
        i = 0,
        l = collection.length,
        iNoClone = l - 1,
        value = args[0],
        valueIsFunction = isFunction(value);
    if (valueIsFunction || (l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value))) {
      return collection.each(function(index) {
        var self = collection.eq(index);
        if (valueIsFunction) {
          args[0] = value.call(this, index, self.html());
        }
        domManip(self, args, callback, ignored);
      });
    }
    if (l) {
      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
      first = fragment.firstChild;
      if (fragment.childNodes.length === 1) {
        fragment = first;
      }
      if (first || ignored) {
        scripts = jQuery.map(getAll(fragment, "script"), disableScript);
        hasScripts = scripts.length;
        for (; i < l; i++) {
          node = fragment;
          if (i !== iNoClone) {
            node = jQuery.clone(node, true, true);
            if (hasScripts) {
              jQuery.merge(scripts, getAll(node, "script"));
            }
          }
          callback.call(collection[i], node, i);
        }
        if (hasScripts) {
          doc = scripts[scripts.length - 1].ownerDocument;
          jQuery.map(scripts, restoreScript);
          for (i = 0; i < hasScripts; i++) {
            node = scripts[i];
            if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
              if (node.src && (node.type || "").toLowerCase() !== "module") {
                if (jQuery._evalUrl) {
                  jQuery._evalUrl(node.src);
                }
              } else {
                DOMEval(node.textContent.replace(rcleanScript, ""), doc, node);
              }
            }
          }
        }
      }
    }
    return collection;
  }
  function remove(elem, selector, keepData) {
    var node,
        nodes = selector ? jQuery.filter(selector, elem) : elem,
        i = 0;
    for (; (node = nodes[i]) != null; i++) {
      if (!keepData && node.nodeType === 1) {
        jQuery.cleanData(getAll(node));
      }
      if (node.parentNode) {
        if (keepData && jQuery.contains(node.ownerDocument, node)) {
          setGlobalEval(getAll(node, "script"));
        }
        node.parentNode.removeChild(node);
      }
    }
    return elem;
  }
  jQuery.extend({
    htmlPrefilter: function(html) {
      return html.replace(rxhtmlTag, "<$1></$2>");
    },
    clone: function(elem, dataAndEvents, deepDataAndEvents) {
      var i,
          l,
          srcElements,
          destElements,
          clone = elem.cloneNode(true),
          inPage = jQuery.contains(elem.ownerDocument, elem);
      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      destElements = getAll(clone, "script");
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      }
      return clone;
    },
    cleanData: function(elems) {
      var data,
          elem,
          type,
          special = jQuery.event.special,
          i = 0;
      for (; (elem = elems[i]) !== undefined; i++) {
        if (acceptData(elem)) {
          if ((data = elem[dataPriv.expando])) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            elem[dataPriv.expando] = undefined;
          }
          if (elem[dataUser.expando]) {
            elem[dataUser.expando] = undefined;
          }
        }
      }
    }
  });
  jQuery.fn.extend({
    detach: function(selector) {
      return remove(this, selector, true);
    },
    remove: function(selector) {
      return remove(this, selector);
    },
    text: function(value) {
      return access(this, function(value) {
        return value === undefined ? jQuery.text(this) : this.empty().each(function() {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function() {
      return domManip(this, arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function() {
      return domManip(this, arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function() {
      return domManip(this, arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function() {
      return domManip(this, arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    empty: function() {
      var elem,
          i = 0;
      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
          elem.textContent = "";
        }
      }
      return this;
    },
    clone: function(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function() {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function(value) {
      return access(this, function(value) {
        var elem = this[0] || {},
            i = 0,
            l = this.length;
        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        }
        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = jQuery.htmlPrefilter(value);
          try {
            for (; i < l; i++) {
              elem = this[i] || {};
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;
          } catch (e) {}
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function() {
      var ignored = [];
      return domManip(this, arguments, function(elem) {
        var parent = this.parentNode;
        if (jQuery.inArray(this, ignored) < 0) {
          jQuery.cleanData(getAll(this));
          if (parent) {
            parent.replaceChild(elem, this);
          }
        }
      }, ignored);
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(name, original) {
    jQuery.fn[name] = function(selector) {
      var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);
        push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
  var getStyles = function(elem) {
    var view = elem.ownerDocument.defaultView;
    if (!view || !view.opener) {
      view = window;
    }
    return view.getComputedStyle(elem);
  };
  var rboxStyle = new RegExp(cssExpand.join("|"), "i");
  (function() {
    function computeStyleTests() {
      if (!div) {
        return;
      }
      container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
      div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
      documentElement.appendChild(container).appendChild(div);
      var divStyle = window.getComputedStyle(div);
      pixelPositionVal = divStyle.top !== "1%";
      reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
      div.style.right = "60%";
      pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
      boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
      div.style.position = "absolute";
      scrollboxSizeVal = div.offsetWidth === 36 || "absolute";
      documentElement.removeChild(container);
      div = null;
    }
    function roundPixelMeasures(measure) {
      return Math.round(parseFloat(measure));
    }
    var pixelPositionVal,
        boxSizingReliableVal,
        scrollboxSizeVal,
        pixelBoxStylesVal,
        reliableMarginLeftVal,
        container = document.createElement("div"),
        div = document.createElement("div");
    if (!div.style) {
      return;
    }
    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    jQuery.extend(support, {
      boxSizingReliable: function() {
        computeStyleTests();
        return boxSizingReliableVal;
      },
      pixelBoxStyles: function() {
        computeStyleTests();
        return pixelBoxStylesVal;
      },
      pixelPosition: function() {
        computeStyleTests();
        return pixelPositionVal;
      },
      reliableMarginLeft: function() {
        computeStyleTests();
        return reliableMarginLeftVal;
      },
      scrollboxSize: function() {
        computeStyleTests();
        return scrollboxSizeVal;
      }
    });
  })();
  function curCSS(elem, name, computed) {
    var width,
        minWidth,
        maxWidth,
        ret,
        style = elem.style;
    computed = computed || getStyles(elem);
    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name];
      if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
        ret = jQuery.style(elem, name);
      }
      if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret !== undefined ? ret + "" : ret;
  }
  function addGetHookIf(conditionFn, hookFn) {
    return {get: function() {
        if (conditionFn()) {
          delete this.get;
          return;
        }
        return (this.get = hookFn).apply(this, arguments);
      }};
  }
  var rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      rcustomProp = /^--/,
      cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
      },
      cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      },
      cssPrefixes = ["Webkit", "Moz", "ms"],
      emptyStyle = document.createElement("div").style;
  function vendorPropName(name) {
    if (name in emptyStyle) {
      return name;
    }
    var capName = name[0].toUpperCase() + name.slice(1),
        i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in emptyStyle) {
        return name;
      }
    }
  }
  function finalPropName(name) {
    var ret = jQuery.cssProps[name];
    if (!ret) {
      ret = jQuery.cssProps[name] = vendorPropName(name) || name;
    }
    return ret;
  }
  function setPositiveNumber(elem, value, subtract) {
    var matches = rcssNum.exec(value);
    return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
  }
  function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
    var i = dimension === "width" ? 1 : 0,
        extra = 0,
        delta = 0;
    if (box === (isBorderBox ? "border" : "content")) {
      return 0;
    }
    for (; i < 4; i += 2) {
      if (box === "margin") {
        delta += jQuery.css(elem, box + cssExpand[i], true, styles);
      }
      if (!isBorderBox) {
        delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        if (box !== "padding") {
          delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        } else {
          extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      } else {
        if (box === "content") {
          delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        }
        if (box !== "margin") {
          delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    }
    if (!isBorderBox && computedVal >= 0) {
      delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5));
    }
    return delta;
  }
  function getWidthOrHeight(elem, dimension, extra) {
    var styles = getStyles(elem),
        val = curCSS(elem, dimension, styles),
        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box",
        valueIsBorderBox = isBorderBox;
    if (rnumnonpx.test(val)) {
      if (!extra) {
        return val;
      }
      val = "auto";
    }
    valueIsBorderBox = valueIsBorderBox && (support.boxSizingReliable() || val === elem.style[dimension]);
    if (val === "auto" || !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") {
      val = elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)];
      valueIsBorderBox = true;
    }
    val = parseFloat(val) || 0;
    return (val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, val)) + "px";
  }
  jQuery.extend({
    cssHooks: {opacity: {get: function(elem, computed) {
          if (computed) {
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }}},
    cssNumber: {
      "animationIterationCount": true,
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    cssProps: {},
    style: function(elem, name, value, extra) {
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }
      var ret,
          type,
          hooks,
          origName = camelCase(name),
          isCustomProp = rcustomProp.test(name),
          style = elem.style;
      if (!isCustomProp) {
        name = finalPropName(origName);
      }
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (value !== undefined) {
        type = typeof value;
        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
          value = adjustCSS(elem, name, ret);
          type = "number";
        }
        if (value == null || value !== value) {
          return;
        }
        if (type === "number") {
          value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
        }
        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        }
        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          if (isCustomProp) {
            style.setProperty(name, value);
          } else {
            style[name] = value;
          }
        }
      } else {
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }
        return style[name];
      }
    },
    css: function(elem, name, extra, styles) {
      var val,
          num,
          hooks,
          origName = camelCase(name),
          isCustomProp = rcustomProp.test(name);
      if (!isCustomProp) {
        name = finalPropName(origName);
      }
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      }
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || isFinite(num) ? num || 0 : val;
      }
      return val;
    }
  });
  jQuery.each(["height", "width"], function(i, dimension) {
    jQuery.cssHooks[dimension] = {
      get: function(elem, computed, extra) {
        if (computed) {
          return rdisplayswap.test(jQuery.css(elem, "display")) && (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
            return getWidthOrHeight(elem, dimension, extra);
          }) : getWidthOrHeight(elem, dimension, extra);
        }
      },
      set: function(elem, value, extra) {
        var matches,
            styles = getStyles(elem),
            isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box",
            subtract = extra && boxModelAdjustment(elem, dimension, extra, isBorderBox, styles);
        if (isBorderBox && support.scrollboxSize() === styles.position) {
          subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
        }
        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
          elem.style[dimension] = value;
          value = jQuery.css(elem, dimension);
        }
        return setPositiveNumber(elem, value, subtract);
      }
    };
  });
  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
    if (computed) {
      return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {marginLeft: 0}, function() {
        return elem.getBoundingClientRect().left;
      })) + "px";
    }
  });
  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function(prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {expand: function(value) {
        var i = 0,
            expanded = {},
            parts = typeof value === "string" ? value.split(" ") : [value];
        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }};
    if (prefix !== "margin") {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({css: function(name, value) {
      return access(this, function(elem, name, value) {
        var styles,
            len,
            map = {},
            i = 0;
        if (Array.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    }});
  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || jQuery.easing._default;
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function() {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function(percent) {
      var eased,
          hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {_default: {
      get: function(tween) {
        var result;
        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
          return tween.elem[tween.prop];
        }
        result = jQuery.css(tween.elem, tween.prop, "");
        return !result || result === "auto" ? 0 : result;
      },
      set: function(tween) {
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }};
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {set: function(tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }};
  jQuery.easing = {
    linear: function(p) {
      return p;
    },
    swing: function(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    },
    _default: "swing"
  };
  jQuery.fx = Tween.prototype.init;
  jQuery.fx.step = {};
  var fxNow,
      inProgress,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rrun = /queueHooks$/;
  function schedule() {
    if (inProgress) {
      if (document.hidden === false && window.requestAnimationFrame) {
        window.requestAnimationFrame(schedule);
      } else {
        window.setTimeout(schedule, jQuery.fx.interval);
      }
      jQuery.fx.tick();
    }
  }
  function createFxNow() {
    window.setTimeout(function() {
      fxNow = undefined;
    });
    return (fxNow = Date.now());
  }
  function genFx(type, includeWidth) {
    var which,
        i = 0,
        attrs = {height: type};
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  function createTween(value, prop, animation) {
    var tween,
        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
        index = 0,
        length = collection.length;
    for (; index < length; index++) {
      if ((tween = collection[index].call(animation, prop, value))) {
        return tween;
      }
    }
  }
  function defaultPrefilter(elem, props, opts) {
    var prop,
        value,
        toggle,
        hooks,
        oldfire,
        propTween,
        restoreDisplay,
        display,
        isBox = "width" in props || "height" in props,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHiddenWithinTree(elem),
        dataShow = dataPriv.get(elem, "fxshow");
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function() {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function() {
        anim.always(function() {
          hooks.unqueued--;
          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    }
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.test(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";
        if (value === (hidden ? "hide" : "show")) {
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      }
    }
    propTween = !jQuery.isEmptyObject(props);
    if (!propTween && jQuery.isEmptyObject(orig)) {
      return;
    }
    if (isBox && elem.nodeType === 1) {
      opts.overflow = [style.overflow, style.overflowX, style.overflowY];
      restoreDisplay = dataShow && dataShow.display;
      if (restoreDisplay == null) {
        restoreDisplay = dataPriv.get(elem, "display");
      }
      display = jQuery.css(elem, "display");
      if (display === "none") {
        if (restoreDisplay) {
          display = restoreDisplay;
        } else {
          showHide([elem], true);
          restoreDisplay = elem.style.display || restoreDisplay;
          display = jQuery.css(elem, "display");
          showHide([elem]);
        }
      }
      if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
        if (jQuery.css(elem, "float") === "none") {
          if (!propTween) {
            anim.done(function() {
              style.display = restoreDisplay;
            });
            if (restoreDisplay == null) {
              display = style.display;
              restoreDisplay = display === "none" ? "" : display;
            }
          }
          style.display = "inline-block";
        }
      }
    }
    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function() {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }
    propTween = false;
    for (prop in orig) {
      if (!propTween) {
        if (dataShow) {
          if ("hidden" in dataShow) {
            hidden = dataShow.hidden;
          }
        } else {
          dataShow = dataPriv.access(elem, "fxshow", {display: restoreDisplay});
        }
        if (toggle) {
          dataShow.hidden = !hidden;
        }
        if (hidden) {
          showHide([elem], true);
        }
        anim.done(function() {
          if (!hidden) {
            showHide([elem]);
          }
          dataPriv.remove(elem, "fxshow");
          for (prop in orig) {
            jQuery.style(elem, prop, orig[prop]);
          }
        });
      }
      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
      if (!(prop in dataShow)) {
        dataShow[prop] = propTween.start;
        if (hidden) {
          propTween.end = propTween.start;
          propTween.start = 0;
        }
      }
    }
  }
  function propFilter(props, specialEasing) {
    var index,
        name,
        easing,
        value,
        hooks;
    for (index in props) {
      name = camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (Array.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name];
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result,
        stopped,
        index = 0,
        length = Animation.prefilters.length,
        deferred = jQuery.Deferred().always(function() {
          delete tick.elem;
        }),
        tick = function() {
          if (stopped) {
            return false;
          }
          var currentTime = fxNow || createFxNow(),
              remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
              temp = remaining / animation.duration || 0,
              percent = 1 - temp,
              index = 0,
              length = animation.tweens.length;
          for (; index < length; index++) {
            animation.tweens[index].run(percent);
          }
          deferred.notifyWith(elem, [animation, percent, remaining]);
          if (percent < 1 && length) {
            return remaining;
          }
          if (!length) {
            deferred.notifyWith(elem, [animation, 1, 0]);
          }
          deferred.resolveWith(elem, [animation]);
          return false;
        },
        animation = deferred.promise({
          elem: elem,
          props: jQuery.extend({}, properties),
          opts: jQuery.extend(true, {
            specialEasing: {},
            easing: jQuery.easing._default
          }, options),
          originalProperties: properties,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function(prop, end) {
            var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
            animation.tweens.push(tween);
            return tween;
          },
          stop: function(gotoEnd) {
            var index = 0,
                length = gotoEnd ? animation.tweens.length : 0;
            if (stopped) {
              return this;
            }
            stopped = true;
            for (; index < length; index++) {
              animation.tweens[index].run(1);
            }
            if (gotoEnd) {
              deferred.notifyWith(elem, [animation, 1, 0]);
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }
            return this;
          }
        }),
        props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        if (isFunction(result.stop)) {
          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
        }
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation;
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweeners: {"*": [function(prop, value) {
        var tween = this.createTween(prop, value);
        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
        return tween;
      }]},
    tweener: function(props, callback) {
      if (isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.match(rnothtmlwhite);
      }
      var prop,
          index = 0,
          length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
        Animation.tweeners[prop].unshift(callback);
      }
    },
    prefilters: [defaultPrefilter],
    prefilter: function(callback, prepend) {
      if (prepend) {
        Animation.prefilters.unshift(callback);
      } else {
        Animation.prefilters.push(callback);
      }
    }
  });
  jQuery.speed = function(speed, easing, fn) {
    var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !isFunction(easing) && easing
    };
    if (jQuery.fx.off) {
      opt.duration = 0;
    } else {
      if (typeof opt.duration !== "number") {
        if (opt.duration in jQuery.fx.speeds) {
          opt.duration = jQuery.fx.speeds[opt.duration];
        } else {
          opt.duration = jQuery.fx.speeds._default;
        }
      }
    }
    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    }
    opt.old = opt.complete;
    opt.complete = function() {
      if (isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.fn.extend({
    fadeTo: function(speed, to, easing, callback) {
      return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({opacity: to}, speed, easing, callback);
    },
    animate: function(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function() {
            var anim = Animation(this, jQuery.extend({}, prop), optall);
            if (empty || dataPriv.get(this, "finish")) {
              anim.stop(true);
            }
          };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function(type, clearQueue, gotoEnd) {
      var stopQueue = function(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }
      return this.each(function() {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = dataPriv.get(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function(type) {
      if (type !== false) {
        type = type || "fx";
      }
      return this.each(function() {
        var index,
            data = dataPriv.get(this),
            queue = data[type + "queue"],
            hooks = data[type + "queueHooks"],
            timers = jQuery.timers,
            length = queue ? queue.length : 0;
        data.finish = true;
        jQuery.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function(i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function(speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {opacity: "show"},
    fadeOut: {opacity: "hide"},
    fadeToggle: {opacity: "toggle"}
  }, function(name, props) {
    jQuery.fn[name] = function(speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];
  jQuery.fx.tick = function() {
    var timer,
        i = 0,
        timers = jQuery.timers;
    fxNow = Date.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function(timer) {
    jQuery.timers.push(timer);
    jQuery.fx.start();
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function() {
    if (inProgress) {
      return;
    }
    inProgress = true;
    schedule();
  };
  jQuery.fx.stop = function() {
    inProgress = null;
  };
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  };
  jQuery.fn.delay = function(time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function(next, hooks) {
      var timeout = window.setTimeout(next, time);
      hooks.stop = function() {
        window.clearTimeout(timeout);
      };
    });
  };
  (function() {
    var input = document.createElement("input"),
        select = document.createElement("select"),
        opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox";
    support.checkOn = input.value !== "";
    support.optSelected = opt.selected;
    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();
  var boolHook,
      attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function(name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function(name) {
      return this.each(function() {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType;
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (typeof elem.getAttribute === "undefined") {
        return jQuery.prop(elem, name, value);
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
          return;
        }
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }
        elem.setAttribute(name, value + "");
        return value;
      }
      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }
      ret = jQuery.find.attr(elem, name);
      return ret == null ? undefined : ret;
    },
    attrHooks: {type: {set: function(elem, value) {
          if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }}},
    removeAttr: function(elem, value) {
      var name,
          i = 0,
          attrNames = value && value.match(rnothtmlwhite);
      if (attrNames && elem.nodeType === 1) {
        while ((name = attrNames[i++])) {
          elem.removeAttribute(name);
        }
      }
    }
  });
  boolHook = {set: function(elem, value, name) {
      if (value === false) {
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }};
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;
    attrHandle[name] = function(elem, name, isXML) {
      var ret,
          handle,
          lowercaseName = name.toLowerCase();
      if (!isXML) {
        handle = attrHandle[lowercaseName];
        attrHandle[lowercaseName] = ret;
        ret = getter(elem, name, isXML) != null ? lowercaseName : null;
        attrHandle[lowercaseName] = handle;
      }
      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i,
      rclickable = /^(?:a|area)$/i;
  jQuery.fn.extend({
    prop: function(name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function(name) {
      return this.each(function() {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    prop: function(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType;
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }
        return (elem[name] = value);
      }
      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }
      return elem[name];
    },
    propHooks: {tabIndex: {get: function(elem) {
          var tabindex = jQuery.find.attr(elem, "tabindex");
          if (tabindex) {
            return parseInt(tabindex, 10);
          }
          if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
            return 0;
          }
          return -1;
        }}},
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  });
  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function(elem) {
        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      },
      set: function(elem) {
        var parent = elem.parentNode;
        if (parent) {
          parent.selectedIndex;
          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }
      }
    };
  }
  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
    jQuery.propFix[this.toLowerCase()] = this;
  });
  function stripAndCollapse(value) {
    var tokens = value.match(rnothtmlwhite) || [];
    return tokens.join(" ");
  }
  function getClass(elem) {
    return elem.getAttribute && elem.getAttribute("class") || "";
  }
  function classesToArray(value) {
    if (Array.isArray(value)) {
      return value;
    }
    if (typeof value === "string") {
      return value.match(rnothtmlwhite) || [];
    }
    return [];
  }
  jQuery.fn.extend({
    addClass: function(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;
      if (isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).addClass(value.call(this, j, getClass(this)));
        });
      }
      classes = classesToArray(value);
      if (classes.length) {
        while ((elem = this[i++])) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            }
            finalValue = stripAndCollapse(cur);
            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }
      return this;
    },
    removeClass: function(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;
      if (isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).removeClass(value.call(this, j, getClass(this)));
        });
      }
      if (!arguments.length) {
        return this.attr("class", "");
      }
      classes = classesToArray(value);
      if (classes.length) {
        while ((elem = this[i++])) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              while (cur.indexOf(" " + clazz + " ") > -1) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            }
            finalValue = stripAndCollapse(cur);
            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }
      return this;
    },
    toggleClass: function(value, stateVal) {
      var type = typeof value,
          isValidValue = type === "string" || Array.isArray(value);
      if (typeof stateVal === "boolean" && isValidValue) {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (isFunction(value)) {
        return this.each(function(i) {
          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
        });
      }
      return this.each(function() {
        var className,
            i,
            self,
            classNames;
        if (isValidValue) {
          i = 0;
          self = jQuery(this);
          classNames = classesToArray(value);
          while ((className = classNames[i++])) {
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }
        } else if (value === undefined || type === "boolean") {
          className = getClass(this);
          if (className) {
            dataPriv.set(this, "__className__", className);
          }
          if (this.setAttribute) {
            this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
          }
        }
      });
    },
    hasClass: function(selector) {
      var className,
          elem,
          i = 0;
      className = " " + selector + " ";
      while ((elem = this[i++])) {
        if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
          return true;
        }
      }
      return false;
    }
  });
  var rreturn = /\r/g;
  jQuery.fn.extend({val: function(value) {
      var hooks,
          ret,
          valueIsFunction,
          elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }
          ret = elem.value;
          if (typeof ret === "string") {
            return ret.replace(rreturn, "");
          }
          return ret == null ? "" : ret;
        }
        return;
      }
      valueIsFunction = isFunction(value);
      return this.each(function(i) {
        var val;
        if (this.nodeType !== 1) {
          return;
        }
        if (valueIsFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }
        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (Array.isArray(val)) {
          val = jQuery.map(val, function(value) {
            return value == null ? "" : value + "";
          });
        }
        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }});
  jQuery.extend({valHooks: {
      option: {get: function(elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ? val : stripAndCollapse(jQuery.text(elem));
        }},
      select: {
        get: function(elem) {
          var value,
              option,
              i,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one",
              values = one ? null : [],
              max = one ? index + 1 : options.length;
          if (index < 0) {
            i = max;
          } else {
            i = one ? index : 0;
          }
          for (; i < max; i++) {
            option = options[i];
            if ((option.selected || i === index) && !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
              value = jQuery(option).val();
              if (one) {
                return value;
              }
              values.push(value);
            }
          }
          return values;
        },
        set: function(elem, value) {
          var optionSet,
              option,
              options = elem.options,
              values = jQuery.makeArray(value),
              i = options.length;
          while (i--) {
            option = options[i];
            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
              optionSet = true;
            }
          }
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    }});
  jQuery.each(["radio", "checkbox"], function() {
    jQuery.valHooks[this] = {set: function(elem, value) {
        if (Array.isArray(value)) {
          return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
        }
      }};
    if (!support.checkOn) {
      jQuery.valHooks[this].get = function(elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  });
  support.focusin = "onfocusin" in window;
  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
      stopPropagationCallback = function(e) {
        e.stopPropagation();
      };
  jQuery.extend(jQuery.event, {
    trigger: function(event, data, elem, onlyHandlers) {
      var i,
          cur,
          tmp,
          bubbleType,
          ontype,
          handle,
          special,
          lastElement,
          eventPath = [elem || document],
          type = hasOwn.call(event, "type") ? event.type : event,
          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = lastElement = tmp = elem = elem || document;
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }
      if (type.indexOf(".") > -1) {
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(":") < 0 && "on" + type;
      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      data = data == null ? [event] : jQuery.makeArray(data, [event]);
      special = jQuery.event.special[type] || {};
      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      }
      if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        lastElement = cur;
        event.type = i > 1 ? bubbleType : special.bindType || type;
        handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
        if (handle) {
          handle.apply(cur, data);
        }
        handle = ontype && cur[ontype];
        if (handle && handle.apply && acceptData(cur)) {
          event.result = handle.apply(cur, data);
          if (event.result === false) {
            event.preventDefault();
          }
        }
      }
      event.type = type;
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
          if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            jQuery.event.triggered = type;
            if (event.isPropagationStopped()) {
              lastElement.addEventListener(type, stopPropagationCallback);
            }
            elem[type]();
            if (event.isPropagationStopped()) {
              lastElement.removeEventListener(type, stopPropagationCallback);
            }
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    simulate: function(type, elem, event) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true
      });
      jQuery.event.trigger(e, null, elem);
    }
  });
  jQuery.fn.extend({
    trigger: function(type, data) {
      return this.each(function() {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function(type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  if (!support.focusin) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function(orig, fix) {
      var handler = function(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
      };
      jQuery.event.special[fix] = {
        setup: function() {
          var doc = this.ownerDocument || this,
              attaches = dataPriv.access(doc, fix);
          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }
          dataPriv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function() {
          var doc = this.ownerDocument || this,
              attaches = dataPriv.access(doc, fix) - 1;
          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            dataPriv.remove(doc, fix);
          } else {
            dataPriv.access(doc, fix, attaches);
          }
        }
      };
    });
  }
  var location = window.location;
  var nonce = Date.now();
  var rquery = (/\?/);
  jQuery.parseXML = function(data) {
    var xml;
    if (!data || typeof data !== "string") {
      return null;
    }
    try {
      xml = (new window.DOMParser()).parseFromString(data, "text/xml");
    } catch (e) {
      xml = undefined;
    }
    if (!xml || xml.getElementsByTagName("parsererror").length) {
      jQuery.error("Invalid XML: " + data);
    }
    return xml;
  };
  var rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (Array.isArray(obj)) {
      jQuery.each(obj, function(i, v) {
        if (traditional || rbracket.test(prefix)) {
          add(prefix, v);
        } else {
          buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && toType(obj) === "object") {
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      add(prefix, obj);
    }
  }
  jQuery.param = function(a, traditional) {
    var prefix,
        s = [],
        add = function(key, valueOrFunction) {
          var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
          s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
        };
    if (Array.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
      jQuery.each(a, function() {
        add(this.name, this.value);
      });
    } else {
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    return s.join("&");
  };
  jQuery.fn.extend({
    serialize: function() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function() {
      return this.map(function() {
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function() {
        var type = this.type;
        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function(i, elem) {
        var val = jQuery(this).val();
        if (val == null) {
          return null;
        }
        if (Array.isArray(val)) {
          return jQuery.map(val, function(val) {
            return {
              name: elem.name,
              value: val.replace(rCRLF, "\r\n")
            };
          });
        }
        return {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  });
  var r20 = /%20/g,
      rhash = /#.*$/,
      rantiCache = /([?&])_=[^&]*/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
      rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,
      prefilters = {},
      transports = {},
      allTypes = "*/".concat("*"),
      originAnchor = document.createElement("a");
  originAnchor.href = location.href;
  function addToPrefiltersOrTransports(structure) {
    return function(dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }
      var dataType,
          i = 0,
          dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
      if (isFunction(func)) {
        while ((dataType = dataTypes[i++])) {
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func);
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
        seekingTransport = (structure === transports);
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  }
  function ajaxExtend(target, src) {
    var key,
        deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }
  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
        type,
        finalDataType,
        firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes;
    while (dataTypes[0] === "*") {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    }
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      finalDataType = finalDataType || firstDataType;
    }
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
        current,
        conv,
        tmp,
        prev,
        converters = {},
        dataTypes = s.dataTypes.slice();
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        if (current === "*") {
          current = prev;
        } else if (prev !== "*" && prev !== current) {
          conv = converters[prev + " " + current] || converters["* " + current];
          if (!conv) {
            for (conv2 in converters) {
              tmp = conv2.split(" ");
              if (tmp[1] === current) {
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                if (conv) {
                  if (conv === true) {
                    conv = converters[conv2];
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          if (conv !== true) {
            if (conv && s.throws) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: "success",
      data: response
    };
  }
  jQuery.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: location.href,
      type: "GET",
      isLocal: rlocalProtocol.test(location.protocol),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": true,
        "text json": JSON.parse,
        "text xml": jQuery.parseXML
      },
      flatOptions: {
        url: true,
        context: true
      }
    },
    ajaxSetup: function(target, settings) {
      return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function(url, options) {
      if (typeof url === "object") {
        options = url;
        url = undefined;
      }
      options = options || {};
      var transport,
          cacheURL,
          responseHeadersString,
          responseHeaders,
          timeoutTimer,
          urlAnchor,
          completed,
          fireGlobals,
          i,
          uncached,
          s = jQuery.ajaxSetup({}, options),
          callbackContext = s.context || s,
          globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
          deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),
          statusCode = s.statusCode || {},
          requestHeaders = {},
          requestHeadersNames = {},
          strAbort = "canceled",
          jqXHR = {
            readyState: 0,
            getResponseHeader: function(key) {
              var match;
              if (completed) {
                if (!responseHeaders) {
                  responseHeaders = {};
                  while ((match = rheaders.exec(responseHeadersString))) {
                    responseHeaders[match[1].toLowerCase()] = match[2];
                  }
                }
                match = responseHeaders[key.toLowerCase()];
              }
              return match == null ? null : match;
            },
            getAllResponseHeaders: function() {
              return completed ? responseHeadersString : null;
            },
            setRequestHeader: function(name, value) {
              if (completed == null) {
                name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                requestHeaders[name] = value;
              }
              return this;
            },
            overrideMimeType: function(type) {
              if (completed == null) {
                s.mimeType = type;
              }
              return this;
            },
            statusCode: function(map) {
              var code;
              if (map) {
                if (completed) {
                  jqXHR.always(map[jqXHR.status]);
                } else {
                  for (code in map) {
                    statusCode[code] = [statusCode[code], map[code]];
                  }
                }
              }
              return this;
            },
            abort: function(statusText) {
              var finalText = statusText || strAbort;
              if (transport) {
                transport.abort(finalText);
              }
              done(0, finalText);
              return this;
            }
          };
      deferred.promise(jqXHR);
      s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");
      s.type = options.method || options.type || s.method || s.type;
      s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
      if (s.crossDomain == null) {
        urlAnchor = document.createElement("a");
        try {
          urlAnchor.href = s.url;
          urlAnchor.href = urlAnchor.href;
          s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
        } catch (e) {
          s.crossDomain = true;
        }
      }
      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      }
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      if (completed) {
        return jqXHR;
      }
      fireGlobals = jQuery.event && s.global;
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      }
      s.type = s.type.toUpperCase();
      s.hasContent = !rnoContent.test(s.type);
      cacheURL = s.url.replace(rhash, "");
      if (!s.hasContent) {
        uncached = s.url.slice(cacheURL.length);
        if (s.data && (s.processData || typeof s.data === "string")) {
          cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
          delete s.data;
        }
        if (s.cache === false) {
          cacheURL = cacheURL.replace(rantiCache, "$1");
          uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + (nonce++) + uncached;
        }
        s.url = cacheURL + uncached;
      } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
        s.data = s.data.replace(r20, "+");
      }
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      }
      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      }
      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
        return jqXHR.abort();
      }
      strAbort = "abort";
      completeDeferred.add(s.complete);
      jqXHR.done(s.success);
      jqXHR.fail(s.error);
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1;
        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        }
        if (completed) {
          return jqXHR;
        }
        if (s.async && s.timeout > 0) {
          timeoutTimer = window.setTimeout(function() {
            jqXHR.abort("timeout");
          }, s.timeout);
        }
        try {
          completed = false;
          transport.send(requestHeaders, done);
        } catch (e) {
          if (completed) {
            throw e;
          }
          done(-1, e);
        }
      }
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
            success,
            error,
            response,
            modified,
            statusText = nativeStatusText;
        if (completed) {
          return;
        }
        completed = true;
        if (timeoutTimer) {
          window.clearTimeout(timeoutTimer);
        }
        transport = undefined;
        responseHeadersString = headers || "";
        jqXHR.readyState = status > 0 ? 4 : 0;
        isSuccess = status >= 200 && status < 300 || status === 304;
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        if (isSuccess) {
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader("etag");
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }
          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent";
          } else if (status === 304) {
            statusText = "notmodified";
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          error = statusText;
          if (status || !statusText) {
            statusText = "error";
            if (status < 0) {
              status = 0;
            }
          }
        }
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + "";
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        }
        jqXHR.statusCode(statusCode);
        statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        }
        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
          if (!(--jQuery.active)) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }
      return jqXHR;
    },
    getJSON: function(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function(i, method) {
    jQuery[method] = function(url, data, callback, type) {
      if (isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax(jQuery.extend({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      }, jQuery.isPlainObject(url) && url));
    };
  });
  jQuery._evalUrl = function(url) {
    return jQuery.ajax({
      url: url,
      type: "GET",
      dataType: "script",
      cache: true,
      async: false,
      global: false,
      "throws": true
    });
  };
  jQuery.fn.extend({
    wrapAll: function(html) {
      var wrap;
      if (this[0]) {
        if (isFunction(html)) {
          html = html.call(this[0]);
        }
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function() {
          var elem = this;
          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function(html) {
      if (isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function() {
        var self = jQuery(this),
            contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function(html) {
      var htmlIsFunction = isFunction(html);
      return this.each(function(i) {
        jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function(selector) {
      this.parent(selector).not("body").each(function() {
        jQuery(this).replaceWith(this.childNodes);
      });
      return this;
    }
  });
  jQuery.expr.pseudos.hidden = function(elem) {
    return !jQuery.expr.pseudos.visible(elem);
  };
  jQuery.expr.pseudos.visible = function(elem) {
    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
  };
  jQuery.ajaxSettings.xhr = function() {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  };
  var xhrSuccessStatus = {
    0: 200,
    1223: 204
  },
      xhrSupported = jQuery.ajaxSettings.xhr();
  support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function(options) {
    var callback,
        errorCallback;
    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function(headers, complete) {
          var i,
              xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password);
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          }
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }
          callback = function(type) {
            return function() {
              if (callback) {
                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  if (typeof xhr.status !== "number") {
                    complete(0, "error");
                  } else {
                    complete(xhr.status, xhr.statusText);
                  }
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {binary: xhr.response} : {text: xhr.responseText}, xhr.getAllResponseHeaders());
                }
              }
            };
          };
          xhr.onload = callback();
          errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
          if (xhr.onabort !== undefined) {
            xhr.onabort = errorCallback;
          } else {
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                window.setTimeout(function() {
                  if (callback) {
                    errorCallback();
                  }
                });
              }
            };
          }
          callback = callback("abort");
          try {
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            if (callback) {
              throw e;
            }
          }
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  jQuery.ajaxPrefilter(function(s) {
    if (s.crossDomain) {
      s.contents.script = false;
    }
  });
  jQuery.ajaxSetup({
    accepts: {script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"},
    contents: {script: /\b(?:java|ecma)script\b/},
    converters: {"text script": function(text) {
        jQuery.globalEval(text);
        return text;
      }}
  });
  jQuery.ajaxPrefilter("script", function(s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = "GET";
    }
  });
  jQuery.ajaxTransport("script", function(s) {
    if (s.crossDomain) {
      var script,
          callback;
      return {
        send: function(_, complete) {
          script = jQuery("<script>").prop({
            charset: s.scriptCharset,
            src: s.url
          }).on("load error", callback = function(evt) {
            script.remove();
            callback = null;
            if (evt) {
              complete(evt.type === "error" ? 404 : 200, evt.type);
            }
          });
          document.head.appendChild(script[0]);
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/;
  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
      this[callback] = true;
      return callback;
    }
  });
  jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
    var callbackName,
        overwritten,
        responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
    if (jsonProp || s.dataTypes[0] === "jsonp") {
      callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      }
      s.converters["script json"] = function() {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }
        return responseContainer[0];
      };
      s.dataTypes[0] = "json";
      overwritten = window[callbackName];
      window[callbackName] = function() {
        responseContainer = arguments;
      };
      jqXHR.always(function() {
        if (overwritten === undefined) {
          jQuery(window).removeProp(callbackName);
        } else {
          window[callbackName] = overwritten;
        }
        if (s[callbackName]) {
          s.jsonpCallback = originalSettings.jsonpCallback;
          oldCallbacks.push(callbackName);
        }
        if (responseContainer && isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      return "script";
    }
  });
  support.createHTMLDocument = (function() {
    var body = document.implementation.createHTMLDocument("").body;
    body.innerHTML = "<form></form><form></form>";
    return body.childNodes.length === 2;
  })();
  jQuery.parseHTML = function(data, context, keepScripts) {
    if (typeof data !== "string") {
      return [];
    }
    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }
    var base,
        parsed,
        scripts;
    if (!context) {
      if (support.createHTMLDocument) {
        context = document.implementation.createHTMLDocument("");
        base = context.createElement("base");
        base.href = document.location.href;
        context.head.appendChild(base);
      } else {
        context = document;
      }
    }
    parsed = rsingleTag.exec(data);
    scripts = !keepScripts && [];
    if (parsed) {
      return [context.createElement(parsed[1])];
    }
    parsed = buildFragment([data], context, scripts);
    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }
    return jQuery.merge([], parsed.childNodes);
  };
  jQuery.fn.load = function(url, params, callback) {
    var selector,
        type,
        response,
        self = this,
        off = url.indexOf(" ");
    if (off > -1) {
      selector = stripAndCollapse(url.slice(off));
      url = url.slice(0, off);
    }
    if (isFunction(params)) {
      callback = params;
      params = undefined;
    } else if (params && typeof params === "object") {
      type = "POST";
    }
    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        type: type || "GET",
        dataType: "html",
        data: params
      }).done(function(responseText) {
        response = arguments;
        self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
      }).always(callback && function(jqXHR, status) {
        self.each(function() {
          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
        });
      });
    }
    return this;
  };
  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
    jQuery.fn[type] = function(fn) {
      return this.on(type, fn);
    };
  });
  jQuery.expr.pseudos.animated = function(elem) {
    return jQuery.grep(jQuery.timers, function(fn) {
      return elem === fn.elem;
    }).length;
  };
  jQuery.offset = {setOffset: function(elem, options, i) {
      var curPosition,
          curLeft,
          curCSSTop,
          curTop,
          curOffset,
          curCSSLeft,
          calculatePosition,
          position = jQuery.css(elem, "position"),
          curElem = jQuery(elem),
          props = {};
      if (position === "static") {
        elem.style.position = "relative";
      }
      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (isFunction(options)) {
        options = options.call(elem, i, jQuery.extend({}, curOffset));
      }
      if (options.top != null) {
        props.top = (options.top - curOffset.top) + curTop;
      }
      if (options.left != null) {
        props.left = (options.left - curOffset.left) + curLeft;
      }
      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }};
  jQuery.fn.extend({
    offset: function(options) {
      if (arguments.length) {
        return options === undefined ? this : this.each(function(i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }
      var rect,
          win,
          elem = this[0];
      if (!elem) {
        return;
      }
      if (!elem.getClientRects().length) {
        return {
          top: 0,
          left: 0
        };
      }
      rect = elem.getBoundingClientRect();
      win = elem.ownerDocument.defaultView;
      return {
        top: rect.top + win.pageYOffset,
        left: rect.left + win.pageXOffset
      };
    },
    position: function() {
      if (!this[0]) {
        return;
      }
      var offsetParent,
          offset,
          doc,
          elem = this[0],
          parentOffset = {
            top: 0,
            left: 0
          };
      if (jQuery.css(elem, "position") === "fixed") {
        offset = elem.getBoundingClientRect();
      } else {
        offset = this.offset();
        doc = elem.ownerDocument;
        offsetParent = elem.offsetParent || doc.documentElement;
        while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.parentNode;
        }
        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
          parentOffset = jQuery(offsetParent).offset();
          parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
          parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
        }
      }
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    offsetParent: function() {
      return this.map(function() {
        var offsetParent = this.offsetParent;
        while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || documentElement;
      });
    }
  });
  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function(method, prop) {
    var top = "pageYOffset" === prop;
    jQuery.fn[method] = function(val) {
      return access(this, function(elem, method, val) {
        var win;
        if (isWindow(elem)) {
          win = elem;
        } else if (elem.nodeType === 9) {
          win = elem.defaultView;
        }
        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length);
    };
  });
  jQuery.each(["top", "left"], function(i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop);
        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    });
  });
  jQuery.each({
    Height: "height",
    Width: "width"
  }, function(name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function(defaultExtra, funcName) {
      jQuery.fn[funcName] = function(margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function(elem, type, value) {
          var doc;
          if (isWindow(elem)) {
            return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
          }
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }
          return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable);
      };
    });
  });
  jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function(i, name) {
    jQuery.fn[name] = function(data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({hover: function(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    }});
  jQuery.fn.extend({
    bind: function(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function(types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function(selector, types, fn) {
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    }
  });
  jQuery.proxy = function(fn, context) {
    var tmp,
        args,
        proxy;
    if (typeof context === "string") {
      tmp = fn[context];
      context = fn;
      fn = tmp;
    }
    if (!isFunction(fn)) {
      return undefined;
    }
    args = slice.call(arguments, 2);
    proxy = function() {
      return fn.apply(context || this, args.concat(slice.call(arguments)));
    };
    proxy.guid = fn.guid = fn.guid || jQuery.guid++;
    return proxy;
  };
  jQuery.holdReady = function(hold) {
    if (hold) {
      jQuery.readyWait++;
    } else {
      jQuery.ready(true);
    }
  };
  jQuery.isArray = Array.isArray;
  jQuery.parseJSON = JSON.parse;
  jQuery.nodeName = nodeName;
  jQuery.isFunction = isFunction;
  jQuery.isWindow = isWindow;
  jQuery.camelCase = camelCase;
  jQuery.type = toType;
  jQuery.now = Date.now;
  jQuery.isNumeric = function(obj) {
    var type = jQuery.type(obj);
    return (type === "number" || type === "string") && !isNaN(obj - parseFloat(obj));
  };
  if (typeof define === "function" && define.amd) {
    define("86", [], function() {
      return jQuery;
    }) && define("jquery", ["86"], function(m) {
      return m;
    });
  }
  var _jQuery = window.jQuery,
      _$ = window.$;
  jQuery.noConflict = function(deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }
    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }
    return jQuery;
  };
  if (!noGlobal) {
    window.jQuery = window.$ = jQuery;
  }
  return jQuery;
});

})();
(function() {
var define = $__System.amdDefine;
define("28", ["86"], function(main) {
  return main;
});

})();
(function() {
var define = $__System.amdDefine;
(function(factory) {
  if (typeof define === 'function' && define.amd) {
    define("87", ["28"], factory);
  } else if (typeof module === 'object' && module.exports) {
    module.exports = factory(require('jquery'));
  } else {
    factory(window.jQuery);
  }
}(function($) {
  var FileDialog = function(context) {
    var self = this;
    var ui = $.summernote.ui;
    var $editor = context.layoutInfo.editor;
    var options = context.options;
    var lang = options.langInfo;
    var callbacks = options.callbacks;
    context.memo('button.file', function() {
      return ui.button({
        contents: '<i class="fa fa-paperclip" />',
        tooltip: lang.file.insert,
        click: context.createInvokeHandler('fileDialog.show')
      }).render();
    });
    this.initialize = function() {
      var $container = options.dialogsInBody ? $(document.body) : $editor;
      var footer = '<button href="#" class="btn btn-primary note-file-btn">' + lang.file.insert + '</button>';
      var body = '<div class="form-group note-group-select-from-files">' + '<label>' + lang.file.selectFromFiles + '</label>' + '<input class="note-file-input form-control" type="file" name="files" multiple="multiple" />' + '</div>' + '<div class="form-group" style="overflow:auto;">' + '<label>' + lang.file.text + '</label>' + '<input class="note-file-text form-control col-md-12" type="text" />' + '</div>';
      this.$dialog = ui.dialog({
        title: lang.file.insert,
        fade: options.dialogsFade,
        body: body,
        footer: footer
      }).render().appendTo($container);
    };
    this.show = function() {
      context.invoke('editor.saveRange');
      this.showFileDialog().then(function(files, text) {
        ui.hideDialog(self.$dialog);
        context.invoke('editor.restoreRange');
        if (callbacks.onFileUpload) {
          context.triggerEvent('file.upload', files, text);
        } else {
          console.log('onFileUpload not defined');
        }
      }).fail(function() {
        context.invoke('editor.restoreRange');
      });
    };
    this.showFileDialog = function() {
      return $.Deferred(function(deferred) {
        var $fileInput = self.$dialog.find('.note-file-input'),
            $fileText = self.$dialog.find('.note-file-text'),
            $fileBtn = self.$dialog.find('.note-file-btn');
        ui.onDialogShown(self.$dialog, function() {
          $fileBtn.click(function(event) {
            event.preventDefault();
            deferred.resolve($fileInput.prop('files') || $fileInput.prop('value'), $fileText.val());
          });
        });
        ui.onDialogHidden(self.$dialog, function() {
          $fileBtn.off('click');
          $fileInput.replaceWith($fileInput.clone().val(''));
          $fileText.replaceWith($fileText.clone().val(''));
          if (deferred.state() === 'pending') {
            deferred.reject();
          }
        });
        ui.showDialog(self.$dialog);
      });
    };
    this.destroy = function() {
      this.$dialog.remove();
      this.$dialog = null;
    };
  };
  $.extend(true, $.summernote, {
    plugins: {fileDialog: FileDialog},
    lang: {'en-US': {file: {
          file: 'File',
          text: 'Link Text',
          insert: 'Insert File',
          selectFromFiles: 'Select from files'
        }}},
    options: {callbacks: {onFileUpload: null}}
  });
}));

})();
(function() {
var define = $__System.amdDefine;
define("88", ["87"], function(main) {
  return main;
});

})();
$__System.register('89', ['5', '6', '7', '28', '80', '81', '82', '83', '85', '88', 'a', '7a', '7b', '7d', '7e', '7f'], function (_export) {
	var _get, _inherits, _classCallCheck, $, _createClass, MasterEditor, Helper, EditorSummernote;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_4) {
			$ = _4['default'];
		}, function (_5) {}, function (_6) {}, function (_7) {}, function (_8) {}, function (_9) {}, function (_10) {}, function (_a) {
			_createClass = _a['default'];
		}, function (_a2) {
			MasterEditor = _a2.MasterEditor;
		}, function (_b) {
			Helper = _b.Helper;
		}, function (_d) {}, function (_e) {}, function (_f) {}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			EditorSummernote = (function (_MasterEditor) {
				_inherits(EditorSummernote, _MasterEditor);

				function EditorSummernote() {
					var _this = this;

					var WebTorrent = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

					_classCallCheck(this, EditorSummernote);

					_get(Object.getPrototypeOf(EditorSummernote.prototype), 'constructor', this).call(this);
					this.WebTorrent = WebTorrent;
					this.torrentNodeName = 'span';

					this.container = null;
					this.summernote = $.summernote;
					this.Helper = new Helper();
					this.changeEvent = function () {
						console.warn('No ChangeEvent defined!!!');
					};
					this.changeDelay = 1000;
					this.timeout = true;
					this.timeoutCont = null; // used internal when timeout true
					// add css
					this.css = this.Helper.addBaseURL(['jspm_packages/' + System.map['bootstrap'] + '/css/bootstrap.min.css', 'JavaScript/js/Editor/lib/codemirror/codemirror.css', 'JavaScript/js/Editor/lib/codemirror/monokai.css', 'jspm_packages/' + System.map['summernote/summernote'] + '/summernote.css']);
					//`` // ide has some issues here to highlight properly without this line
					this.css.forEach(function (e) {
						$('<link/>', {
							rel: 'stylesheet',
							type: 'text/css',
							href: e
						}).appendTo('head');
					});
					// options
					this.addEmojis();
					this.opts = {
						toolbar: [['insert', ['link', 'codeview' /*, 'picture', 'video'*/]], ['font', ['style', 'fontsize', 'fontname']], ['weight', ['color', 'bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript', 'clear']], ['para', ['height', 'ul', 'ol', 'paragraph', 'table']], ['view', ['undo', 'redo', 'fullscreen', 'help']]],
						// catch drag and drop file
						callbacks: {
							// If no WebTorrent remove the onImageUpload callback and let default handle it
							onImageload: function onImageload(files) {
								if (files.length > 0) _this.loadFileInit(files);
							},
							onFileUpload: function onFileUpload(files, text) {
								if (files.length > 0) _this.loadFileInit(files, text, undefined, false);
							},
							// trash icon
							onMediaDelete: function onMediaDelete($target, container) {
								// remove element in container
								$target.remove();
								var nodeList = document.evaluate('//' + _this.torrentNodeName + '[@data-blobs[contains(., \'' + $target[0].src + '\')]]', document, null, XPathResult.ANY_TYPE, null);
								var node = nodeList.iterateNext(); // it is supposed to be empty before deleting
								while (node && node.childNodes.length !== 0) {
									node = nodeList.iterateNext();
								}
								if (node) {
									if (node.nextSibling && node.nextSibling.innerHTML === '') node.nextSibling.remove(); // remove buffer element added at line 176, this is used for setting focus after torrentNode
									node.remove();
								}
							}
						},
						hint: {
							match: /:([\-+\w]+)$/,
							search: function search(keyword, callback) {
								callback($.grep(emojis, function (item) {
									return item.indexOf(keyword) === 0;
								}));
							},
							template: function template(item) {
								var content = emojiUrls[item];
								return '<img src="' + content + '" width="20" /> :' + item + ':';
							},
							content: function content(item) {
								var url = emojiUrls[item];
								if (url) {
									return $('<img />').attr('src', url).css('width', 20)[0];
								}
								return '';
							}
						},
						codemirror: {
							mode: 'htmlmixed',
							htmlMode: true,
							lineNumbers: true,
							theme: 'monokai'
						},
						height: '40vh',
						minHeight: null,
						maxHeight: null,
						focus: false
					};
				}

				_createClass(EditorSummernote, [{
					key: 'add',
					value: function add() {
						var container = arguments.length <= 0 || arguments[0] === undefined ? this.container : arguments[0];

						this.container = container;
						container.summernote(this.opts);
						this.addFileDialog(container);
					}
				}, {
					key: 'remove',
					value: function remove() {
						var container = arguments.length <= 0 || arguments[0] === undefined ? this.container : arguments[0];

						container.summernote('destroy');
					}
				}, {
					key: 'getData',
					value: function getData() {
						var container = arguments.length <= 0 || arguments[0] === undefined ? this.container : arguments[0];

						return container.summernote('code');
					}
				}, {
					key: 'setData',
					value: function setData() {
						var container = arguments.length <= 0 || arguments[0] === undefined ? this.container : arguments[0];
						var data = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];
						var type = arguments.length <= 2 || arguments[2] === undefined ? 'insertText' : arguments[2];

						return container.summernote(type, data, type);
					}
				}, {
					key: 'attachChangeEvent',
					value: function attachChangeEvent(container, event) {
						var _this2 = this;

						if (container === undefined) container = this.container;

						this.changeEvent = event;
						container.on('summernote.change', function (we, contents, $editable) {
							if (contents && contents.length > 0) {
								clearTimeout(_this2.timeoutCont);
								_this2.timeoutCont = setTimeout(function () {
									// unseed webTorrents when node.webTorrent deleted
									if (_this2.WebTorrent) {
										if (_this2.WebTorrent.api.removeDeletedNodes().length > 0 && !_this2.WebTorrent.api.areTorrentsLoading()) {
											// enable codeview
											$('.btn-codeview').first().removeClass('disabled').removeAttr('disabled', true);
										}
									}
								}, _this2.changeDelay);
								// !!!Send here the whole content #sender div instead of only the one element!!!
								_this2.changeEvent(contents, container[0].id);
							}
						});
					}
				}, {
					key: 'addFileDialog',
					value: function addFileDialog() {
						var container = arguments.length <= 0 || arguments[0] === undefined ? this.container : arguments[0];

						// add button
						var ui = this.summernote.ui;
						var button = ui.button({
							contents: '<i class="glyphicon glyphicon-open-file"/>',
							tooltip: 'File',
							click: function click() {
								container.summernote('fileDialog.show');
							}
						});
						$('.note-btn-group.btn-group.note-insert').prepend(button.render());
					}
				}, {
					key: 'loadFileInit',
					value: function loadFileInit(files, text) {
						var container = arguments.length <= 2 || arguments[2] === undefined ? this.container : arguments[2];
						var image = arguments.length <= 3 || arguments[3] === undefined ? true : arguments[3];

						if (this.WebTorrent) {
							// check for doublicated video, this has a browser bug, which eventuelly looses the blob
							var torrent = undefined;
							// TODO: adding videos twice breaks the blob link, this is most likely a bug in browsers
							if (!image && (torrent = this.WebTorrent.api.torrents.get(this.WebTorrent.api.createFilesId(files))) && torrent.sst_containsVideo && !confirm('Adding a video more than once is going to reset the videos of Sender and Receiver. Do you want to continue?')) {
								return;
							}
							this.loadFile(files, text, container);
						} else {
							_get(Object.getPrototypeOf(EditorSummernote.prototype), 'loadFile', this).call(this, files, text, container);
						}
					}
				}, {
					key: 'loadFile',
					value: function loadFile(files, text) {
						var _this3 = this;

						var container = arguments.length <= 2 || arguments[2] === undefined ? this.container : arguments[2];

						// append file
						var node = document.createElement(this.torrentNodeName);
						node.id = this.Helper.getRandomString(); // give each node an id, so that virtual-dom doesn't mix up things
						// disable codeview until file is loaded, otherwise it doesn't get added when in codeview
						$('.btn-codeview').first().addClass('disabled').attr('disabled', true);
						// console.log(App.Editor.areTorrentsLoading()); console.log(App.Editor.WebTorrent.torrents);  console.log(App.Editor.WebTorrent.client.torrents); console.log(App.Editor.WebTorrent.nodes);
						this.WebTorrent.api.seed(files, text, node, undefined, undefined, undefined, function (torrent) {
							_this3.changeEvent(_this3.getData(), container[0].id);
							// enable codeview
							if (!_this3.WebTorrent.api.areTorrentsLoading()) {
								$('.btn-codeview').first().removeClass('disabled').removeAttr('disabled', true);
							}
						});
						this.setData(container, document.createElement('span'), 'insertNode'); // trying to get cursor focus after node
						this.setData(container, node, 'insertNode');
					}
				}]);

				return EditorSummernote;
			})(MasterEditor);

			_export('EditorSummernote', EditorSummernote);
		}
	};
});
// Summernote supported codemirror version not available on github anymore
$__System.registerDynamic('77', ['33', '35', '31'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var $export = $__require('33'),
        core = $__require('35'),
        fails = $__require('31');
    module.exports = function (KEY, exec) {
        var fn = (core.Object || {})[KEY] || Object[KEY],
            exp = {};
        exp[KEY] = exec(fn);
        $export($export.S + $export.F * fails(function () {
            fn(1);
        }), 'Object', exp);
    };
});
$__System.registerDynamic('8a', ['8b', '77'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toIObject = $__require('8b');
  $__require('77')('getOwnPropertyDescriptor', function ($getOwnPropertyDescriptor) {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
});
$__System.registerDynamic('8c', ['2e', '8a'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('2e');
  $__require('8a');
  module.exports = function getOwnPropertyDescriptor(it, key) {
    return $.getDesc(it, key);
  };
});
$__System.registerDynamic("8d", ["8c"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("8c"), __esModule: true };
});
$__System.registerDynamic("5", ["8d"], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var _Object$getOwnPropertyDescriptor = $__require("8d")["default"];
  exports["default"] = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
      var object = _x,
          property = _x2,
          receiver = _x3;
      _again = false;
      if (object === null) object = Function.prototype;
      var desc = _Object$getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x = parent;
          _x2 = property;
          _x3 = receiver;
          _again = true;
          desc = parent = undefined;
          continue _function;
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  exports.__esModule = true;
});
$__System.registerDynamic('8e', ['2e'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('2e');
  module.exports = function create(P, D) {
    return $.create(P, D);
  };
});
$__System.registerDynamic("8f", ["8e"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("8e"), __esModule: true };
});
$__System.registerDynamic('4d', ['2e', '3f', '38', '41'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var getDesc = $__require('2e').getDesc,
      isObject = $__require('3f'),
      anObject = $__require('38');
  var check = function (O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function (test, buggy, set) {
      try {
        set = $__require('41')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
});
$__System.registerDynamic('90', ['33', '4d'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $export = $__require('33');
  $export($export.S, 'Object', { setPrototypeOf: $__require('4d').set });
});
$__System.registerDynamic('91', ['90', '35'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('90');
  module.exports = $__require('35').Object.setPrototypeOf;
});
$__System.registerDynamic("92", ["91"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("91"), __esModule: true };
});
$__System.registerDynamic("6", ["8f", "92"], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var _Object$create = $__require("8f")["default"];
  var _Object$setPrototypeOf = $__require("92")["default"];
  exports["default"] = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = _Object$create(superClass && superClass.prototype, { constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      } });
    if (superClass) _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  exports.__esModule = true;
});
$__System.registerDynamic("93", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function () {/* empty */};
});
$__System.registerDynamic("69", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (done, value) {
    return { value: value, done: !!done };
  };
});
$__System.registerDynamic('30', ['42'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var cof = $__require('42');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
});
$__System.registerDynamic('8b', ['30', '67'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var IObject = $__require('30'),
      defined = $__require('67');
  module.exports = function (it) {
    return IObject(defined(it));
  };
});
$__System.registerDynamic('94', ['93', '69', '6f', '8b', '68'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var addToUnscopables = $__require('93'),
      step = $__require('69'),
      Iterators = $__require('6f'),
      toIObject = $__require('8b');
  module.exports = $__require('68')(Array, 'Array', function (iterated, kind) {
    this._t = toIObject(iterated);
    this._i = 0;
    this._k = kind;
  }, function () {
    var O = this._t,
        kind = this._k,
        index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys') return step(0, index);
    if (kind == 'values') return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  Iterators.Arguments = Iterators.Array;
  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');
});
$__System.registerDynamic('56', ['94', '6f'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('94');
  var Iterators = $__require('6f');
  Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
});
$__System.registerDynamic("70", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // 7.1.4 ToInteger
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function (it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
});
$__System.registerDynamic("67", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // 7.2.1 RequireObjectCoercible(argument)
  module.exports = function (it) {
    if (it == undefined) throw TypeError("Can't call method on  " + it);
    return it;
  };
});
$__System.registerDynamic('95', ['70', '67'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toInteger = $__require('70'),
      defined = $__require('67');
  module.exports = function (TO_STRING) {
    return function (that, pos) {
      var s = String(defined(that)),
          i = toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
});
$__System.registerDynamic("49", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = true;
});
$__System.registerDynamic('39', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (it) {
    if (typeof it != 'function') throw TypeError(it + ' is not a function!');
    return it;
  };
});
$__System.registerDynamic('41', ['39'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var aFunction = $__require('39');
  module.exports = function (fn, that, length) {
    aFunction(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 1:
        return function (a) {
          return fn.call(that, a);
        };
      case 2:
        return function (a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function (a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function () {
      return fn.apply(that, arguments);
    };
  };
});
$__System.registerDynamic('33', ['3d', '35', '41'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var global = $__require('3d'),
      core = $__require('35'),
      ctx = $__require('41'),
      PROTOTYPE = 'prototype';
  var $export = function (type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        IS_WRAP = type & $export.W,
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
        key,
        own,
        out;
    if (IS_GLOBAL) source = name;
    for (key in source) {
      own = !IS_FORCED && target && key in target;
      if (own && key in exports) continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? function (C) {
        var F = function (param) {
          return this instanceof C ? new C(param) : C(param);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (IS_PROTO) (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  module.exports = $export;
});
$__System.registerDynamic('6c', ['66'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = $__require('66');
});
$__System.registerDynamic("96", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
});
$__System.registerDynamic("31", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
});
$__System.registerDynamic('4e', ['31'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = !$__require('31')(function () {
    return Object.defineProperty({}, 'a', { get: function () {
        return 7;
      } }).a != 7;
  });
});
$__System.registerDynamic('66', ['2e', '96', '4e'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('2e'),
      createDesc = $__require('96');
  module.exports = $__require('4e') ? function (object, key, value) {
    return $.setDesc(object, key, createDesc(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };
});
$__System.registerDynamic('97', ['2e', '96', '50', '66', '3a'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $ = $__require('2e'),
      descriptor = $__require('96'),
      setToStringTag = $__require('50'),
      IteratorPrototype = {};
  $__require('66')(IteratorPrototype, $__require('3a')('iterator'), function () {
    return this;
  });
  module.exports = function (Constructor, NAME, next) {
    Constructor.prototype = $.create(IteratorPrototype, { next: descriptor(1, next) });
    setToStringTag(Constructor, NAME + ' Iterator');
  };
});
$__System.registerDynamic("6b", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function (it, key) {
    return hasOwnProperty.call(it, key);
  };
});
$__System.registerDynamic('50', ['2e', '6b', '3a'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var def = $__require('2e').setDesc,
      has = $__require('6b'),
      TAG = $__require('3a')('toStringTag');
  module.exports = function (it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
      configurable: true,
      value: tag
    });
  };
});
$__System.registerDynamic('68', ['49', '33', '6c', '66', '6b', '6f', '97', '50', '2e', '3a'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var LIBRARY = $__require('49'),
      $export = $__require('33'),
      redefine = $__require('6c'),
      hide = $__require('66'),
      has = $__require('6b'),
      Iterators = $__require('6f'),
      $iterCreate = $__require('97'),
      setToStringTag = $__require('50'),
      getProto = $__require('2e').getProto,
      ITERATOR = $__require('3a')('iterator'),
      BUGGY = !([].keys && 'next' in [].keys()),
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';
  var returnThis = function () {
    return this;
  };
  module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    $iterCreate(Constructor, NAME, next);
    var getMethod = function (kind) {
      if (!BUGGY && kind in proto) return proto[kind];
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        DEF_VALUES = DEFAULT == VALUES,
        VALUES_BUG = false,
        proto = Base.prototype,
        $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        $default = $native || getMethod(DEFAULT),
        methods,
        key;
    if ($native) {
      var IteratorPrototype = getProto($default.call(new Base()));
      setToStringTag(IteratorPrototype, TAG, true);
      if (!LIBRARY && has(proto, FF_ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
      if (DEF_VALUES && $native.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
          return $native.call(this);
        };
      }
    }
    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      hide(proto, ITERATOR, $default);
    }
    Iterators[NAME] = $default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: !DEF_VALUES ? $default : getMethod('entries')
      };
      if (FORCED) for (key in methods) {
        if (!(key in proto)) redefine(proto, key, methods[key]);
      } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
});
$__System.registerDynamic('55', ['95', '68'], true, function ($__require, exports, module) {
  /* */
  'use strict';

  var global = this || self,
      GLOBAL = global;
  var $at = $__require('95')(true);
  $__require('68')(String, 'String', function (iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function () {
    var O = this._t,
        index = this._i,
        point;
    if (index >= O.length) return {
      value: undefined,
      done: true
    };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });
});
$__System.registerDynamic('3f', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = function (it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
});
$__System.registerDynamic('38', ['3f'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var isObject = $__require('3f');
  module.exports = function (it) {
    if (!isObject(it)) throw TypeError(it + ' is not an object!');
    return it;
  };
});
$__System.registerDynamic("42", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var toString = {}.toString;

  module.exports = function (it) {
    return toString.call(it).slice(8, -1);
  };
});
$__System.registerDynamic('4a', ['42', '3a'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var cof = $__require('42'),
        TAG = $__require('3a')('toStringTag'),
        ARG = cof(function () {
        return arguments;
    }()) == 'Arguments';
    module.exports = function (it) {
        var O, T, B;
        return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
    };
});
$__System.registerDynamic('98', ['3d'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var global = $__require('3d'),
        SHARED = '__core-js_shared__',
        store = global[SHARED] || (global[SHARED] = {});
    module.exports = function (key) {
        return store[key] || (store[key] = {});
    };
});
$__System.registerDynamic('6a', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var id = 0,
      px = Math.random();
  module.exports = function (key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
});
$__System.registerDynamic('3d', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
});
$__System.registerDynamic('3a', ['98', '6a', '3d'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var store = $__require('98')('wks'),
        uid = $__require('6a'),
        Symbol = $__require('3d').Symbol;
    module.exports = function (name) {
        return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
    };
});
$__System.registerDynamic("6f", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = {};
});
$__System.registerDynamic('62', ['4a', '3a', '6f', '35'], true, function ($__require, exports, module) {
    var global = this || self,
        GLOBAL = global;
    /* */
    var classof = $__require('4a'),
        ITERATOR = $__require('3a')('iterator'),
        Iterators = $__require('6f');
    module.exports = $__require('35').getIteratorMethod = function (it) {
        if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
    };
});
$__System.registerDynamic('35', [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var core = module.exports = { version: '1.2.6' };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
});
$__System.registerDynamic('99', ['38', '62', '35'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var anObject = $__require('38'),
      get = $__require('62');
  module.exports = $__require('35').getIterator = function (it) {
    var iterFn = get(it);
    if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
    return anObject(iterFn.call(it));
  };
});
$__System.registerDynamic('9a', ['56', '55', '99'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  $__require('56');
  $__require('55');
  module.exports = $__require('99');
});
$__System.registerDynamic("5d", ["9a"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("9a"), __esModule: true };
});
$__System.registerDynamic("2e", [], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
});
$__System.registerDynamic('9b', ['2e'], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  var $ = $__require('2e');
  module.exports = function defineProperty(it, key, desc) {
    return $.setDesc(it, key, desc);
  };
});
$__System.registerDynamic("9", ["9b"], true, function ($__require, exports, module) {
  var global = this || self,
      GLOBAL = global;
  /* */
  module.exports = { "default": $__require("9b"), __esModule: true };
});
$__System.registerDynamic("a", ["9"], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  var _Object$defineProperty = $__require("9")["default"];
  exports["default"] = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        _Object$defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  exports.__esModule = true;
});
$__System.registerDynamic("7", [], true, function ($__require, exports, module) {
  /* */
  "use strict";

  var global = this || self,
      GLOBAL = global;
  exports["default"] = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  exports.__esModule = true;
});
$__System.register('19', ['7', 'a'], function (_export) {
	var _classCallCheck, _createClass, MasterHelper;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterHelper = (function () {
				function MasterHelper() {
					_classCallCheck(this, MasterHelper);

					this.baseURL = window.sst && window.sst.karma ? window.sst.karma : location.host.includes('github') ? 'PeerWebSite/' : '';
				}

				_createClass(MasterHelper, [{
					key: 'addBaseURL',
					value: function addBaseURL() {
						var _this = this;

						var url = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
						var relative = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

						var locOrigin = relative ? '.' : location.origin;
						return url.map(function (e) {
							if (!_this.baseURL && relative && e.includes('./')) return e;
							return locOrigin + '/' + (location.host.includes('github') && relative ? '' : _this.baseURL) + e.replace(':', '/');
						});
					}
				}, {
					key: 'getRandomString',
					value: function getRandomString() {
						if (window.crypto && window.crypto.getRandomValues && navigator.userAgent.indexOf('Safari') === -1) {
							var a = window.crypto.getRandomValues(new Uint32Array(3)),
							    token = '';
							for (var i = 0, l = a.length; i < l; i++) {
								token += a[i].toString(36);
							}
							return token;
						} else {
							return (Math.random() * new Date().getTime()).toString(36).replace(/\./g, '');
						}
					}
				}]);

				return MasterHelper;
			})();

			_export('MasterHelper', MasterHelper);
		}
	};
});
$__System.register('5c', ['5', '6', '7', '19', 'a', '5d'], function (_export) {
	var _get, _inherits, _classCallCheck, MasterHelper, _createClass, _getIterator, Helper;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_4) {
			MasterHelper = _4.MasterHelper;
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_d) {
			_getIterator = _d['default'];
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			Helper = (function (_MasterHelper) {
				_inherits(Helper, _MasterHelper);

				function Helper() {
					_classCallCheck(this, Helper);

					_get(Object.getPrototypeOf(Helper.prototype), 'constructor', this).apply(this, arguments);
				}

				_createClass(Helper, [{
					key: 'createFilesId',

					/**
      * creates id's from files (api Hook)
      * 
      * @param {FileList} files 
      * @returns 
      * @memberof Helper
      */
					value: function createFilesId(files) {
						if (!files.length) return this.getHash('' + files.lastModified + files.name + files.size);
						var str = '';
						var _iteratorNormalCompletion = true;
						var _didIteratorError = false;
						var _iteratorError = undefined;

						try {
							for (var _iterator = _getIterator(files), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
								var file = _step.value;

								str += '' + file.lastModified + file.name + file.size;
							}
						} catch (err) {
							_didIteratorError = true;
							_iteratorError = err;
						} finally {
							try {
								if (!_iteratorNormalCompletion && _iterator['return']) {
									_iterator['return']();
								}
							} finally {
								if (_didIteratorError) {
									throw _iteratorError;
								}
							}
						}

						return this.getHash(str);
					}
				}, {
					key: 'getHash',
					value: function getHash(str) {
						var hash = 0,
						    i = undefined,
						    chr = undefined;
						for (i = 0; i < str.length; i++) {
							chr = str.charCodeAt(i);
							hash = (hash << 5) - hash + chr;
							hash |= 0; // Convert to 32bit integer
						}
						return Math.abs(hash);
					}
				}]);

				return Helper;
			})(MasterHelper);

			_export('Helper', Helper);
		}
	};
});
$__System.register('9c', ['7', 'a', '5c'], function (_export) {
	var _classCallCheck, _createClass, Helper, ServiceWorker;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_c) {
			Helper = _c.Helper;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			ServiceWorker = (function () {
				function ServiceWorker(serviceWorkerPath, serviceWorkerScope, getBlobByFileName) {
					if (serviceWorkerPath === undefined) serviceWorkerPath = 'MasterServiceWorker.js';
					if (serviceWorkerScope === undefined) serviceWorkerScope = './';

					_classCallCheck(this, ServiceWorker);

					this.serviceWorkerPath = serviceWorkerPath;
					this.serviceWorkerScope = serviceWorkerScope;
					this.getBlobByFileName = getBlobByFileName;

					this.name = 'ServiceWorker';
					this.Worker = null;
					this.messageChannel = new MessageChannel();
					this.Helper = new Helper();
					// NOTE: Karma Tests don't work, more information at ./JavaScript/tests/ServiceWorker/ServiceWorker.js
					this.serviceWorkerPath = this.Helper.addBaseURL([this.serviceWorkerPath])[0];
					this.serviceWorkerScope = this.Helper.addBaseURL([this.serviceWorkerScope])[0];
				}

				_createClass(ServiceWorker, [{
					key: 'run',
					value: function run() {
						if (navigator.serviceWorker) {
							this.addReadyEventListener();
							this.register();
						} else {
							console.warn('SST:Service Worker is not supported in this browser.');
						}
					}

					// wait until the ServiceWorker is ready and then addMessageChannelEventListener
				}, {
					key: 'addReadyEventListener',
					value: function addReadyEventListener() {
						var _this = this;

						//console.log('@sw_helper listening to ready event');
						navigator.serviceWorker.ready.then(function (registration) {
							_this.Worker = registration.active;
							_this.addMessageChannelEventListener();
							// send port to service worker
							//console.log('@sw_helper sending port to ServiceWorker');
							_this.Worker.postMessage(location.origin, [_this.messageChannel.port2]);
						})['catch'](function (e) {
							console.error(e);
						});
					}

					// gets executed on every message received from ServiceWorker
				}, {
					key: 'addMessageChannelEventListener',
					value: function addMessageChannelEventListener() {
						var _this2 = this;

						this.messageChannel.port1.onmessage = function (event) {
							if (event.data === '!!!ready') {
								//console.log('@sw_helper Intercept is ready!');
							} else if (Array.isArray(event.data) && event.data[0].includes('.')) {
									(function () {
										var name = event.data[0].split('/').slice(-1)[0];
										_this2.getBlobByFileName(name).then(function (blob) {
											var init = { 'status': 200, 'statusText': name };
											_this2.Worker.postMessage([event.data, [blob, init]]);
										}, function () {
											_this2.Worker.postMessage([event.data, false]);
										});
									})();
								} else {
									_this2.Worker.postMessage([event.data, false]);
								}
						};
					}

					// register the service worker
				}, {
					key: 'register',
					value: function register() {
						//console.log(`@sw_helper register: ${this.serviceWorkerPath}; with scope: ${this.serviceWorkerScope}`);
						navigator.serviceWorker.register(this.serviceWorkerPath, { scope: this.serviceWorkerScope }).then(function (registration) {
							registration.update();
							//console.log('@sw_helper registered', registration);
						})['catch'](function (e) {
							console.error(e);
						});
					}
				}]);

				return ServiceWorker;
			})();

			_export('ServiceWorker', ServiceWorker);
		}
	};
});
$__System.register('9d', ['7', '22', '29', '75', '89', 'a', '2a', '9c'], function (_export) {
	var _classCallCheck, WebRTC, HTML, WebTorrentReceiver, EditorSummernote, _createClass, WebTorrentSeeder, ServiceWorker, MasterApp;

	return {
		setters: [function (_) {
			_classCallCheck = _['default'];
		}, function (_2) {
			WebRTC = _2.WebRTC;
		}, function (_3) {
			HTML = _3.HTML;
		}, function (_4) {
			WebTorrentReceiver = _4.WebTorrentReceiver;
		}, function (_5) {
			EditorSummernote = _5.EditorSummernote;
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_a2) {
			WebTorrentSeeder = _a2.WebTorrentSeeder;
		}, function (_c) {
			ServiceWorker = _c.ServiceWorker;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			MasterApp = (function () {
				function MasterApp() {
					_classCallCheck(this, MasterApp);

					this.WebRTC = new WebRTC();
					this.WebTorrentReceiver = new WebTorrentReceiver();
					this.HTML = new HTML(this.WebTorrentReceiver);
					this.WebTorrentSeeder = new WebTorrentSeeder();
					this.Editor = new EditorSummernote(this.WebTorrentSeeder);
					this.ServiceWorker = new ServiceWorker(undefined, undefined, this.WebTorrentReceiver.getBlobByFileName.bind(this.WebTorrentReceiver));
					this.ServiceWorker.run();

					// hot-reloader clear all
					if (window.sst && window.sst.isDebug) {
						window.App = this;
					}
				}

				_createClass(MasterApp, [{
					key: 'createElements',
					value: function createElements(name) {
						return this.HTML.createElements(name, undefined, this.WebRTC.connection);
					}
				}]);

				return MasterApp;
			})();

			_export('MasterApp', MasterApp);
		}
	};
});
$__System.register('9e', ['5', '6', '7', 'a', '9d'], function (_export) {
	var _get, _inherits, _classCallCheck, _createClass, MasterApp, App;

	return {
		setters: [function (_) {
			_get = _['default'];
		}, function (_2) {
			_inherits = _2['default'];
		}, function (_3) {
			_classCallCheck = _3['default'];
		}, function (_a) {
			_createClass = _a['default'];
		}, function (_d) {
			MasterApp = _d.MasterApp;
		}],
		execute: function () {
			/*jshint esnext: true */

			'use strict';

			App = (function (_MasterApp) {
				_inherits(App, _MasterApp);

				function App() {
					_classCallCheck(this, App);

					_get(Object.getPrototypeOf(App.prototype), 'constructor', this).call(this);
				}

				_createClass(App, [{
					key: 'createElements',
					value: function createElements() {
						var name = arguments.length <= 0 || arguments[0] === undefined ? 'open-or-join-room' : arguments[0];

						var htmlElements = _get(Object.getPrototypeOf(App.prototype), 'createElements', this).call(this, name);
						var sendCont = htmlElements[0];
						var receiveCont = htmlElements[1];
						this.WebTorrentReceiver.container = receiveCont[0]; // set the dom scope for the WebTorrent clients
						var button = htmlElements[2];
						this.Editor.add(sendCont);
						this.WebTorrentSeeder.container = sendCont[0].nextSibling.getElementsByClassName('note-editable')[0]; // dom scope not set for Seeder. 1: SummerNote changes the active container, 2: its only used at removeDeletedNodes
						// *** Events Triggert by DOM ***
						// openOrJoinEvent(roomid, message = '', elID = '')
						this.HTML.attachButtonEvent(button, sendCont, this.Editor.getData, this.WebRTC.api.openOrJoinEvent);
						// sendEvent(message, elID = 'sst_all', remoteUserId = 'sst_toAll', requestID = '', options = new Map([['diffed', true], ['compressed', 'auto']])
						this.Editor.attachChangeEvent(sendCont, this.WebRTC.api.sendEvent);
						// *** Events Triggert by Connection ***
						// onNewParticipant.add(newMessageFunc, scope = this, args = []) ==> has to return [message = '', elID = '']
						this.WebRTC.api.onNewParticipant.add(function (remoteUserId) {
							return [this.Editor.getData(), this.Editor.container[0].id];
						}, this);
						// onReceive.add(newMessageFunc, scope = this, args = [])
						this.WebRTC.api.onReceive.add(function (dataPack) {
							this.HTML.setData(receiveCont, dataPack);
						}, this);

						// connect by hash
						this.connectHash();
						window.addEventListener('hashchange', this.connectHash);
						$('#txt-roomid').focus();
					}
				}, {
					key: 'connectHash',
					value: function connectHash() {
						if (location.hash) {
							$('#txt-roomid').val(location.hash.substr(1));
							$('#open-or-join-room').click();
						}
					}
				}]);

				return App;
			})(MasterApp);

			_export('App', App);
		}
	};
});
$__System.register('9f', ['9e'], function (_export) {
  /*jshint esnext: true */

  'use strict';

  var App, App1;
  return {
    setters: [function (_e) {
      App = _e.App;
    }],
    execute: function () {
      App1 = new App();

      App1.createElements();
    }
  };
});
$__System.register('2', ['9f'], function (_export) {
  /*jshint esnext: true */

  'use strict';

  return {
    setters: [function (_f) {}],
    execute: function () {}
  };
});
})
(function(factory) {
  factory();
});
//# sourceMappingURL=webRTC.js.map